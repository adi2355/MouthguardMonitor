

================================================================================
File: app.js
================================================================================

 

================================================================================
File: app.json
================================================================================

{
  "expo": {
    "name": "MouthguardMonitor",
    "slug": "mouthguard-monitor",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.sandchealth.mouthguardmonitor",
      "infoPlist": {
        "NSBluetoothAlwaysUsageDescription": "This app requires Bluetooth access to connect to mouthguard devices for impact monitoring.",
        "NSBluetoothPeripheralUsageDescription": "This app requires Bluetooth access to communicate with mouthguard devices for impact monitoring.",
        "UIBackgroundModes": [
          "bluetooth-central"
        ]
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "permissions": [
        "android.permission.BLUETOOTH",
        "android.permission.BLUETOOTH_ADMIN",
        "android.permission.BLUETOOTH_SCAN",
        "android.permission.BLUETOOTH_CONNECT",
        "android.permission.ACCESS_FINE_LOCATION"
      ],
      "package": "com.sandchealth.mouthguardmonitor"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ],
      "expo-sqlite",
      [
        "react-native-ble-plx",
        {
          "isBackgroundEnabled": true,
          "modes": [
            "peripheral",
            "central"
          ],
          "bluetoothAlwaysPermission": "Allow $(PRODUCT_NAME) to connect to mouthguard devices for impact monitoring"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}


================================================================================
File: app/_layout.tsx
================================================================================

import { clearAppData } from '../src/utils/resetAppData';
import { Stack } from "expo-router";
import { useState, useEffect } from "react";
import { BluetoothHandler, BluetoothContext } from "@/src/contexts/BluetoothContext";
import { useColorScheme, AppState, AppStateStatus, Alert, Text, View, StyleSheet } from 'react-native';
import * as SplashScreen from 'expo-splash-screen';
import { useFonts } from 'expo-font';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { AppProvider } from '@/src/providers/AppProvider';
import AsyncStorage from '@react-native-async-storage/async-storage';
import SimpleApp from '../src/SimpleApp'; // Import the simple app
import { COLORS } from '@/src/constants';
// Import our custom theme wrapper
import ThemeWrapper from './components/shared/ThemeWrapper';
import AlertOverlay from './components/shared/AlertOverlay';

export {
  // Catch any errors thrown by the Layout component.
  ErrorBoundary,
} from 'expo-router';

export const unstable_settings = {
  // Ensure that reloading on `/modal` keeps a back button present.
  initialRouteName: '(tabs)',
};

// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();

// Use this for testing - set to true to use the SimpleApp
const USE_SIMPLE_APP = false; // Toggle this to use SimpleApp directly

export default function RootLayout() {
  console.log("[RootLayout] Initializing...");
  
  const [loaded, error] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
    ...FontAwesome.font,
  });
  const [didReset, setDidReset] = useState(false);
  const [appState, setAppState] = useState<string>('loading');
  const [useSimpleApp, setUseSimpleApp] = useState(USE_SIMPLE_APP);
  
  console.log("[RootLayout] Initial state - loaded:", loaded, "error:", error);

  // Set a timeout to show SimpleApp if initialization takes too long
  useEffect(() => {
    const timer = setTimeout(() => {
      if (!didReset) {
        console.log("[RootLayout] Initialization timeout - switching to SimpleApp");
        setUseSimpleApp(true);
        setDidReset(true); // Force app to continue
      }
    }, 10000); // 10 second timeout
    
    return () => clearTimeout(timer);
  }, [didReset]);

  // Force a reset on every app launch
  useEffect(() => {
    async function forceReset() {
      if (USE_SIMPLE_APP) {
        // If we're using simple app, skip the reset
        console.log("[RootLayout] Using SimpleApp, skipping reset");
        setDidReset(true);
        return;
      }
      
      try {
        console.log("[RootLayout] Checking reset status...");
        setAppState('checking-reset');
        
        // Use a specific version-keyed reset flag to control app resets
        const RESET_PERFORMED_KEY = 'APP_RESET_V1_PERFORMED';
        const resetPerformed = await AsyncStorage.getItem(RESET_PERFORMED_KEY);
        
        if (!resetPerformed) {
          // Only reset if not done before
          console.log("[RootLayout] Reset not performed yet, starting app reset...");
          setAppState('resetting');
          
          // Perform the actual reset
          const resetResult = await clearAppData();
          console.log("[RootLayout] Reset completed with result:", resetResult);
          
          if (resetResult) {
            // Mark reset as performed only if successful
            await AsyncStorage.setItem(RESET_PERFORMED_KEY, 'true');
            console.log("[RootLayout] App data cleared and reset marked as performed.");
          }
          
          setDidReset(true);
          setAppState('reset-complete');
          console.log("[RootLayout] App reset completed successfully");
        } else {
          // Reset already performed, skip
          console.log("[RootLayout] Reset already performed, skipping reset process");
          setDidReset(true);
          setAppState('no-reset-needed');
        }
      } catch (err) {
        console.error('[RootLayout] Error during app reset check:', err);
        setAppState('reset-error');
        Alert.alert(
          'Reset Error',
          'There was an error checking app reset status. Try restarting the app.',
          [{ text: 'OK' }]
        );
        setDidReset(true); // Continue anyway to prevent blocking the app
      }
    }
    
    forceReset();
    
    return () => {
      console.log("[RootLayout] Cleanup effect");
    };
  }, []);

  // Expo Router uses Error Boundaries to catch errors in the navigation tree.
  useEffect(() => {
    console.log("[RootLayout] Error effect triggered, error:", error);
    if (error) {
      console.error("[RootLayout] Font loading error:", error);
      setAppState('font-error');
      throw error;
    }
  }, [error]);

  useEffect(() => {
    console.log("[RootLayout] Loaded effect triggered, loaded:", loaded);
    if (loaded) {
      console.log("[RootLayout] Fonts loaded, hiding splash screen");
      setAppState('fonts-loaded');
      SplashScreen.hideAsync().catch(err => {
        console.error("[RootLayout] Error hiding splash screen:", err);
      });
    }
  }, [loaded]);

  console.log("[RootLayout] Render state - loaded:", loaded, "didReset:", didReset, "appState:", appState, "useSimpleApp:", useSimpleApp);

  // Show SimpleApp if configured to do so
  if (useSimpleApp && loaded) {
    console.log("[RootLayout] Rendering SimpleApp");
    return <SimpleApp />;
  }

  if (!loaded || !didReset) {
    console.log("[RootLayout] Still loading... Showing loading screen");
    return (
      <View style={styles.loadingContainer}>
        <Text style={styles.loadingText}>Loading app... {appState}</Text>
      </View>
    );
  }

  console.log("[RootLayout] Ready to render RootLayoutNav");
  return <RootLayoutNav />;
}

function RootLayoutNav() {
  console.log("[RootLayoutNav] Initializing...");
  
  // Create the Bluetooth handler to pass to the AppProvider
  const [bluetoothHandler] = useState<BluetoothHandler>(new BluetoothHandler());

  console.log("[RootLayoutNav] Rendering navigation stack");
  return (
    <ThemeProvider value={DefaultTheme}>
      <BluetoothContext.Provider value={bluetoothHandler}>
        <AppProvider bluetoothHandler={bluetoothHandler}>
          <ThemeWrapper>
            <Stack>
              <Stack.Screen 
                name="(tabs)" 
                options={{ headerShown: false }} 
              />
              <Stack.Screen name="+not-found" />
            </Stack>
            <AlertOverlay />
          </ThemeWrapper>
        </AppProvider>
      </BluetoothContext.Provider>
    </ThemeProvider>
  );
}

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background
  },
  loadingText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    marginTop: 10
  }
});


================================================================================
File: app/(tabs)/_layout.tsx
================================================================================

import React from 'react';
import { Tabs } from 'expo-router';
import { StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: COLORS.primary,
        tabBarInactiveTintColor: COLORS.textTertiary,
        tabBarStyle: {
          backgroundColor: COLORS.background,
          borderTopColor: COLORS.border,
          height: 60,
          paddingBottom: 8,
          paddingTop: 8,
          shadowColor: COLORS.shadow,
          shadowOffset: { width: 0, height: -1 },
          shadowOpacity: 0.05,
          shadowRadius: 4,
          elevation: 5,
        },
        headerShown: false,
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: 'Dashboard',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons 
              name="view-dashboard-outline" 
              size={size} 
              color={color} 
            />
          ),
        }}
      />
      
      <Tabs.Screen
        name="coach"
        options={{
          title: 'Coach View',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons 
              name="clipboard-account-outline" 
              size={size} 
              color={color} 
            />
          ),
        }}
      />
      
      <Tabs.Screen
        name="devices"
        options={{
          title: 'Athletes & Devices',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons 
              name="account-group" 
              size={size} 
              color={color} 
            />
          ),
        }}
      />
      
      <Tabs.Screen
        name="livemonitor"
        options={{
          title: 'Live Monitor',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons 
              name="monitor-dashboard" 
              size={size} 
              color={color} 
            />
          ),
        }}
      />
      
      <Tabs.Screen
        name="reportsDetailed"
        options={{
          title: 'Reports',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons 
              name="chart-timeline-variant" 
              size={size} 
              color={color} 
            />
          ),
        }}
      />
      
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons 
              name="cog-outline" 
              size={size} 
              color={color} 
            />
          ),
        }}
      />
    </Tabs>
  );
}

const styles = StyleSheet.create({
  tabBar: {
    backgroundColor: COLORS.background,
    borderTopColor: COLORS.border,
    height: 60,
    paddingBottom: 8,
    paddingTop: 8,
    shadowColor: COLORS.shadow,
    shadowOffset: { width: 0, height: -1 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 5,
  },
});

================================================================================
File: app/(tabs)/coach.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, ScrollView, FlatList, TouchableOpacity, ViewStyle } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { coachData } from '@/src/constants'; // Import simulated coach/player data
import { COLORS } from '@/src/constants'; // Use your COLORS

// Define the Theme based on your constants
const THEME = {
  background: COLORS.background,
  cardBackground: COLORS.card,
  primary: COLORS.primary,
  text: {
    primary: COLORS.textPrimary,
    secondary: COLORS.textSecondary,
    tertiary: COLORS.textTertiary,
  },
  divider: 'rgba(0,0,0,0.08)',
  card: {
    shadow: 'rgba(0,0,0,0.12)',
    border: 'rgba(0,0,0,0.05)',
  },
  error: COLORS.error,
};

// Define a type for Player from coachData
type Player = typeof coachData.players[0];

// Fallback Card Style (if not using GlassCard)
interface PlayerCardProps {
  style?: ViewStyle;
  children: React.ReactNode;
}

const PlayerCard: React.FC<PlayerCardProps> = ({ style, children }) => (
  <View style={[styles.playerCard, style]}>{children}</View>
);

export default function CoachDashboardScreen() {

  const renderPlayerItem = ({ item }: { item: Player }) => {
    const latestSession = item.sessions.length > 0 ? item.sessions[0] : null;
    const concussionRisk = latestSession?.stats?.concussionRisk;
    const isHighRisk = concussionRisk === 'High';

    return (
      <TouchableOpacity style={[styles.playerRow, isHighRisk && styles.playerRowHighRisk]}>
         <LinearGradient
          // Optional gradient for the row
          colors={isHighRisk ? ['rgba(255,59,48,0.1)', 'rgba(255,59,48,0.05)'] : ['rgba(0,176,118,0.1)', 'rgba(0,176,118,0.05)']}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        />
        <View style={styles.playerInfo}>
          <Text style={styles.playerName}>{item.name}</Text>
          {/* Alert indicator next to name */}
          {isHighRisk && (
              <View style={styles.alertIndicator}>
                  <MaterialCommunityIcons name="alert-decagram" size={16} color={THEME.error} />
                  <Text style={styles.alertIndicatorText}>High Risk</Text>
              </View>
          )}
        </View>
        <MaterialCommunityIcons name="chevron-right" size={24} color={THEME.text.tertiary} />
      </TouchableOpacity>
    );
  };

  return (
    <SafeAreaProvider>
      <ScrollView
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View style={styles.header}>
          <LinearGradient
            colors={['rgba(0,176,118,0.15)', 'rgba(0,176,118,0.05)', 'transparent']}
            style={styles.headerGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          />
          <View style={styles.headerContent}>
            <Text style={styles.headerTitle}>Coach Dashboard</Text>
            {/* Add "Add Player" button if needed */}
            {/* <TouchableOpacity style={styles.addButton}>...</TouchableOpacity> */}
          </View>
        </View>

        {/* Player List */}
        <View style={styles.playerListContainer}>
            <Text style={styles.listTitle}>Players</Text>
            <FlatList
                data={coachData.players}
                renderItem={renderPlayerItem}
                keyExtractor={(item) => item.id}
                scrollEnabled={false} // Disable nested scroll
                ItemSeparatorComponent={() => <View style={styles.separator} />}
            />
        </View>

        {/* Bottom Spacer */}
        <View style={{ height: 24 }} />
      </ScrollView>
    </SafeAreaProvider>
  );
}

// Add Styles
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  header: {
    height: 140,
    position: 'relative',
    marginBottom: 20,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16, // Adjust as needed
    justifyContent: 'center',
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: THEME.text.primary,
    letterSpacing: 0.5,
    textAlign: 'center',
  },
  playerListContainer: {
      marginHorizontal: 16,
      backgroundColor: THEME.cardBackground, // Container for list
      borderRadius: 16,
      padding: 16,
      // Add shadows etc. if using Card style
      borderColor: THEME.card.border,
      borderWidth: 1,
      shadowColor: THEME.card.shadow,
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.1,
      shadowRadius: 8,
      elevation: 5,
  },
  listTitle: {
      fontSize: 18,
      fontWeight: '600',
      color: THEME.text.primary,
      marginBottom: 12,
  },
  playerRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 14,
    paddingHorizontal: 12,
    borderRadius: 8,
    overflow: 'hidden', // For gradient
    position: 'relative',
    // backgroundColor: 'rgba(0,176,118,0.05)', // Default green tint
  },
   playerRowHighRisk: {
     // Optional: Add specific style for high risk rows if needed beyond gradient
     // borderColor: THEME.error,
     // borderWidth: 1,
   },
  playerInfo: {
    flex: 1,
    flexDirection: 'row', // Arrange name and alert horizontally
    alignItems: 'center',
  },
  playerName: {
    fontSize: 16,
    fontWeight: '500',
    color: THEME.text.primary,
  },
  alertIndicator: {
      flexDirection: 'row',
      alignItems: 'center',
      marginLeft: 8,
      backgroundColor: 'rgba(255, 59, 48, 0.15)', // Red tint background
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
  },
  alertIndicatorText: {
      color: THEME.error,
      fontSize: 12,
      fontWeight: '600',
      marginLeft: 4,
  },
  separator: {
    height: StyleSheet.hairlineWidth,
    backgroundColor: THEME.divider,
    marginVertical: 4,
  },
  // Fallback player card style
   playerCard: {
    backgroundColor: THEME.cardBackground,
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    flexDirection: 'row',
    alignItems: 'center',
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
}); 

================================================================================
File: app/(tabs)/devices.tsx
================================================================================

import { Athlete, DeviceStatus, SavedDevice } from '@/src/types';
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Alert,
  ScrollView,
  RefreshControl,
  Platform
} from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useBluetoothService, useAthleteRepository } from '@/src/providers/AppProvider';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';

// Custom theme colors for beige theme
const THEME = {
  background: '#f2efe4', // Beige background matching bottom bar
  cardBackground: '#ffffff',
  primary: '#00b076', // Green primary color
  success: '#34c759',
  error: '#ff3b30',
  warning: '#ff9500',
  text: {
    primary: '#333333',
    secondary: '#666666',
    tertiary: '#999999',
    onPrimary: '#ffffff',
  },
  divider: 'rgba(0,0,0,0.08)',
  card: {
    shadow: 'rgba(0,0,0,0.12)',
    border: 'rgba(0,0,0,0.05)',
  }
};

// Premium Glass Card component
const GlassCard = ({ style, children, intensity = 15 }: { 
  style?: any; 
  children: React.ReactNode; 
  intensity?: number 
}) => {
  return Platform.OS === 'ios' ? (
    <BlurView intensity={intensity} tint="light" style={[styles.glassCard, style]}>
      {children}
    </BlurView>
  ) : (
    <View style={[styles.glassCardFallback, style]}>
      {children}
    </View>
  );
};

export default function Devices() {
  const router = useRouter();
  const bluetoothService = useBluetoothService();
  const athleteRepository = useAthleteRepository();
  
  const [savedDevices, setSavedDevices] = useState<DeviceStatus[]>([]);
  const [scannedDevices, setScannedDevices] = useState<{id: string, name: string}[]>([]);
  const [scanning, setScanning] = useState(false);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [connectionInProgress, setConnectionInProgress] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const [selectedDeviceId, setSelectedDeviceId] = useState<string | null>(null);
  const [athleteListVisible, setAthleteListVisible] = useState(false);
  const [athletes, setAthletes] = useState<Athlete[]>([]);
  
  // Load devices and status
  const loadDevices = useCallback(async () => {
    try {
      setLoading(true);
      // Get device statuses from BluetoothService
      const deviceStatuses = bluetoothService.getDeviceStatuses();
      setSavedDevices(deviceStatuses);

      // Load athletes for assignment
      const athleteList = await athleteRepository.getAllAthletes();
      setAthletes(athleteList);
    } catch (error) {
      console.error('Error loading devices:', error);
      Alert.alert('Error', 'Failed to load devices');
    } finally {
      setLoading(false);
    }
  }, [bluetoothService, athleteRepository]);
  
  // Handle refresh
  const handleRefresh = useCallback(async () => {
    setRefreshing(true);
    await loadDevices();
    setRefreshing(false);
  }, [loadDevices]);
  
  // Initial load
  useEffect(() => {
    loadDevices();
  }, [loadDevices]);
  
  // Subscribe to device status updates
  useEffect(() => {
    const unsubscribe = bluetoothService.subscribeToDeviceStatusUpdates((status: DeviceStatus) => {
      // Use a function to update based on previous state
      setSavedDevices(prevStatuses => {
        // Check if this status is already in our list
        const statusIndex = prevStatuses.findIndex(s => s.id === status.id);
        
        if (statusIndex >= 0) {
          // Update existing status
          return prevStatuses.map(s => 
            s.id === status.id ? status : s
          );
        } else {
          // Add new status
          return [...prevStatuses, status];
        }
      });
    });
    
    // Call the remove method on the unsubscribe object instead of treating it as a function
    return () => {
      if (unsubscribe && typeof unsubscribe.remove === 'function') {
        unsubscribe.remove();
      } else {
        console.warn("[Devices] Cleanup function received invalid unsubscribe object:", unsubscribe);
      }
    };
  }, [bluetoothService]);
  
  // Connect to a device
  const connectToDevice = async (deviceId: string, deviceName: string) => {
    try {
      setConnectionInProgress(true);
      setConnectionError(null);
      
      await bluetoothService.connectToDevice(deviceId);
      
      // Success will be reflected via the subscription to device status updates
      Alert.alert('Success', `Connected to ${deviceName || deviceId}`);
    } catch (error) {
      console.error('Error connecting to device:', error);
      setConnectionError('Failed to connect to device. Please try again.');
      Alert.alert('Connection Error', 'Failed to connect to device. Please try again.');
    } finally {
      setConnectionInProgress(false);
    }
  };
  
  // Disconnect from a device
  const disconnectDevice = async (deviceId: string) => {
    try {
      await bluetoothService.disconnectFromDevice(deviceId);
      
      // Success will be reflected via the subscription to device status updates
    } catch (error) {
      console.error('Error disconnecting from device:', error);
      Alert.alert('Disconnection Error', 'Failed to disconnect from device. Please try again.');
    }
  };
  
  // Scan for devices
  const scanDevices = async () => {
    try {
      setScanning(true);
      setScannedDevices([]);
      
      await bluetoothService.scanForDevices((device) => {
        setScannedDevices(prevDevices => {
          const deviceMap = new Map(prevDevices.map(d => [d.id, d]));
          if (!deviceMap.has(device.id) && device.name) {
            deviceMap.set(device.id, { id: device.id, name: device.name });
            return Array.from(deviceMap.values());
          }
          return prevDevices;
        });
      });
      
    } catch (error) {
      console.error('Error scanning for devices:', error);
      Alert.alert('Scan Error', 'Failed to scan for devices. Please check Bluetooth permissions and try again.');
    } finally {
      setScanning(false);
    }
  };
  
  // Open the athlete assignment modal
  const openAssignDeviceModal = (deviceId: string) => {
    setSelectedDeviceId(deviceId);
    setAthleteListVisible(true);
  };
  
  // Assign device to athlete
  const assignDeviceToAthlete = async (athleteId: string) => {
    if (!selectedDeviceId) return;
    
    try {
      await athleteRepository.assignDeviceToAthlete(athleteId, selectedDeviceId);
      
      // Update local saved devices
      await loadDevices();
      
      // Close the modal
      setAthleteListVisible(false);
      setSelectedDeviceId(null);
      
      Alert.alert('Success', 'Device assigned to athlete');
    } catch (error) {
      console.error('Error assigning device to athlete:', error);
      Alert.alert('Assignment Error', 'Failed to assign device to athlete. Please try again.');
    }
  };
  
  // Renders saved device
  const renderDevice = ({ item }: { item: DeviceStatus }) => {
    const isConnected = item.connected;
    
    return (
      <TouchableOpacity 
        style={styles.deviceItem}
        activeOpacity={0.7}
      >
        <LinearGradient
          colors={[isConnected ? 'rgba(0,176,118,0.15)' : 'rgba(0,0,0,0.08)', isConnected ? 'rgba(0,176,118,0.05)' : 'rgba(0,0,0,0.02)']}
          style={[styles.deviceIcon, { borderRadius: 20 }]}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          <MaterialCommunityIcons 
            name="tooth-outline" 
            size={22} 
            color={isConnected ? THEME.primary : THEME.text.secondary} 
          />
        </LinearGradient>
        <View style={styles.deviceInfo}>
          <Text style={styles.deviceName}>{item.name}</Text>
          <Text style={[styles.deviceStatus, isConnected ? styles.connectedText : styles.disconnectedText]}>
            {isConnected ? "Connected" : "Not Connected"}
          </Text>
          {item.batteryLevel !== undefined && (
            <View style={styles.batteryContainer}>
              <MaterialCommunityIcons 
                name={getBatteryIcon(item.batteryLevel)} 
                size={14} 
                color={getBatteryColor(item.batteryLevel)} 
              />
              <Text style={[styles.batteryText, {color: getBatteryColor(item.batteryLevel)}]}>
                {item.batteryLevel}%
              </Text>
            </View>
          )}
          {item.athleteInfo && (
            <Text style={styles.athleteText}>Assigned to: {item.athleteInfo.name}</Text>
          )}
        </View>
        <View style={styles.deviceActions}>
          {connectionInProgress && selectedDeviceId === item.id ? (
            <View style={styles.loadingButton}>
              <ActivityIndicator size="small" color={THEME.primary} />
            </View>
          ) : isConnected ? (
            <TouchableOpacity 
              onPress={() => disconnectDevice(item.id)}
              style={styles.actionButton}
              disabled={connectionInProgress}
              activeOpacity={0.7}
            >
              <MaterialCommunityIcons name="bluetooth-off" size={20} color={THEME.error} />
            </TouchableOpacity>
          ) : (
            <TouchableOpacity 
              onPress={() => connectToDevice(item.id, item.name)}
              style={styles.actionButton}
              disabled={connectionInProgress}
              activeOpacity={0.7}
            >
              <MaterialCommunityIcons name="bluetooth-connect" size={20} color={THEME.primary} />
            </TouchableOpacity>
          )}
          
          <TouchableOpacity 
            onPress={() => openAssignDeviceModal(item.id)}
            style={styles.actionButton}
            activeOpacity={0.7}
          >
            <MaterialCommunityIcons name="account-plus" size={20} color={THEME.text.primary} />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    );
  };
  
  // Renders scanned device
  const renderScannedDevice = ({ item }: { item: any }) => {
    // Check if this device is already saved
    const isAlreadySaved = savedDevices.some(device => device.id === item.id);
    
    return (
      <TouchableOpacity 
        style={styles.deviceItem}
        activeOpacity={0.7}
      >
        <LinearGradient
          colors={['#4c669f', '#3b5998']}
          style={{
            width: 50,
            height: 50,
            borderRadius: 25,
            justifyContent: 'center',
            alignItems: 'center',
            marginRight: 10,
            borderWidth: 2,
            borderColor: 'white',
          }}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 0 }}
        >
          <MaterialCommunityIcons 
            name="bluetooth-connect" 
            size={22} 
            color={THEME.primary} 
          />
        </LinearGradient>
        <View style={styles.deviceInfo}>
          <Text style={styles.deviceName}>{item.name || item.id}</Text>
          <Text style={styles.newDeviceLabel}>New Device</Text>
        </View>
        <View style={styles.deviceActions}>
          {!isAlreadySaved && (
            <TouchableOpacity 
              onPress={() => connectToDevice(item.id, item.name)}
              style={styles.actionButton}
              disabled={connectionInProgress}
              activeOpacity={0.7}
            >
              <MaterialCommunityIcons name="bluetooth-connect" size={20} color={THEME.primary} />
            </TouchableOpacity>
          )}
        </View>
      </TouchableOpacity>
    );
  };
  
  // Renders athlete for assignment
  const renderAthlete = ({ item }: { item: Athlete }) => {
    const hasDevice = item.deviceId !== undefined && item.deviceId !== null;
    
    return (
      <TouchableOpacity 
        style={[styles.athleteItem, hasDevice && styles.athleteItemDisabled]}
        onPress={() => !hasDevice && assignDeviceToAthlete(item.id)}
        disabled={hasDevice}
        activeOpacity={0.7}
      >
        <LinearGradient
          colors={[hasDevice ? 'rgba(0,0,0,0.05)' : 'rgba(0,176,118,0.15)', hasDevice ? 'rgba(0,0,0,0.02)' : 'rgba(0,176,118,0.05)']}
          style={[styles.deviceIcon, { borderRadius: 20 }]}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          <MaterialCommunityIcons 
            name="account" 
            size={22} 
            color={hasDevice ? THEME.text.tertiary : THEME.primary} 
          />
        </LinearGradient>
        <View style={styles.athleteInfo}>
          <Text style={[styles.athleteName, hasDevice && styles.textDisabled]}>{item.name}</Text>
          {hasDevice ? (
            <Text style={styles.textDisabled}>Already has device assigned</Text>
          ) : (
            <Text style={styles.availableText}>Available for assignment</Text>
          )}
        </View>
      </TouchableOpacity>
    );
  };

  return (
    <SafeAreaProvider>
      <ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            tintColor={THEME.primary}
            colors={[THEME.primary]}
            progressBackgroundColor="rgba(0,0,0,0.05)"
          />
        }
      >
        {/* Premium Header with Gradient */}
        <View style={styles.header}>
          <LinearGradient
            colors={['rgba(0,176,118,0.15)', 'rgba(0,176,118,0.05)', 'transparent']}
            style={styles.headerGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          />
          <View style={styles.headerContent}>
            <Text style={styles.headerTitle}>Devices</Text>
          </View>
        </View>

        {/* Connected Devices Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Connected Devices</Text>
          <GlassCard style={styles.sectionCard}>
            <LinearGradient
              colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
              style={styles.cardGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 0, y: 1 }}
            />
            <View style={styles.cardInner}>
              {savedDevices.filter(device => device.connected).length > 0 ? (
                <FlatList
                  data={savedDevices.filter(device => device.connected)}
                  keyExtractor={(item) => item.id}
                  renderItem={renderDevice}
                  scrollEnabled={false}
                  ItemSeparatorComponent={() => <View style={styles.deviceSeparator} />}
                />
              ) : (
                <View style={styles.emptyStateContainer}>
                  <LinearGradient
                    colors={['rgba(0,0,0,0.06)', 'rgba(0,0,0,0.03)']}
                    style={[styles.emptyStateIcon, { borderRadius: 30 }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                  >
                    <MaterialCommunityIcons name="bluetooth-off" size={36} color={THEME.text.tertiary} />
                  </LinearGradient>
                  <Text style={styles.emptyStateText}>No connected devices</Text>
                  <Text style={styles.emptyStateSubtext}>Connect to a mouthguard device to monitor impacts</Text>
                </View>
              )}
            </View>
          </GlassCard>
        </View>

        {/* Available Devices Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Available Devices</Text>
          <GlassCard style={styles.sectionCard}>
            <LinearGradient
              colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
              style={styles.cardGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 0, y: 1 }}
            />
            <View style={styles.cardInner}>
              {savedDevices.filter(device => !device.connected).length > 0 ? (
                <FlatList
                  data={savedDevices.filter(device => !device.connected)}
                  keyExtractor={(item) => item.id}
                  renderItem={renderDevice}
                  scrollEnabled={false}
                  ItemSeparatorComponent={() => <View style={styles.deviceSeparator} />}
                />
              ) : (
                <View style={styles.emptyStateContainer}>
                  <LinearGradient
                    colors={['rgba(0,0,0,0.06)', 'rgba(0,0,0,0.03)']}
                    style={[styles.emptyStateIcon, { borderRadius: 30 }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                  >
                    <MaterialCommunityIcons name="bluetooth-settings" size={36} color={THEME.text.tertiary} />
                  </LinearGradient>
                  <Text style={styles.emptyStateText}>No available devices</Text>
                  <Text style={styles.emptyStateSubtext}>All saved devices are currently connected</Text>
                </View>
              )}
            </View>
          </GlassCard>
        </View>

        {/* Scan Devices Section */}
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Discover New Devices</Text>
            <TouchableOpacity 
              style={styles.scanButton}
              onPress={scanDevices}
              disabled={scanning}
              activeOpacity={0.8}
            >
              <LinearGradient
                colors={['#00d68f', '#00b076']}
                style={[StyleSheet.absoluteFill, { borderRadius: 24 }]}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 1 }}
              />
              <MaterialCommunityIcons name="bluetooth-connect" size={20} color="#fff" />
              <Text style={styles.scanButtonText}>
                {scanning ? 'Scanning...' : 'Scan'}
              </Text>
              {scanning && <ActivityIndicator color="#fff" style={{ marginLeft: 8 }} />}
            </TouchableOpacity>
          </View>
          
          <GlassCard style={styles.sectionCard}>
            <LinearGradient
              colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
              style={styles.cardGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 0, y: 1 }}
            />
            <View style={styles.cardInner}>
              {scanning ? (
                <View style={styles.loadingContainer}>
                  <ActivityIndicator size="large" color={THEME.primary} />
                  <Text style={styles.loadingText}>Scanning for devices...</Text>
                </View>
              ) : scannedDevices.length > 0 ? (
                <FlatList
                  data={scannedDevices}
                  keyExtractor={(item) => item.id}
                  renderItem={renderScannedDevice}
                  scrollEnabled={false}
                  ItemSeparatorComponent={() => <View style={styles.deviceSeparator} />}
                />
              ) : (
                <View style={styles.emptyStateContainer}>
                  <LinearGradient
                    colors={['rgba(0,0,0,0.06)', 'rgba(0,0,0,0.03)']}
                    style={[styles.emptyStateIcon, { borderRadius: 30 }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                  >
                    <MaterialCommunityIcons name="bluetooth-transfer" size={36} color={THEME.text.tertiary} />
                  </LinearGradient>
                  <Text style={styles.emptyStateText}>No devices found</Text>
                  <Text style={styles.emptyStateSubtext}>Tap the Scan button to search for nearby mouthguard devices</Text>
                </View>
              )}
            </View>
          </GlassCard>
        </View>

        {/* Athletes Section */}
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Athletes & Assignments</Text>
            <TouchableOpacity 
              style={styles.addButton}
              onPress={() => router.push('/(tabs)/athletes')}
              activeOpacity={0.8}
            >
              <LinearGradient
                colors={['#00d68f', '#00b076']}
                style={[StyleSheet.absoluteFill, { borderRadius: 24 }]}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 1 }}
              />
              <MaterialCommunityIcons name="account-plus" size={20} color="#fff" />
              <Text style={styles.scanButtonText}>Add Athlete</Text>
            </TouchableOpacity>
          </View>
          
          <GlassCard style={styles.sectionCard}>
            <LinearGradient
              colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
              style={styles.cardGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 0, y: 1 }}
            />
            <View style={styles.cardInner}>
              {athletes.length > 0 ? (
                <FlatList
                  data={athletes}
                  keyExtractor={(item) => item.id}
                  renderItem={renderAthlete}
                  scrollEnabled={false}
                  ItemSeparatorComponent={() => <View style={styles.deviceSeparator} />}
                />
              ) : (
                <View style={styles.emptyStateContainer}>
                  <LinearGradient
                    colors={['rgba(0,0,0,0.06)', 'rgba(0,0,0,0.03)']}
                    style={[styles.emptyStateIcon, { borderRadius: 30 }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                  >
                    <MaterialCommunityIcons name="account-group" size={36} color={THEME.text.tertiary} />
                  </LinearGradient>
                  <Text style={styles.emptyStateText}>No athletes found</Text>
                  <Text style={styles.emptyStateSubtext}>Add athletes to start assigning devices</Text>
                </View>
              )}
            </View>
          </GlassCard>
        </View>

        {connectionError && (
          <View style={styles.errorContainer}>
            <MaterialCommunityIcons name="alert-circle" size={20} color={THEME.error} />
            <Text style={styles.errorText}>{connectionError}</Text>
          </View>
        )}
        
        {/* Bottom tab spacer */}
        <View style={{ height: 24 }} />
      </ScrollView>
    </SafeAreaProvider>
  );
}

// Helper functions
const getBatteryIcon = (level: number | undefined) => {
  if (level === undefined) return 'battery-unknown';
  if (level <= 10) return 'battery-10';
  if (level <= 20) return 'battery-20';
  if (level <= 30) return 'battery-30';
  if (level <= 40) return 'battery-40';
  if (level <= 50) return 'battery-50';
  if (level <= 60) return 'battery-60';
  if (level <= 70) return 'battery-70';
  if (level <= 80) return 'battery-80';
  if (level <= 90) return 'battery-90';
  return 'battery';
};

const getBatteryColor = (level: number | undefined) => {
  if (level === undefined) return '#999999';
  if (level <= 20) return '#ff3b30'; // Red
  if (level <= 40) return '#ff9500'; // Orange
  return '#34c759'; // Green
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.background, // Beige background
  },
  contentContainer: {
    paddingBottom: 32,
    paddingHorizontal: 16,
  },
  // Premium header styling
  header: {
    height: 140,
    position: 'relative',
    marginBottom: 20,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  headerContent: {
    flex: 1,
    paddingTop: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: THEME.text.primary,
    letterSpacing: 0.5,
  },
  section: {
    marginBottom: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 12,
    letterSpacing: 0.3,
  },
  // Glass card styles
  glassCard: {
    borderRadius: 16,
    overflow: 'hidden',
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  glassCardFallback: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: THEME.cardBackground,
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  cardGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  cardInner: {
    padding: 16,
  },
  sectionCard: {
    position: 'relative',
  },
  deviceItem: {
    flexDirection: 'row',
    paddingVertical: 14,
    paddingHorizontal: 4,
    alignItems: 'center',
    backgroundColor: 'transparent',
  },
  deviceIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(0, 176, 118, 0.2)',
  },
  deviceInfo: {
    flex: 1,
  },
  deviceName: {
    fontSize: 16,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 4,
    letterSpacing: 0.2,
  },
  deviceStatus: {
    fontSize: 14,
    marginBottom: 4,
    letterSpacing: 0.2,
  },
  connectedText: {
    color: THEME.success,
    fontWeight: '500',
  },
  disconnectedText: {
    color: THEME.text.tertiary,
  },
  newDeviceLabel: {
    color: THEME.primary,
    fontSize: 14,
    fontWeight: '500',
    letterSpacing: 0.2,
  },
  batteryContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.03)',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 10,
    alignSelf: 'flex-start',
    marginBottom: 4,
  },
  batteryText: {
    fontSize: 12,
    marginLeft: 4,
    fontWeight: '500',
  },
  athleteText: {
    fontSize: 12,
    color: THEME.primary,
    fontWeight: '500',
    letterSpacing: 0.2,
  },
  deviceActions: {
    flexDirection: 'row',
  },
  actionButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0,0,0,0.03)',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 6,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  loadingButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0,0,0,0.03)',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 6,
  },
  deviceSeparator: {
    height: StyleSheet.hairlineWidth,
    backgroundColor: THEME.divider,
    marginHorizontal: 4,
  },
  // Premium scan button
  scanButton: {
    position: 'relative',
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 24,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  addButton: {
    position: 'relative',
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 24,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  scanButtonText: {
    color: THEME.text.onPrimary,
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 6,
  },
  emptyStateContainer: {
    padding: 32,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyStateIcon: {
    width: 60,
    height: 60,
    borderRadius: 30,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  emptyStateText: {
    fontSize: 17,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 8,
    textAlign: 'center',
    letterSpacing: 0.2,
  },
  emptyStateSubtext: {
    fontSize: 15,
    color: THEME.text.secondary,
    textAlign: 'center',
    lineHeight: 22,
    maxWidth: '80%',
  },
  loadingContainer: {
    padding: 32,
    alignItems: 'center',
    backgroundColor: 'transparent',
  },
  loadingText: {
    marginTop: 12,
    color: THEME.text.secondary,
    fontSize: 15,
    letterSpacing: 0.2,
  },
  errorContainer: {
    backgroundColor: 'rgba(255, 50, 50, 0.08)',
    padding: 12,
    borderRadius: 12,
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 59, 48, 0.2)',
  },
  errorText: {
    color: THEME.error,
    fontSize: 14,
    marginLeft: 8,
    flex: 1,
  },
  athleteItem: {
    flexDirection: 'row',
    paddingVertical: 14,
    paddingHorizontal: 4,
    alignItems: 'center',
    backgroundColor: 'transparent',
  },
  athleteInfo: {
    flex: 1,
  },
  athleteName: {
    fontSize: 16,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 4,
    letterSpacing: 0.2,
  },
  textDisabled: {
    color: THEME.text.tertiary,
  },
  availableText: {
    color: THEME.primary,
    fontSize: 12,
  },
  athleteItemDisabled: {
    opacity: 0.7,
  }
});

================================================================================
File: app/(tabs)/index.tsx
================================================================================

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  TouchableOpacity, 
  ActivityIndicator,
  ScrollView,
  Alert,
  RefreshControl,
  Platform,
} from 'react-native';
import { useRouter } from 'expo-router';
import { 
  COLORS, 
  SAMPLE_ATHLETES, 
  SAMPLE_IMPACT_EVENTS, 
  SAMPLE_SENSOR_READINGS,
  playerData,
} from '@/src/constants';
import { useBluetoothService, useDeviceService } from '@/src/providers/AppProvider';
import { LiveDataPoint, SavedDevice, DeviceStatus } from '@/src/types';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import LineChart from '../../app/components/charts/LineChart';
import { BlurView } from 'expo-blur';
import { LinearGradient } from 'expo-linear-gradient';

// Sample data remains the same
const SAMPLE_DEVICES = [
  {
    id: 'mouthguard_A',
    name: 'Mouthguard A',
    connected: true,
    batteryLevel: 85,
    athlete: SAMPLE_ATHLETES.find(a => a.deviceId === 'mouthguard_A')
  },
  {
    id: 'mouthguard_B',
    name: 'Mouthguard B',
    connected: true,
    batteryLevel: 72,
    athlete: SAMPLE_ATHLETES.find(a => a.deviceId === 'mouthguard_B')
  }
];

// Get some sample accelerometer data for charting
const accelerometerData = SAMPLE_SENSOR_READINGS
  .find(group => group.table === 'accelerometer_data')?.data || [];

// Custom theme colors for beige theme
const THEME = {
  background: '#f2efe4', // Beige background matching bottom bar
  cardBackground: '#ffffff',
  primary: '#00b076', // Green primary color
  text: {
    primary: '#333333',
    secondary: '#666666',
    tertiary: '#999999',
  },
  divider: 'rgba(0,0,0,0.08)',
  card: {
    shadow: 'rgba(0,0,0,0.12)',
    border: 'rgba(0,0,0,0.05)',
  },
  error: COLORS.error,
  warning: COLORS.warning,
};

// Premium Glass Card component with proper TypeScript types
const GlassCard: React.FC<{style?: any, children: React.ReactNode, intensity?: number}> = 
  ({ style, children, intensity = 15 }) => {
    return Platform.OS === 'ios' ? (
      <BlurView intensity={intensity} tint="light" style={[styles.glassCard, style]}>
        {children}
      </BlurView>
    ) : (
      <View style={[styles.glassCardFallback, style]}>
        {children}
      </View>
    );
  };

export default function Dashboard() {
  const router = useRouter();
  const bluetoothService = useBluetoothService();
  const deviceService = useDeviceService();
  
  // Session State
  const [isSessionActive, setIsSessionActive] = useState(false);
  const [sessionStartTime, setSessionStartTime] = useState<Date | null>(null);
  const [elapsedTime, setElapsedTime] = useState(0);
  
  // Loading & Refreshing State
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  
  // Data State 
  const [connectedDevices, setConnectedDevices] = useState<DeviceStatus[]>([]);
  const [recentImpacts, setRecentImpacts] = useState(SAMPLE_IMPACT_EVENTS);
  const [deviceHistory, setDeviceHistory] = useState<SavedDevice[]>([]); 
  
  // Live Data State
  const [currentAcceleration, setCurrentAcceleration] = useState<number | null>(null);
  const [currentHeartRate, setCurrentHeartRate] = useState<number | null>(null);
  const [maxHeartRateSession, setMaxHeartRateSession] = useState<number | null>(null);
  
  // Create a ref to track the latest connectedDevices state without triggering effect reruns
  const connectedDevicesRef = useRef<DeviceStatus[]>([]);
  
  // Update the ref whenever connectedDevices changes
  useEffect(() => {
    connectedDevicesRef.current = connectedDevices;
  }, [connectedDevices]);
  
  // Timer interval for session timing remains the same
  useEffect(() => {
    let timerInterval = null;
    
    if (isSessionActive && sessionStartTime) {
      timerInterval = setInterval(() => {
        const now = new Date();
        const elapsed = now.getTime() - sessionStartTime.getTime();
        setElapsedTime(elapsed);
      }, 1000);
    }
    
    return () => {
      if (timerInterval) {
        clearInterval(timerInterval);
      }
    };
  }, [isSessionActive, sessionStartTime]);
  
  // Load data function with real data
  const loadData = useCallback(async () => {
    console.log("[Dashboard] Loading data...");
    setLoading(true);
    try {
      // Fetch device statuses from bluetooth service
      const initialStatuses = bluetoothService.getDeviceStatuses();
      setConnectedDevices(initialStatuses.filter(d => d.connected));

      // Fetch saved device history
      const saved = await deviceService.getSavedDevices();
      // Sort by last connected time (most recent first) and take top 5
      const sortedHistory = saved
        .filter(d => d.lastConnected)
        .sort((a, b) => (b.lastConnected || 0) - (a.lastConnected || 0))
        .slice(0, 5);
      setDeviceHistory(sortedHistory);

      // For now, keep sample impacts until we implement the repository
      // const impacts = await sensorDataRepository.getRecentImpacts(5);
      // setRecentImpacts(impacts);

      console.log("[Dashboard] Initial data loaded");
    } catch (error) {
      console.error('Error loading dashboard data:', error);
      Alert.alert('Error', 'Failed to load dashboard data');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, [bluetoothService, deviceService]);

  // Modify the useEffect for Bluetooth subscriptions to remove connectedDevices dependency
  useEffect(() => {
    loadData(); // Initial load

    // Subscribe to device status updates
    const statusSubscription = bluetoothService.subscribeToDeviceStatusUpdates(deviceStatus => {
      // Update the list of connected devices
      setConnectedDevices(prev => {
        const existingIndex = prev.findIndex(d => d.id === deviceStatus.id);
        if (deviceStatus.connected) {
          if (existingIndex > -1) {
            // Update existing
            const updated = [...prev];
            updated[existingIndex] = deviceStatus;
            return updated;
          } else {
            // Add new connected device
            return [...prev, deviceStatus];
          }
        } else {
          // Remove disconnected device
          return prev.filter(d => d.id !== deviceStatus.id);
        }
      });
    });

    // Subscribe to live sensor data
    const sensorSubscription = bluetoothService.subscribeSensorData((deviceId, dataPoint: LiveDataPoint) => {
      // Use the ref instead of the state to check if device is connected
      const deviceIsConnected = connectedDevicesRef.current.some(d => d.id === deviceId);
      if (!deviceIsConnected) return;

      if (dataPoint.type === 'accelerometer') {
        const magnitude = dataPoint.values[3]; // Assuming magnitude is the 4th value
        setCurrentAcceleration(magnitude);
      } else if (dataPoint.type === 'heartRate') {
        const hr = dataPoint.values[0];
        setCurrentHeartRate(hr);
        // Update session max HR if needed
        if (isSessionActive) {
          setMaxHeartRateSession(prevMax => (hr > (prevMax ?? 0) ? hr : prevMax));
        }
      }
    });

    return () => {
      statusSubscription.remove();
      sensorSubscription.remove();
    };
  }, [bluetoothService, loadData, isSessionActive]);

  // Handle refresh
  const onRefresh = useCallback(() => {
    console.log("[Dashboard] Refresh triggered");
    setRefreshing(true);
    loadData();
  }, [loadData]);
  
  // Session control functions remain the same
  const handleStartSession = () => {
    setIsSessionActive(true);
    setSessionStartTime(new Date());
    setElapsedTime(0);
    setMaxHeartRateSession(null); // Reset max HR for new session
    Alert.alert('Session Started', 'Monitoring session has begun. All connected devices will record data.');
  };
  
  const handleStopSession = async () => {
    if (!isSessionActive || !sessionStartTime) return;
    
    const endTime = new Date();
    const duration = endTime.getTime() - sessionStartTime.getTime();
    setIsSessionActive(false);
    
    try {
      // Simulate saving session
      await new Promise(resolve => setTimeout(resolve, 500));
      
      Alert.alert(
        'Session Ended',
        `Duration: ${formatDuration(duration)}`,
        [{ text: 'View Report', onPress: () => router.push('/(tabs)/reports') }, { text: 'OK' }]
      );
    } catch (error) {
      console.error('Error ending session:', error);
      Alert.alert('Error', 'Failed to end session');
    }
  };
  
  const formatDuration = (ms: number) => {
    const totalSeconds = Math.floor(ms / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    
    // Format: hh:mm:ss
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  };
  
  // Extract data for the accelerometer magnitude chart
  const magnitudeData = accelerometerData.map(d => {
    // Handle different sensor data types
    if ('x' in d && 'y' in d && 'z' in d) {
      const x = d.x || 0;
      const y = d.y || 0;
      const z = d.z || 0;
      return Math.sqrt(x*x + y*y + z*z);
    }
    return 0;
  });
  const magnitudeLabels = accelerometerData.map((_, i) => `${i}`);

  // Prepare data for athletes summary
  const totalAthletes = SAMPLE_ATHLETES.length;
  const assignedAthletes = SAMPLE_ATHLETES.filter(a => a.deviceId).length;
  const unassignedAthletes = totalAthletes - assignedAthletes;

  const formatTimestamp = (ts: number | undefined): string => {
    if (!ts) return 'Never';
    const date = new Date(ts);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  // --- Data from constants.ts ---
  const { name, sessions, isDeviceConnected } = playerData;
  // Get data for the latest session to display summaries
  const latestSession = sessions.length > 0 ? sessions[0] : null;
  const sessionStats = latestSession?.stats;
  const concussionRisk = sessionStats?.concussionRisk;

  // --- Navigation Handler for Tiles ---
  const handleTilePress = (focusSection: string) => {
    router.push({
      pathname: '/reportsDetailed', // Navigate to the NEW reports screen
      params: { focus: focusSection } // Optional: pass parameter
    });
  };

  const navigateToLogs = () => {
    // Fix navigation path to avoid conflicts
    router.push('/screens/logs');
  };

  return (
    <View style={styles.container}>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor={THEME.primary}
            colors={[THEME.primary]}
            progressBackgroundColor="rgba(0,0,0,0.05)"
          />
        }
      >
        {/* Header */}
        <View style={styles.header}>
          <LinearGradient
            colors={['rgba(0,176,118,0.15)', 'rgba(0,176,118,0.05)', 'transparent']}
            style={styles.headerGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          />
          <View style={styles.headerContent}>
            <Text style={styles.headerTitle}>{name}</Text>
            <TouchableOpacity 
              style={styles.profileContainer} 
              onPress={() => router.push('/(tabs)/settings')}
            >
              <MaterialCommunityIcons 
                name="account-circle-outline" 
                size={28} 
                color={THEME.primary} 
              />
            </TouchableOpacity>
          </View>
        </View>

        {/* --- Alert Banner (Conditional) --- */}
        {concussionRisk === 'High' && (
          <View style={styles.alertBanner}>
            <MaterialCommunityIcons name="alert-decagram" size={24} color="#fff" style={styles.alertIcon} />
            <Text style={styles.alertText}>High Concussion Risk Detected</Text>
          </View>
        )}

        {/* --- Session Control (Keep this GlassCard) --- */}
        <GlassCard style={styles.card}>
          <View style={styles.sessionHeader}>
            <View>
              <Text style={styles.sessionTitle}>
                {isSessionActive ? 'Session in Progress' : 'Start New Session'}
              </Text>
              {isSessionActive && sessionStartTime && (
                <Text style={styles.sessionTime}>
                  Duration: {formatDuration(elapsedTime)}
                </Text>
              )}
            </View>
            <View style={styles.sessionControls}>
              {isSessionActive ? (
                <TouchableOpacity
                  style={[styles.sessionButton, styles.stopButton]}
                  onPress={handleStopSession}
                >
                  <MaterialCommunityIcons name="stop-circle" size={20} color="#fff" />
                  <Text style={styles.sessionButtonText}>End</Text>
                </TouchableOpacity>
              ) : (
                <TouchableOpacity
                  style={[styles.sessionButton, styles.startButton]}
                  onPress={handleStartSession}
                >
                  <LinearGradient
                    colors={['#00d68f', '#00b076']}
                    style={StyleSheet.absoluteFill}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                  />
                  <MaterialCommunityIcons name="play-circle" size={20} color="#fff" />
                  <Text style={styles.sessionButtonText}>Start</Text>
                </TouchableOpacity>
              )}
            </View>
          </View>
        </GlassCard>

        {/* --- NEW: Summary Tiles Card --- */}
        <GlassCard style={styles.card}>
          <View style={styles.summaryTilesContainer}>
            {/* Heart Rate Tile */}
            <TouchableOpacity style={styles.summaryTile} onPress={() => handleTilePress('heartRate')}>
              <MaterialCommunityIcons name="heart-pulse" size={32} color={THEME.primary} />
              <Text style={styles.summaryTileValue}>{sessionStats?.heartRate?.avg ?? '--'} bpm</Text>
              <Text style={styles.summaryTileLabel}>Avg Heart Rate</Text>
            </TouchableOpacity>

            {/* Temperature Tile */}
            <TouchableOpacity style={styles.summaryTile} onPress={() => handleTilePress('temperature')}>
              <MaterialCommunityIcons name="thermometer" size={32} color={THEME.primary} />
              <Text style={styles.summaryTileValue}>{sessionStats?.temperature ?? '--'} F</Text>
              <Text style={styles.summaryTileLabel}>Avg Temp</Text>
            </TouchableOpacity>

            {/* Acceleration Tile */}
            <TouchableOpacity style={styles.summaryTile} onPress={() => handleTilePress('acceleration')}>
              <MaterialCommunityIcons name="run-fast" size={32} color={THEME.primary} />
              <Text style={styles.summaryTileValue}>{sessionStats?.acceleration ?? '--'} mph</Text>
              <Text style={styles.summaryTileLabel}>Avg Accel</Text>
            </TouchableOpacity>
          </View>
        </GlassCard>
        
        {/* --- Data Logs & Analytics Card --- */}
        <GlassCard style={styles.card}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Data & Analytics</Text>
          </View>
          <View style={styles.summaryTilesContainer}>
            {/* Data Logs Tile */}
            <TouchableOpacity style={styles.summaryTile} onPress={navigateToLogs}>
              <MaterialCommunityIcons name="chart-line" size={32} color={THEME.primary} />
              <Text style={styles.summaryTileValue}>Logs</Text>
              <Text style={styles.summaryTileLabel}>View Data</Text>
            </TouchableOpacity>
            
            {/* Test Data Generator Tile */}
            <TouchableOpacity style={styles.summaryTile} onPress={() => router.push('/screens/TestDataScreen')}>
              <MaterialCommunityIcons name="database-plus" size={32} color={THEME.primary} />
              <Text style={styles.summaryTileValue}>Test Data</Text>
              <Text style={styles.summaryTileLabel}>Insert Data</Text>
            </TouchableOpacity>
            
            {/* Reports Tile */}
            <TouchableOpacity style={styles.summaryTile} onPress={() => router.push('/(tabs)/reportsDetailed')}>
              <MaterialCommunityIcons name="chart-timeline-variant" size={32} color={THEME.primary} />
              <Text style={styles.summaryTileValue}>Reports</Text>
              <Text style={styles.summaryTileLabel}>Analytics</Text>
            </TouchableOpacity>
            
            {/* Settings Tile */}
            <TouchableOpacity style={styles.summaryTile} onPress={() => router.push('/(tabs)/settings')}>
              <MaterialCommunityIcons name="cog-outline" size={32} color={THEME.primary} />
              <Text style={styles.summaryTileValue}>Settings</Text>
              <Text style={styles.summaryTileLabel}>Configure</Text>
            </TouchableOpacity>
          </View>
        </GlassCard>

        {/* Bottom tab spacer */}
        <View style={{ height: 80 }}><Text style={{ display: 'none' }}>Spacer for footer</Text></View>

      </ScrollView>

      {/* --- Connection Status Footer --- */}
      <View style={styles.connectionStatusFooter}>
        <Text style={styles.connectionStatusText}>
          {isDeviceConnected ? 'Device Connected' : 'No Device Connected'}
        </Text>
      </View>
    </View>
  );
}

// Helper functions remain similar with updated colors
const getSeverityColor = (severity: string) => {
  switch (severity.toLowerCase()) {
    case 'severe':
      return '#ff3b30'; // Red
    case 'moderate':
      return '#ff9500'; // Orange
    case 'mild':
      return '#00b076'; // Green
    default:
      return '#00b076'; // Green
  }
};

const getBatteryIcon = (level: number) => {
  if (level === undefined) return 'battery-unknown';
  if (level <= 10) return 'battery-10';
  if (level <= 20) return 'battery-20';
  if (level <= 30) return 'battery-30';
  if (level <= 40) return 'battery-40';
  if (level <= 50) return 'battery-50';
  if (level <= 60) return 'battery-60';
  if (level <= 70) return 'battery-70';
  if (level <= 80) return 'battery-80';
  if (level <= 90) return 'battery-90';
  return 'battery';
};

const getBatteryColor = (level: number) => {
  if (level === undefined) return '#999999';
  if (level <= 20) return '#ff3b30'; // Red
  if (level <= 40) return '#ff9500'; // Orange
  return '#34c759'; // Green
};

const formatTime = (timestamp: number) => {
  const date = new Date(timestamp);
  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.background,
  },
  scrollView: {
    flex: 1,
  },
  content: {
    paddingBottom: 32,
  },
  header: {
    height: 140,
    position: 'relative',
    marginBottom: 20,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: THEME.text.primary,
    letterSpacing: 0.5,
    flex: 1,
  },
  profileContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0,176,118,0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(0,176,118,0.2)',
    marginLeft: 16,
  },
  alertBanner: {
    backgroundColor: THEME.error,
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
    marginHorizontal: 16,
    borderRadius: 8,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  alertIcon: {
    marginRight: 10,
  },
  alertText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
    flex: 1,
  },
  card: {
    marginHorizontal: 16,
    marginBottom: 16,
  },
  sessionHeader: {
    padding: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  sessionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 4,
  },
  sessionTime: {
    fontSize: 14,
    color: THEME.text.secondary,
  },
  sessionControls: {
    flexDirection: 'row',
  },
  sessionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 24,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    minWidth: 80,
    justifyContent: 'center',
  },
  startButton: {
    position: 'relative',
  },
  stopButton: {
    backgroundColor: THEME.error,
  },
  sessionButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 4,
    fontSize: 14,
  },
  summaryTilesContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 16,
  },
  summaryTile: {
    flex: 1,
    alignItems: 'center',
    padding: 10,
    marginHorizontal: 4,
    borderRadius: 12,
    backgroundColor: 'rgba(0,0,0,0.03)',
    minHeight: 120,
    justifyContent: 'center',
  },
  summaryTileValue: {
    fontSize: 18,
    fontWeight: '700',
    color: THEME.text.primary,
    marginVertical: 8,
  },
  summaryTileLabel: {
    fontSize: 13,
    color: THEME.text.secondary,
    textAlign: 'center',
  },
  sectionHeader: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: THEME.divider,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: THEME.text.primary,
  },
  connectionStatusFooter: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    paddingVertical: 8,
    alignItems: 'center',
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  connectionStatusText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '500',
  },
  glassCard: {
    borderRadius: 16,
    overflow: 'hidden',
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  glassCardFallback: {
    borderRadius: 16,
    backgroundColor: THEME.cardBackground,
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
    marginHorizontal: 16,
    marginBottom: 16,
  },
});

================================================================================
File: app/(tabs)/livemonitor.tsx
================================================================================

import React, { useState, useEffect, useRef } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  ActivityIndicator, 
  TouchableOpacity, 
  Platform 
} from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import { useBluetoothService } from '@/src/providers/AppProvider';
import { DeviceStatus, LiveDataPoint } from '@/src/types';
import LineChart from '../components/charts/LineChart';
import { BlurView } from 'expo-blur';
import { LinearGradient } from 'expo-linear-gradient';

// Maximum number of data points to keep per device
const MAX_DATA_POINTS = 20;

// Custom theme colors to match the beige theme from index.tsx
const THEME = {
  background: '#f2efe4', // Beige background matching bottom bar
  cardBackground: '#ffffff',
  primary: '#00b076', // Green primary color
  text: {
    primary: '#333333',
    secondary: '#666666',
    tertiary: '#999999',
  },
  divider: 'rgba(0,0,0,0.08)',
  card: {
    shadow: 'rgba(0,0,0,0.12)',
    border: 'rgba(0,0,0,0.05)',
  }
};

// Premium Glass Card component
const GlassCard = ({ style, children, intensity = 15 }) => {
  return Platform.OS === 'ios' ? (
    <BlurView intensity={intensity} tint="light" style={[styles.glassCard, style]}>
      {children}
    </BlurView>
  ) : (
    <View style={[styles.glassCardFallback, style]}>
      {children}
    </View>
  );
};

export default function LiveMonitorScreen() {
  const [connectedDevices, setConnectedDevices] = useState([]);
  const [loading, setLoading] = useState(true);
  const [sessionActive, setSessionActive] = useState(false);
  const [liveData, setLiveData] = useState({});
  
  const bluetoothService = useBluetoothService();
  
  // Reference to store sensor data subscriptions
  const sensorDataSubscriptionRef = useRef(null);
  
  // Initialize device status and data
  useEffect(() => {
    console.log('[LiveMonitorScreen] useEffect running. Subscribing...');

    // Flag to prevent setting loading state multiple times if updates come fast
    let initialLoadComplete = false;
    
    // Subscribe to device status updates
    const subscription = bluetoothService.subscribeToDeviceStatusUpdates((deviceStatus) => {
      console.log('[LiveMonitorScreen] Device Status Update Received:', deviceStatus);
      setConnectedDevices(prevDevices => {
        // Update or add device
        const updatedDevices = [...prevDevices];
        const existingIndex = updatedDevices.findIndex(d => d.id === deviceStatus.id);
        
        if (existingIndex >= 0) {
          updatedDevices[existingIndex] = deviceStatus;
        } else if (deviceStatus.connected) {
          updatedDevices.push(deviceStatus);
        }
        
        // Filter out disconnected devices
        return updatedDevices.filter(d => d.connected);
      });
      
      // Set loading to false ONCE on the first update received
      if (!initialLoadComplete) {
        setLoading(false);
        initialLoadComplete = true;
        console.log('[LiveMonitorScreen] Initial load complete via status update.');
      }
    });
    
    // Subscribe to sensor data updates
    const unsubscribeSensorData = bluetoothService.subscribeSensorData((deviceId, dataPoint) => {
      setLiveData(prevData => {
        // Initialize array for this device if it doesn't exist
        const deviceData = prevData[deviceId] || [];
        
        // Add new data point and limit length
        const updatedData = [...deviceData, dataPoint];
        if (updatedData.length > MAX_DATA_POINTS) {
          updatedData.shift(); // Remove oldest data point
        }
        
        return {
          ...prevData,
          [deviceId]: updatedData
        };
      });
    });
    
    // --- FIX: Ensure loading becomes false even if no initial status update ---
    // Use a small timeout to allow initial updates to potentially arrive first,
    // but guarantee the loading state resolves.
    const loadingTimeout = setTimeout(() => {
      if (!initialLoadComplete) {
        setLoading(false);
        initialLoadComplete = true;
        console.log('[LiveMonitorScreen] Initial load complete via timeout.');
      }
    }, 1500); // Wait 1.5 seconds
    
    // Save unsubscribe function to ref
    sensorDataSubscriptionRef.current = unsubscribeSensorData;
    
    return () => {
      console.log('[LiveMonitorScreen] Cleaning up subscriptions.');
      clearTimeout(loadingTimeout); // Clear the timeout on cleanup
      subscription.remove();
      if (sensorDataSubscriptionRef.current) {
        sensorDataSubscriptionRef.current();
      }
    };
  }, [bluetoothService]);
  
  // Handle session start/stop
  const toggleSession = async () => {
    if (sessionActive) {
      // Stop session
      try {
        await bluetoothService.stopSession();
        setSessionActive(false);
      } catch (error) {
        console.error('Error stopping session:', error);
      }
    } else {
      // Start session
      try {
        await bluetoothService.startSession();
        setSessionActive(true);
      } catch (error) {
        console.error('Error starting session:', error);
      }
    }
  };
  
  // Render chart for a device's data
  const renderDeviceChart = (deviceId) => {
    const deviceData = liveData[deviceId] || [];
    
    if (deviceData.length === 0) {
      return (
        <View style={styles.emptyChart}>
          <Text style={styles.emptyChartText}>Waiting for data...</Text>
        </View>
      );
    }
    
    // Get the latest data point to display current values
    const latestData = deviceData[deviceData.length - 1];
    
    // For accelerometer data, for example
    if (latestData.type === 'accelerometer') {
      const chartData = {
        labels: deviceData.map((_, i) => ''),
        datasets: [
          {
            data: deviceData.map(d => d.values[0]), // X
            color: () => 'rgba(255, 0, 0, 0.8)',
            strokeWidth: 2
          },
          {
            data: deviceData.map(d => d.values[1]), // Y
            color: () => 'rgba(0, 255, 0, 0.8)',
            strokeWidth: 2
          },
          {
            data: deviceData.map(d => d.values[2]), // Z
            color: () => 'rgba(0, 0, 255, 0.8)',
            strokeWidth: 2
          }
        ],
        legend: ['X', 'Y', 'Z']
      };
      
      return (
        <View>
          <View style={styles.currentValues}>
            <Text style={styles.currentValueLabel}>Current: </Text>
            <Text style={[styles.currentValue, {color: 'rgba(255, 0, 0, 0.8)'}]}>
              X: {latestData.values[0].toFixed(2)}
            </Text>
            <Text style={[styles.currentValue, {color: 'rgba(0, 255, 0, 0.8)'}]}>
              Y: {latestData.values[1].toFixed(2)}
            </Text>
            <Text style={[styles.currentValue, {color: 'rgba(0, 0, 255, 0.8)'}]}>
              Z: {latestData.values[2].toFixed(2)}
            </Text>
          </View>
          
          <LineChart
            data={chartData}
            width={320}
            height={180}
            chartConfig={{
              backgroundColor: THEME.cardBackground,
              backgroundGradientFrom: THEME.cardBackground,
              backgroundGradientTo: THEME.cardBackground,
              decimalPlaces: 1,
              color: (opacity = 1) => `rgba(0, 176, 118, ${opacity})`,
              labelColor: (opacity = 1) => `rgba(51, 51, 51, ${opacity})`,
              propsForDots: {
                r: '3',
                strokeWidth: '1',
                stroke: THEME.primary,
              }
            }}
            bezier
            style={styles.chart}
          />
        </View>
      );
    }
    
    // For temperature data
    if (latestData.type === 'temperature') {
      const chartData = {
        labels: deviceData.map((_, i) => ''),
        datasets: [
          {
            data: deviceData.map(d => d.values[0]),
            color: () => 'rgba(255, 193, 7, 0.8)',
            strokeWidth: 2
          }
        ]
      };
      
      return (
        <View>
          <View style={styles.currentValues}>
            <Text style={styles.currentValueLabel}>Current Temperature: </Text>
            <Text style={[styles.currentValue, {color: 'rgba(255, 193, 7, 0.8)'}]}>
              {latestData.values[0].toFixed(1)}C
            </Text>
          </View>
          
          <LineChart
            data={chartData}
            width={320}
            height={180}
            chartConfig={{
              backgroundColor: THEME.cardBackground,
              backgroundGradientFrom: THEME.cardBackground,
              backgroundGradientTo: THEME.cardBackground,
              decimalPlaces: 1,
              color: (opacity = 1) => `rgba(255, 193, 7, ${opacity})`,
              labelColor: (opacity = 1) => `rgba(51, 51, 51, ${opacity})`,
              propsForDots: {
                r: '3',
                strokeWidth: '1',
                stroke: 'rgba(255, 193, 7, 1)',
              }
            }}
            bezier
            style={styles.chart}
          />
        </View>
      );
    }
    
    // Generic fallback chart for other data types
    return (
      <View style={styles.emptyChart}>
        <Text style={styles.emptyChartText}>
          No visualization available for {latestData.type} data
        </Text>
      </View>
    );
  };
  
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={THEME.primary} />
        <Text style={styles.loadingText}>Initializing monitor...</Text>
      </View>
    );
  }
  
  return (
    <SafeAreaProvider>
      <ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
      >
        {/* Premium Header with Gradient */}
        <View style={styles.header}>
          <LinearGradient
            colors={['rgba(0,176,118,0.15)', 'rgba(0,176,118,0.05)', 'transparent']}
            style={styles.headerGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          />
          <View style={styles.headerContent}>
            <Text style={styles.headerTitle}>Live Monitor</Text>
            <TouchableOpacity
              onPress={toggleSession}
              style={[
                styles.sessionToggle,
                sessionActive ? styles.sessionActive : styles.sessionInactive
              ]}
            >
              <LinearGradient
                colors={sessionActive ? ['#ff5252', '#ff3b30'] : ['rgba(100,100,100,0.1)', 'rgba(100,100,100,0.2)']}
                style={StyleSheet.absoluteFill}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 1 }}
                borderRadius={24}
              />
              <MaterialCommunityIcons 
                name={sessionActive ? "record-circle" : "record-circle-outline"} 
                size={16} 
                color={sessionActive ? "#fff" : "#555"} 
              />
              <Text style={sessionActive ? styles.sessionActiveText : styles.sessionInactiveText}>
                {sessionActive ? "Session Active" : "Session Inactive"}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Connected Devices Section */}
        <GlassCard style={styles.card}>
          <LinearGradient
            colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
            style={styles.cardGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 0, y: 1 }}
          />
          <View style={styles.cardInner}>
            <View style={styles.cardHeader}>
              <Text style={styles.cardTitle}>Monitoring {connectedDevices.length} Athletes</Text>
            </View>
            
            {connectedDevices.length === 0 ? (
              <View style={styles.emptyState}>
                <MaterialCommunityIcons name="bluetooth-off" size={40} color={THEME.text.tertiary} />
                <Text style={styles.emptyStateText}>No connected devices</Text>
                <Text style={styles.emptyStateSubtext}>Connect to mouthguard devices to begin monitoring</Text>
              </View>
            ) : (
              connectedDevices.map(device => (
                <View key={device.id} style={styles.deviceItem}>
                  <LinearGradient
                    colors={['rgba(0,176,118,0.15)', 'rgba(0,176,118,0.05)']}
                    style={styles.deviceIcon}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                    borderRadius={20}
                  >
                    <MaterialCommunityIcons 
                      name="tooth-outline" 
                      size={22} 
                      color={THEME.primary} 
                    />
                  </LinearGradient>
                  <View style={styles.deviceInfo}>
                    <Text style={styles.deviceName}>
                      {device.athleteInfo?.name || device.name}
                    </Text>
                    <Text style={styles.deviceDetail}>
                      {device.batteryLevel ? `Battery: ${device.batteryLevel}%` : 'No battery data'}
                    </Text>
                  </View>
                  
                  <View style={styles.statusIndicator}>
                    <View style={[styles.statusDot, styles.statusConnected]} />
                    <Text style={styles.statusText}>Connected</Text>
                  </View>
                </View>
              ))
            )}
          </View>
        </GlassCard>
        
        {/* Real-time Data Visualizations Section */}
        {connectedDevices.length > 0 && (
          <GlassCard style={styles.card}>
            <LinearGradient
              colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
              style={styles.cardGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 0, y: 1 }}
            />
            <View style={styles.cardInner}>
              <View style={styles.cardHeader}>
                <Text style={styles.cardTitle}>Real-time Data</Text>
              </View>
              
              {connectedDevices.map(device => (
                <View key={device.id} style={styles.chartContainer}>
                  <Text style={styles.chartTitle}>{device.athleteInfo?.name || device.name}</Text>
                  {renderDeviceChart(device.id)}
                </View>
              ))}
            </View>
          </GlassCard>
        )}
        
        {/* Team Overview Section */}
        <GlassCard style={styles.card}>
          <LinearGradient
            colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
            style={styles.cardGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 0, y: 1 }}
          />
          <View style={styles.cardInner}>
            <View style={styles.cardHeader}>
              <Text style={styles.cardTitle}>Team Overview</Text>
            </View>
            <View style={styles.emptyState}>
              <MaterialCommunityIcons name="chart-line" size={40} color={THEME.text.tertiary} />
              <Text style={styles.emptyStateText}>Team-wide data visualization will be displayed here</Text>
            </View>
          </View>
        </GlassCard>

        {/* Bottom tab spacer */}
        <View style={{ height: 24 }} />
      </ScrollView>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: THEME.background,
  },
  loadingText: {
    marginTop: 16,
    color: THEME.text.primary,
    fontSize: 16,
  },
  // Premium Header styles
  header: {
    height: 140,
    position: 'relative',
    marginBottom: 20,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: THEME.text.primary,
    letterSpacing: 0.5,
  },
  // Glass card styles
  glassCard: {
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 16,
    overflow: 'hidden',
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  glassCardFallback: {
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: THEME.cardBackground,
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  cardGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  card: {
    marginHorizontal: 16,
    marginBottom: 16,
  },
  cardInner: {
    padding: 16,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: THEME.text.primary,
    letterSpacing: 0.3,
  },
  // Session toggle styles
  sessionToggle: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 24,
    overflow: 'hidden',
    position: 'relative',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  sessionActive: {
    borderWidth: 1,
    borderColor: 'rgba(255,82,82,0.3)',
  },
  sessionInactive: {
    borderWidth: 1,
    borderColor: 'rgba(100,100,100,0.1)',
  },
  sessionActiveText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 4,
  },
  sessionInactiveText: {
    color: '#555',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 4,
  },
  // Device Item styles
  deviceItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 14,
    paddingHorizontal: 4,
    borderRadius: 8,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: THEME.divider,
    marginBottom: 12,
  },
  deviceIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(0,176,118,0.2)',
  },
  deviceInfo: {
    flex: 1,
  },
  deviceName: {
    fontSize: 16,
    fontWeight: '500',
    color: THEME.text.primary,
    marginBottom: 2,
  },
  deviceDetail: {
    fontSize: 12,
    color: THEME.text.secondary,
  },
  statusIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 6,
    borderRadius: 12,
    backgroundColor: 'rgba(0,0,0,0.03)',
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6,
  },
  statusConnected: {
    backgroundColor: '#4CAF50',
  },
  statusText: {
    fontSize: 14,
    color: THEME.text.secondary,
  },
  // Empty state styles
  emptyState: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
    backgroundColor: 'rgba(0,0,0,0.02)',
    borderRadius: 12,
  },
  emptyStateText: {
    marginTop: 16,
    fontSize: 18,
    fontWeight: '500',
    color: THEME.text.primary,
  },
  emptyStateSubtext: {
    marginTop: 8,
    fontSize: 14,
    color: THEME.text.secondary,
    textAlign: 'center',
  },
  // Chart styles
  chartContainer: {
    marginTop: 8,
    padding: 12,
    backgroundColor: 'rgba(0,0,0,0.02)',
    borderRadius: 12,
    marginBottom: 16,
  },
  chartTitle: {
    fontSize: 16,
    fontWeight: '500',
    color: THEME.text.primary,
    marginBottom: 12,
  },
  chart: {
    borderRadius: 12,
    padding: 8,
    backgroundColor: THEME.cardBackground,
    marginTop: 8,
    overflow: 'hidden',
  },
  emptyChart: {
    height: 180,
    borderRadius: 8,
    backgroundColor: 'rgba(0,0,0,0.05)',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  emptyChartText: {
    color: THEME.text.secondary,
    fontSize: 16,
  },
  currentValues: {
    flexDirection: 'row',
    alignItems: 'center',
    flexWrap: 'wrap',
    marginTop: 8,
    marginBottom: 8,
    padding: 8,
    backgroundColor: 'rgba(0,0,0,0.02)',
    borderRadius: 8,
  },
  currentValueLabel: {
    color: THEME.text.secondary,
    fontSize: 14,
  },
  currentValue: {
    fontSize: 14,
    fontWeight: '500',
    marginRight: 10,
  },
});

================================================================================
File: app/(tabs)/reports.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity, 
  Platform 
} from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { BlurView } from 'expo-blur';
import { LinearGradient } from 'expo-linear-gradient';
import { 
  COLORS, 
  SAMPLE_ATHLETES, 
  SAMPLE_IMPACT_EVENTS, 
  SAMPLE_SESSIONS 
} from '@/src/constants';

// Create derived report data based on our sample data
const REPORTS = [
  ...SAMPLE_SESSIONS.map(session => ({
    id: session.id,
    title: session.name,
    date: new Date(session.startTime).toLocaleDateString(),
    type: 'Session',
    status: 'Generated',
    details: `Team: ${session.team}, Duration: ${Math.round((session.endTime - session.startTime) / (60 * 1000))} min`
  })),
  ...SAMPLE_ATHLETES.filter(athlete => athlete.deviceId).map(athlete => ({
    id: `report_${athlete.id}`,
    title: `${athlete.name} Report`,
    date: new Date().toLocaleDateString(),
    type: 'Individual',
    status: 'Generated',
    details: `Team: ${athlete.team}, Position: ${athlete.position}`
  })),
  {
    id: 'team_report_1',
    title: 'Team Impact Analysis',
    date: new Date().toLocaleDateString(),
    type: 'Team',
    status: 'Generated',
    details: `${SAMPLE_IMPACT_EVENTS.length} impacts recorded`
  }
];

type ReportType = 'Team' | 'Individual' | 'Session' | 'All';

// Custom theme colors for beige theme - matching the dashboard
const THEME = {
  background: '#f2efe4', // Beige background matching bottom bar
  cardBackground: '#ffffff',
  primary: '#00b076', // Green primary color
  text: {
    primary: '#333333',
    secondary: '#666666',
    tertiary: '#999999',
  },
  divider: 'rgba(0,0,0,0.08)',
  card: {
    shadow: 'rgba(0,0,0,0.12)',
    border: 'rgba(0,0,0,0.05)',
  }
};

// Premium Glass Card component
const GlassCard = ({ style, children, intensity = 15 }) => {
  return Platform.OS === 'ios' ? (
    <BlurView intensity={intensity} tint="light" style={[styles.glassCard, style]}>
      {children}
    </BlurView>
  ) : (
    <View style={[styles.glassCardFallback, style]}>
      {children}
    </View>
  );
};

export default function ReportsScreen() {
  const [selectedFilter, setSelectedFilter] = useState<ReportType>('All');
  const [reportData, setReportData] = useState(REPORTS);
  
  const filterOptions: ReportType[] = ['All', 'Team', 'Individual', 'Session'];
  
  const filteredReports = selectedFilter === 'All' 
    ? reportData 
    : reportData.filter(report => report.type === selectedFilter);
  
  return (
    <SafeAreaProvider>
      <ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
      >
        {/* Premium Header with Gradient */}
        <View style={styles.header}>
          <LinearGradient
            colors={['rgba(0,176,118,0.15)', 'rgba(0,176,118,0.05)', 'transparent']}
            style={styles.headerGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          />
          <View style={styles.headerContent}>
            <Text style={styles.headerTitle}>Reports</Text>
            <TouchableOpacity 
              style={styles.generateButton}
              onPress={() => {/* Generate report action */}}
            >
              <LinearGradient
                colors={['#00d68f', '#00b076']}
                style={StyleSheet.absoluteFill}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 1 }}
                borderRadius={24}
              />
              <MaterialCommunityIcons name="file-plus-outline" size={20} color="#fff" />
              <Text style={styles.generateButtonText}>Generate</Text>
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Filter Options */}
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.filterContainer}
        >
          {filterOptions.map(option => (
            <TouchableOpacity
              key={option}
              style={[
                styles.filterOption,
                selectedFilter === option && styles.filterOptionSelected
              ]}
              onPress={() => setSelectedFilter(option)}
            >
              <Text 
                style={[
                  styles.filterOptionText,
                  selectedFilter === option && styles.filterOptionTextSelected
                ]}
              >
                {option}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
        
        {/* Reports List */}
        <GlassCard style={styles.card}>
          <LinearGradient
            colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
            style={styles.cardGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 0, y: 1 }}
          />
          <View style={styles.cardInner}>
            <View style={styles.cardHeader}>
              <Text style={styles.cardTitle}>
                {selectedFilter === 'All' ? 'All Reports' : `${selectedFilter} Reports`}
              </Text>
            </View>
            
            {filteredReports.length === 0 ? (
              <View style={styles.emptyState}>
                <MaterialCommunityIcons name="file-document-outline" size={40} color={THEME.text.tertiary} />
                <Text style={styles.emptyStateText}>No reports found</Text>
                <Text style={styles.emptyStateSubtext}>Generate a report to get started</Text>
              </View>
            ) : (
              <View>
                {filteredReports.map((report, index) => (
                  <TouchableOpacity 
                    key={report.id} 
                    activeOpacity={0.7}
                    style={[
                      styles.reportItem,
                      index < filteredReports.length - 1 && styles.reportItemBorder
                    ]}
                    onPress={() => {/* Open report action */}}
                  >
                    <LinearGradient
                      colors={[
                        report.type === 'Team' 
                          ? 'rgba(0,176,118,0.15)' 
                          : report.type === 'Individual' 
                            ? 'rgba(0,122,255,0.15)' 
                            : 'rgba(255,149,0,0.15)',
                        'rgba(255,255,255,0.05)'
                      ]}
                      style={styles.reportTypeIndicator}
                      start={{ x: 0, y: 0 }}
                      end={{ x: 1, y: 1 }}
                      borderRadius={20}
                    >
                      <MaterialCommunityIcons 
                        name={
                          report.type === 'Team' 
                            ? "account-group" 
                            : report.type === 'Individual' 
                              ? "account" 
                              : "timer-outline"
                        } 
                        size={24} 
                        color={THEME.primary} 
                      />
                    </LinearGradient>
                    
                    <View style={styles.reportInfo}>
                      <Text style={styles.reportTitle}>{report.title}</Text>
                      <Text style={styles.reportDetails}>
                        {report.date}  {report.type} Report
                      </Text>
                      {report.details && (
                        <Text style={styles.reportSubdetails}>{report.details}</Text>
                      )}
                    </View>
                    
                    <MaterialCommunityIcons 
                      name="chevron-right" 
                      size={24} 
                      color={THEME.text.tertiary} 
                    />
                  </TouchableOpacity>
                ))}
              </View>
            )}
          </View>
        </GlassCard>
        
        {/* Impact Events Section */}
        <GlassCard style={styles.card}>
          <LinearGradient
            colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
            style={styles.cardGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 0, y: 1 }}
          />
          <View style={styles.cardInner}>
            <View style={styles.cardHeader}>
              <Text style={styles.cardTitle}>Recent Impact Events</Text>
              <TouchableOpacity>
                <Text style={styles.viewAllLink}>View All</Text>
              </TouchableOpacity>
            </View>
            
            {SAMPLE_IMPACT_EVENTS.length === 0 ? (
              <View style={styles.emptyState}>
                <MaterialCommunityIcons name="shield-alert-outline" size={40} color={THEME.text.tertiary} />
                <Text style={styles.emptyStateText}>No impact events recorded</Text>
              </View>
            ) : (
              <View>
                {SAMPLE_IMPACT_EVENTS.map((impact, index) => {
                  // Find the athlete for this impact
                  const athlete = SAMPLE_ATHLETES.find(a => a.id === impact.athleteId);
                  const formattedDate = new Date(impact.timestamp).toLocaleString();
                  
                  return (
                    <TouchableOpacity 
                      key={index} 
                      activeOpacity={0.7}
                      style={[
                        styles.impactItem,
                        index < SAMPLE_IMPACT_EVENTS.length - 1 && styles.impactItemBorder
                      ]}
                      onPress={() => {/* View impact details */}}
                    >
                      <View style={[
                        styles.severityIndicator, 
                        { backgroundColor: getSeverityColor(impact.severity || 'moderate') }
                      ]} />
                      
                      <View style={styles.impactInfo}>
                        <Text style={styles.impactTitle}>
                          {impact.magnitude.toFixed(1)}g Impact
                        </Text>
                        <Text style={styles.impactAthlete}>
                          {athlete ? athlete.name : 'Unknown Athlete'}
                        </Text>
                        <Text style={styles.impactTime}>{formattedDate}</Text>
                        
                        <View style={styles.impactCoordinates}>
                          <Text style={styles.coordinateText}>X: {impact.x.toFixed(1)}</Text>
                          <Text style={styles.coordinateText}>Y: {impact.y.toFixed(1)}</Text>
                          <Text style={styles.coordinateText}>Z: {impact.z.toFixed(1)}</Text>
                        </View>
                      </View>
                      
                      <MaterialCommunityIcons 
                        name="chevron-right" 
                        size={20} 
                        color={THEME.text.tertiary} 
                      />
                    </TouchableOpacity>
                  );
                })}
              </View>
            )}
          </View>
        </GlassCard>
        
        {/* Create New Report Section */}
        <GlassCard style={styles.card}>
          <LinearGradient
            colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
            style={styles.cardGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 0, y: 1 }}
          />
          <View style={styles.cardInner}>
            <View style={styles.cardHeader}>
              <Text style={styles.cardTitle}>Create New Report</Text>
            </View>
            
            <View style={styles.reportTypeGrid}>
              {[
                {
                  icon: "account-group",
                  title: "Team Report",
                  description: "Comprehensive overview of all athlete data"
                },
                {
                  icon: "account",
                  title: "Individual Report",
                  description: "Detailed analysis of a single athlete"
                },
                {
                  icon: "timer-outline",
                  title: "Session Report",
                  description: "Data from a specific practice or game"
                },
                {
                  icon: "chart-timeline-variant",
                  title: "Custom Report",
                  description: "Create a report with custom parameters"
                }
              ].map((reportType, index) => (
                <TouchableOpacity 
                  key={index}
                  style={styles.reportTypeCard}
                >
                  <LinearGradient
                    colors={['rgba(0,176,118,0.15)', 'rgba(0,176,118,0.05)']}
                    style={styles.reportTypeIcon}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                    borderRadius={24}
                  >
                    <MaterialCommunityIcons 
                      name={reportType.icon} 
                      size={32} 
                      color={THEME.primary} 
                    />
                  </LinearGradient>
                  <Text style={styles.reportTypeTitle}>{reportType.title}</Text>
                  <Text style={styles.reportTypeDescription}>
                    {reportType.description}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>
        </GlassCard>
        
        {/* Bottom tab spacer */}
        <View style={{ height: 24 }} />
      </ScrollView>
    </SafeAreaProvider>
  );
}

// Helper function to get color based on impact severity
function getSeverityColor(severity: string): string {
  switch (severity.toLowerCase()) {
    case 'severe':
      return '#ff3b30'; // Red
    case 'moderate':
      return '#ff9500'; // Orange
    case 'mild':
      return '#00b076'; // Green
    default:
      return '#00b076'; // Green
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  header: {
    height: 140,
    position: 'relative',
    marginBottom: 20,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: THEME.text.primary,
    letterSpacing: 0.5,
  },
  generateButton: {
    position: 'relative',
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 24,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  generateButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 4,
  },
  filterContainer: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginBottom: 8,
  },
  filterOption: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 8,
    backgroundColor: 'rgba(0,0,0,0.03)',
    borderWidth: 1,
    borderColor: 'rgba(0,0,0,0.05)',
  },
  filterOptionSelected: {
    backgroundColor: THEME.primary,
    borderColor: 'rgba(0,176,118,0.2)',
  },
  filterOptionText: {
    fontSize: 14,
    fontWeight: '500',
    color: THEME.text.secondary,
  },
  filterOptionTextSelected: {
    color: '#fff',
    fontWeight: '600',
  },
  // Glass card styles
  glassCard: {
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 16,
    overflow: 'hidden',
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  glassCardFallback: {
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: THEME.cardBackground,
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  cardGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  card: {
    marginHorizontal: 16,
    marginBottom: 16,
  },
  cardInner: {
    padding: 16,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: THEME.text.primary,
    letterSpacing: 0.3,
  },
  viewAllLink: {
    fontSize: 14,
    color: THEME.primary,
    fontWeight: '500',
  },
  emptyState: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
    backgroundColor: 'rgba(0,0,0,0.02)',
    borderRadius: 12,
  },
  emptyStateText: {
    marginTop: 8,
    color: THEME.text.tertiary,
    fontSize: 16,
    fontWeight: '500',
  },
  emptyStateSubtext: {
    fontSize: 14,
    color: THEME.text.tertiary,
    marginTop: 4,
    textAlign: 'center',
  },
  reportItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 14,
    paddingHorizontal: 4,
    borderRadius: 8,
  },
  reportItemBorder: {
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: THEME.divider,
  },
  reportTypeIndicator: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(0,176,118,0.2)',
  },
  reportInfo: {
    flex: 1,
  },
  reportTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 2,
  },
  reportDetails: {
    fontSize: 14,
    color: THEME.text.secondary,
    marginBottom: 2,
  },
  reportSubdetails: {
    fontSize: 12,
    color: THEME.text.tertiary,
  },
  impactItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 14,
    paddingHorizontal: 4,
    borderRadius: 8,
  },
  impactItemBorder: {
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: THEME.divider,
  },
  severityIndicator: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2,
  },
  impactInfo: {
    flex: 1,
  },
  impactTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 2,
  },
  impactAthlete: {
    fontSize: 14,
    fontWeight: '500',
    color: THEME.text.secondary,
    marginBottom: 2,
  },
  impactTime: {
    fontSize: 12,
    color: THEME.text.tertiary,
    marginBottom: 4,
  },
  impactCoordinates: {
    flexDirection: 'row',
    marginTop: 4,
  },
  coordinateText: {
    fontSize: 12,
    color: THEME.text.tertiary,
    marginRight: 12,
  },
  reportTypeGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
    justifyContent: 'space-between',
  },
  reportTypeCard: {
    backgroundColor: 'rgba(255,255,255,0.5)',
    borderRadius: 16,
    padding: 16,
    width: '48%',
    marginBottom: 12,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: THEME.card.border,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  reportTypeIcon: {
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12,
    borderWidth: 1,
    borderColor: 'rgba(0,176,118,0.2)',
  },
  reportTypeTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 4,
    textAlign: 'center',
  },
  reportTypeDescription: {
    fontSize: 12,
    color: THEME.text.tertiary,
    textAlign: 'center',
    lineHeight: 16,
  },
});

================================================================================
File: app/(tabs)/reportsDetailed.tsx
================================================================================

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, ViewStyle, ActivityIndicator, Dimensions, Platform, Animated } from 'react-native';
import { SafeAreaProvider, SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { COLORS, DEVICE_ID_SIM } from '@/src/constants';
import { useSensorDataRepository } from '@/src/providers/AppProvider';
import { dataChangeEmitter, dbEvents } from '@/src/utils/EventEmitter';
import { MotionPacket, FSRPacket, HRMPacket, HTMPacket, ImpactEvent, ChartData } from '@/src/types';
import { debounce } from 'lodash';

// Import the chart components
import LineChart from '../components/charts/LineChart';
import BarChart from '../components/charts/BarChart';

// Import new data processing utilities
import { 
  processHrmForChart, 
  processTempForChart, 
  processFsrForChart, 
  processMotionForChart, 
  processImpactsForCharts 
} from '@/src/utils/dataProcessing';

// Import our new visualization components
import HeartRateTrendChart from '../components/charts/HeartRateTrendChart';
import TemperatureStabilityGraph from '../components/charts/TemperatureStabilityGraph';
import BiteForceDynamicsChart from '../components/charts/BiteForceDynamicsChart';
import MotionOverviewGraph from '../components/charts/MotionOverviewGraph';
import ConcussionRiskGauge from '../components/charts/ConcussionRiskGauge';
import ImpactTimelineGraph from '../components/charts/ImpactTimelineGraph';
import SeverityDistributionGraph from '../components/charts/SeverityDistributionGraph';
import CumulativeExposureGraph from '../components/charts/CumulativeExposureGraph';

// Safe wrapper for LineChart that ensures proper dataset format
const SafeLineChart = ({ 
  data, 
  emptyMessage = "No data available", 
  ...props 
}: {
  data: any; 
  emptyMessage?: string;
  [key: string]: any;
}) => {
  // First check if data exists at all
  if (!data) {
    return <Text style={styles.emptyChartText}>{emptyMessage}</Text>;
  }

  // Check if datasets array exists and is valid
  if (!data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
    return <Text style={styles.emptyChartText}>{emptyMessage}</Text>;
  }

  // Check if any dataset has actual data to display
  const hasActualData = data.datasets.some((ds: any) => {
    // Guard against undefined or null dataset
    if (!ds) return false;
    // Guard against missing data array
    if (!ds.data || !Array.isArray(ds.data)) return false;
    // Check if there's at least one valid data point
    return ds.data.length > 0 && ds.data.some((val: any) => val !== null && val !== undefined);
  });

  // If no actual data was found, show empty message
  if (!hasActualData) {
    return <Text style={styles.emptyChartText}>{emptyMessage}</Text>;
  }

  // Create a safe data structure with properly formatted datasets
  const safeData = {
    labels: Array.isArray(data.labels) ? data.labels : [],
    datasets: data.datasets.map((dataset: any, index: number) => {
      // Handle null/undefined dataset
      if (!dataset) {
        return {
          data: [],
          color: () => 'rgba(0, 176, 118, 1)',
          strokeWidth: 2,
          index
        };
      }
      
      return {
        data: Array.isArray(dataset.data) ? dataset.data.map((val: any) => 
          typeof val === 'number' && !isNaN(val) ? val : 0
        ) : [],
        color: typeof dataset.color === 'function' ? dataset.color : () => 'rgba(0, 176, 118, 1)',
        strokeWidth: typeof dataset.strokeWidth === 'number' ? dataset.strokeWidth : 2,
        index
      };
    }),
    legend: data.legend
  };

  // Extract only the supported props to avoid type errors
  const { width, height, bezier, style, chartConfig } = props;

  return (
    <LineChart 
      data={safeData}
      width={width}
      height={height}
      bezier={bezier}
      style={style}
      chartConfig={chartConfig || {
        backgroundColor: 'transparent',
        backgroundGradientFrom: 'transparent',
        backgroundGradientTo: 'transparent',
        fillShadowGradientFrom: typeof safeData.datasets[0]?.color === 'function' ? 
          safeData.datasets[0].color(0.8) : 'rgba(0, 176, 118, 0.8)',
        fillShadowGradientTo: 'rgba(255, 255, 255, 0)',
        decimalPlaces: 0,
        color: (opacity = 1) => typeof safeData.datasets[0]?.color === 'function' ? 
          safeData.datasets[0].color(opacity) : `rgba(0, 176, 118, ${opacity})`,
        labelColor: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
        propsForBackgroundLines: {
          strokeDasharray: '4, 4',
          strokeWidth: 0.5,
          stroke: 'rgba(0, 0, 0, 0.05)',
        },
      }}
    />
  );
};

// Enhanced GlassCard component with improved styling
const GlassCard = ({ 
  style, 
  children, 
  intensity = 15 
}: {
  style?: any;
  children: React.ReactNode;
  intensity?: number;
}) => {
  // Use BlurView on iOS for true glass effect, fallback for Android
  if (Platform.OS === 'ios') {
    return (
      <View style={[styles.cardContainer, style]}>
        <BlurView intensity={intensity} tint="light" style={styles.blurView}>
          <View style={styles.cardContent}>
            {children}
          </View>
        </BlurView>
      </View>
    );
  }
  
  // Fallback for Android with enhanced styling
  return (
    <View style={[styles.cardContainer, styles.cardAndroid, style]}>
      <View style={styles.cardContent}>
        {children}
      </View>
    </View>
  );
};

export default function ReportsDetailedScreen() {
  const sensorDataRepository = useSensorDataRepository();

  // Animation values
  const fadeAnim = React.useRef(new Animated.Value(0)).current;

  // State for raw data (only when needed for specialized visualization)
  const [impacts, setImpacts] = useState<any[]>([]);

  // State for processed chart data
  const [hrmChartData, setHrmChartData] = useState<ChartData | null>(null);
  const [tempChartData, setTempChartData] = useState<ChartData | null>(null);
  const [biteForceChartData, setBiteForceChartData] = useState<ChartData | null>(null);
  const [motionChartData, setMotionChartData] = useState<ChartData | null>(null);
  const [impactTimelineData, setImpactTimelineData] = useState<ChartData | null>(null);
  const [severityDistData, setSeverityDistData] = useState<{ labels: string[], data: number[] } | null>(null);
  const [chieData, setChieData] = useState<ChartData | null>(null);
  
  // State for calculated session stats/KPIs
  const [sessionStats, setSessionStats] = useState<{
    avgHr?: number | null;
    minHr?: number | null;
    maxHr?: number | null;
    avgTemp?: number | null;
    maxTemp?: number | null;
    currentTemp?: number | null;
    avgBiteLeft?: number | null;
    avgBiteRight?: number | null;
    avgBiteTotal?: number | null;
    maxBiteForce?: number | null;
    peakAccel?: number | null;
    totalImpacts?: number | null;
    highImpacts?: number | null;
    maxG?: number | null;
    concussionRisk?: 'Low' | 'Moderate' | 'High' | 'Critical' | null;
  } | null>(null);

  // Loading and error states
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const deviceId = DEVICE_ID_SIM;

  const getRiskStyle = (risk: any) => {
    switch (risk?.toLowerCase()) {
      case 'high': 
      case 'critical': return { color: COLORS.error };
      case 'moderate': return { color: COLORS.warning };
      default: return { color: COLORS.primary };
    }
  };

  const fetchData = useCallback(async () => {
    console.log('[ReportsDetailed] Fetching data...');
    setLoading(true);
    setError(null);

    try {
      // Define time range (e.g., last 24 hours, or all data for sim device)
      const endTime = Date.now();
      const startTime = 0; // Fetch all data for simplicity initially

      // Fetch all relevant data types
      const [
        fetchedImpacts,
        fetchedMotion,
        fetchedFsr,
        fetchedHrm,
        fetchedHtm
      ] = await Promise.all([
        sensorDataRepository.getSensorData(deviceId, 'impact_events', startTime, endTime),
        sensorDataRepository.getSensorData(deviceId, 'motion_packets', startTime, endTime),
        sensorDataRepository.getSensorData(deviceId, 'fsr_packets', startTime, endTime),
        sensorDataRepository.getSensorData(deviceId, 'hrm_packets', startTime, endTime),
        sensorDataRepository.getSensorData(deviceId, 'htm_packets', startTime, endTime),
      ]);

      // Keep raw impact data for direction visualization if needed
      setImpacts(fetchedImpacts);
      
      console.log(`[ReportsDetailed] Fetched ${fetchedImpacts.length} impacts, ${fetchedMotion.length} motion, ${fetchedFsr.length} fsr, ${fetchedHrm.length} hrm, ${fetchedHtm.length} htm packets.`);

      // --- Process data using utility functions ---
      
      // Process heart rate data
      const hrmResults = processHrmForChart(fetchedHrm);
      setHrmChartData(hrmResults.chartData);
      
      // Process temperature data
      const tempResults = processTempForChart(fetchedHtm);
      setTempChartData(tempResults.chartData);
      
      // Process bite force data
      const fsrResults = processFsrForChart(fetchedFsr);
      setBiteForceChartData(fsrResults.chartData);
      
      // Process motion data
      const motionResults = processMotionForChart(fetchedMotion);
      setMotionChartData(motionResults.accelMagnitudeChart);
      
      // Process impact data for various visualizations
      const impactResults = processImpactsForCharts(fetchedImpacts);
      setImpactTimelineData(impactResults.timelineChart);
      setSeverityDistData(impactResults.severityDistribution);
      setChieData(impactResults.cumulativeExposureChart);
      
      // Create a consolidated object with all stats, ensuring each property is defined
      const finalStats = {
        // Heart rate
        avgHr: hrmResults.avgHr ?? null,
        minHr: hrmResults.minHr ?? null,
        maxHr: hrmResults.maxHr ?? null,
        
        // Temperature
        avgTemp: tempResults.avgTemp ?? null,
        maxTemp: tempResults.maxTemp ?? null,
        currentTemp: tempResults.currentTemp ?? null,
        
        // Bite force
        avgBiteLeft: fsrResults.avgLeft ?? null,
        avgBiteRight: fsrResults.avgRight ?? null,
        avgBiteTotal: fsrResults.avgTotal ?? null,
        maxBiteForce: fsrResults.maxForce ?? null,
        
        // Motion
        peakAccel: motionResults.peakAccel ?? null,
        
        // Impacts
        totalImpacts: impactResults.totalImpacts ?? 0,
        highImpacts: impactResults.highImpacts ?? 0,
        maxG: impactResults.maxG ?? null,
        concussionRisk: impactResults.concussionRisk ?? 'Low'
      };
      
      // Update session stats with the consolidated object
      setSessionStats(finalStats);

      // Animate cards in
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 400,
        useNativeDriver: true,
      }).start();

    } catch (err) {
      console.error('[ReportsDetailed] Error fetching data:', err);
      setError(err instanceof Error ? err.message : 'Failed to load report data');
      
      // Clear existing data on error
      setImpacts([]);
      setHrmChartData(null);
      setTempChartData(null);
      setBiteForceChartData(null);
      setMotionChartData(null);
      setImpactTimelineData(null);
      setSeverityDistData(null);
      setChieData(null);
      setSessionStats(null);
    } finally {
      setLoading(false);
      console.log('[ReportsDetailed] Fetching complete.');
    }
  }, [deviceId, sensorDataRepository, fadeAnim]);

  // Fetch data on initial mount
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Create a ref to hold the latest fetchData function
  const fetchDataRef = useRef(fetchData);
  
  // Update the ref whenever fetchData changes
  useEffect(() => {
    fetchDataRef.current = fetchData;
  }, [fetchData]);
  
  // Create a debounced version of fetchData ONLY for the listener
  const debouncedFetchData = useRef(
    debounce(() => {
      console.log('[ReportsDetailed] Debounced fetch triggered...');
      // Call the latest fetchData function from the ref
      fetchDataRef.current();
    }, 1000, { leading: false, trailing: true }) // Fetch on the trailing edge after 1s pause
  ).current;

  // Subscribe to data changes (using the debounced fetch)
  useEffect(() => {
    const handleDataChange = (eventData: { deviceId: string; type: string }) => {
      // Re-fetch data if the change affects the current device
      if (eventData.deviceId === deviceId) {
        console.log(`[ReportsDetailed] Data changed for device ${deviceId} (type: ${eventData.type}), queueing debounced fetch...`);
        debouncedFetchData(); // Call the debounced function
      }
    };

    dataChangeEmitter.on(dbEvents.DATA_CHANGED, handleDataChange);
    
    // Cleanup subscription on unmount
    return () => {
      dataChangeEmitter.off(dbEvents.DATA_CHANGED, handleDataChange);
      debouncedFetchData.cancel(); // Cancel any pending debounced calls
    };
  }, [deviceId, debouncedFetchData]);

  // Show loading indicator
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>Loading Report Data...</Text>
      </View>
    );
  }

  // Show error message
  if (error) {
    return (
      <View style={styles.errorContainer}>
        <MaterialCommunityIcons name="alert-circle-outline" size={48} color={COLORS.error} />
        <Text style={styles.errorTitle}>Error Loading Report</Text>
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={fetchData}>
          <Text style={styles.retryButtonText}>Retry</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Show message if no data
  if (!sessionStats && 
      !impactTimelineData?.datasets?.[0]?.data?.length && 
      !biteForceChartData?.datasets?.[0]?.data?.length && 
      !hrmChartData?.datasets?.[0]?.data?.length && 
      !tempChartData?.datasets?.[0]?.data?.length) {
    return (
      <View style={styles.emptyContainer}>
        <MaterialCommunityIcons name="chart-bar-stacked" size={48} color={COLORS.textTertiary} />
        <Text style={styles.emptyText}>No Data Available</Text>
        <Text style={styles.emptySubText}>Generate test data or connect a device to see reports.</Text>
      </View>
    );
  }

  return (
    <SafeAreaProvider>
      <SafeAreaView style={styles.safeArea} edges={['top']}>
        <ScrollView
          style={styles.container}
          contentContainerStyle={styles.contentContainer}
          showsVerticalScrollIndicator={false}
        >
          {/* Enhanced Header */}
          <View style={styles.header}>
            <LinearGradient
              colors={['rgba(0,176,118,0.2)', 'rgba(0,176,118,0.05)', 'transparent']}
              style={styles.headerGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 0, y: 1 }}
            />
            <View style={styles.headerContent}>
              <Text style={styles.headerTitle}>Detailed Report</Text>
            </View>
          </View>

          {/* Session Info Card - Refined */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}]}}>
            <GlassCard style={styles.summaryCard}>
              <View style={styles.cardHeader}>
                <Text style={styles.cardTitle}>Session Report</Text>
                <Text style={styles.deviceId}>({deviceId})</Text>
              </View>
              
              <View style={styles.metricsRow}>
                <View style={styles.metricColumn}>
                  <Text style={styles.metricNumber}>{sessionStats?.totalImpacts ?? '0'}</Text>
                  <Text style={styles.metricLabel}>Total Impacts</Text>
                </View>
                
                <View style={styles.metricDivider} />
                
                <View style={styles.metricColumn}>
                  <Text style={styles.metricNumber}>{sessionStats?.maxG ?? '0'}g</Text>
                  <Text style={styles.metricLabel}>Max G-Force</Text>
                </View>
                
                <View style={styles.metricDivider} />
                
                <View style={styles.metricColumn}>
                  <Text style={styles.metricNumber}>{sessionStats?.highImpacts ?? '0'}</Text>
                  <Text style={styles.metricLabel}>High Impacts</Text>
                </View>
              </View>
            </GlassCard>
          </Animated.View>

          {/* Heart Rate Card */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}], marginTop: 8}}>
            <GlassCard style={styles.dataCard}>
              <View style={styles.cardHeader}>
                <View style={[styles.iconContainer, {backgroundColor: 'rgba(255, 59, 48, 0.1)'}]}>
                  <MaterialCommunityIcons name="heart-pulse" size={20} color="rgba(255, 59, 48, 1)" />
                </View>
                <Text style={styles.cardTitle}>Heart Rate</Text>
              </View>
              
              <View style={styles.chartContainer}>
                {loading ? (
                  <ActivityIndicator color={COLORS.primary} />
                ) : error ? (
                  <Text style={styles.errorText}>{error}</Text>
                ) : hrmChartData ? (
                  <HeartRateTrendChart
                    data={hrmChartData}
                    avgHr={sessionStats?.avgHr}
                    minHr={sessionStats?.minHr}
                    maxHr={sessionStats?.maxHr}
                  />
                ) : (
                  <Text style={styles.emptyChartText}>No heart rate data available</Text>
                )}
              </View>
            </GlassCard>
          </Animated.View>

          {/* Temperature Card */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}], marginTop: 8}}>
            <GlassCard style={styles.dataCard}>
              <View style={styles.cardHeader}>
                <View style={[styles.iconContainer, {backgroundColor: 'rgba(255, 149, 0, 0.1)'}]}>
                  <MaterialCommunityIcons name="thermometer" size={20} color="rgba(255, 149, 0, 1)" />
                </View>
                <Text style={styles.cardTitle}>Temperature</Text>
              </View>
              
              <View style={styles.chartContainer}>
                {loading ? (
                  <ActivityIndicator color={COLORS.primary} />
                ) : error ? (
                  <Text style={styles.errorText}>{error}</Text>
                ) : tempChartData ? (
                  <TemperatureStabilityGraph
                    data={tempChartData}
                    currentTemp={sessionStats?.currentTemp}
                    avgTemp={sessionStats?.avgTemp}
                    maxTemp={sessionStats?.maxTemp}
                  />
                ) : (
                  <Text style={styles.emptyChartText}>No temperature data available</Text>
                )}
              </View>
            </GlassCard>
          </Animated.View>

          {/* Bite Force Card */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}], marginTop: 8}}>
            <GlassCard style={styles.dataCard}>
              <View style={styles.cardHeader}>
                <View style={[styles.iconContainer, {backgroundColor: 'rgba(0, 122, 255, 0.1)'}]}>
                  <MaterialCommunityIcons name="tooth-outline" size={20} color="rgba(0, 122, 255, 1)" />
                </View>
                <Text style={styles.cardTitle}>Bite Force</Text>
              </View>
              
              <View style={styles.chartContainer}>
                {loading ? (
                  <ActivityIndicator color={COLORS.primary} />
                ) : error ? (
                  <Text style={styles.errorText}>{error}</Text>
                ) : biteForceChartData ? (
                  <BiteForceDynamicsChart
                    data={biteForceChartData}
                    avgLeft={sessionStats?.avgBiteLeft}
                    avgRight={sessionStats?.avgBiteRight}
                    avgTotal={sessionStats?.avgBiteTotal}
                    maxForce={sessionStats?.maxBiteForce}
                  />
                ) : (
                  <Text style={styles.emptyChartText}>No bite force data available</Text>
                )}
              </View>
            </GlassCard>
          </Animated.View>

          {/* Motion Overview Card */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}], marginTop: 8}}>
            <GlassCard style={styles.dataCard}>
              <View style={styles.cardHeader}>
                <View style={[styles.iconContainer, {backgroundColor: 'rgba(80, 80, 80, 0.1)'}]}>
                  <MaterialCommunityIcons name="axis-arrow" size={20} color="rgba(80, 80, 80, 1)" />
                </View>
                <Text style={styles.cardTitle}>Motion Overview</Text>
              </View>
              
              <View style={styles.chartContainer}>
                {loading ? (
                  <ActivityIndicator color={COLORS.primary} />
                ) : error ? (
                  <Text style={styles.errorText}>{error}</Text>
                ) : motionChartData ? (
                  <MotionOverviewGraph
                    data={motionChartData}
                    peakAccel={sessionStats?.peakAccel}
                  />
                ) : (
                  <Text style={styles.emptyChartText}>No motion data available</Text>
                )}
              </View>
            </GlassCard>
          </Animated.View>

          {/* Concussion Risk Card - Refined */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}], marginTop: 8}}>
            <GlassCard style={[styles.dataCard, styles.riskCard]}>
              <View style={styles.cardHeader}>
                <View style={[styles.iconContainer, {backgroundColor: `${getRiskStyle(sessionStats?.concussionRisk).color}15`}]}>
                  <MaterialCommunityIcons 
                    name="shield-alert-outline" 
                    size={20} 
                    color={getRiskStyle(sessionStats?.concussionRisk).color} 
                  />
                </View>
                <Text style={styles.cardTitle}>Concussion Risk</Text>
              </View>
              
              <ConcussionRiskGauge risk={sessionStats?.concussionRisk} />
            </GlassCard>
          </Animated.View>

          {/* Impact Timeline Card */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}], marginTop: 8}}>
            <GlassCard style={styles.dataCard}>
              <View style={styles.cardHeader}>
                <View style={[styles.iconContainer, {backgroundColor: 'rgba(0, 176, 118, 0.1)'}]}>
                  <MaterialCommunityIcons name="chart-timeline-variant" size={20} color={COLORS.primary} />
                </View>
                <Text style={styles.cardTitle}>Impact Timeline</Text>
              </View>
              
              <View style={styles.chartContainer}>
                {loading ? (
                  <ActivityIndicator color={COLORS.primary} />
                ) : error ? (
                  <Text style={styles.errorText}>{error}</Text>
                ) : impactTimelineData ? (
                  <ImpactTimelineGraph
                    data={impactTimelineData}
                    totalImpacts={sessionStats?.totalImpacts}
                    maxG={sessionStats?.maxG}
                  />
                ) : (
                  <Text style={styles.emptyChartText}>No impact data available</Text>
                )}
              </View>
            </GlassCard>
          </Animated.View>

          {/* Severity Distribution Card - Refined */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}], marginTop: 8}}>
            <GlassCard style={styles.dataCard}>
              <View style={styles.cardHeader}>
                <View style={[styles.iconContainer, {backgroundColor: 'rgba(0, 176, 118, 0.1)'}]}>
                  <MaterialCommunityIcons name="chart-histogram" size={20} color={COLORS.primary} />
                </View>
                <Text style={styles.cardTitle}>Severity Distribution</Text>
              </View>
              
              <View style={styles.chartContainer}>
                {loading ? (
                  <ActivityIndicator color={COLORS.primary} />
                ) : error ? (
                  <Text style={styles.errorText}>{error}</Text>
                ) : severityDistData ? (
                  <SeverityDistributionGraph data={severityDistData} />
                ) : (
                  <Text style={styles.emptyChartText}>No impact data available</Text>
                )}
              </View>
            </GlassCard>
          </Animated.View>

          {/* CHIE Card */}
          <Animated.View style={{opacity: fadeAnim, transform: [{translateY: fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })}], marginTop: 8}}>
            <GlassCard style={styles.dataCard}>
              <View style={styles.cardHeader}>
                <View style={[styles.iconContainer, {backgroundColor: 'rgba(0, 122, 255, 0.1)'}]}>
                  <MaterialCommunityIcons name="brain" size={20} color="rgba(0, 122, 255, 1)" />
                </View>
                <Text style={styles.cardTitle}>Cumulative Head Impact Exposure</Text>
              </View>
              
              <View style={styles.chartContainer}>
                {loading ? (
                  <ActivityIndicator color={COLORS.primary} />
                ) : error ? (
                  <Text style={styles.errorText}>{error}</Text>
                ) : chieData ? (
                  <CumulativeExposureGraph data={chieData} />
                ) : (
                  <Text style={styles.emptyChartText}>No cumulative exposure data available</Text>
                )}
              </View>
            </GlassCard>
          </Animated.View>

          {/* Bottom Spacer */}
          <View style={{ height: 24 }} />
        </ScrollView>
      </SafeAreaView>
    </SafeAreaProvider>
  );
}

// Refined StyleSheet with Apple-like aesthetics
const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  header: {
    height: 120,
    position: 'relative',
    marginBottom: 16,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
    justifyContent: 'flex-end',
    paddingBottom: 20,
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: COLORS.textPrimary,
    letterSpacing: 0.5,
  },
  // Card container styling
  cardContainer: {
    marginHorizontal: 20,
    marginBottom: 8,
    borderRadius: 16,
    overflow: 'hidden',
  },
  cardContent: {
    padding: 20,
  },
  blurView: {
    ...StyleSheet.absoluteFillObject,
  },
  cardAndroid: {
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.06,
    shadowRadius: 8,
    elevation: 2,
    borderWidth: 1,
    borderColor: 'rgba(0, 0, 0, 0.04)',
  },
  summaryCard: {
    marginBottom: 16,
  },
  dataCard: {
    marginBottom: 8,
  },
  riskCard: {
    minHeight: 120,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  iconContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 176, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  cardTitle: {
    fontSize: 17,
    fontWeight: '600',
    color: COLORS.textPrimary,
  },
  deviceId: {
    fontSize: 13,
    color: COLORS.textSecondary,
    marginLeft: 8,
    alignSelf: 'flex-end',
  },
  metricsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 12,
  },
  metricColumn: {
    flex: 1,
    alignItems: 'center',
  },
  metricDivider: {
    width: 1,
    height: '100%',
    backgroundColor: 'rgba(0, 0, 0, 0.06)',
  },
  metricNumber: {
    fontSize: 24,
    fontWeight: '600',
    color: COLORS.textPrimary,
    marginBottom: 4,
  },
  metricLabel: {
    fontSize: 13,
    color: COLORS.textSecondary,
    textAlign: 'center',
  },
  dataValueContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
    justifyContent: 'center',
    marginBottom: 4,
  },
  dataValue: {
    fontSize: 40,
    fontWeight: '500',
    color: COLORS.textPrimary,
  },
  dataUnit: {
    fontSize: 16,
    fontWeight: '500',
    color: COLORS.textSecondary,
    marginLeft: 4,
  },
  dataSubtext: {
    fontSize: 13,
    fontWeight: '500',
    color: COLORS.textSecondary,
    textAlign: 'center',
    marginBottom: 16,
  },
  chartContainer: {
    alignItems: 'center',
    marginTop: 8,
  },
  legendContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: 12,
  },
  legendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginHorizontal: 8,
  },
  legendDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6,
  },
  legendText: {
    fontSize: 13,
    color: COLORS.textSecondary,
  },
  riskValueContainer: {
    alignItems: 'center',
    marginTop: 16,
    marginBottom: 8,
  },
  riskValue: {
    fontSize: 32,
    fontWeight: '600',
  },
  emptyChartText: {
    fontSize: 14,
    color: COLORS.textTertiary,
    textAlign: 'center',
    marginVertical: 30,
    fontWeight: '500',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
  },
  loadingText: {
    marginTop: 12,
    color: COLORS.textSecondary,
    fontSize: 16,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
    padding: 20,
  },
  errorTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.error,
    marginTop: 16,
    marginBottom: 8,
    textAlign: 'center',
  },
  errorText: {
    color: COLORS.textSecondary,
    textAlign: 'center',
    marginBottom: 24,
  },
  retryButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 12,
  },
  retryButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
    minHeight: 300,
  },
  emptyText: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.textPrimary,
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubText: {
    fontSize: 14,
    color: COLORS.textSecondary,
    textAlign: 'center',
    lineHeight: 20,
  },
});

================================================================================
File: app/(tabs)/settings.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, Switch, Platform } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { BlurView } from 'expo-blur';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '@/src/constants';
import { useAppSetupService } from '@/src/providers/AppProvider';

// Define the material community icon names we'll use
type IconName = 
  | 'bell-outline'
  | 'theme-light-dark'
  | 'bluetooth-settings'
  | 'devices'
  | 'cloud-upload-outline'
  | 'export'
  | 'delete-outline'
  | 'information-outline'
  | 'help-circle-outline' 
  | 'shield-check-outline'
  | 'chevron-right';

type SettingItemType = {
  id: string;
  title: string;
  description: string;
  icon: IconName;
  type: 'toggle' | 'link' | 'info';
  value?: boolean;
  onValueChange?: (value: boolean) => void;
  onPress?: () => void;
  danger?: boolean;
};

type SettingsSectionType = {
  title: string;
  items: SettingItemType[];
};

// Custom theme colors for beige theme - matching the dashboard
const THEME = {
  background: '#f2efe4', // Beige background matching bottom bar
  cardBackground: '#ffffff',
  primary: '#00b076', // Green primary color
  text: {
    primary: '#333333',
    secondary: '#666666',
    tertiary: '#999999',
  },
  divider: 'rgba(0,0,0,0.08)',
  card: {
    shadow: 'rgba(0,0,0,0.12)',
    border: 'rgba(0,0,0,0.05)',
  },
  danger: '#ff3b30'
};

// Premium Glass Card component
const GlassCard = ({ style, children, intensity = 15 }) => {
  return Platform.OS === 'ios' ? (
    <BlurView intensity={intensity} tint="light" style={[styles.glassCard, style]}>
      {children}
    </BlurView>
  ) : (
    <View style={[styles.glassCardFallback, style]}>
      {children}
    </View>
  );
};

export default function SettingsScreen() {
  const [notificationsEnabled, setNotificationsEnabled] = React.useState(true);
  const [darkModeEnabled, setDarkModeEnabled] = React.useState(false);
  const [autoConnectDevices, setAutoConnectDevices] = React.useState(true);
  const [dataUploadEnabled, setDataUploadEnabled] = React.useState(true);
  
  const appSetupService = useAppSetupService();
  
  const handleResetData = async () => {
    try {
      await appSetupService.resetAppState();
      // Show success message
    } catch (error) {
      console.error('Failed to reset application data:', error);
      // Show error message
    }
  };
  
  const settingsSections: SettingsSectionType[] = [
    {
      title: 'General',
      items: [
        {
          id: 'notifications',
          title: 'Push Notifications',
          description: 'Receive alerts for important events',
          icon: 'bell-outline',
          type: 'toggle',
          value: notificationsEnabled,
          onValueChange: setNotificationsEnabled,
        },
        {
          id: 'darkMode',
          title: 'Dark Mode',
          description: 'Change app appearance',
          icon: 'theme-light-dark',
          type: 'toggle',
          value: darkModeEnabled,
          onValueChange: setDarkModeEnabled,
        },
      ],
    },
    {
      title: 'Devices',
      items: [
        {
          id: 'autoConnect',
          title: 'Auto-Connect',
          description: 'Automatically connect to remembered devices',
          icon: 'bluetooth-settings',
          type: 'toggle',
          value: autoConnectDevices,
          onValueChange: setAutoConnectDevices,
        },
        {
          id: 'manageDevices',
          title: 'Manage Devices',
          description: 'View and manage all paired devices',
          icon: 'devices',
          type: 'link',
          onPress: () => {/* Navigate to device management */},
        },
      ],
    },
    {
      title: 'Data',
      items: [
        {
          id: 'dataUpload',
          title: 'Auto Upload Data',
          description: 'Automatically sync data when connected',
          icon: 'cloud-upload-outline',
          type: 'toggle',
          value: dataUploadEnabled,
          onValueChange: setDataUploadEnabled,
        },
        {
          id: 'exportData',
          title: 'Export Data',
          description: 'Export your data in CSV format',
          icon: 'export',
          type: 'link',
          onPress: () => {/* Export data */},
        },
        {
          id: 'resetData',
          title: 'Reset All Data',
          description: 'Delete all app data and reset to defaults',
          icon: 'delete-outline',
          type: 'link',
          onPress: handleResetData,
          danger: true,
        },
      ],
    },
    {
      title: 'About',
      items: [
        {
          id: 'version',
          title: 'App Version',
          description: '1.0.0',
          icon: 'information-outline',
          type: 'info',
        },
        {
          id: 'help',
          title: 'Help & Support',
          description: 'Contact support or view FAQs',
          icon: 'help-circle-outline',
          type: 'link',
          onPress: () => {/* Navigate to help */},
        },
        {
          id: 'privacy',
          title: 'Privacy Policy',
          description: 'View our privacy policy',
          icon: 'shield-check-outline',
          type: 'link',
          onPress: () => {/* Navigate to privacy policy */},
        },
      ],
    },
  ];
  
  const renderSettingItem = (item: SettingItemType, index: number, itemsLength: number) => {
    return (
      <TouchableOpacity 
        key={item.id}
        style={[
          styles.settingItem,
          index < itemsLength - 1 && styles.settingItemBorder,
          item.danger && styles.dangerItem
        ]}
        disabled={item.type === 'toggle' || item.type === 'info'}
        onPress={item.onPress}
      >
        <LinearGradient
          colors={[
            item.danger ? 'rgba(255,59,48,0.15)' : 'rgba(0,176,118,0.15)', 
            item.danger ? 'rgba(255,59,48,0.05)' : 'rgba(0,176,118,0.05)'
          ]}
          style={styles.settingIconGradient}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
          borderRadius={20}
        >
          <MaterialCommunityIcons 
            name={item.icon} 
            size={24} 
            color={item.danger ? THEME.danger : THEME.primary} 
          />
        </LinearGradient>
        
        <View style={styles.settingContent}>
          <Text style={[
            styles.settingTitle,
            item.danger && styles.dangerText
          ]}>
            {item.title}
          </Text>
          <Text style={styles.settingDescription}>{item.description}</Text>
        </View>
        
        {item.type === 'toggle' && (
          <Switch
            value={item.value}
            onValueChange={item.onValueChange}
            trackColor={{ false: '#d0d0d0', true: 'rgba(0,176,118,0.3)' }}
            thumbColor={item.value ? THEME.primary : '#f4f3f4'}
            ios_backgroundColor="#d0d0d0"
          />
        )}
        
        {item.type === 'link' && (
          <MaterialCommunityIcons 
            name="chevron-right" 
            size={22} 
            color={item.danger ? THEME.danger : THEME.text.tertiary} 
          />
        )}
      </TouchableOpacity>
    );
  };
  
  return (
    <SafeAreaProvider>
      <ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
      >
        {/* Premium Header with Gradient */}
        <View style={styles.header}>
          <LinearGradient
            colors={['rgba(0,176,118,0.15)', 'rgba(0,176,118,0.05)', 'transparent']}
            style={styles.headerGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          />
          <View style={styles.headerContent}>
            <Text style={styles.headerTitle}>Settings</Text>
          </View>
        </View>
        
        {/* Settings Sections */}
        {settingsSections.map(section => (
          <View key={section.title} style={styles.section}>
            <Text style={styles.sectionTitle}>{section.title}</Text>
            <GlassCard>
              <LinearGradient
                colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.75)']}
                style={styles.cardGradient}
                start={{ x: 0, y: 0 }}
                end={{ x: 0, y: 1 }}
              />
              <View style={styles.cardInner}>
                {section.items.map((item, index) => 
                  renderSettingItem(item, index, section.items.length)
                )}
              </View>
            </GlassCard>
          </View>
        ))}
        
        {/* Bottom tab spacer */}
        <View style={{ height: 24 }} />
      </ScrollView>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  header: {
    height: 140,
    position: 'relative',
    marginBottom: 20,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: THEME.text.primary,
    letterSpacing: 0.5,
  },
  section: {
    marginBottom: 20,
    paddingHorizontal: 16,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: THEME.text.secondary,
    marginBottom: 10,
    marginLeft: 8,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  // Glass card styles
  glassCard: {
    borderRadius: 16,
    overflow: 'hidden',
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  glassCardFallback: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: THEME.cardBackground,
    borderColor: THEME.card.border,
    borderWidth: 1,
    shadowColor: THEME.card.shadow,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  cardGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  cardInner: {
    padding: 8,
  },
  settingItem: {
    flexDirection: 'row',
    padding: 12,
    alignItems: 'center',
    borderRadius: 8,
  },
  settingItemBorder: {
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: THEME.divider,
  },
  dangerItem: {
    borderBottomWidth: 0,
  },
  settingIconGradient: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(0,176,118,0.2)',
  },
  settingContent: {
    flex: 1,
  },
  settingTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: THEME.text.primary,
    marginBottom: 2,
  },
  settingDescription: {
    fontSize: 14,
    color: THEME.text.tertiary,
  },
  dangerText: {
    color: THEME.danger,
  },
});

================================================================================
File: app/app.tsx
================================================================================

import 'expo-dev-client';
import 'react-native-gesture-handler';
import { Slot, Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import * as SplashScreen from 'expo-splash-screen';
import { useCallback, useEffect, useState } from 'react';
import * as Font from 'expo-font';
import { RootSiblingParent } from 'react-native-root-siblings';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { COLORS } from '../src/constants';
import { DatabaseManager } from '../src/DatabaseManager';

SplashScreen.preventAutoHideAsync();

const RootLayout = () => {
  const [appIsReady, setAppIsReady] = useState(false);

  useEffect(() => {
    async function prepare() {
      try {
        // Pre-load fonts, make any API calls, etc.
        await Font.loadAsync({
          'Inter-Bold': require('../assets/fonts/Inter-Bold.ttf'),
          'Inter-Medium': require('../assets/fonts/Inter-Medium.ttf'),
          'Inter-Regular': require('../assets/fonts/Inter-Regular.ttf'),
          'Inter-SemiBold': require('../assets/fonts/Inter-SemiBold.ttf'),
        });
        
        // Initialize the database
        await DatabaseManager.getInstance().initialize();
      } catch (e) {
        console.warn(e);
      } finally {
        // Tell the application to render
        setAppIsReady(true);
      }
    }

    prepare();
  }, []);

  const onLayoutRootView = useCallback(async () => {
    if (appIsReady) {
      await SplashScreen.hideAsync();
    }
  }, [appIsReady]);

  if (!appIsReady) {
    return null;
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }} onLayout={onLayoutRootView}>
      <RootSiblingParent>
        <SafeAreaProvider>
          <Stack
            screenOptions={{
              headerShown: false,
              contentStyle: {
                backgroundColor: COLORS.background,
              },
            }}
          >
            <Stack.Screen name="index" />
            <Stack.Screen
              name="(tabs)"
              options={{
                // Disable the header to prevent double headers when using Tabs
                headerShown: false,
              }}
            />
            <Stack.Screen name="devices/add" />
            <Stack.Screen name="devices/create" />
            <Stack.Screen name="devices/[id]" />
            <Stack.Screen name="devices/[id]/edit" />
            <Stack.Screen name="devices/[id]/pair" />
            <Stack.Screen name="devices/ble-test" />
            <Stack.Screen name="devices/test-data" options={{ title: "Test Data" }} />
            <Stack.Screen name="screens/logs" options={{ title: "Data Logs" }} />
          </Stack>
          <StatusBar style="auto" />
        </SafeAreaProvider>
      </RootSiblingParent>
    </GestureHandlerRootView>
  );
};

export default RootLayout; 

================================================================================
File: app/components/charts/BarChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';

interface BarChartProps {
  data: number[];
  labels: string[];
  maxValue?: number;
  barColor?: string;
}

const BarChart: React.FC<BarChartProps> = ({ 
  data, 
  labels, 
  maxValue: propMaxValue, 
  barColor = COLORS.primary
}) => {
  // Calculate maxValue if not provided
  const maxValue = propMaxValue || Math.max(...data) * 1.2; // Add 20% padding
  const chartHeight = 220;
  const divisions = 5; // Number of horizontal lines

  // Generate y-axis labels
  const yAxisLabels = Array.from({ length: divisions + 1 }, (_, i) => {
    const value = (maxValue / divisions) * (divisions - i);
    return Math.round(value).toString();
  });

  return (
    <View style={styles.container}>
      {/* Y-axis labels */}
      <View style={styles.yAxis}>
        {yAxisLabels.map((label, index) => (
          <Text key={index} style={styles.yAxisLabel}>
            {label}
          </Text>
        ))}
      </View>

      {/* Chart area */}
      <View style={styles.chartArea}>
        {/* Horizontal grid lines */}
        {yAxisLabels.map((_, index) => (
          <View 
            key={index} 
            style={[
              styles.gridLine,
              { top: (chartHeight / divisions) * index }
            ]} 
          />
        ))}

        {/* Bars */}
        <View style={styles.barsContainer}>
          {data.map((value, index) => {
            const barHeight = (value / maxValue) * chartHeight;
            
            return (
              <View key={index} style={styles.barWrapper}>
                <View style={styles.barLabelContainer}>
                  <Text style={styles.barValue}>{value}</Text>
                </View>
                <View style={[styles.barBackground, { height: barHeight }]}>
                  <LinearGradient
                    colors={[
                      `${barColor}CC`, // 80% opacity
                      `${barColor}66`, // 40% opacity
                    ]}
                    style={[styles.bar, { height: '100%' }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 0, y: 1 }}
                  />
                </View>
                <Text style={styles.xAxisLabel}>{labels[index]}</Text>
              </View>
            );
          })}
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    height: 280, // Include space for labels
    paddingRight: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 12,
    padding: 16,
  },
  yAxis: {
    width: 50,
    justifyContent: 'space-between',
    marginRight: 10,
  },
  yAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    textAlign: 'right',
  },
  chartArea: {
    flex: 1,
    height: 220,
    position: 'relative',
  },
  gridLine: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  barsContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    height: '100%',
  },
  barWrapper: {
    flex: 1,
    alignItems: 'center',
    height: '100%',
    justifyContent: 'flex-end',
  },
  barLabelContainer: {
    position: 'absolute',
    top: -20,
    width: '100%',
    alignItems: 'center',
  },
  barValue: {
    color: COLORS.text.primary,
    fontSize: 12,
    fontWeight: '600',
  },
  barBackground: {
    width: '60%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
    overflow: 'hidden',
  },
  bar: {
    width: '100%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
  },
  xAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    marginTop: 8,
  },
});

export default BarChart; 

================================================================================
File: app/components/charts/BiteForceDynamicsChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { COLORS } from '@/src/constants';
import { ChartData } from '@/src/types';
import LineChart from './LineChart';

interface BiteForceDynamicsChartProps {
  data: ChartData;
  avgLeft?: number | null;
  avgRight?: number | null;
  avgTotal?: number | null;
  maxForce?: number | null;
  height?: number;
  width?: number;
}

const BiteForceDynamicsChart: React.FC<BiteForceDynamicsChartProps> = ({
  data,
  avgLeft,
  avgRight,
  avgTotal,
  maxForce,
  height = 180,
  width = Dimensions.get('window').width - 64,
}) => {
  // More comprehensive check for valid data
  if (!data || !data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
    return (
      <View style={[styles.container, { height, width }]}>
        <Text style={styles.emptyText}>No bite force data available</Text>
      </View>
    );
  }

  // Ensure that the first dataset has data
  const firstDataset = data.datasets[0];
  if (!firstDataset || !firstDataset.data || !Array.isArray(firstDataset.data) || firstDataset.data.length === 0) {
    return (
      <View style={[styles.container, { height, width }]}>
        <Text style={styles.emptyText}>No bite force data available</Text>
      </View>
    );
  }

  // Create a safe version of the data object
  const safeData = {
    labels: Array.isArray(data.labels) ? data.labels : [],
    datasets: data.datasets.map(dataset => {
      if (!dataset) return {
        data: [],
        color: (opacity = 1) => 'rgba(0, 0, 0, 0)',
        strokeWidth: 0
      };
      
      return {
        data: Array.isArray(dataset.data) ? dataset.data : [],
        color: typeof dataset.color === 'function' ? dataset.color : 
          (opacity = 1) => dataset === data.datasets[0] ? 
            'rgba(0, 176, 118, 1)' : 'rgba(0, 122, 255, 1)',
        strokeWidth: typeof dataset.strokeWidth === 'number' ? dataset.strokeWidth : 2
      };
    }),
    legend: data.legend
  };

  return (
    <View style={styles.container}>
      {/* KPI metrics row */}
      <View style={styles.metricsRow}>
        <View style={styles.metricItem}>
          <Text style={[styles.metricValue, { color: 'rgba(0, 176, 118, 1)' }]}>
            {avgLeft ?? '--'}
          </Text>
          <Text style={styles.metricLabel}>Left Avg</Text>
        </View>
        <View style={styles.metricItem}>
          <Text style={[styles.metricValue, { color: 'rgba(0, 122, 255, 1)' }]}>
            {avgRight ?? '--'}
          </Text>
          <Text style={styles.metricLabel}>Right Avg</Text>
        </View>
        <View style={styles.metricItem}>
          <Text style={styles.metricValue}>{maxForce ?? '--'}</Text>
          <Text style={styles.metricLabel}>Max Force</Text>
        </View>
      </View>

      {/* Legend */}
      <View style={styles.legendContainer}>
        <View style={styles.legendItem}>
          <View style={[styles.legendDot, { backgroundColor: 'rgba(0, 176, 118, 1)' }]} />
          <Text style={styles.legendText}>Left</Text>
        </View>
        <View style={styles.legendItem}>
          <View style={[styles.legendDot, { backgroundColor: 'rgba(0, 122, 255, 1)' }]} />
          <Text style={styles.legendText}>Right</Text>
        </View>
      </View>

      {/* Chart */}
      <LineChart 
        data={safeData}
        width={width}
        height={height}
        bezier={false}
        chartConfig={{
          backgroundColor: 'transparent',
          backgroundGradientFrom: 'transparent',
          backgroundGradientTo: 'transparent',
          decimalPlaces: 0,
          // Color function that will be overridden by dataset colors
          color: (opacity = 1) => `rgba(0, 0, 0, ${opacity})`,
          labelColor: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
          style: {
            borderRadius: 16,
          },
          propsForDots: {
            r: "2",
            strokeWidth: "1",
          },
          propsForBackgroundLines: {
            strokeDasharray: '4, 4',
            strokeWidth: 0.5,
            stroke: 'rgba(0, 0, 0, 0.05)',
          },
        }}
        style={{
          marginVertical: 8,
          borderRadius: 16,
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  metricsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
    paddingHorizontal: 8,
    marginBottom: 8,
  },
  metricItem: {
    alignItems: 'center',
  },
  metricValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.textPrimary,
  },
  metricLabel: {
    fontSize: 12,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
  legendContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: 8,
  },
  legendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginHorizontal: 8,
  },
  legendDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6,
  },
  legendText: {
    fontSize: 12,
    color: COLORS.textSecondary,
  },
  emptyText: {
    fontSize: 14,
    color: COLORS.textTertiary,
    textAlign: 'center',
    padding: 20,
  }
});

export default BiteForceDynamicsChart; 

================================================================================
File: app/components/charts/ChartStyles.ts
================================================================================

import { StyleSheet } from 'react-native';
import { COLORS } from '../../../src/constants';

const chartStyles = StyleSheet.create({
  card: {
    backgroundColor: COLORS.cardBackground,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 20,
    padding: 20,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 15,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.08)',
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12,
  },
  headerIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: 0.38,
  },
  description: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 20,
    letterSpacing: -0.24,
    lineHeight: 20,
  },
  chartWrapper: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
  },
  chartContainer: {
    borderRadius: 16,
    overflow: 'hidden',
  },
});

export default chartStyles; 

================================================================================
File: app/components/charts/ConcussionRiskGauge.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { COLORS } from '@/src/constants';

interface ConcussionRiskGaugeProps {
  risk?: 'Low' | 'Moderate' | 'High' | 'Critical' | null;
  width?: number;
}

const ConcussionRiskGauge: React.FC<ConcussionRiskGaugeProps> = ({
  risk = 'Low',
  width = Dimensions.get('window').width - 64,
}) => {
  // Default to 'Low' if risk is undefined or null
  const safeRisk = risk || 'Low';
  
  // Calculate indicator position
  let percentage = 0;
  let textColor = COLORS.primary;
  let gaugeColor = COLORS.primary;
  
  switch (safeRisk) {
    case 'Critical':
      percentage = 100;
      textColor = 'rgb(200, 0, 0)';
      gaugeColor = 'rgb(200, 0, 0)';
      break;
    case 'High':
      percentage = 75;
      textColor = 'rgb(255, 59, 48)';
      gaugeColor = 'rgb(255, 59, 48)';
      break;
    case 'Moderate':
      percentage = 50;
      textColor = 'rgb(255, 149, 0)';
      gaugeColor = 'rgb(255, 149, 0)';
      break;
    case 'Low':
    default:
      percentage = 25;
      textColor = 'rgb(0, 176, 118)';
      gaugeColor = 'rgb(0, 176, 118)';
      break;
  }
  
  const indicatorPosition = (percentage / 100) * (width - 32);
  
  return (
    <View style={[styles.container, { width }]}>
      <Text style={[styles.riskValue, { color: textColor }]}>
        {safeRisk}
      </Text>
      <Text style={styles.riskLabel}>
        Concussion Risk Level
      </Text>
      
      {/* Gauge Track */}
      <View style={[styles.gaugeTrack, { width: width - 32 }]}>
        {/* Risk labels */}
        <View style={styles.riskLabelContainer}>
          <Text style={[styles.riskLabelText, { color: 'rgb(0, 176, 118)' }]}>Low</Text>
          <Text style={[styles.riskLabelText, { color: 'rgb(255, 149, 0)' }]}>Moderate</Text>
          <Text style={[styles.riskLabelText, { color: 'rgb(255, 59, 48)' }]}>High</Text>
          <Text style={[styles.riskLabelText, { color: 'rgb(200, 0, 0)' }]}>Critical</Text>
        </View>
        
        {/* Gauge indicator */}
        <View style={[styles.gaugeIndicator, { left: indicatorPosition - 6, backgroundColor: gaugeColor }]} />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
  },
  riskValue: {
    fontSize: 32,
    fontWeight: '600',
    marginBottom: 4,
  },
  riskLabel: {
    fontSize: 14,
    color: COLORS.textSecondary,
    marginBottom: 24,
  },
  gaugeTrack: {
    height: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.05)',
    borderRadius: 4,
    position: 'relative',
  },
  gaugeIndicator: {
    width: 12,
    height: 12,
    borderRadius: 6,
    position: 'absolute',
    top: -2,
    borderWidth: 2,
    borderColor: '#fff',
  },
  riskLabelContainer: {
    position: 'absolute',
    top: 16,
    left: 0,
    right: 0,
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  riskLabelText: {
    fontSize: 12,
    fontWeight: '500',
  }
});

export default ConcussionRiskGauge; 

================================================================================
File: app/components/charts/CumulativeExposureGraph.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { COLORS } from '@/src/constants';
import { ChartData } from '@/src/types';
import LineChart from './LineChart';

interface CumulativeExposureGraphProps {
  data: ChartData | null;
  height?: number;
  width?: number;
}

const CumulativeExposureGraph: React.FC<CumulativeExposureGraphProps> = ({
  data,
  height = 180,
  width = Dimensions.get('window').width - 64,
}) => {
  // Check if we have valid data to display
  if (!data || !data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
    return (
      <View style={[styles.container, { height, width }]}>
        <Text style={styles.emptyText}>No impact exposure data available</Text>
      </View>
    );
  }

  // Create a safe version of the data
  const safeData = {
    labels: Array.isArray(data.labels) ? data.labels : [],
    datasets: data.datasets.map(dataset => {
      if (!dataset) return {
        data: [],
        color: (opacity = 1) => 'rgba(0, 122, 255, 1)',
        strokeWidth: 2
      };
      
      return {
        data: Array.isArray(dataset.data) ? dataset.data : [],
        color: typeof dataset.color === 'function' ? dataset.color : 
          (opacity = 1) => `rgba(0, 122, 255, ${opacity})`,
        strokeWidth: typeof dataset.strokeWidth === 'number' ? dataset.strokeWidth : 2
      };
    }),
    legend: data.legend
  };

  // Get last data point (most recent cumulative value)
  const lastDataPoint = safeData.datasets[0]?.data?.length ? 
    safeData.datasets[0].data[safeData.datasets[0].data.length - 1] : 0;

  return (
    <View style={styles.container}>
      {/* Cumulative Value */}
      <View style={styles.totalContainer}>
        <Text style={styles.totalValue}>
          {lastDataPoint !== null && lastDataPoint !== undefined ? Math.round(lastDataPoint) : '0'}
        </Text>
        <Text style={styles.totalLabel}>Total Accumulated G-Force</Text>
      </View>

      {/* Chart */}
      <LineChart 
        data={safeData}
        width={width}
        height={height}
        bezier={true}
        chartConfig={{
          backgroundColor: 'transparent',
          backgroundGradientFrom: 'transparent',
          backgroundGradientTo: 'transparent',
          decimalPlaces: 0,
          color: (opacity = 1) => `rgba(0, 122, 255, ${opacity})`,
          labelColor: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
          style: {
            borderRadius: 16,
          },
          propsForDots: {
            r: "2",
            strokeWidth: "1",
          },
          propsForBackgroundLines: {
            strokeDasharray: '4, 4',
            strokeWidth: 0.5,
            stroke: 'rgba(0, 0, 0, 0.05)',
          },
        }}
        style={{
          marginVertical: 8,
          borderRadius: 16,
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  totalContainer: {
    alignItems: 'center',
    marginBottom: 16,
  },
  totalValue: {
    fontSize: 24,
    fontWeight: '600',
    color: 'rgba(0, 122, 255, 1)',
  },
  totalLabel: {
    fontSize: 12,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
  emptyText: {
    fontSize: 14,
    color: COLORS.textTertiary,
    textAlign: 'center',
    padding: 20,
  }
});

export default CumulativeExposureGraph; 

================================================================================
File: app/components/charts/HeartRateTrendChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { COLORS } from '@/src/constants';
import { ChartData } from '@/src/types';
import LineChart from './LineChart';

interface HeartRateTrendChartProps {
  data: ChartData | null;
  avgHr?: number | null;
  minHr?: number | null;
  maxHr?: number | null;
  height?: number;
  width?: number;
}

const HeartRateTrendChart: React.FC<HeartRateTrendChartProps> = ({
  data,
  avgHr,
  minHr,
  maxHr,
  height = 180,
  width = Dimensions.get('window').width - 64,
}) => {
  // Check if we have valid data to display
  if (!data || !data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
    return (
      <View style={[styles.container, { height, width }]}>
        <Text style={styles.emptyText}>No heart rate data available</Text>
      </View>
    );
  }

  // Create a safe version of the data
  const safeData = {
    labels: Array.isArray(data.labels) ? data.labels : [],
    datasets: data.datasets.map(dataset => {
      if (!dataset) return {
        data: [],
        color: (opacity = 1) => 'rgba(255, 59, 48, 1)',
        strokeWidth: 2
      };
      
      return {
        data: Array.isArray(dataset.data) ? dataset.data : [],
        color: typeof dataset.color === 'function' ? dataset.color : 
          (opacity = 1) => `rgba(255, 59, 48, ${opacity})`,
        strokeWidth: typeof dataset.strokeWidth === 'number' ? dataset.strokeWidth : 2
      };
    }),
    legend: data.legend
  };

  return (
    <View style={styles.container}>
      {/* Stats row with KPIs */}
      <View style={styles.metricsRow}>
        <View style={styles.metricItem}>
          <Text style={[styles.metricValue, { color: 'rgba(255, 59, 48, 1)' }]}>
            {avgHr !== null && avgHr !== undefined ? avgHr : '--'}
          </Text>
          <Text style={styles.metricLabel}>Avg BPM</Text>
        </View>
        <View style={styles.metricItem}>
          <Text style={styles.metricValue}>
            {minHr !== null && minHr !== undefined ? minHr : '--'}
          </Text>
          <Text style={styles.metricLabel}>Min</Text>
        </View>
        <View style={styles.metricItem}>
          <Text style={styles.metricValue}>
            {maxHr !== null && maxHr !== undefined ? maxHr : '--'}
          </Text>
          <Text style={styles.metricLabel}>Max</Text>
        </View>
      </View>

      {/* Chart */}
      <LineChart 
        data={safeData}
        width={width}
        height={height}
        bezier={true}
        chartConfig={{
          backgroundColor: 'transparent',
          backgroundGradientFrom: 'transparent',
          backgroundGradientTo: 'transparent',
          decimalPlaces: 0,
          color: (opacity = 1) => `rgba(255, 59, 48, ${opacity})`,
          labelColor: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
          style: {
            borderRadius: 16,
          },
          propsForDots: {
            r: "2",
            strokeWidth: "1",
          },
          propsForBackgroundLines: {
            strokeDasharray: '4, 4',
            strokeWidth: 0.5,
            stroke: 'rgba(0, 0, 0, 0.05)',
          },
        }}
        style={{
          marginVertical: 8,
          borderRadius: 16,
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  metricsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  metricItem: {
    alignItems: 'center',
  },
  metricValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.textPrimary,
  },
  metricLabel: {
    fontSize: 12,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
  emptyText: {
    fontSize: 14,
    color: COLORS.textTertiary,
    textAlign: 'center',
    padding: 20,
  }
});

export default HeartRateTrendChart; 

================================================================================
File: app/components/charts/ImpactTimelineGraph.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { COLORS } from '@/src/constants';
import { ChartData } from '@/src/types';
import LineChart from './LineChart';

interface ImpactTimelineGraphProps {
  data: ChartData | null;
  totalImpacts?: number | null;
  maxG?: number | null;
  height?: number;
  width?: number;
}

const ImpactTimelineGraph: React.FC<ImpactTimelineGraphProps> = ({
  data,
  totalImpacts,
  maxG,
  height = 180,
  width = Dimensions.get('window').width - 64,
}) => {
  // Check if we have valid data to display
  if (!data || !data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
    return (
      <View style={[styles.container, { height, width }]}>
        <Text style={styles.emptyText}>No impact data available</Text>
      </View>
    );
  }

  // Create a safe version of the data
  const safeData = {
    labels: Array.isArray(data.labels) ? data.labels : [],
    datasets: data.datasets.map(dataset => {
      if (!dataset) return {
        data: [],
        color: (opacity = 1) => 'rgba(0, 176, 118, 1)',
        strokeWidth: 2
      };
      
      return {
        data: Array.isArray(dataset.data) ? dataset.data : [],
        color: typeof dataset.color === 'function' ? dataset.color : 
          (opacity = 1) => `rgba(0, 176, 118, ${opacity})`,
        strokeWidth: typeof dataset.strokeWidth === 'number' ? dataset.strokeWidth : 2
      };
    }),
    legend: data.legend
  };

  return (
    <View style={styles.container}>
      {/* Stats row */}
      <View style={styles.metricsRow}>
        <View style={styles.metricItem}>
          <Text style={styles.metricValue}>
            {totalImpacts !== null && totalImpacts !== undefined ? totalImpacts : '0'}
          </Text>
          <Text style={styles.metricLabel}>Total Impacts</Text>
        </View>
        <View style={styles.metricItem}>
          <Text style={styles.metricValue}>
            {maxG !== null && maxG !== undefined ? `${maxG}g` : '0g'}
          </Text>
          <Text style={styles.metricLabel}>Max G-Force</Text>
        </View>
      </View>

      {/* Chart */}
      <LineChart 
        data={safeData}
        width={width}
        height={height}
        bezier={true}
        chartConfig={{
          backgroundColor: 'transparent',
          backgroundGradientFrom: 'transparent',
          backgroundGradientTo: 'transparent',
          decimalPlaces: 0,
          color: (opacity = 1) => `rgba(0, 176, 118, ${opacity})`,
          labelColor: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
          style: {
            borderRadius: 16,
          },
          propsForDots: {
            r: "4",
            strokeWidth: "2",
          },
          propsForBackgroundLines: {
            strokeDasharray: '4, 4',
            strokeWidth: 0.5,
            stroke: 'rgba(0, 0, 0, 0.05)',
          },
        }}
        style={{
          marginVertical: 8,
          borderRadius: 16,
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  metricsRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  metricItem: {
    alignItems: 'center',
  },
  metricValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.textPrimary,
  },
  metricLabel: {
    fontSize: 12,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
  emptyText: {
    fontSize: 14,
    color: COLORS.textTertiary,
    textAlign: 'center',
    padding: 20,
  }
});

export default ImpactTimelineGraph; 

================================================================================
File: app/components/charts/LineChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { LineChart as RNLineChart } from 'react-native-chart-kit';
import { COLORS } from '../../../src/constants';
import { ChartData } from '../../../src/types';

interface LineChartProps {
  data: ChartData | {
    labels: string[];
    datasets: {
      data: number[];
      color: (opacity?: number) => string;
      strokeWidth: number;
    }[];
    legend?: string[];
  };
  width?: number;
  height?: number;
  alwaysShowZero?: boolean;
  chartConfig?: any;
  bezier?: boolean;
  style?: any;
}

const screenWidth = Dimensions.get('window').width;

const LineChart: React.FC<LineChartProps> = ({
  data,
  width = screenWidth - 64,
  height = 220,
  alwaysShowZero = true,
  chartConfig,
  bezier = true,
  style
}) => {
  // More robust checks for data and its structure
  if (!data) {
    return (
      <View style={[styles.container, { height, width, justifyContent: 'center', alignItems: 'center' }]}>
        <Text style={styles.noDataText}>No data available</Text>
      </View>
    );
  }
  
  // Check if we have valid datasets
  const hasValidDatasets = data.datasets && 
                          Array.isArray(data.datasets) && 
                          data.datasets.length > 0;
  
  if (!hasValidDatasets) {
    return (
      <View style={[styles.container, { height, width, justifyContent: 'center', alignItems: 'center' }]}>
        <Text style={styles.noDataText}>No data available</Text>
      </View>
    );
  }
  
  // Create safe datasets - ensure each dataset has a valid data array and color function
  const safeDatasets = data.datasets.map((dataset, index) => {
    if (!dataset) return { data: [], color: () => 'rgba(0, 230, 118, 1)', strokeWidth: 2 };
    
    return {
      data: dataset.data && Array.isArray(dataset.data) ? dataset.data : [],
      color: typeof dataset.color === 'function' ? dataset.color : () => 'rgba(0, 230, 118, 1)',
      strokeWidth: typeof dataset.strokeWidth === 'number' ? dataset.strokeWidth : 2,
    };
  });
  
  // Check if any dataset has valid data
  const hasDataPoints = safeDatasets.some(ds => 
    ds.data.length > 0 && ds.data.some(val => typeof val === 'number')
  );
  
  if (!hasDataPoints) {
    return (
      <View style={[styles.container, { height, width, justifyContent: 'center', alignItems: 'center' }]}>
        <Text style={styles.noDataText}>No data available</Text>
      </View>
    );
  }
  
  // Create a safe data object
  const safeData = {
    labels: Array.isArray(data.labels) ? data.labels : [],
    datasets: safeDatasets,
    legend: data.legend
  };
  
  // Generate default chart config if not provided
  const defaultChartConfig = chartConfig || {
    backgroundColor: 'transparent',
    backgroundGradientFrom: 'transparent',
    backgroundGradientTo: 'transparent',
    decimalPlaces: 1,
    color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
    labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity * 0.7})`,
    style: {
      borderRadius: 16
    },
    propsForDots: {
      r: '3',
      strokeWidth: '1',
      stroke: COLORS.primary
    },
    propsForBackgroundLines: {
      strokeDasharray: '5, 5',
      stroke: 'rgba(255, 255, 255, 0.1)',
      strokeWidth: 1
    },
    propsForLabels: {
      fontSize: 10
    }
  };

  // Combine styles
  const combinedStyle = {
    ...styles.chart,
    ...(style || {})
  };

  return (
    <View style={styles.container}>
      <RNLineChart
        data={safeData}
        width={width}
        height={height}
        chartConfig={defaultChartConfig}
        bezier={bezier}
        style={combinedStyle}
        withInnerLines={true}
        withOuterLines={false}
        withHorizontalLabels={true}
        withVerticalLabels={true}
        withDots={true}
        segments={5}
        fromZero={true}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 16,
    overflow: 'hidden',
    position: 'relative',
  },
  chart: {
    borderRadius: 16,
  },
  noDataText: {
    color: COLORS.text.secondary,
    fontSize: 16,
    textAlign: 'center',
  }
});

export default LineChart; 

================================================================================
File: app/components/charts/MonthlyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '../../../src/types';

interface MonthlyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const MonthlyOverviewChart: React.FC<MonthlyOverviewChartProps> = ({ data, onPress }) => {
  // Validate data to prevent NaN values
  const validatedData = data.map(item => ({
    ...item,
    value: isNaN(item.value) ? 0 : item.value
  }));
  
  const chartData = {
    labels: validatedData.map(item => item.label),
    datasets: [{
      data: validatedData.map(item => item.value)
    }]
  };

  // Calculate monthly stats with validated data
  const totalHits = validatedData.reduce((sum, month) => sum + month.value, 0);
  const avgHits = totalHits / validatedData.length;
  const maxHits = Math.max(...validatedData.map(month => month.value));
  const maxMonth = validatedData.find(month => month.value === maxHits)?.label || '';
  
  // Prevent division by zero and handle potential NaN values
  const monthlyGrowth = validatedData.length > 1 && validatedData[0].value !== 0
    ? ((validatedData[validatedData.length - 1].value - validatedData[0].value) / validatedData[0].value * 100).toFixed(1)
    : '0';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Monthly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/month average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-areaspline" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Month</Text>
              <Text style={styles.statValue}>{maxMonth}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Growth</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={Number(monthlyGrowth) >= 0 ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(Number(monthlyGrowth))}%
                </Text>
              </View>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Monthly Analysis</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 18,
    fontWeight: '600',
    marginLeft: 4,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default MonthlyOverviewChart; 

================================================================================
File: app/components/charts/MotionOverviewGraph.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { COLORS } from '@/src/constants';
import { ChartData } from '@/src/types';
import LineChart from './LineChart';

interface MotionOverviewGraphProps {
  data: ChartData | null;
  peakAccel?: number | null;
  height?: number;
  width?: number;
}

const MotionOverviewGraph: React.FC<MotionOverviewGraphProps> = ({
  data,
  peakAccel,
  height = 180,
  width = Dimensions.get('window').width - 64,
}) => {
  // Check if we have valid data to display
  if (!data || !data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
    return (
      <View style={[styles.container, { height, width }]}>
        <Text style={styles.emptyText}>No motion data available</Text>
      </View>
    );
  }

  // Create a safe version of the data
  const safeData = {
    labels: Array.isArray(data.labels) ? data.labels : [],
    datasets: data.datasets.map(dataset => {
      if (!dataset) return {
        data: [],
        color: (opacity = 1) => 'rgba(80, 80, 80, 1)',
        strokeWidth: 2
      };
      
      return {
        data: Array.isArray(dataset.data) ? dataset.data : [],
        color: typeof dataset.color === 'function' ? dataset.color : 
          (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
        strokeWidth: typeof dataset.strokeWidth === 'number' ? dataset.strokeWidth : 2
      };
    }),
    legend: data.legend
  };

  return (
    <View style={styles.container}>
      {/* Stats */}
      <View style={styles.metricsRow}>
        <View style={styles.metricItem}>
          <Text style={styles.metricValue}>
            {peakAccel !== null && peakAccel !== undefined ? peakAccel : '--'}
          </Text>
          <Text style={styles.metricLabel}>Peak Acceleration (g)</Text>
        </View>
      </View>

      {/* Chart */}
      <LineChart 
        data={safeData}
        width={width}
        height={height}
        bezier={true}
        chartConfig={{
          backgroundColor: 'transparent',
          backgroundGradientFrom: 'transparent',
          backgroundGradientTo: 'transparent',
          decimalPlaces: 2,
          color: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
          labelColor: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
          style: {
            borderRadius: 16,
          },
          propsForDots: {
            r: "2",
            strokeWidth: "1",
          },
          propsForBackgroundLines: {
            strokeDasharray: '4, 4',
            strokeWidth: 0.5,
            stroke: 'rgba(0, 0, 0, 0.05)',
          },
        }}
        style={{
          marginVertical: 8,
          borderRadius: 16,
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  metricsRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    width: '100%',
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  metricItem: {
    alignItems: 'center',
  },
  metricValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.textPrimary,
  },
  metricLabel: {
    fontSize: 12,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
  emptyText: {
    fontSize: 14,
    color: COLORS.textTertiary,
    textAlign: 'center',
    padding: 20,
  }
});

export default MotionOverviewGraph; 

================================================================================
File: app/components/charts/SeverityDistributionGraph.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { COLORS } from '@/src/constants';
import BarChart from './BarChart';

interface SeverityDistributionGraphProps {
  data: { labels: string[]; data: number[] };
  height?: number;
  width?: number;
}

const SeverityDistributionGraph: React.FC<SeverityDistributionGraphProps> = ({
  data,
  height = 180,
  width = Dimensions.get('window').width - 64,
}) => {
  // Check if we have valid data to display
  const hasData = data && 
                 data.labels && 
                 data.labels.length > 0 && 
                 data.data && 
                 data.data.length > 0 && 
                 data.data.some(val => val > 0);

  if (!hasData) {
    return (
      <View style={[styles.container, { height, width }]}>
        <Text style={styles.emptyText}>No severity distribution data available</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <BarChart 
        data={data.data}
        labels={data.labels}
        barColor={COLORS.primary}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyText: {
    fontSize: 14,
    color: COLORS.textTertiary,
    textAlign: 'center',
    padding: 20,
  }
});

export default SeverityDistributionGraph; 

================================================================================
File: app/components/charts/TemperatureStabilityGraph.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { COLORS } from '@/src/constants';
import { ChartData } from '@/src/types';
import LineChart from './LineChart';

interface TemperatureStabilityGraphProps {
  data: ChartData;
  avgTemp?: number | null;
  maxTemp?: number | null;
  currentTemp?: number | null;
  height?: number;
  width?: number;
}

const TemperatureStabilityGraph: React.FC<TemperatureStabilityGraphProps> = ({
  data,
  avgTemp,
  maxTemp,
  currentTemp,
  height = 180,
  width = Dimensions.get('window').width - 64,
}) => {
  // Check if we have valid data to display
  if (!data || !data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
    return (
      <View style={[styles.container, { height, width }]}>
        <Text style={styles.emptyText}>No temperature data available</Text>
      </View>
    );
  }

  // Create a safe version of the data
  const safeData = {
    labels: Array.isArray(data.labels) ? data.labels : [],
    datasets: data.datasets.map(dataset => {
      if (!dataset) return {
        data: [],
        color: (opacity = 1) => 'rgba(255, 149, 0, 1)',
        strokeWidth: 2
      };
      
      return {
        data: Array.isArray(dataset.data) ? dataset.data : [],
        color: typeof dataset.color === 'function' ? dataset.color : 
          (opacity = 1) => `rgba(255, 149, 0, ${opacity})`,
        strokeWidth: typeof dataset.strokeWidth === 'number' ? dataset.strokeWidth : 2
      };
    }),
    legend: data.legend
  };

  return (
    <View style={styles.container}>
      {/* KPI stats */}
      <View style={styles.metricsRow}>
        <View style={styles.metricItem}>
          <Text style={[styles.metricValue, { color: 'rgba(255, 149, 0, 1)' }]}>
            {currentTemp !== null && currentTemp !== undefined ? currentTemp : '--'}F
          </Text>
          <Text style={styles.metricLabel}>Current</Text>
        </View>
        <View style={styles.metricItem}>
          <Text style={styles.metricValue}>
            {avgTemp !== null && avgTemp !== undefined ? avgTemp : '--'}F
          </Text>
          <Text style={styles.metricLabel}>Average</Text>
        </View>
        <View style={styles.metricItem}>
          <Text style={styles.metricValue}>
            {maxTemp !== null && maxTemp !== undefined ? maxTemp : '--'}F
          </Text>
          <Text style={styles.metricLabel}>Maximum</Text>
        </View>
      </View>

      {/* Chart */}
      <LineChart 
        data={safeData}
        width={width}
        height={height}
        bezier={true}
        chartConfig={{
          backgroundColor: 'transparent',
          backgroundGradientFrom: 'transparent',
          backgroundGradientTo: 'transparent',
          decimalPlaces: 1,
          color: (opacity = 1) => `rgba(255, 149, 0, ${opacity})`,
          labelColor: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`,
          style: {
            borderRadius: 16,
          },
          propsForDots: {
            r: "2",
            strokeWidth: "1",
          },
          propsForBackgroundLines: {
            strokeDasharray: '4, 4',
            strokeWidth: 0.5,
            stroke: 'rgba(0, 0, 0, 0.05)',
          },
        }}
        style={{
          marginVertical: 8,
          borderRadius: 16,
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  metricsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  metricItem: {
    alignItems: 'center',
  },
  metricValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.textPrimary,
  },
  metricLabel: {
    fontSize: 12,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
  emptyText: {
    fontSize: 14,
    color: COLORS.textTertiary,
    textAlign: 'center',
    padding: 20,
  }
});

export default TemperatureStabilityGraph; 

================================================================================
File: app/components/charts/WeeklyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '../../../src/types';

interface WeeklyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const WeeklyOverviewChart: React.FC<WeeklyOverviewChartProps> = ({ data, onPress }) => {
  // Validate data to prevent NaN values
  const validatedData = data.map(item => ({
    ...item,
    value: isNaN(item.value) ? 0 : item.value
  }));
  
  const chartData = {
    labels: validatedData.map(item => item.label),
    datasets: [{
      data: validatedData.map(item => item.value)
    }]
  };

  // Calculate weekly stats using validated data
  const totalHits = validatedData.reduce((sum, day) => sum + day.value, 0);
  const avgHits = totalHits / 7;
  const maxHits = Math.max(...validatedData.map(day => day.value));
  const maxDay = validatedData.find(day => day.value === maxHits)?.label || '';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Weekly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/day average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-line-variant" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Day</Text>
              <Text style={styles.statValue}>{maxDay}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Max Hits</Text>
              <Text style={styles.statValue}>{maxHits}</Text>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Details</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default WeeklyOverviewChart; 

================================================================================
File: app/components/Header.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { COLORS } from '@/src/constants';

interface HeaderProps {
  title: string;
}

export default function Header({ title }: HeaderProps) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: COLORS.background,
  },
  title: {
    fontSize: 28,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
}); 

================================================================================
File: app/components/shared/AlertOverlay.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { dataChangeEmitter } from '@/src/utils/EventEmitter';
import { ConcussionAlert } from '@/src/types';
import { COLORS } from '@/src/constants';
import { useRouter } from 'expo-router';

const AlertOverlay: React.FC = () => {
  const [activeAlert, setActiveAlert] = useState<ConcussionAlert | null>(null);
  const router = useRouter();

  useEffect(() => {
    const handleAlert = (alertData: ConcussionAlert) => {
      // Only show unacknowledged alerts, prioritize critical ones if multiple arrive
      if (!alertData.acknowledged) {
        // Simple logic: just show the latest alert
        setActiveAlert(alertData);
      }
    };

    dataChangeEmitter.on('ALERT_TRIGGERED', handleAlert);

    return () => {
      dataChangeEmitter.off('ALERT_TRIGGERED', handleAlert);
    };
  }, []);

  const handleAcknowledge = async () => {
    if (activeAlert) {
      // In a real app, call a repository method to update alert status
      console.log(`Acknowledging alert: ${activeAlert.id}`);
      // Simulate API call
      try {
        // await alertRepository.acknowledgeAlert(activeAlert.id);
        // For now, just hide the alert
        setActiveAlert(null);
      } catch (error) {
        console.error('Error acknowledging alert:', error);
      }
    }
  };

  const handleViewDetails = () => {
    if (activeAlert) {
      // Navigate to alert details or athlete profile
      console.log(`Viewing details for alert: ${activeAlert.id}`);
      
      if (activeAlert.athleteId) {
        // Navigate to athlete detail page if we have an athlete
        router.push({
          pathname: '/athletes/[id]',
          params: { id: activeAlert.athleteId }
        });
      } else {
        // Otherwise go to reports/impacts page
        router.push('/reports');
      }
      
      // Hide alert after navigating
      setActiveAlert(null);
    }
  };

  if (!activeAlert) {
    return null;
  }

  const getAlertColor = (severity: string | undefined) => {
    switch (severity) {
      case 'critical':
        return COLORS.error;
      case 'severe':
        return COLORS.error;
      case 'moderate':
        return COLORS.warning;
      default:
        return COLORS.info;
    }
  };
  
  const alertColor = getAlertColor(activeAlert.severity);

  return (
    <View style={[styles.overlayContainer, { backgroundColor: alertColor }]}>
      <MaterialCommunityIcons name="alert-decagram" size={24} color="#fff" style={styles.icon} />
      <View style={styles.textContainer}>
        <Text style={styles.title}>ALERT: {activeAlert.severity?.toUpperCase()}</Text>
        <Text style={styles.message}>
          {activeAlert.athleteName || 'Unknown Athlete'} - {activeAlert.magnitude.toFixed(1)}g impact detected
        </Text>
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity style={styles.button} onPress={handleAcknowledge}>
          <Text style={styles.buttonText}>Acknowledge</Text>
        </TouchableOpacity>
        <TouchableOpacity style={[styles.button, styles.detailsButton]} onPress={handleViewDetails}>
          <Text style={styles.buttonText}>Details</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  overlayContainer: {
    position: 'absolute',
    top: Platform.OS === 'ios' ? 40 : 10, // Adjust for status bar
    left: 10,
    right: 10,
    borderRadius: 12,
    padding: 12,
    flexDirection: 'row',
    alignItems: 'center',
    zIndex: 1000, // Ensure it's on top
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  icon: {
    marginRight: 10,
  },
  textContainer: {
    flex: 1,
  },
  title: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
    marginBottom: 2,
  },
  message: {
    color: '#fff',
    fontSize: 14,
  },
  buttonContainer: {
    flexDirection: 'column',
    marginLeft: 10,
  },
  button: {
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 6,
    backgroundColor: 'rgba(255,255,255,0.2)',
    marginBottom: 4, // Space buttons vertically
  },
  detailsButton: {
    backgroundColor: 'rgba(255,255,255,0.3)', // Slightly different
  },
  buttonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '500',
  },
});

export default AlertOverlay; 

================================================================================
File: app/components/shared/Card.tsx
================================================================================

import React, { ReactNode } from 'react';
import { View, StyleSheet } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '@/src/constants';

interface CardProps {
  children: ReactNode;
  style?: any;
}

/**
 * Card component that provides consistent styling for card elements
 * with the green gradient accents shown in the design.
 */
const Card: React.FC<CardProps> = ({ children, style }) => {
  return (
    <View style={[styles.container, style]}>
      <LinearGradient
        colors={['rgba(0,230,118,0.15)', 'rgba(0,230,118,0.05)', 'transparent']}
        style={styles.gradientBackground}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />
      {children}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: COLORS.card,
    borderRadius: 16,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
    position: 'relative',
  },
  gradientBackground: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
});

export default Card;

================================================================================
File: app/components/shared/ErrorView.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '@/src/constants';

interface ErrorViewProps {
  error: string;
}

export default function ErrorView({ error }: ErrorViewProps) {
  return (
    <View style={styles.container}>
      <MaterialCommunityIcons 
        name="alert-circle-outline" 
        size={48} 
        color={COLORS.error} 
      />
      <Text style={styles.title}>Error</Text>
      <Text style={styles.message}>{error}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  title: {
    marginTop: 16,
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.textPrimary,
  },
  message: {
    marginTop: 8,
    fontSize: 16,
    color: COLORS.textSecondary,
    textAlign: 'center',
    lineHeight: 22,
    maxWidth: '90%',
  },
});

================================================================================
File: app/components/shared/LoadingView.tsx
================================================================================

import React, { useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '../../../src/constants';
import Animated, { 
  withRepeat, 
  withTiming,
  useAnimatedStyle, 
  useSharedValue,
  FadeIn
} from 'react-native-reanimated';
import { TIMING_CONFIG } from '@/src/utils/animations';

export default function LoadingView() {
  const rotation = useSharedValue(0);

  useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        ...TIMING_CONFIG,
        duration: 1500 // Slightly slower for smoother rotation
      }),
      -1
    );
  }, []);

  const spinStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }]
  }));

  return (
    <View style={styles.container}>
      <Animated.View 
        entering={FadeIn.duration(300)}
        style={styles.content}
      >
        <Animated.View style={spinStyle}>
          <MaterialCommunityIcons 
            name="loading" 
            size={32} 
            color={COLORS.primary} 
          />
        </Animated.View>
        <Text style={styles.text}>Loading...</Text>
      </Animated.View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    alignItems: 'center',
    gap: 12,
  },
  text: {
    fontSize: 16,
    color: COLORS.textSecondary,
    marginTop: 8,
  },
});

================================================================================
File: app/components/shared/ThemeWrapper.tsx
================================================================================

import React, { ReactNode } from 'react';
import { View, StyleSheet } from 'react-native';
import { COLORS } from '@/src/constants';
import { LinearGradient } from 'expo-linear-gradient';

interface ThemeWrapperProps {
  children: ReactNode;
}

/**
 * ThemeWrapper provides consistent styling for all screens
 * with the yellowish background color from the design.
 */
const ThemeWrapper: React.FC<ThemeWrapperProps> = ({ children }) => {
  return (
    <View style={styles.container}>
      <LinearGradient
        colors={['rgba(237, 235, 209, 1)', 'rgba(237, 235, 209, 0.8)']}
        style={styles.backgroundGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      {children}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.secondaryBackground, // Sand color as fallback
    position: 'relative',
  },
  backgroundGradient: {
    ...StyleSheet.absoluteFillObject,
  },
});

export default ThemeWrapper; 

================================================================================
File: app/index.tsx
================================================================================

import { Redirect } from 'expo-router';

export default function Index() {
  return <Redirect href="/(tabs)" />;
} 

================================================================================
File: app/screens/LogsScreen.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, RefreshControl, TouchableOpacity, ActivityIndicator } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Stack } from 'expo-router';
import { DatabaseManager } from '../../src/DatabaseManager';
import { SQLiteDatabase } from 'expo-sqlite';

interface LogItem {
  id: number;
  timestamp: string;
  type: string;
  data: string;
}

export default function LogsScreen() {
  const [logs, setLogs] = useState<LogItem[]>([]);
  const [filteredLogs, setFilteredLogs] = useState<LogItem[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<string>('all');
  const [loading, setLoading] = useState(true);

  const fetchLogs = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const allLogs: LogItem[] = [];
      
      // Fetch different types of logs
      const motionLogs = await fetchLogsByType('motion');
      const fsrLogs = await fetchLogsByType('fsr');
      const hrmLogs = await fetchLogsByType('hrm');
      const htmLogs = await fetchLogsByType('htm');
      
      // Combine all logs
      allLogs.push(...motionLogs, ...fsrLogs, ...hrmLogs, ...htmLogs);
      
      // Sort logs by timestamp (newest first)
      allLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
      
      setLogs(allLogs);
      setFilteredLogs(allLogs);
      setActiveTab('all');
    } catch (err) {
      console.error('Error fetching logs:', err);
      setError(`Failed to fetch logs: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const fetchLogsByType = async (type: string): Promise<LogItem[]> => {
    try {
      const db = await DatabaseManager.getInstance().getDatabase('mouthguardMonitor.db');
      
      let query = '';
      switch (type) {
        case 'motion':
          query = `
            SELECT id, device_timestamp as timestamp, 
            'motion' as type,
            json_object(
              'accel16_x', accel16_x,
              'accel16_y', accel16_y,
              'accel16_z', accel16_z,
              'accel200_x', accel200_x,
              'accel200_y', accel200_y,
              'accel200_z', accel200_z,
              'gyro_x', gyro_x,
              'gyro_y', gyro_y,
              'gyro_z', gyro_z,
              'mag_x', mag_x,
              'mag_y', mag_y,
              'mag_z', mag_z,
              'bite_l', bite_l,
              'bite_r', bite_r
            ) as data
            FROM motion_packets
            ORDER BY device_timestamp DESC
            LIMIT 100
          `;
          break;
        case 'fsr':
          query = `
            SELECT id, device_timestamp as timestamp, 
            'fsr' as type,
            json_object(
              'left_bite', left_bite,
              'right_bite', right_bite
            ) as data
            FROM fsr_packets
            ORDER BY device_timestamp DESC
            LIMIT 100
          `;
          break;
        case 'hrm':
          query = `
            SELECT id, app_timestamp as timestamp, 
            'hrm' as type,
            json_object('heart_rate', heart_rate) as data
            FROM hrm_packets
            ORDER BY app_timestamp DESC
            LIMIT 100
          `;
          break;
        case 'htm':
          query = `
            SELECT id, app_timestamp as timestamp, 
            'htm' as type,
            json_object('temperature', temperature) as data
            FROM htm_packets
            ORDER BY app_timestamp DESC
            LIMIT 100
          `;
          break;
        default:
          return [];
      }
      
      try {
        // getAllAsync returns the array of rows directly
        const resultRows = await db.getAllAsync<any>(query);
        
        console.log(`[LogsScreen] Raw result for ${type}:`, JSON.stringify(resultRows).substring(0, 200) + '...'); // Log first part to avoid huge logs
        console.log(`[LogsScreen] Result type: ${typeof resultRows}, is array: ${Array.isArray(resultRows)}, length: ${Array.isArray(resultRows) ? resultRows.length : 'N/A'}`);
        
        // Check if resultRows is an array and has items
        if (Array.isArray(resultRows) && resultRows.length > 0) {
          console.log(`[LogsScreen] Found ${resultRows.length} rows for ${type} logs.`);
          return resultRows.map((row: any) => ({
            id: row.id,
            // Ensure timestamp exists, fallback if necessary
            timestamp: row.timestamp ?? row.app_timestamp ?? row.device_timestamp ?? new Date().toISOString(),
            type: row.type,
            data: row.data // Assuming 'data' is correctly formed by the JSON_OBJECT function
          }));
        } else {
          console.log(`[LogsScreen] No rows found or invalid result for ${type} logs.`);
          return [];
        }
      } catch (queryError) {
        console.error(`Error executing query for ${type} logs:`, queryError);
        return [];
      }
    } catch (err) {
      console.error(`Error getting database for ${type} logs:`, err);
      throw err;
    }
  };

  const onRefresh = async () => {
    setRefreshing(true);
    await fetchLogs();
  };

  const filterLogs = (type: string) => {
    setActiveTab(type);
    if (type === 'all') {
      setFilteredLogs(logs);
    } else {
      setFilteredLogs(logs.filter(log => log.type === type));
    }
  };

  useEffect(() => {
    fetchLogs();
  }, []);

  const formatLogData = (data: string, type: string) => {
    try {
      const parsedData = typeof data === 'string' ? JSON.parse(data) : data;
      
      switch (type) {
        case 'motion':
          return `Accel16(x,y,z): ${parsedData.accel16_x}, ${parsedData.accel16_y}, ${parsedData.accel16_z}\n` +
                 `Accel200(x,y,z): ${parsedData.accel200_x}, ${parsedData.accel200_y}, ${parsedData.accel200_z}\n` +
                 `Gyro(x,y,z): ${parsedData.gyro_x}, ${parsedData.gyro_y}, ${parsedData.gyro_z}\n` +
                 `Mag(x,y,z): ${parsedData.mag_x}, ${parsedData.mag_y}, ${parsedData.mag_z}\n` +
                 `Bite(L/R): ${parsedData.bite_l}, ${parsedData.bite_r}`;
        case 'fsr':
          return `Bite Force (L/R): ${parsedData.left_bite}, ${parsedData.right_bite}`;
        case 'hrm':
          return `Heart rate: ${parsedData.heart_rate} BPM`;
        case 'htm':
          return `Temperature: ${parsedData.temperature}C`;
        default:
          return JSON.stringify(parsedData, null, 2);
      }
    } catch (err) {
      console.error(`Error formatting log data: ${err}`);
      return String(data);
    }
  };

  const renderLogItem = (log: LogItem) => {
    const formattedData = formatLogData(log.data, log.type);
    
    // Parse timestamp correctly based on format:
    // If it's just a number that represents seconds, multiply by 1000
    // Otherwise, assume it's already milliseconds
    let timestampMs;
    if (typeof log.timestamp === 'string') {
      const parsedTimestamp = parseInt(log.timestamp, 10);
      // Check if this looks like a seconds-based epoch (10 digits) or millisecond epoch (13 digits)
      timestampMs = parsedTimestamp < 10000000000 
        ? parsedTimestamp * 1000  // Convert seconds to milliseconds
        : parsedTimestamp;        // Already milliseconds
    } else {
      timestampMs = log.timestamp;
    }
    
    const logDate = new Date(timestampMs);
    const formattedTime = logDate.toLocaleTimeString();
    const formattedDate = logDate.toLocaleDateString();
    
    // Check if this is a recent entry (within the last minute)
    const isRecent = Date.now() - timestampMs < 60000; // 60 seconds
    
    return (
      <View key={`${log.type}_${log.id}`} style={[
        styles.logItem, 
        isRecent && styles.recentLogItem
      ]}>
        <View style={styles.logHeader}>
          <Text style={styles.logType}>
            {log.type.toUpperCase()}
            {isRecent && " (NEW)"}
          </Text>
          <Text style={styles.logTime}>{formattedDate} {formattedTime}</Text>
        </View>
        <Text style={styles.logData}>{formattedData}</Text>
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container} edges={["top"]}>
      <Stack.Screen
        options={{
          title: "Database Logs",
          headerStyle: { backgroundColor: '#f5f5f5' },
        }}
      />
      
      <View style={styles.tabContainer}>
        {['all', 'motion', 'fsr', 'hrm', 'htm'].map((tab) => (
          <TouchableOpacity
            key={tab}
            style={[styles.tabButton, activeTab === tab && styles.activeTab]}
            onPress={() => filterLogs(tab)}
          >
            <Text style={[styles.tabText, activeTab === tab && styles.activeTabText]}>
              {tab === 'all' ? 'All' : tab.toUpperCase()}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
      
      <ScrollView
        style={styles.scrollView}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {loading && !refreshing ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#0000ff" />
            <Text style={styles.loadingText}>Loading logs...</Text>
          </View>
        ) : error ? (
          <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{error}</Text>
            <TouchableOpacity style={styles.retryButton} onPress={fetchLogs}>
              <Text style={styles.retryButtonText}>Retry</Text>
            </TouchableOpacity>
          </View>
        ) : filteredLogs.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>No logs found</Text>
            <Text style={styles.emptySubtext}>
              {activeTab === 'all' 
                ? 'No data has been recorded in the database yet.' 
                : `No ${activeTab} logs have been recorded.`}
            </Text>
          </View>
        ) : (
          filteredLogs.map(renderLogItem)
        )}
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
  },
  logItem: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 12,
    marginHorizontal: 16,
    marginVertical: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.5,
    elevation: 2,
  },
  recentLogItem: {
    backgroundColor: '#e6f7ff', // Light blue to highlight new entries
    borderLeftWidth: 4,
    borderLeftColor: '#0066cc',
  },
  logHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  logType: {
    fontWeight: 'bold',
    color: '#0066cc',
  },
  logTime: {
    color: '#666',
    fontSize: 12,
  },
  logData: {
    fontSize: 14,
    lineHeight: 20,
  },
  errorContainer: {
    padding: 16,
    alignItems: 'center',
  },
  errorText: {
    color: 'red',
    marginBottom: 16,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: '#0066cc',
    padding: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  loadingContainer: {
    padding: 24,
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 8,
    color: '#666',
  },
  emptyContainer: {
    padding: 24,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  emptySubtext: {
    color: '#666',
    textAlign: 'center',
  },
  tabContainer: {
    flexDirection: 'row',
    paddingHorizontal: 8,
    marginBottom: 8,
    backgroundColor: 'white',
  },
  tabButton: {
    paddingVertical: 12,
    paddingHorizontal: 8,
    flex: 1,
    alignItems: 'center',
  },
  tabText: {
    color: '#666',
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: '#0066cc',
  },
  activeTabText: {
    color: '#0066cc',
    fontWeight: 'bold',
  },
}); 

================================================================================
File: app/screens/TestDataScreen.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, ActivityIndicator, Alert, TextInput, FlatList } from 'react-native';
import { useRouter } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { MOUTHGUARD_DB_NAME, COLORS } from '../../src/constants';
import { DatabaseManager } from '../../src/DatabaseManager';
import { BluetoothService } from '../../src/services/BluetoothService';
import {
  SAMPLE_ATHLETES,
  SAMPLE_SENSOR_READINGS,
  SAMPLE_IMPACT_EVENTS,
  SAMPLE_SESSIONS,
  SAMPLE_SESSION_ATHLETES,
  SAMPLE_CALIBRATION_DATA,
  DEVICE_ID_SIM,
  BULK_SIMULATED_MOTION,
  BULK_SIMULATED_FSR,
  SIMULATED_MOTION_PACKET,
  SIMULATED_FSR_PACKET,
  SIMULATED_HRM_DATA,
  SIMULATED_HTM_DATA,
} from '../../src/constants';
import { SensorDataRepository } from '../../src/repositories/SensorDataRepository';
import LineChart from '../components/charts/LineChart';
import { useSensorDataRepository } from '../../src/providers/AppProvider';
import { MotionPacket, FSRPacket, HRMPacket, HTMPacket } from '../../src/types';

// Test data generation utilities
const TEST_DURATIONS = [ 123, 456, 789, 1234 ]; // Example durations in ms
const TIME_OFFSETS = [ 0, 2, 6, 24 ];

// Define interfaces for our data types
interface Athlete {
  id: string;
  name: string;
  team: string;
  position: string;
  height: number;
  weight: number;
  deviceId?: string;
  createdAt: number;
}

interface ImpactEvent {
  id: string;
  deviceId: string;
  athleteId: string;
  timestamp: number;
  magnitude: number;
  duration: number;
  severity: string;
  location: string;
  createdAt: number;
}

// Generate test data for a period of time
const generateTestDataForPeriod = async (sensorDataRepository: SensorDataRepository, deviceId: string, days: number = 7) => {
  const now = Date.now();
  const millisecondsPerDay = 24 * 60 * 60 * 1000;
  const dataPoints = days * 24; // 24 data points per day (hourly)
  const results = [];
  
  for (let i = 0; i < dataPoints; i++) {
    // Generate timestamps going back 'days' days up to now
    const timestamp = Math.floor((now - (millisecondsPerDay * days) + (millisecondsPerDay * i / 24)) / 1000);
    
    try {
      // Generate motion data
      const motionPacket: MotionPacket = {
        ...SIMULATED_MOTION_PACKET,
        gyro: [Math.random()*20-10, Math.random()*20-10, Math.random()*20-10].map(n=>Math.round(n)) as [number,number,number],
        accel16: [Math.random()*200-100, Math.random()*200-100, 900 + Math.random()*200].map(n=>Math.round(n)) as [number,number,number],
        timestamp: timestamp,
      };
      await sensorDataRepository.recordMotionPacket(deviceId, motionPacket);
      
      // Generate FSR data
      const fsrPacket: FSRPacket = {
        ...SIMULATED_FSR_PACKET,
        left_bite: 400 + Math.round(Math.random()*200),
        right_bite: 400 + Math.round(Math.random()*200),
        timestamp: timestamp,
      };
      await sensorDataRepository.recordFSRPacket(deviceId, fsrPacket);
      
      // Generate HRM data (every 6 hours)
      if (i % 6 === 0) {
        const hrmPacket: HRMPacket = {
          ...SIMULATED_HRM_DATA,
          heartRate: 60 + Math.round(Math.random()*40),
          appTimestamp: now - (millisecondsPerDay * days) + (millisecondsPerDay * i / 24),
        };
        await sensorDataRepository.recordHRMPacket(deviceId, hrmPacket);
      }
      
      // Generate HTM data (every 12 hours)
      if (i % 12 === 0) {
        const htmPacket: HTMPacket = {
          ...SIMULATED_HTM_DATA,
          temperature: 97.0 + Math.random() * 3,
          appTimestamp: now - (millisecondsPerDay * days) + (millisecondsPerDay * i / 24),
        };
        await sensorDataRepository.recordHTMPacket(deviceId, htmPacket);
      }
    } catch (e) {
      console.error("Error generating test data:", e);
    }
  }
  
  return `Generated ${dataPoints} hours of test data spanning ${days} days`;
};

export default function TestDataScreen() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<string | null>(null);
  const [customDeviceId, setCustomDeviceId] = useState('');
  const [customMagnitude, setCustomMagnitude] = useState('');
  const [activeTab, setActiveTab] = useState<'inject' | 'manual'>('inject');
  const [selectedAthleteId, setSelectedAthleteId] = useState<string | null>(null);
  const [selectedImpactId, setSelectedImpactId] = useState<string | null>(null);

  // Get the DatabaseManager instance on component mount
  useEffect(() => {
    const initDatabase = async () => {
      try {
        await DatabaseManager.getInstance().getDatabase(MOUTHGUARD_DB_NAME);
        console.log('[TestDataScreen] Successfully connected to database');
      } catch (error) {
        console.error('[TestDataScreen] Database initialization error:', error);
      }
    };
    
    initDatabase();
  }, []);

  // Get repository using the custom hook
  const sensorDataRepository = useSensorDataRepository();

  // --- Bulk Data Injection ---
  const injectBulkTestData = async () => {
    setLoading(true);
    setResult(null);
    let successCount = 0;
    let errorCount = 0;
    const results = [];

    try {
      console.log('[TestDataScreen] Injecting bulk simulated data...');

      // Inject Motion Packets
      results.push("Injecting Motion Packets...");
      for (const packet of BULK_SIMULATED_MOTION) {
        try {
          await sensorDataRepository.recordMotionPacket(DEVICE_ID_SIM, packet);
          successCount++;
        } catch (e) { errorCount++; console.error("Motion inject error:", e); }
      }
      results.push(`  -> ${BULK_SIMULATED_MOTION.length} motion packets processed.`);

      // Inject FSR Packets
      results.push("Injecting FSR Packets...");
      for (const packet of BULK_SIMULATED_FSR) {
         try {
          await sensorDataRepository.recordFSRPacket(DEVICE_ID_SIM, packet);
          successCount++;
        } catch (e) { errorCount++; console.error("FSR inject error:", e); }
      }
       results.push(`  -> ${BULK_SIMULATED_FSR.length} FSR packets processed.`);

       // Inject Single HRM/HTM for example
       results.push("Injecting Sample HRM/HTM...");
       try {
          await sensorDataRepository.recordHRMPacket(DEVICE_ID_SIM, SIMULATED_HRM_DATA);
          successCount++;
        } catch (e) { errorCount++; console.error("HRM inject error:", e); }
       try {
          await sensorDataRepository.recordHTMPacket(DEVICE_ID_SIM, SIMULATED_HTM_DATA);
          successCount++;
        } catch (e) { errorCount++; console.error("HTM inject error:", e); }
       results.push(`  -> 1 HRM, 1 HTM packet processed.`);


      setResult(`Bulk Injection Complete:\n${results.join('\n')}\nSuccess: ${successCount}, Errors: ${errorCount}`);
      console.log('[TestDataScreen] Bulk data injection finished.');

    } catch (error) {
      console.error('[TestDataScreen] Error injecting bulk test data:', error);
      setResult(`Bulk Injection Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  // --- Manual Single Data Entry ---
  const addSinglePacket = async (type: 'motion' | 'fsr' | 'hrm' | 'htm') => {
    setLoading(true);
    setResult(null);
    const currentDeviceTime = () => Math.floor(Date.now() / 1000);

    try {
      let packetInfo = "";
      switch (type) {
        case 'motion':
          const motionPacket: MotionPacket = {
            ...SIMULATED_MOTION_PACKET, // Use defaults
            // Randomize slightly for variety
            gyro: [Math.random()*20-10, Math.random()*20-10, Math.random()*20-10].map(n=>Math.round(n)) as [number,number,number],
            accel16: [Math.random()*200-100, Math.random()*200-100, 900 + Math.random()*200].map(n=>Math.round(n)) as [number,number,number],
            timestamp: currentDeviceTime(),
          };
          await sensorDataRepository.recordMotionPacket(DEVICE_ID_SIM, motionPacket);
          packetInfo = `Motion Packet (Timestamp: ${motionPacket.timestamp})`;
          break;
        case 'fsr':
           const fsrPacket: FSRPacket = {
             ...SIMULATED_FSR_PACKET, // Use defaults
             left_bite: 400 + Math.round(Math.random()*200),
             right_bite: 400 + Math.round(Math.random()*200),
             timestamp: currentDeviceTime(),
           };
          await sensorDataRepository.recordFSRPacket(DEVICE_ID_SIM, fsrPacket);
          packetInfo = `FSR Packet (Timestamp: ${fsrPacket.timestamp})`;
          break;
        case 'hrm':
           const hrmPacket: HRMPacket = {
               ...SIMULATED_HRM_DATA,
               heartRate: 60 + Math.round(Math.random()*40),
               appTimestamp: Date.now(),
           };
          await sensorDataRepository.recordHRMPacket(DEVICE_ID_SIM, hrmPacket);
          packetInfo = `HRM Packet (Rate: ${hrmPacket.heartRate})`;
          break;
        case 'htm':
           const htmPacket: HTMPacket = {
               ...SIMULATED_HTM_DATA,
               temperature: 97.0 + Math.random() * 3, // Random temp F
               appTimestamp: Date.now(),
           };
          await sensorDataRepository.recordHTMPacket(DEVICE_ID_SIM, htmPacket);
           packetInfo = `HTM Packet (Temp: ${htmPacket.temperature.toFixed(1)}F)`;
          break;
      }
      setResult(`Successfully added single ${packetInfo}`);
      console.log(`[TestDataScreen] Added single ${type} packet.`);

    } catch (error) {
      console.error(`[TestDataScreen] Error adding single ${type} packet:`, error);
      setResult(`Error adding ${type} packet: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  // Navigate to Logs screen
  const navigateToLogs = () => {
    router.push('/screens/logs');
  };

  // Get accelerometer data for the selected athlete
  const getAccelerometerData = () => {
    if (!selectedAthleteId) return [];
    
    const athlete = SAMPLE_ATHLETES.find(a => (a as any).id === selectedAthleteId);
    if (!athlete || !(athlete as any).deviceId) return [];
    
    const deviceId = (athlete as any).deviceId;
    const accelerometerReadings = SAMPLE_SENSOR_READINGS
      .find(group => group.table === 'accelerometer_data')?.data || [];
    
    // Use type assertion to handle mixed types in the data
    return (accelerometerReadings as any[])
      .filter(reading => 
        reading.deviceId === deviceId && 
        'x' in reading && 'y' in reading && 'z' in reading
      )
      .map(reading => {
        // Calculate magnitude
        const x = reading.x || 0;
        const y = reading.y || 0;
        const z = reading.z || 0;
        const magnitude = Math.sqrt(x*x + y*y + z*z);
        return { ...reading, magnitude };
      });
  };

  // Get impact details for the selected impact
  const getSelectedImpactDetails = () => {
    if (!selectedImpactId) return null;
    
    const impact = (SAMPLE_IMPACT_EVENTS as any[]).find(i => i.id === selectedImpactId);
    if (!impact) return null;
    
    const athlete = (SAMPLE_ATHLETES as any[]).find(a => a.id === impact.athleteId);
    
    return {
      ...impact,
      athleteName: athlete?.name || 'Unknown'
    };
  };

  // Render athlete item in the list
  const renderAthleteItem = ({ item }: { item: Athlete }) => {
    const isSelected = selectedAthleteId === item.id;
    
    return (
      <TouchableOpacity 
        style={[styles.dataItem, isSelected && styles.selectedDataItem]}
        onPress={() => setSelectedAthleteId(isSelected ? null : item.id)}
      >
        <View style={styles.dataItemIcon}>
          <MaterialCommunityIcons 
            name="account" 
            size={20} 
            color={COLORS.primary} 
          />
        </View>
        <View style={styles.dataItemInfo}>
          <Text style={styles.dataItemTitle}>{item.name}</Text>
          <Text style={styles.dataItemSubtitle}>
            {item.team}  {item.position}
            {item.deviceId ? `  Device: ${item.deviceId}` : '  No Device'}
          </Text>
        </View>
        {isSelected && (
          <MaterialCommunityIcons 
            name="check-circle" 
            size={20} 
            color={COLORS.primary} 
            style={styles.selectedIcon}
          />
        )}
      </TouchableOpacity>
    );
  };

  // Render impact event item in the list
  const renderImpactItem = ({ item }: { item: ImpactEvent }) => {
    const isSelected = selectedImpactId === item.id;
    const athlete = SAMPLE_ATHLETES.find(a => a.id === item.athleteId);
    
    return (
      <TouchableOpacity 
        style={[styles.dataItem, isSelected && styles.selectedDataItem]}
        onPress={() => setSelectedImpactId(isSelected ? null : item.id)}
      >
        <View style={[styles.impactSeverity, { backgroundColor: getSeverityColor(item.severity) }]} />
        <View style={styles.dataItemInfo}>
          <Text style={styles.dataItemTitle}>{item.magnitude.toFixed(1)}g Impact</Text>
          <Text style={styles.dataItemSubtitle}>
            {athlete?.name || 'Unknown'}  {formatDate(item.timestamp)}
          </Text>
        </View>
        {isSelected && (
          <MaterialCommunityIcons 
            name="check-circle" 
            size={20} 
            color={COLORS.primary} 
            style={styles.selectedIcon}
          />
        )}
      </TouchableOpacity>
    );
  };

  // Prepare data for charts based on selected athlete or impact
  const prepareChartData = () => {
    if (selectedAthleteId) {
      // Show athlete's sensor data
      const accelerometerData = getAccelerometerData();
      
      if (accelerometerData.length === 0) {
        return { labels: [], data: [] };
      }
      
      // Get magnitudes for chart
      const magnitudes = accelerometerData
        .filter(reading => 'x' in reading && 'y' in reading && 'z' in reading)
        .map(reading => {
          if ('magnitude' in reading) {
            return reading.magnitude;
          } 
          if ('x' in reading && 'y' in reading && 'z' in reading) {
            return Math.sqrt(
              Math.pow(reading.x || 0, 2) + 
              Math.pow(reading.y || 0, 2) + 
              Math.pow(reading.z || 0, 2)
            );
          }
          return 0;
        });
      
      // Create sequential labels
      const labels = accelerometerData.map((_, index) => `${index + 1}`);
      
      return { labels, data: magnitudes };
    } 
    else if (selectedImpactId) {
      // Show impact data
      const impact = getSelectedImpactDetails();
      if (!impact) {
        return { labels: [], data: [] };
      }
      
      // For an impact, we generate a bell curve to simulate the impact waveform
      const pointCount = 20;
      const peakIndex = Math.floor(pointCount / 2);
      const data = Array(pointCount).fill(0).map((_, i) => {
        const distance = Math.abs(i - peakIndex);
        const falloff = Math.exp(-(distance * distance) / 8);
        return impact.magnitude * falloff;
      });
      
      const labels = Array(pointCount).fill(0).map((_, i) => `${i}`);
      
      return { labels, data };
    }
    
    // Default empty data
    return { labels: [], data: [] };
  };

  // Render content based on active tab
  const renderTabContent = () => {
    switch (activeTab) {
      case 'inject':
        return (
          <View>
            {/* Bulk Data Injection Section */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Inject Simulated Data</Text>
              <Text style={styles.sectionDescription}>
                Inject simulated packet data (Motion, FSR, HRM, HTM) into the database based on `constants.ts`.
              </Text>
              <TouchableOpacity
                style={[styles.actionButton, {backgroundColor: COLORS.info}]}
                onPress={injectBulkTestData}
                disabled={loading}
              >
                <MaterialCommunityIcons name="database-import-outline" size={20} color="#fff" style={styles.buttonIcon} />
                <Text style={styles.buttonText}>
                  {loading ? 'Injecting Data...' : 'Inject Bulk Simulated Data'}
                </Text>
                {loading && <ActivityIndicator color="#fff" style={{ marginLeft: 10 }} />}
              </TouchableOpacity>
              
              <TouchableOpacity
                style={[styles.actionButton, {backgroundColor: COLORS.success, marginTop: 10}]}
                onPress={async () => {
                  setLoading(true);
                  setResult(null);
                  try {
                    const result = await generateTestDataForPeriod(sensorDataRepository, DEVICE_ID_SIM, 7);
                    setResult(`Test Data Generation Complete:\n${result}`);
                  } catch (error) {
                    console.error('[TestDataScreen] Error generating test data:', error);
                    setResult(`Error generating test data: ${error instanceof Error ? error.message : 'Unknown error'}`);
                  } finally {
                    setLoading(false);
                  }
                }}
                disabled={loading}
              >
                <MaterialCommunityIcons name="calendar-clock" size={20} color="#fff" style={styles.buttonIcon} />
                <Text style={styles.buttonText}>
                  {loading ? 'Generating Data...' : 'Generate 1-Week Test Data'}
                </Text>
                {loading && <ActivityIndicator color="#fff" style={{ marginLeft: 10 }} />}
              </TouchableOpacity>
              
              <TouchableOpacity
                style={[styles.actionButton, {backgroundColor: COLORS.error, marginTop: 10}]}
                onPress={async () => {
                  Alert.alert(
                    "Generate Test Data",
                    "How many days of test data would you like to generate?",
                    [
                      {
                        text: "Cancel",
                        style: "cancel"
                      },
                      {
                        text: "1 Day",
                        onPress: async () => {
                          setLoading(true);
                          setResult(null);
                          try {
                            const result = await generateTestDataForPeriod(sensorDataRepository, DEVICE_ID_SIM, 1);
                            setResult(`Test Data Generation Complete:\n${result}`);
                          } catch (error) {
                            console.error('[TestDataScreen] Error generating test data:', error);
                            setResult(`Error generating test data: ${error instanceof Error ? error.message : 'Unknown error'}`);
                          } finally {
                            setLoading(false);
                          }
                        }
                      },
                      {
                        text: "3 Days",
                        onPress: async () => {
                          setLoading(true);
                          setResult(null);
                          try {
                            const result = await generateTestDataForPeriod(sensorDataRepository, DEVICE_ID_SIM, 3);
                            setResult(`Test Data Generation Complete:\n${result}`);
                          } catch (error) {
                            console.error('[TestDataScreen] Error generating test data:', error);
                            setResult(`Error generating test data: ${error instanceof Error ? error.message : 'Unknown error'}`);
                          } finally {
                            setLoading(false);
                          }
                        }
                      },
                      {
                        text: "7 Days",
                        onPress: async () => {
                          setLoading(true);
                          setResult(null);
                          try {
                            const result = await generateTestDataForPeriod(sensorDataRepository, DEVICE_ID_SIM, 7);
                            setResult(`Test Data Generation Complete:\n${result}`);
                          } catch (error) {
                            console.error('[TestDataScreen] Error generating test data:', error);
                            setResult(`Error generating test data: ${error instanceof Error ? error.message : 'Unknown error'}`);
                          } finally {
                            setLoading(false);
                          }
                        }
                      },
                      {
                        text: "30 Days",
                        onPress: async () => {
                          setLoading(true);
                          setResult(null);
                          try {
                            const result = await generateTestDataForPeriod(sensorDataRepository, DEVICE_ID_SIM, 30);
                            setResult(`Test Data Generation Complete:\n${result}`);
                          } catch (error) {
                            console.error('[TestDataScreen] Error generating test data:', error);
                            setResult(`Error generating test data: ${error instanceof Error ? error.message : 'Unknown error'}`);
                          } finally {
                            setLoading(false);
                          }
                        }
                      }
                    ]
                  );
                }}
                disabled={loading}
              >
                <MaterialCommunityIcons name="calendar-plus" size={20} color="#fff" style={styles.buttonIcon} />
                <Text style={styles.buttonText}>
                  Custom Data Generation
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        );

      case 'manual':
        return (
          <View>
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Manually Add Single Packet</Text>
              <Text style={styles.sectionDescription}>
                Add a single data packet with the current timestamp and randomized values.
              </Text>
              <TouchableOpacity
                style={[styles.actionButton, {backgroundColor: COLORS.accent2, marginBottom: 10}]}
                onPress={() => addSinglePacket('motion')} disabled={loading}>
                <MaterialCommunityIcons name="axis-arrow" size={18} color="#fff" style={styles.buttonIcon} />
                <Text style={styles.buttonText}>Add Motion Packet</Text>
              </TouchableOpacity>
              <TouchableOpacity
                 style={[styles.actionButton, {backgroundColor: COLORS.accent3, marginBottom: 10}]}
                onPress={() => addSinglePacket('fsr')} disabled={loading}>
                 <MaterialCommunityIcons name="tooth-outline" size={18} color="#fff" style={styles.buttonIcon} />
                <Text style={styles.buttonText}>Add FSR Packet</Text>
              </TouchableOpacity>
              <TouchableOpacity
                 style={[styles.actionButton, {backgroundColor: COLORS.accent4, marginBottom: 10}]}
                onPress={() => addSinglePacket('hrm')} disabled={loading}>
                 <MaterialCommunityIcons name="heart-pulse" size={18} color="#fff" style={styles.buttonIcon} />
                <Text style={styles.buttonText}>Add HRM Packet</Text>
              </TouchableOpacity>
               <TouchableOpacity
                 style={[styles.actionButton, {backgroundColor: COLORS.accent5, marginBottom: 10}]}
                onPress={() => addSinglePacket('htm')} disabled={loading}>
                 <MaterialCommunityIcons name="thermometer" size={18} color="#fff" style={styles.buttonIcon} />
                <Text style={styles.buttonText}>Add HTM Packet</Text>
              </TouchableOpacity>
            </View>
          </View>
        );
      default:
        return null;
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color={COLORS.primary} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Data Simulation</Text>
      </View>

      {/* Tab navigation */}
      <View style={styles.tabBar}>
        <TouchableOpacity
          style={[styles.tabButton, activeTab === 'inject' && styles.activeTabButton]}
          onPress={() => setActiveTab('inject')}>
          <MaterialCommunityIcons name="database-arrow-down" size={18} color={activeTab === 'inject' ? COLORS.primary : COLORS.text.secondary} />
          <Text style={[styles.tabText, activeTab === 'inject' && styles.activeTabText]}>Inject Data</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.tabButton, activeTab === 'manual' && styles.activeTabButton]}
          onPress={() => setActiveTab('manual')}>
          <MaterialCommunityIcons name="plus-box" size={18} color={activeTab === 'manual' ? COLORS.primary : COLORS.text.secondary} />
          <Text style={[styles.tabText, activeTab === 'manual' && styles.activeTabText]}>Manual Add</Text>
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.content}>
        {renderTabContent()}

        {/* Result Display */}
        {result && (
          <View style={styles.resultContainer}>
            <Text style={styles.resultTitle}>Result:</Text>
            <Text style={styles.resultText}>{result}</Text>
          </View>
        )}

        {/* Navigation Section - Keep if needed */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Navigate</Text>
          <TouchableOpacity
            style={[styles.actionButton, { backgroundColor: '#2196F3' }]}
            onPress={() => router.push('/(tabs)/devices')}>
            <Ionicons name="people-outline" size={20} color="#fff" style={styles.buttonIcon} />
            <Text style={styles.buttonText}>Go to Athletes & Devices</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.actionButton, { backgroundColor: '#9C27B0', marginTop: 8 }]}
            onPress={() => router.push('/(tabs)/reportsDetailed')}>
            <Ionicons name="document-text-outline" size={20} color="#fff" style={styles.buttonIcon} />
            <Text style={styles.buttonText}>Go to Detailed Reports</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.actionButton, { backgroundColor: '#4CAF50', marginTop: 8 }]}
            onPress={navigateToLogs}>
            <MaterialCommunityIcons name="clipboard-list-outline" size={20} color="#fff" style={styles.buttonIcon} />
            <Text style={styles.buttonText}>View Data Logs</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

// Helper functions
const getSeverityColor = (severity?: string): string => {
  switch (severity?.toLowerCase()) {
    case 'severe':
      return COLORS.danger;
    case 'moderate':
      return COLORS.warning;
    case 'mild':
      return COLORS.success;
    default:
      return COLORS.primary;
  }
};

const formatDate = (timestamp: number): string => {
  const date = new Date(timestamp);
  return date.toLocaleTimeString(undefined, { 
    hour: '2-digit',
    minute: '2-digit',
    hour12: true 
  });
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.border,
  },
  backButton: {
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  section: {
    marginBottom: 24,
    backgroundColor: COLORS.cardBackground,
    borderRadius: 8,
    padding: 16,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
  },
  sectionDescription: {
    fontSize: 14,
    color: COLORS.text.secondary,
    marginBottom: 16,
    lineHeight: 20,
  },
  actionButton: {
    backgroundColor: COLORS.primary,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  buttonIcon: {
    marginRight: 8,
  },
  buttonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '600',
  },
  resultContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 8,
    padding: 16,
    marginTop: 16,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: COLORS.borderLight,
  },
  resultTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
  },
  resultText: {
    color: COLORS.text.secondary,
    fontSize: 14,
    fontFamily: 'monospace',
  },
  tabBar: {
    flexDirection: 'row',
    backgroundColor: COLORS.cardBackground,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.border,
  },
  tabButton: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
    borderBottomWidth: 3,
    borderBottomColor: 'transparent',
  },
  activeTabButton: {
    borderBottomColor: COLORS.primary,
  },
  tabText: {
    color: COLORS.text.secondary,
    fontSize: 14,
    marginLeft: 6,
  },
  activeTabText: {
    color: COLORS.primary,
    fontWeight: '600',
  },
  // Added styles for list items
  dataItem: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: COLORS.borderLight,
  },
  selectedDataItem: {
    borderColor: COLORS.primary,
    borderWidth: 2,
  },
  dataItemIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(0,84,50,0.1)', // Primary with low opacity
    marginRight: 12,
  },
  dataItemInfo: {
    flex: 1,
  },
  dataItemTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  dataItemSubtitle: {
    fontSize: 13,
    color: COLORS.text.secondary,
    marginTop: 2,
  },
  selectedIcon: {
    marginLeft: 8,
  },
  impactSeverity: {
    width: 4,
    height: 36,
    borderRadius: 2,
    marginRight: 12,
  },
}); 

================================================================================
File: components/charts/WeeklyOverviewChart.tsx
================================================================================

import { Card } from "@/components/Card";
import { StyleSheet, View, Text, Dimensions } from "react-native";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { BarChart } from "react-native-chart-kit";
import { LinearGradient } from "expo-linear-gradient";
import { Datapoint } from "@/src/types";
import { useMemo } from "react";
import { COLORS } from "@/src/constants"; // Import the centralized color palette

const windowWidth = Dimensions.get("window").width;

interface WeeklyOverviewChartProps {
  data: Datapoint[];
  onPress?: () => void;
}

export function WeeklyOverviewChart({ data }: WeeklyOverviewChartProps) {
  // Memoize the chart width calculation
  const chartWidth = useMemo(() => Math.max(windowWidth - 64, 200), [windowWidth]);

  // Base chart config with optimizations
  const baseChartConfig = useMemo(() => ({
    backgroundColor: COLORS.background,
    backgroundGradientFrom: COLORS.background,
    backgroundGradientTo: COLORS.background,
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(0, 84, 50, ${opacity})`, // Primary color converted to rgba
    labelColor: (opacity = 0.8) => `rgba(79, 96, 105, ${opacity})`, // textSecondary
    barPercentage: 0.7,
    useShadowColorFromDataset: false,
    withInnerLines: false,
    withVerticalLabels: true,
    withHorizontalLabels: true,
    withVerticalLines: false,
    withHorizontalLines: true,
    propsForBackgroundLines: {
      stroke: COLORS.borderLight,
      strokeWidth: 1,
    },
    propsForDots: {
      r: "4",
      strokeWidth: "2",
      stroke: COLORS.primary,
    },
    style: {
      borderRadius: 16,
    },
    formatYLabel: (value: string) => Math.round(Number(value)).toString(),
    formatXLabel: (label: string) => label.substring(0, 3),
    segments: 4,
  }), []);

  // Memoize the data transformation
  const chartData = useMemo(() => ({
    labels: data.map((d) => d.label),
    datasets: [{ 
      data: data.map((d) => d.value),
      color: (opacity = 1) => `rgba(0, 84, 50, ${opacity})`, // Primary color converted to rgba
      strokeWidth: 2,
    }]
  }), [data]);

  if (!data?.length) {
    return (
      <Card style={styles.card}>
        <View style={styles.cardHeader}>
          <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
          <Text style={styles.cardTitle}>Weekly Overview</Text>
        </View>
        <View style={styles.chartContainer}>
          <Text style={styles.noDataText}>No data available</Text>
        </View>
      </Card>
    );
  }

  return (
    <Card style={styles.card}>
      <View style={styles.cardHeader}>
        <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
        <Text style={styles.cardTitle}>Weekly Overview</Text>
      </View>
      <Text style={styles.cardDescription}>Compare your usage across different days</Text>
      <View style={styles.chartContainer}>
        <LinearGradient
          colors={[
            `${COLORS.primary}33`, // ~20% opacity 
            `${COLORS.primary}19`, // ~10% opacity
            `${COLORS.background}00` // transparent
          ]}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
          style={styles.chartGradient}
        />
        <BarChart
          data={chartData}
          width={chartWidth}
          height={180}
          chartConfig={baseChartConfig}
          style={styles.chart}
          showValuesOnTopOfBars
          fromZero
          segments={4}
          flatColor={true}
          withCustomBarColorFromData={true}
        />
      </View>
    </Card>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: COLORS.card,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 16,
    padding: 16,
    shadowColor: COLORS.shadow,
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 4,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: COLORS.borderLight,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  cardTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.textPrimary,
    marginLeft: 10,
  },
  cardDescription: {
    fontSize: 15,
    color: COLORS.textSecondary,
    marginTop: 4,
    marginBottom: 16,
    lineHeight: 20,
  },
  chartContainer: {
    marginTop: 16,
    alignItems: "center",
    paddingHorizontal: 8,
    backgroundColor: COLORS.background,
    borderRadius: 16,
    shadowColor: COLORS.shadow,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 2,
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
    backgroundColor: COLORS.background,
    overflow: 'hidden',
  },
  chartGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 16,
  },
  noDataText: {
    color: COLORS.textTertiary,
    fontSize: 16,
    marginVertical: 40,
    fontStyle: 'italic',
  }
}); 

================================================================================
File: components/Leaderboard.tsx
================================================================================

import React from 'react';
import { View, Text, FlatList, StyleSheet } from 'react-native';

interface LeaderboardEntry {
  id: string;
  name: string;
  score: number;
}

interface LeaderboardProps {
  data: LeaderboardEntry[];
  title: string;
}

const Leaderboard: React.FC<LeaderboardProps> = ({ title, data }) => {
  const renderItem = ({ item, index }: { item: LeaderboardEntry; index: number }) => (
    <View style={[styles.row, index === 0 ? styles.topRank : {}]}>
      <Text style={styles.rank}>{index + 1}</Text>
      <Text style={styles.name}>{item.name}</Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
      <FlatList
        data={data.sort((a, b) => b.score - a.score)} // Sort by score in descending order
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        ListEmptyComponent={<Text style={styles.empty}>No entries yet!</Text>}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 16,
    color: '#333',
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    marginVertical: 4,
    backgroundColor: '#fff',
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  topRank: {
    backgroundColor: '#ffd700', // Gold for top rank
  },
  rank: {
    fontSize: 18,
    fontWeight: 'bold',
    width: 40,
    textAlign: 'center',
  },
  name: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginLeft: 8,
  },
  score: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#12a35f',
  },
  empty: {
    textAlign: 'center',
    fontSize: 16,
    color: '#aaa',
    marginTop: 20,
  },
});

export default Leaderboard;

================================================================================
File: context.py
================================================================================

#!/usr/bin/env python3
"""
Context Extractor for React Native/TypeScript Cannabis Recommendation Codebase

This script extracts structured context from a React Native/TypeScript codebase, focusing on:
- React component definitions and props
- Hooks and their usage
- Service classes and methods
- API endpoints and connections
- TypeScript interfaces and types
- State management patterns

Usage:
  python context_extractor.py [output_file]
"""

import os
import re
import sys
import json
import argparse
from typing import List, Dict, Tuple, Any, Optional, Set
from collections import defaultdict
import datetime

# Configuration
DEFAULT_CONFIG = {
    "extensions": [".tsx", ".ts", ".js", ".jsx", ".json"],
    "exclude_dirs": [
        "node_modules", "__tests__", "coverage", "build", "dist", "android", "ios",
        ".expo", ".expo-shared", ".git", ".github", "web-build"
    ],
    "exclude_files": [
        ".test.", ".spec.", ".min.js", ".map", "setup.js",
        ".gitignore", "package-lock.json", ".env"
    ],
    "include_dirs": [
        "app", "src"
    ],
    "max_file_size": 1024 * 1024,  # 1MB
    "max_lines": 15000,  # Target maximum lines for output
    "analyze_performance": False,   # Whether to analyze performance issues
    "analyze_data_flow": False,     # Whether to analyze data flow
    "show_component_tree": False,   # Whether to show component hierarchy tree
    "analyze_react_native": False   # Whether to include React Native specific analysis
}

class CodeContextExtractor:
    """Extracts structured context from a React Native/TypeScript codebase"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.component_props = {}
        self.hooks = []
        self.services = []
        self.api_endpoints = []
        self.interfaces = {}
        self.state_management = []
        self.navigation_routes = []
        self.file_summaries = []
        self.total_lines = 0
        # Add tracking structures
        self.component_hierarchy = defaultdict(set)  # Parent -> Children
        self.hook_usages = defaultdict(set)  # Component -> Hooks used
        self.api_calls = defaultdict(set)  # Component/Hook -> API services called
        self.component_complexity = []  # Track complex components
        self.files = []  # Track all processed files
        self.performance_issues = []  # Track performance issues
        self.react_native_issues = []  # Track React Native specific issues
        self.state_flows = {}  # Track state flows between components
        self.api_flows = {}  # Track API data flows
        self.database_schemas = []  # Track database schemas
        # New tracking properties for enhanced analysis
        self.import_dependencies = []  # Track module dependencies
        self.complex_types = []  # Track complex type relationships
        self.enhanced_api_endpoints = []  # Enhanced API endpoint documentation
        self.prop_flows = []  # Track component prop flows
        self.style_patterns = []  # Track styling patterns
        self.hook_usages_analysis = []  # Enhanced hook usage analysis
        self.enhanced_navigation = []  # Enhanced navigation route analysis
        self.security_patterns = []  # Security pattern analysis
    
    def should_exclude_file(self, file_path: str) -> bool:
        """Check if a file should be excluded based on config"""
        normalized_path = os.path.normpath(file_path)
        
        # Check excluded patterns
        for pattern in self.config["exclude_files"]:
            if pattern in normalized_path:
                return True
        
        # Check file extension        
        ext = os.path.splitext(file_path)[1].lower()
        if ext not in self.config["extensions"]:
            return True
            
        return False

    def should_exclude_dir(self, dir_path: str) -> bool:
        """Check if a directory should be excluded based on config"""
        normalized_path = os.path.normpath(dir_path)
        dir_name = os.path.basename(normalized_path)
        
        # Check if the directory name itself is in the exclude list
        if dir_name in self.config["exclude_dirs"]:
            print(f"Excluding directory (name match): {normalized_path}")
            return True
            
        # Check if the path contains any of the excluded directory patterns
        for exclude_dir in self.config["exclude_dirs"]:
            if exclude_dir in normalized_path:
                print(f"Excluding directory (path match): {normalized_path} - matched: {exclude_dir}")
                return True
        
        # If we have include_dirs, check if this is in it
        if self.config["include_dirs"]:
            for include_dir in self.config["include_dirs"]:
                if include_dir in normalized_path:
                    return False
            # If not in any include_dirs, exclude it
            return True
                
        return False

    def collect_files(self, root_dir: str) -> List[Tuple[str, str]]:
        """Collect all eligible files in the directory"""
        results = []
        print(f"Collecting files from: {root_dir}")
        print(f"Exclusion patterns: {self.config['exclude_dirs']}")
        
        for root, dirs, files in os.walk(root_dir):
            # Process directories
            dirs_before = len(dirs)
            dirs[:] = [d for d in dirs if not self.should_exclude_dir(os.path.join(root, d))]
            if dirs_before > len(dirs):
                print(f"  In {root}: Filtered out {dirs_before - len(dirs)} directories")
            
            for file in files:
                file_path = os.path.join(root, file)
                rel_path = os.path.relpath(file_path, root_dir)
                
                # Check exclusion patterns
                if self.should_exclude_file(rel_path):
                    continue
                    
                # Check file size
                if os.path.getsize(file_path) > self.config["max_file_size"]:
                    continue
                
                # Check if the file is in an excluded directory
                file_dir = os.path.dirname(file_path)
                if self.should_exclude_dir(file_dir):
                    print(f"  Skipping file in excluded directory: {rel_path}")
                    continue
                    
                results.append((file_path, rel_path))
                
        print(f"Collected {len(results)} files for processing")
        return results

    def extract_react_component(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract React component information from file content"""
        components = []
        
        # Match functional components
        func_component_pattern = r'(?:export\s+)?(?:const|function)\s+([A-Z][a-zA-Z0-9_]*)\s*(?:<.*?>)?\s*(?:=\s*(?:\([^)]*\)|[^=]*)\s*=>|[({])'
        func_matches = re.finditer(func_component_pattern, content)
        
        for match in func_matches:
            component_name = match.group(1)
            if component_name.endswith('Provider') or component_name.endswith('Context'):
                continue  # Skip context providers, process them separately
            
            start_pos = match.start()
            
            # Find JSX start position
            jsx_start = content.find('return (', start_pos)
            if jsx_start == -1:
                jsx_start = content.find('return {', start_pos)
            
            # Find component props
            props_match = re.search(r'\(\s*(?:{\s*([^}]*)\s*}|\s*props\s*|\s*([^)]*)\s*)', content[start_pos:start_pos+500])
            props = []
            
            if props_match:
                props_text = props_match.group(1) or props_match.group(2) or ''
                # Parse prop names
                prop_matches = re.finditer(r'(\w+)(?::\s*([^,\s]+))?', props_text)
                props = [{'name': m.group(1), 'type': m.group(2) if m.group(2) else 'any'} for m in prop_matches]
            
            # Extract hooks used
            hook_usages = []
            hook_matches = re.finditer(r'use[A-Z][a-zA-Z0-9]*', content[:jsx_start] if jsx_start != -1 else content)
            for hook_match in hook_matches:
                hook_usages.append(hook_match.group())
                self.hook_usages[component_name].add(hook_match.group())
            
            # Extract API calls
            api_calls = []
            api_patterns = [
                r'([a-zA-Z0-9_]+)\.(?:get|post|put|delete|patch)\(',
                r'fetch\(',
                r'axios\.(?:get|post|put|delete|patch)\(',
                r'api\.(?:[a-zA-Z0-9_]+)\('
            ]
            
            for pattern in api_patterns:
                api_matches = re.finditer(pattern, content)
                for api_match in api_matches:
                    api_calls.append(api_match.group())
                    self.api_calls[component_name].add(api_match.group())
            
            # Calculate complexity based on number of hooks, conditionals, etc.
            complexity = len(hook_usages) + len(api_calls)
            complexity += content.count('if (') + content.count('? ')
            
            component_data = {
                'name': component_name,
                'type': 'functional',
                'file_path': file_path,
                'props': props,
                'hooks_used': hook_usages,
                'api_calls': api_calls,
                'complexity': complexity
            }
            
            # Add performance analysis if enabled
            if self.config.get("analyze_performance", False):
                performance_issues = self.analyze_performance_issues(content, component_name)
                if performance_issues:
                    component_data['performance_issues'] = performance_issues
                    self.performance_issues.append({
                        'component': component_name,
                        'file_path': file_path,
                        'issues': performance_issues
                    })
            
            # Add React Native analysis if enabled
            if self.config.get("analyze_react_native", False):
                rn_issues = self.analyze_react_native_patterns(content, component_name)
                if rn_issues:
                    component_data['react_native_issues'] = rn_issues
                    self.react_native_issues.append({
                        'component': component_name,
                        'file_path': file_path,
                        'issues': rn_issues
                    })
            
            # Add state flow analysis if enabled
            if self.config.get("analyze_data_flow", False):
                state_flows = self.track_state_flow(content, component_name)
                if state_flows:
                    component_data['state_flows'] = state_flows
                    self.state_flows.update(state_flows)
            
            components.append(component_data)
            
            # Track complex components
            if complexity > 10:
                self.component_complexity.append({
                    'name': component_name,
                    'file_path': file_path,
                    'complexity': complexity
                })
            
            # Store props information for reference
            self.component_props[component_name] = props
        
        # Match class components
        class_component_pattern = r'class\s+([A-Z][a-zA-Z0-9_]*)\s+extends\s+(?:React\.)?Component'
        class_matches = re.finditer(class_component_pattern, content)
        
        for match in class_matches:
            component_name = match.group(1)
            start_pos = match.start()
            
            # Find render method
            render_start = content.find('render()', start_pos)
            if render_start == -1:
                render_start = content.find('render () {', start_pos)
            if render_start == -1:
                render_start = content.find('render() {', start_pos)
            
            # Extract API calls
            api_calls = []
            api_patterns = [
                r'([a-zA-Z0-9_]+)\.(?:get|post|put|delete|patch)\(',
                r'fetch\(',
                r'axios\.(?:get|post|put|delete|patch)\(',
                r'api\.(?:[a-zA-Z0-9_]+)\('
            ]
            
            for pattern in api_patterns:
                api_matches = re.finditer(pattern, content)
                for api_match in api_matches:
                    api_calls.append(api_match.group())
                    self.api_calls[component_name].add(api_match.group())
            
            # Calculate complexity
            complexity = len(api_calls)
            complexity += content.count('if (') + content.count('? ')
            complexity += content.count('this.state') + content.count('this.setState')
            
            component_data = {
                'name': component_name,
                'type': 'class',
                'file_path': file_path,
                'api_calls': api_calls,
                'complexity': complexity
            }
            
            # Add performance analysis if enabled
            if self.config.get("analyze_performance", False):
                performance_issues = self.analyze_performance_issues(content, component_name)
                if performance_issues:
                    component_data['performance_issues'] = performance_issues
                    self.performance_issues.append({
                        'component': component_name,
                        'file_path': file_path,
                        'issues': performance_issues
                    })
            
            # Add React Native analysis if enabled
            if self.config.get("analyze_react_native", False):
                rn_issues = self.analyze_react_native_patterns(content, component_name)
                if rn_issues:
                    component_data['react_native_issues'] = rn_issues
                    self.react_native_issues.append({
                        'component': component_name,
                        'file_path': file_path,
                        'issues': rn_issues
                    })
            
            components.append(component_data)
            
            # Track complex components
            if complexity > 10:
                self.component_complexity.append({
                    'name': component_name,
                    'file_path': file_path,
                    'complexity': complexity
                })
        
        return components

    def extract_hooks(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract custom hooks from file content"""
        hooks = []
        
        # Match custom hooks
        hook_pattern = r'(?:export\s+)?(?:const|function)\s+(use[A-Z][a-zA-Z0-9_]*)\s*(?:<.*?>)?\s*(?:=\s*(?:\([^)]*\)|[^=]*)\s*=>|[({])'
        hook_matches = re.finditer(hook_pattern, content)
        
        for match in hook_matches:
            hook_name = match.group(1)
            start_pos = match.start()
            
            # Find hook parameters
            params_match = re.search(r'\(\s*([^)]*)\s*\)', content[start_pos:start_pos+200])
            params = []
            
            if params_match:
                params_text = params_match.group(1)
                # Parse parameter names
                param_matches = re.finditer(r'(\w+)(?::\s*([^,\s]+))?', params_text)
                params = [{'name': m.group(1), 'type': m.group(2) if m.group(2) else 'any'} for m in param_matches]
            
            # Find return type (look for useState, useReducer patterns)
            return_values = []
            
            # Look for useState hooks
            state_hooks = re.finditer(r'const\s+\[\s*(\w+)\s*,\s*set(\w+)\s*\]\s*=\s*useState[<(]', content[start_pos:])
            for state_match in state_hooks:
                state_name = state_match.group(1)
                setter_name = 'set' + state_match.group(2)
                return_values.append(f"[{state_name}, {setter_name}]")
            
            # Look for other React hooks
            hook_usages = []
            hook_matches = re.finditer(r'(use[A-Z][a-zA-Z0-9]*)', content[start_pos:])
            for hook_match in hook_matches:
                if hook_match.group(1) != hook_name:  # Avoid self-reference
                    hook_usages.append(hook_match.group(1))
            
            # Extract API calls
            api_calls = []
            api_patterns = [
                r'([a-zA-Z0-9_]+)\.(?:get|post|put|delete|patch)\(',
                r'fetch\(',
                r'axios\.(?:get|post|put|delete|patch)\(',
                r'api\.(?:[a-zA-Z0-9_]+)\('
            ]
            
            for pattern in api_patterns:
                api_matches = re.finditer(pattern, content[start_pos:])
                for api_match in api_matches:
                    api_calls.append(api_match.group())
            
            hooks.append({
                'name': hook_name,
                'file_path': file_path,
                'params': params,
                'returns': return_values,
                'uses_hooks': hook_usages,
                'api_calls': api_calls
            })
            
            # Add to class hook list
            self.hooks.append({
                'name': hook_name,
                'file_path': file_path,
                'params': params,
                'returns': return_values,
                'uses_hooks': hook_usages,
                'api_calls': api_calls
            })
        
        return hooks

    def extract_services(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract service classes and methods from file content"""
        services = []
        
        # Check if it's a service file by filename pattern
        file_name = os.path.basename(file_path)
        is_service = "Service" in file_name or "/services/" in file_path
        
        if not is_service:
            return services
        
        # Match class definitions
        class_pattern = r'(?:export\s+)?class\s+(\w+)(?:\s+extends\s+(\w+))?'
        class_matches = re.finditer(class_pattern, content)
        
        for match in class_matches:
            service_name = match.group(1)
            parent_class = match.group(2) if match.group(2) else None
            start_pos = match.start()
            
            # Find methods
            methods = []
            method_pattern = r'(?:async\s+)?(\w+)\s*\(([^)]*)\)\s*(?::\s*([^{]+))?\s*{'
            method_matches = re.finditer(method_pattern, content[start_pos:])
            
            for method_match in method_matches:
                method_name = method_match.group(1)
                if method_name in ['constructor', 'render']:
                    continue  # Skip standard methods
                
                params_str = method_match.group(2)
                return_type = method_match.group(3).strip() if method_match.group(3) else None
                
                # Parse params
                params = []
                if params_str:
                    param_matches = re.finditer(r'(\w+)(?::\s*([^,]+))?', params_str)
                    params = [{'name': m.group(1), 'type': m.group(2).strip() if m.group(2) else 'any'} for m in param_matches]
                
                methods.append({
                    'name': method_name,
                    'params': params,
                    'return_type': return_type
                })
            
            # Detect singleton pattern
            is_singleton = 'getInstance' in content and 'private constructor' in content
            
            # Extract API endpoints
            api_endpoints = []
            api_patterns = [
                r'(?:fetch|axios)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]',
                r'(?:get|post|put|delete|patch)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]'
            ]
            
            for pattern in api_patterns:
                endpoint_matches = re.finditer(pattern, content[start_pos:])
                for endpoint_match in endpoint_matches:
                    api_endpoints.append(endpoint_match.group(1))
            
            services.append({
                'name': service_name,
                'file_path': file_path,
                'parent_class': parent_class,
                'is_singleton': is_singleton,
                'methods': methods,
                'api_endpoints': api_endpoints
            })
            
            # Add to class services list
            self.services.append({
                'name': service_name,
                'file_path': file_path,
                'parent_class': parent_class,
                'is_singleton': is_singleton,
                'methods': methods,
                'api_endpoints': api_endpoints
            })
            
            # Add API endpoints to global list
            for endpoint in api_endpoints:
                self.api_endpoints.append({
                    'endpoint': endpoint,
                    'service': service_name,
                    'file_path': file_path
                })
        
        return services

    def extract_types(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract TypeScript interfaces and types"""
        types_info = {
            'interfaces': [],
            'types': [],
            'enums': []
        }
        
        # Extract interfaces
        interface_pattern = r'(?:export\s+)?interface\s+(\w+)(?:<[^>]*>)?\s*(?:extends\s+(\w+)(?:<[^>]*>)?)?\s*{'
        interface_matches = re.finditer(interface_pattern, content)
        
        for match in interface_matches:
            interface_name = match.group(1)
            parent_interface = match.group(2) if match.group(2) else None
            start_pos = match.start()
            
            # Find the end of the interface (closing brace)
            braces_count = 1
            end_pos = content.find('{', start_pos) + 1
            
            while braces_count > 0 and end_pos < len(content):
                if content[end_pos] == '{':
                    braces_count += 1
                elif content[end_pos] == '}':
                    braces_count -= 1
                end_pos += 1
            
            interface_content = content[start_pos:end_pos]
            
            # Extract properties
            properties = []
            property_pattern = r'(\w+)\??\s*:\s*([^;]+);'
            property_matches = re.finditer(property_pattern, interface_content)
            
            for prop_match in property_matches:
                prop_name = prop_match.group(1)
                prop_type = prop_match.group(2).strip()
                
                properties.append({
                    'name': prop_name,
                    'type': prop_type
                })
            
            types_info['interfaces'].append({
                'name': interface_name,
                'file_path': file_path,
                'parent': parent_interface,
                'properties': properties
            })
            
            # Add to global interfaces dict
            self.interfaces[interface_name] = {
                'file_path': file_path,
                'parent': parent_interface,
                'properties': properties
            }
        
        # Extract type aliases
        type_pattern = r'(?:export\s+)?type\s+(\w+)(?:<[^>]*>)?\s*=\s*([^;]+);'
        type_matches = re.finditer(type_pattern, content)
        
        for match in type_matches:
            type_name = match.group(1)
            type_definition = match.group(2).strip()
            
            types_info['types'].append({
                'name': type_name,
                'file_path': file_path,
                'definition': type_definition
            })
        
        # Extract enums
        enum_pattern = r'(?:export\s+)?enum\s+(\w+)\s*{'
        enum_matches = re.finditer(enum_pattern, content)
        
        for match in enum_matches:
            enum_name = match.group(1)
            start_pos = match.start()
            
            # Find the end of the enum (closing brace)
            braces_count = 1
            end_pos = content.find('{', start_pos) + 1
            
            while braces_count > 0 and end_pos < len(content):
                if content[end_pos] == '{':
                    braces_count += 1
                elif content[end_pos] == '}':
                    braces_count -= 1
                end_pos += 1
            
            enum_content = content[start_pos:end_pos]
            
            # Extract values
            values = []
            value_pattern = r'(\w+)(?:\s*=\s*([^,]+))?'
            value_matches = re.finditer(value_pattern, enum_content)
            
            for val_match in value_matches:
                val_name = val_match.group(1)
                if val_name in ['enum', 'export']:
                    continue  # Skip keywords
                
                val_value = val_match.group(2).strip() if val_match.group(2) else None
                
                values.append({
                    'name': val_name,
                    'value': val_value
                })
            
            types_info['enums'].append({
                'name': enum_name,
                'file_path': file_path,
                'values': values
            })
        
        return types_info

    def extract_navigation(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract navigation routes from file content"""
        routes = []
        
        # Check if it's a navigation file
        if not ("navigation" in file_path.lower() or "router" in file_path.lower()):
            return routes
        
        # Look for screen definitions
        screen_patterns = [
            r'<Stack\.Screen\s+name=[\'"]([^\'"]+)[\'"](?:\s+component={([^}]+)})?',
            r'<Tab\.Screen\s+name=[\'"]([^\'"]+)[\'"](?:\s+component={([^}]+)})?',
            r'<Drawer\.Screen\s+name=[\'"]([^\'"]+)[\'"](?:\s+component={([^}]+)})?',
            r'createStackNavigator\(\s*{\s*([^}]+)\s*}\s*\)',
            r'createBottomTabNavigator\(\s*{\s*([^}]+)\s*}\s*\)',
            r'createDrawerNavigator\(\s*{\s*([^}]+)\s*}\s*\)'
        ]
        
        for pattern in screen_patterns:
            matches = re.finditer(pattern, content)
            
            for match in matches:
                if match.group(1):
                    route_name = match.group(1)
                    component = match.group(2) if len(match.groups()) > 1 and match.group(2) else None
                    
                    routes.append({
                        'name': route_name,
                        'component': component,
                        'file_path': file_path
                    })
                else:
                    # For createXNavigator patterns, extract from the object
                    navigator_content = match.group(1)
                    route_matches = re.finditer(r'([A-Za-z0-9_]+)\s*:\s*([A-Za-z0-9_]+)', navigator_content)
                    
                    for route_match in route_matches:
                        route_name = route_match.group(1)
                        component = route_match.group(2)
                        
                        routes.append({
                            'name': route_name,
                            'component': component,
                            'file_path': file_path
                        })
        
        # Add to class navigation routes
        self.navigation_routes.extend(routes)
        
        return routes

    def extract_state_management(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract state management patterns (Redux, Context API, etc.)"""
        state_patterns = []
        
        # Check for Redux
        redux_indicators = ['createStore', 'createSlice', 'useDispatch', 'useSelector', 'combineReducers', 'Provider']
        redux_count = sum(1 for indicator in redux_indicators if indicator in content)
        
        if redux_count >= 2:  # At least 2 indicators suggests Redux usage
            # Extract reducers
            reducer_pattern = r'(?:export\s+)?(?:const|function)\s+(\w+)Reducer\s*='
            reducer_matches = re.finditer(reducer_pattern, content)
            
            for match in reducer_matches:
                reducer_name = match.group(1)
                
                state_patterns.append({
                    'type': 'redux_reducer',
                    'name': f"{reducer_name}Reducer",
                    'file_path': file_path
                })
            
            # Extract slices (Redux Toolkit)
            slice_pattern = r'(?:export\s+)?const\s+(\w+)Slice\s*=\s*createSlice\('
            slice_matches = re.finditer(slice_pattern, content)
            
            for match in slice_matches:
                slice_name = match.group(1)
                
                state_patterns.append({
                    'type': 'redux_slice',
                    'name': f"{slice_name}Slice",
                    'file_path': file_path
                })
            
            # Extract actions
            action_pattern = r'(?:export\s+)?const\s+{\s*([^}]+)\s*}\s*=\s*(\w+)Slice\.actions'
            action_matches = re.finditer(action_pattern, content)
            
            for match in action_matches:
                actions = [a.strip() for a in match.group(1).split(',')]
                slice_name = match.group(2)
                
                for action in actions:
                    state_patterns.append({
                        'type': 'redux_action',
                        'name': action,
                        'slice': slice_name,
                        'file_path': file_path
                    })
        
        # Check for Context API
        if 'createContext' in content:
            # Extract contexts
            context_pattern = r'(?:export\s+)?const\s+(\w+)Context\s*=\s*(?:React\.)?createContext\('
            context_matches = re.finditer(context_pattern, content)
            
            for match in context_matches:
                context_name = match.group(1)
                
                state_patterns.append({
                    'type': 'context',
                    'name': f"{context_name}Context",
                    'file_path': file_path
                })
            
            # Extract providers
            provider_pattern = r'(?:export\s+)?(?:const|function)\s+(\w+)Provider\s*=\s*\(\s*{\s*children\s*}'
            provider_matches = re.finditer(provider_pattern, content)
            
            for match in provider_matches:
                provider_name = match.group(1)
                
                state_patterns.append({
                    'type': 'context_provider',
                    'name': f"{provider_name}Provider",
                    'file_path': file_path
                })
        
        # Add to class state management list
        self.state_management.extend(state_patterns)
        
        return state_patterns

    def build_component_hierarchy(self):
        """Build a tree of component relationships based on JSX usage"""
        hierarchy = {}
        
        for file_path, rel_path in self.files:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
                
            # Extract component imports
            import_matches = re.finditer(r'import\s+{([^}]+)}\s+from', content)
            imported_components = []
            for match in import_matches:
                components = [c.strip() for c in match.group(1).split(',')]
                imported_components.extend(components)
            
            # Find component usages in JSX
            for component in imported_components:
                # Look for <ComponentName patterns
                usage_pattern = r'<\s*' + re.escape(component) + r'\s*[^>]*>'
                if re.search(usage_pattern, content):
                    # Find the parent component
                    for extracted_component in self.extract_react_component(content, file_path):
                        if extracted_component:
                            parent_name = extracted_component['name']
                            if parent_name not in hierarchy:
                                hierarchy[parent_name] = []
                            if component not in hierarchy[parent_name]:
                                hierarchy[parent_name].append(component)
        
        return hierarchy

    def track_state_flow(self, content, component_name):
        """Track state passing between components via props"""
        state_flows = {}
        
        # Find useState declarations
        state_matches = re.finditer(r'const\s+\[\s*(\w+)\s*,\s*set(\w+)\s*\]\s*=\s*useState', content)
        for match in state_matches:
            state_name = match.group(1)
            
            # Find where this state is passed as props
            prop_pattern = r'<(\w+)[^>]*\b' + re.escape(state_name) + r'={[^}]*}'
            prop_matches = re.finditer(prop_pattern, content)
            
            for prop_match in prop_matches:
                child_component = prop_match.group(1)
                if component_name not in state_flows:
                    state_flows[component_name] = {}
                
                if child_component not in state_flows[component_name]:
                    state_flows[component_name][child_component] = []
                    
                state_flows[component_name][child_component].append(state_name)
        
        return state_flows
        
    def analyze_performance_issues(self, content, component_name):
        """Identify potential performance issues in React components"""
        issues = []
        
        # Check for missing dependency arrays in useEffect
        effect_missing_deps = re.findall(r'useEffect\(\s*\(\)\s*=>\s*{[^}]+}\s*\)', content)
        if effect_missing_deps:
            issues.append(f"Component '{component_name}' has useEffect without dependency array")
        
        # Check for inline function definitions in JSX
        inline_functions = re.findall(r'<\w+\s+\w+={(?:\(\)\s*=>|function\s*\([^)]*\)\s*{)[^}]+}', content)
        if inline_functions:
            issues.append(f"Component '{component_name}' has {len(inline_functions)} inline functions in JSX")
        
        # Check for missing memo or React.memo usage in exported components
        if not re.search(r'memo\(\s*' + re.escape(component_name), content) and not re.search(r'React\.memo\(\s*' + re.escape(component_name), content):
            # Only flag for components with props that might need memoization
            if re.search(r'const\s+' + re.escape(component_name) + r'\s*=\s*\(\s*{\s*[^}]+}\s*\)', content):
                issues.append(f"Component '{component_name}' could benefit from memoization")
        
        return issues

    def analyze_react_native_patterns(self, content, component_name):
        """Analyze React Native specific patterns and potential issues"""
        issues = []
        
        # Check for inline styles (better to use StyleSheet)
        inline_styles = re.findall(r'style={{\s*[^}]+}}', content)
        if inline_styles:
            issues.append(f"Component '{component_name}' has {len(inline_styles)} inline styles that should use StyleSheet")
        
        # Check for missing platform-specific code
        if 'Platform.OS' not in content and ('SafeAreaView' in content or 'StatusBar' in content):
            issues.append(f"Component '{component_name}' might need platform-specific handling")
        
        # Check for large image resources without resize mode
        if 'Image' in content and 'source' in content and 'resizeMode' not in content:
            issues.append(f"Component '{component_name}' has Image without resizeMode specified")
        
        # Check for potential memory leaks in navigation events
        if ('useEffect' in content and 'navigation' in content and 
            ('addEventListener' in content or 'addListener' in content) and 
            'return' not in content):
            issues.append(f"Component '{component_name}' might have memory leaks from navigation event listeners")
        
        return issues

    def extract_database_schema(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract database schema information from file content"""
        schemas = []
        
        # Extract constant definitions for database names
        db_name_pattern = r'(?:const|let|var|export\s+const)\s+(\w+)_DATABASE_NAME\s*=\s*[\'"]([^\'"]+)[\'"]'
        db_names = {}
        for match in re.finditer(db_name_pattern, content):
            prefix = match.group(1)
            value = match.group(2)
            db_names[prefix] = value
            db_names[f"{prefix}_DATABASE_NAME"] = value  # Store both forms
        
        # Look for CREATE TABLE statements with both literal and template variable names
        # This pattern now handles both "TableName" and "${VARIABLE_NAME}"
        table_pattern = r'CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(?:([`"\w]+)|[$]{([^}]+)})\s*\(([^;]+)\)'
        table_matches = re.finditer(table_pattern, content, re.IGNORECASE | re.DOTALL)
        
        for match in table_matches:
            # Either direct table name or variable reference
            table_name = match.group(1) if match.group(1) else match.group(2)
            columns_def = match.group(3).strip()
            
            # If it's a variable reference, try to resolve it from known DB names
            if not match.group(1) and table_name in db_names:
                table_name = db_names[table_name]
            elif not match.group(1):
                # For template literals we couldn't resolve, use the variable name as table name
                table_name = f"{table_name} (variable)"
            else:
                # For direct table names, clean up quotes
                table_name = table_name.strip('`"')
            
            # Parse columns
            columns = []
            primary_keys = []
            foreign_keys = []
            
            # Split by commas, but handle complex constraints that may contain commas
            column_lines = []
            current_line = ""
            paren_count = 0
            
            for char in columns_def:
                current_line += char
                if char == '(':
                    paren_count += 1
                elif char == ')':
                    paren_count -= 1
                elif char == ',' and paren_count == 0:
                    column_lines.append(current_line.strip().rstrip(','))
                    current_line = ""
            
            if current_line.strip():
                column_lines.append(current_line.strip())
            
            # Process column definitions
            for line in column_lines:
                # Check if this is a column definition or constraint
                if re.match(r'^\s*(?:CONSTRAINT|PRIMARY\s+KEY|FOREIGN\s+KEY|UNIQUE|CHECK)', line, re.IGNORECASE):
                    # Handle constraints
                    if re.search(r'PRIMARY\s+KEY', line, re.IGNORECASE):
                        pk_match = re.search(r'PRIMARY\s+KEY\s*\(([^)]+)\)', line, re.IGNORECASE)
                        if pk_match:
                            pks = [pk.strip('`"') for pk in pk_match.group(1).split(',')]
                            primary_keys.extend(pks)
                    
                    if re.search(r'FOREIGN\s+KEY', line, re.IGNORECASE):
                        fk_match = re.search(r'FOREIGN\s+KEY\s*\(([^)]+)\)\s*REFERENCES\s*([`"\w]+|\${[^}]+})\s*\(([^)]+)\)', line, re.IGNORECASE)
                        if fk_match:
                            fk_cols = [col.strip('`"') for col in fk_match.group(1).split(',')]
                            ref_table = fk_match.group(2).strip('`"')
                            
                            # Handle variable reference in foreign key
                            if ref_table.startswith('${') and ref_table.endswith('}'):
                                var_name = ref_table[2:-1]
                                if var_name in db_names:
                                    ref_table = db_names[var_name]
                                else:
                                    ref_table = f"{var_name} (variable)"
                                    
                            ref_cols = [col.strip('`"') for col in fk_match.group(3).split(',')]
                            
                            for i, fk_col in enumerate(fk_cols):
                                ref_col = ref_cols[i] if i < len(ref_cols) else ref_cols[-1]
                                foreign_keys.append({
                                    'column': fk_col,
                                    'ref_table': ref_table,
                                    'ref_column': ref_col
                                })
                else:
                    # Regular column definition
                    parts = line.split()
                    if len(parts) >= 2:
                        col_name = parts[0].strip('`"')
                        col_type = parts[1].split('(')[0]  # Extract base type without size
                        
                        column = {
                            'name': col_name,
                            'type': col_type
                        }
                        
                        # Check for constraints in column definition
                        if 'NOT NULL' in line.upper():
                            column['nullable'] = False
                        else:
                            column['nullable'] = True
                        
                        if 'PRIMARY KEY' in line.upper():
                            primary_keys.append(col_name)
                        
                        if 'DEFAULT' in line.upper():
                            default_match = re.search(r'DEFAULT\s+([^,\s]+)', line, re.IGNORECASE)
                            if default_match:
                                column['default'] = default_match.group(1)
                        
                        columns.append(column)
            
            # Look for INDEX statements related to this table
            # This pattern now handles both "TableName" and "${VARIABLE_NAME}"
            index_pattern = r'CREATE\s+(?:UNIQUE\s+)?INDEX\s+(?:IF\s+NOT\s+EXISTS\s+)?(\w+)\s+ON\s+(?:([`"\w]+)|[$]{([^}]+)})\s*\(([^)]+)\)'
            index_matches = re.finditer(index_pattern, content, re.IGNORECASE)
            
            indices = []
            for idx_match in index_matches:
                idx_table = idx_match.group(2) if idx_match.group(2) else idx_match.group(3)
                
                # If it's a variable, try to resolve it
                if not idx_match.group(2) and idx_table in db_names:
                    idx_table = db_names[idx_table]
                
                # Check if this index belongs to our table (either by name or by variable)
                if idx_table == table_name or (table_name.endswith(' (variable)') and idx_table == table_name[:-11]):
                    idx_name = idx_match.group(1)
                    idx_columns = [col.strip('`"') for col in idx_match.group(4).split(',')]
                    unique = 'UNIQUE' in idx_match.group(0).upper()
                    
                    indices.append({
                        'name': idx_name,
                        'columns': idx_columns,
                        'unique': unique
                    })
            
            # Extract additional table info from constants file if available
            schema_description = None
            schema_source = file_path
            
            schemas.append({
                'table_name': table_name,
                'columns': columns,
                'primary_keys': primary_keys,
                'foreign_keys': foreign_keys,
                'indices': indices,
                'description': schema_description,
                'file_path': schema_source
            })
        
        return {'schemas': schemas}

    def extract_import_dependencies(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract import statements and build dependency relationships"""
        dependencies = []
        
        # Match import statements
        import_patterns = [
            r'import\s+{([^}]+)}\s+from\s+[\'"]([^\'"]+)[\'"]',  # import { X } from 'Y'
            r'import\s+(\w+)\s+from\s+[\'"]([^\'"]+)[\'"]',      # import X from 'Y'
            r'import\s+[\'"]([^\'"]+)[\'"]'                     # import 'X'
        ]
        
        for pattern in import_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                if len(match.groups()) == 2:
                    # Named imports or default import
                    if '{' in match.group(0):
                        # Named imports
                        imported_items = [item.strip() for item in match.group(1).split(',')]
                        source = match.group(2)
                        
                        for item in imported_items:
                            dependencies.append({
                                'type': 'named',
                                'name': item,
                                'source': source
                            })
                    else:
                        # Default import
                        name = match.group(1)
                        source = match.group(2)
                        
                        dependencies.append({
                            'type': 'default',
                            'name': name,
                            'source': source
                        })
                elif len(match.groups()) == 1:
                    # Side effect import
                    source = match.group(1)
                    
                    dependencies.append({
                        'type': 'side_effect',
                        'source': source
                    })
        
        return {'dependencies': dependencies}

    def extract_complex_types(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract and analyze complex TypeScript types with relationships"""
        type_system = {
            'interfaces': [],
            'types': [],
            'enums': [],
            'type_relationships': []
        }
        
        # Extract interfaces with inheritance
        interface_pattern = r'(?:export\s+)?interface\s+(\w+)(?:<[^>]*>)?\s*(?:extends\s+([^{]+))?\s*{([^}]*)}'
        interface_matches = re.finditer(interface_pattern, content, re.DOTALL)
        
        for match in interface_matches:
            interface_name = match.group(1)
            extends = match.group(2).strip() if match.group(2) else None
            body = match.group(3).strip()
            
            # Extract properties with types
            properties = []
            property_pattern = r'(\w+)(?:\?)?:\s*([^;]+);'
            property_matches = re.finditer(property_pattern, body)
            
            for prop_match in property_matches:
                prop_name = prop_match.group(1)
                prop_type = prop_match.group(2).strip()
                
                properties.append({
                    'name': prop_name,
                    'type': prop_type
                })
            
            interface_info = {
                'name': interface_name,
                'extends': extends,
                'properties': properties,
                'file_path': file_path
            }
            
            type_system['interfaces'].append(interface_info)
            
            # Track inheritance relationships
            if extends:
                parent_interfaces = [p.strip() for p in extends.split(',')]
                for parent in parent_interfaces:
                    type_system['type_relationships'].append({
                        'from': interface_name,
                        'to': parent,
                        'type': 'extends'
                    })
        
        # Extract complex type aliases
        type_pattern = r'(?:export\s+)?type\s+(\w+)(?:<[^>]*>)?\s*=\s*([^;]+);'
        type_matches = re.finditer(type_pattern, content)
        
        for match in type_matches:
            type_name = match.group(1)
            type_definition = match.group(2).strip()
            
            # Analyze union, intersection, mapped types
            type_info = {
                'name': type_name,
                'definition': type_definition,
                'file_path': file_path,
                'category': self.categorize_type(type_definition)
            }
            
            type_system['types'].append(type_info)
            
            # Track type dependencies
            for other_type in self.extract_type_references(type_definition):
                type_system['type_relationships'].append({
                    'from': type_name,
                    'to': other_type,
                    'type': 'references'
                })
        
        return type_system

    def categorize_type(self, type_definition: str) -> str:
        """Categorize the kind of type definition"""
        if '|' in type_definition:
            return 'union'
        elif '&' in type_definition:
            return 'intersection'
        elif type_definition.startswith('Record<') or type_definition.startswith('Partial<'):
            return 'utility'
        elif type_definition.startswith('{') and '=>' in type_definition:
            return 'function'
        elif type_definition.startswith('[') and ']' in type_definition:
            return 'tuple'
        elif '{' in type_definition and '}' in type_definition:
            return 'object'
        else:
            return 'basic'

    def extract_type_references(self, type_definition: str) -> List[str]:
        """Extract referenced types from a type definition"""
        # Basic regex to find type names
        referenced_types = []
        type_refs = re.finditer(r'(?<![\'"`])(\b[A-Z]\w+)\b(?![\'"`])', type_definition)
        
        for match in type_refs:
            referenced_types.append(match.group(1))
        
        return referenced_types

    def extract_api_endpoints(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract API endpoints from service files"""
        endpoints = []
        
        # Match various API call patterns
        patterns = [
            # Fetch pattern
            r'fetch\([\'"]([^\'"]+)[\'"](?:,\s*({[^}]+}))?\)',
            
            # Axios pattern
            r'axios\.(?:get|post|put|delete|patch)\([\'"]([^\'"]+)[\'"](?:,\s*([^,)]+))?\)',
            
            # Custom API client pattern
            r'api\.(?:get|post|put|delete|patch)\([\'"]([^\'"]+)[\'"](?:,\s*([^,)]+))?\)',
            
            # REST method pattern
            r'(?:get|post|put|delete|patch)\([\'"]([^\'"]+)[\'"](?:,\s*([^,)]+))?\)'
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                endpoint = match.group(1)
                
                # Try to extract request body/params if available
                request_data = None
                if len(match.groups()) > 1 and match.group(2):
                    request_data = match.group(2)
                
                # Determine HTTP method
                method = 'GET'  # Default
                if 'post(' in match.group(0).lower():
                    method = 'POST'
                elif 'put(' in match.group(0).lower():
                    method = 'PUT'
                elif 'delete(' in match.group(0).lower():
                    method = 'DELETE'
                elif 'patch(' in match.group(0).lower():
                    method = 'PATCH'
                
                # Try to extract surrounding function name
                function_name = self.extract_containing_function(content, match.start())
                
                # Extract return type if available
                return_type = self.extract_return_type(content, match.start())
                
                endpoints.append({
                    'endpoint': endpoint,
                    'method': method,
                    'request_data': request_data,
                    'function': function_name,
                    'return_type': return_type,
                    'file_path': file_path
                })
        
        return {'api_endpoints': endpoints}
    
    def extract_containing_function(self, content: str, position: int) -> Optional[str]:
        """Extract the name of the function containing the given position"""
        # Find the nearest function declaration before the position
        function_pattern = r'(?:async\s+)?(?:function\s+(\w+)|const\s+(\w+)\s*=\s*(?:async\s+)?\([^)]*\)\s*=>)'
        matches = list(re.finditer(function_pattern, content[:position]))
        
        if matches:
            last_match = matches[-1]
            return last_match.group(1) or last_match.group(2)
        
        return None
    
    def extract_return_type(self, content: str, position: int) -> Optional[str]:
        """Extract return type of the function containing the given position"""
        function_with_return = r'(?:function\s+\w+|const\s+\w+\s*=\s*(?:async\s+)?\([^)]*\))\s*:\s*([^{]+)'
        matches = list(re.finditer(function_with_return, content[:position]))
        
        if matches:
            last_match = matches[-1]
            return last_match.group(1).strip()
        
        return None

    def analyze_prop_flow(self, file_path: str, component_name: str, props: List[Dict]) -> Dict[str, Any]:
        """Analyze how props flow through a component"""
        with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()
        
        prop_usage = {}
        
        for prop in props:
            prop_name = prop['name']
            
            # Find where this prop is used within the component
            usages = []
            
            # Direct usage pattern (props.X or X from destructured props)
            direct_pattern = r'(?:props\.{0}|{0})\b'.format(prop_name)
            direct_matches = re.finditer(direct_pattern, content)
            for match in direct_matches:
                context = self.get_context_snippet(content, match.start(), 60)
                usages.append({
                    'type': 'direct',
                    'context': context
                })
            
            # Passed to child component pattern (<ChildComponent propName={X})
            passed_pattern = r'<(\w+)[^>]*{0}={[^}]+}'.format(prop_name)
            passed_matches = re.finditer(passed_pattern, content)
            for match in passed_matches:
                child_component = match.group(1)
                context = self.get_context_snippet(content, match.start(), 60)
                usages.append({
                    'type': 'passed_to_child',
                    'child_component': child_component,
                    'context': context
                })
            
            # Used in conditional rendering
            conditional_pattern = r'{\s*(?:props\.)?{0}\s*\?.+?:'.format(prop_name)
            conditional_matches = re.finditer(conditional_pattern, content)
            for match in conditional_matches:
                context = self.get_context_snippet(content, match.start(), 60)
                usages.append({
                    'type': 'conditional_rendering',
                    'context': context
                })
            
            prop_usage[prop_name] = usages
        
        return {
            'component': component_name,
            'file_path': file_path,
            'prop_usage': prop_usage
        }
    
    def get_context_snippet(self, content: str, position: int, context_length: int) -> str:
        """Get a snippet of content around the specified position"""
        start = max(0, position - context_length // 2)
        end = min(len(content), position + context_length // 2)
        return content[start:end].replace('\n', ' ').strip()

    def extract_style_patterns(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract and analyze styling patterns"""
        style_info = {
            'style_definitions': [],
            'inline_styles': [],
            'theme_usages': [],
            'style_patterns': []
        }
        
        # Extract StyleSheet.create definitions
        stylesheet_pattern = r'(?:const|let|var)\s+(\w+)\s*=\s*StyleSheet\.create\(\s*({[^}]+})\s*\)'
        stylesheet_matches = re.finditer(stylesheet_pattern, content, re.DOTALL)
        
        for match in stylesheet_matches:
            style_name = match.group(1)
            style_content = match.group(2)
            
            style_info['style_definitions'].append({
                'name': style_name,
                'content': style_content,
                'file_path': file_path
            })
            
            # Parse individual style rules
            style_rule_pattern = r'(\w+):\s*{([^}]+)}'
            style_rule_matches = re.finditer(style_rule_pattern, style_content)
            
            for rule_match in style_rule_matches:
                rule_name = rule_match.group(1)
                rule_content = rule_match.group(2)
                
                style_info['style_patterns'].append({
                    'stylesheet': style_name,
                    'rule_name': rule_name,
                    'rule_content': rule_content
                })
        
        # Extract inline styles
        inline_style_pattern = r'style={({[^}]+})}'
        inline_style_matches = re.finditer(inline_style_pattern, content)
        
        for match in inline_style_matches:
            style_content = match.group(1)
            context = self.get_context_snippet(content, match.start(), 100)
            
            style_info['inline_styles'].append({
                'content': style_content,
                'context': context,
                'file_path': file_path
            })
        
        # Extract theme usages (COLORS, etc.)
        theme_usage_pattern = r'(COLORS\.\w+(?:\.\w+)?)'
        theme_usage_matches = re.finditer(theme_usage_pattern, content)
        
        for match in theme_usage_matches:
            theme_var = match.group(1)
            context = self.get_context_snippet(content, match.start(), 60)
            
            style_info['theme_usages'].append({
                'variable': theme_var,
                'context': context,
                'file_path': file_path
            })
        
        return style_info

    def analyze_hook_usage(self, content: str, file_path: str) -> Dict[str, Any]:
        """Analyze custom hook implementations and usage patterns"""
        hook_analysis = {
            'hook_definitions': [],
            'hook_usages': [],
            'dependencies': [],
            'state_management': []
        }
        
        # Extract hook definitions
        hook_pattern = r'(?:export\s+)?(?:function|const)\s+(use\w+)'
        hook_matches = re.finditer(hook_pattern, content)
        
        for match in hook_matches:
            hook_name = match.group(1)
            hook_start = match.start()
            
            # Find the function end (this is a simplification)
            hook_body = self.extract_function_body(content, hook_start)
            
            # Analyze useState calls
            state_pattern = r'const\s+\[\s*(\w+)\s*,\s*set(\w+)\s*\]\s*=\s*useState(?:<[^>]*>)?\(([^)]*)\)'
            state_matches = re.finditer(state_pattern, hook_body)
            
            states = []
            for state_match in state_matches:
                state_name = state_match.group(1)
                setter_name = 'set' + state_match.group(2)
                initial_value = state_match.group(3).strip()
                
                states.append({
                    'name': state_name,
                    'setter': setter_name,
                    'initial_value': initial_value
                })
            
            # Analyze useEffect calls
            effect_pattern = r'useEffect\(\(\)\s*=>\s*{([^}]+)}\s*,\s*\[([^]]*)\]\)'
            effect_matches = re.finditer(effect_pattern, hook_body)
            
            effects = []
            for effect_match in effect_matches:
                effect_body = effect_match.group(1).strip()
                dependencies = effect_match.group(2).strip()
                
                dep_list = []
                if dependencies:
                    dep_list = [dep.strip() for dep in dependencies.split(',')]
                
                effects.append({
                    'body': effect_body,
                    'dependencies': dep_list
                })
            
            # Analyze useCallback/useMemo calls
            memo_pattern = r'(?:useCallback|useMemo)\((?:\([^)]*\))?\s*=>\s*{([^}]+)}\s*,\s*\[([^]]*)\]\)'
            memo_matches = re.finditer(memo_pattern, hook_body)
            
            memoized = []
            for memo_match in memo_matches:
                memo_body = memo_match.group(1).strip()
                dependencies = memo_match.group(2).strip()
                
                dep_list = []
                if dependencies:
                    dep_list = [dep.strip() for dep in dependencies.split(',')]
                
                is_callback = 'useCallback' in memo_match.group(0)
                
                memoized.append({
                    'type': 'callback' if is_callback else 'memo',
                    'body': memo_body,
                    'dependencies': dep_list
                })
            
            hook_analysis['hook_definitions'].append({
                'name': hook_name,
                'file_path': file_path,
                'states': states,
                'effects': effects,
                'memoized': memoized
            })
        
        # Find hook usages in non-hook functions
        component_pattern = r'(?:export\s+)?(?:function|const)\s+([A-Z]\w+)'
        component_matches = re.finditer(component_pattern, content)
        
        for match in component_matches:
            component_name = match.group(1)
            component_start = match.start()
            
            component_body = self.extract_function_body(content, component_start)
            
            # Find hook calls within this component
            hook_call_pattern = r'(?:const\s+(?:\w+|\[[^\]]+\])\s*=\s*)?(use\w+)\('
            hook_call_matches = re.finditer(hook_call_pattern, component_body)
            
            component_hooks = []
            for hook_call in hook_call_matches:
                hook_name = hook_call.group(1)
                context = self.get_context_snippet(component_body, hook_call.start(), 80)
                
                component_hooks.append({
                    'hook': hook_name,
                    'context': context
                })
            
            if component_hooks:
                hook_analysis['hook_usages'].append({
                    'component': component_name,
                    'file_path': file_path,
                    'hooks': component_hooks
                })
        
        return hook_analysis
    
    def extract_function_body(self, content: str, start_pos: int) -> str:
        """Extract the function body from a given starting position"""
        # Find opening brace
        brace_pos = content.find('{', start_pos)
        if brace_pos == -1:
            return ""
        
        # Track nested braces to find the matching closing brace
        brace_count = 1
        pos = brace_pos + 1
        
        while pos < len(content) and brace_count > 0:
            if content[pos] == '{':
                brace_count += 1
            elif content[pos] == '}':
                brace_count -= 1
            pos += 1
        
        if brace_count == 0:
            return content[brace_pos:pos]
        
        return content[brace_pos:]

    def extract_navigation_routes(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract and analyze navigation routes and screen transitions"""
        navigation_info = {
            'routes': [],
            'screens': [],
            'transitions': [],
            'params': []
        }
        
        # Extract Expo Router route definitions
        router_pattern = r'<(Stack|Tabs|Drawer)\.Screen\s+name=[\'"]([^\'"]+)[\'"]'
        router_matches = re.finditer(router_pattern, content)
        
        for match in router_matches:
            nav_type = match.group(1)
            route_name = match.group(2)
            
            # Try to extract options
            options_start = content.find('options=', match.start())
            options_content = ""
            if options_start > 0 and options_start < match.start() + 200:  # Within reasonable range
                options_end = content.find('/>', options_start)
                if options_end > 0:
                    options_content = content[options_start:options_end]
            
            navigation_info['routes'].append({
                'type': nav_type,
                'name': route_name,
                'options': options_content,
                'file_path': file_path
            })
        
        # Extract useRouter().push calls
        push_pattern = r'(?:router|navigation)\.(?:push|navigate)\(\s*[\'"]([^\'"]+)[\'"](?:\s*,\s*({[^}]+}))?\s*\)'
        push_matches = re.finditer(push_pattern, content)
        
        for match in push_matches:
            route = match.group(1)
            params = match.group(2) if len(match.groups()) > 1 and match.group(2) else None
            
            navigation_info['transitions'].append({
                'to': route,
                'params': params,
                'context': self.get_context_snippet(content, match.start(), 120),
                'file_path': file_path
            })
        
        # Extract Expo Router route params
        param_pattern = r'useLocalSearchParams\(\)'
        param_matches = re.finditer(param_pattern, content)
        
        for match in param_matches:
            # Look for destrucutred params
            destruct_pattern = r'const\s+{([^}]+)}\s*=\s*useLocalSearchParams\(\)'
            destruct_match = re.search(destruct_pattern, content[max(0, match.start()-50):match.start()+50])
            
            if destruct_match:
                params = [param.strip() for param in destruct_match.group(1).split(',')]
                
                navigation_info['params'].append({
                    'params': params,
                    'file_path': file_path
                })
        
        return navigation_info

    def analyze_security_patterns(self, content: str, file_path: str) -> Dict[str, Any]:
        """Analyze security practices and patterns in the code"""
        security_info = {
            'data_validation': [],
            'authentication_checks': [],
            'sensitive_data': [],
            'security_concerns': []
        }
        
        # Look for input validation
        validation_patterns = [
            r'\.validate\(',
            r'\.isValid\(',
            r'validator\.',
            r'new\s+Validator\(',
            r'schema\.validate\('
        ]
        
        for pattern in validation_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                context = self.get_context_snippet(content, match.start(), 100)
                security_info['data_validation'].append({
                    'pattern': pattern,
                    'context': context,
                    'file_path': file_path
                })
        
        # Look for authentication checks
        auth_patterns = [
            r'isAuthenticated\(',
            r'requireAuth',
            r'checkAuth',
            r'AuthContext',
            r'useAuth\(',
            r'isLoggedIn'
        ]
        
        for pattern in auth_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                context = self.get_context_snippet(content, match.start(), 100)
                security_info['authentication_checks'].append({
                    'pattern': pattern,
                    'context': context,
                    'file_path': file_path
                })
        
        # Look for potential sensitive data
        sensitive_patterns = [
            r'password',
            r'token',
            r'secret',
            r'auth',
            r'key',
            r'credentials'
        ]
        
        for pattern in sensitive_patterns:
            matches = re.finditer(r'\b' + pattern + r'\b', content, re.IGNORECASE)
            for match in matches:
                context = self.get_context_snippet(content, match.start(), 100)
                
                # Filter out false positives (in comments, etc.)
                if not (
                    '// ' in context[:context.find(match.group(0))] or
                    '/* ' in context[:context.find(match.group(0))]
                ):
                    security_info['sensitive_data'].append({
                        'term': match.group(0),
                        'context': context,
                        'file_path': file_path
                    })
        
        # Identify security concerns
        concern_patterns = {
            'Hardcoded secrets': r'(?:apiKey|secretKey|password|token)\s*=\s*[\'"][^\'"]+[\'"]',
            'Insecure storage': r'localStorage\.setItem\([\'"](?:token|auth|password)[\'"]',
            'SQL injection risk': r'executeQuery\([\'"]SELECT.+\$\{',
            'XSS risk': r'(?:innerHTML|dangerouslySetInnerHTML)\s*=',
            'Potential CSRF': r'fetch\(.+{credentials:\s*[\'"]include[\'"]'
        }
        
        for concern, pattern in concern_patterns.items():
            matches = re.finditer(pattern, content)
            for match in matches:
                context = self.get_context_snippet(content, match.start(), 100)
                security_info['security_concerns'].append({
                    'issue': concern,
                    'pattern': pattern,
                    'context': context,
                    'file_path': file_path
                })
        
        return security_info

    def track_api_data_flow(self):
        """Track data flow from API calls to component state"""
        api_flows = {}
        
        for file_path, rel_path in self.files:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
            
            # Find API calls that update state
            api_call_pattern = r'(get|post|put|delete|patch|fetch)\([^)]+\)(?:.*?)\.then\(\s*(?:\([^)]*\)\s*=>\s*{\s*(?:set(\w+)|this\.setState\(\s*{\s*(\w+)))'
            api_matches = re.finditer(api_call_pattern, content, re.DOTALL)
            
            for match in api_matches:
                api_method = match.group(1)
                state_updated = match.group(2) or match.group(3)
                
                # Find the component for this file
                for component in self.extract_react_component(content, file_path):
                    if component:
                        component_name = component['name']
                        if component_name not in api_flows:
                            api_flows[component_name] = []
                        
                        api_flows[component_name].append({
                            'api_method': api_method,
                            'state_updated': state_updated
                        })
        
        return api_flows
        
    def analyze_hook_patterns(self):
        """Analyze patterns and potential optimizations in hook usage"""
        hook_patterns = {}
        
        # For each custom hook
        for hook in self.hooks:
            hook_name = hook['name']
            hook_patterns[hook_name] = {
                'usage_count': 0,
                'components': [],
                'potential_optimizations': []
            }
            
            # Find components using this hook
            for component_name, used_hooks in self.hook_usages.items():
                if hook_name in used_hooks:
                    hook_patterns[hook_name]['usage_count'] += 1
                    hook_patterns[hook_name]['components'].append(component_name)
            
            # Check for potential optimizations
            if hook['api_calls'] and not any('useCallback' in h for h in hook['uses_hooks']):
                hook_patterns[hook_name]['potential_optimizations'].append(
                    f"API calls in '{hook_name}' could benefit from useCallback"
                )
                
            if hook['api_calls'] and not any('useMemo' in h for h in hook['uses_hooks']):
                hook_patterns[hook_name]['potential_optimizations'].append(
                    f"Data processing in '{hook_name}' could benefit from useMemo"
                )
        
        return hook_patterns

    def generate_output(self, format='text'):
        """Generate output in different formats (text, json, markdown, html)"""
        if format == 'text':
            return self.generate_text_output()
        elif format == 'json':
            return self.generate_json_output()
        elif format == 'markdown':
            return self.generate_markdown_output()
        elif format == 'html':
            return self.generate_html_output()
        else:
            raise ValueError(f"Unsupported output format: {format}")

    def generate_json_output(self):
        """Generate JSON output"""
        data = {
            'components': self.component_complexity,
            'hooks': self.hooks,
            'services': self.services,
            'api_endpoints': self.api_endpoints,
            'interfaces': self.interfaces,
            'navigation_routes': self.navigation_routes,
            'component_hierarchy': self.build_component_hierarchy()
        }
        return json.dumps(data, indent=2)

    def generate_markdown_output(self):
        """Generate Markdown output"""
        lines = []
        
        # Header
        lines.append("# React Native/TypeScript Codebase Analysis")
        lines.append(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append("")
        
        # Component Hierarchy Section
        lines.append("## Component Hierarchy")
        hierarchy = self.build_component_hierarchy()
        for parent, children in hierarchy.items():
            lines.append(f"### {parent}")
            for child in children:
                lines.append(f"- {child}")
            lines.append("")
        
        # Complex Components Section
        lines.append("## Complex Components")
        sorted_components = sorted(self.component_complexity, key=lambda x: x['complexity'], reverse=True)
        lines.append("| Component | Complexity | File |")
        lines.append("|-----------|------------|------|")
        for component in sorted_components[:20]:
            lines.append(f"| {component['name']} | {component['complexity']} | {os.path.basename(component['file_path'])} |")
        
        # Hooks Section
        lines.append("\n## Custom Hooks")
        for hook in self.hooks:
            lines.append(f"### {hook['name']}")
            if hook['params']:
                lines.append("**Parameters:**")
                for param in hook['params']:
                    lines.append(f"- {param['name']}: {param.get('type', 'any')}")
            if hook['uses_hooks']:
                lines.append("**Uses hooks:**")
                for used_hook in hook['uses_hooks']:
                    lines.append(f"- {used_hook}")
            lines.append("")
        
        # Navigation Routes
        lines.append("## Navigation Routes")
        for route in self.navigation_routes:
            component_str = f"  {route['component']}" if route['component'] else ""
            lines.append(f"- {route['name']}{component_str}")
        
        # API Endpoints
        lines.append("\n## API Endpoints")
        for endpoint in self.api_endpoints:
            lines.append(f"- {endpoint['endpoint']} (from {endpoint['service']})")
        
        # Database Schemas Section
        if self.database_schemas:
            lines.append("\n## Database Schemas")
            for schema in self.database_schemas:
                lines.append(f"\n### Table: {schema['table_name']}")
                
                # Columns
                lines.append("#### Columns")
                for column in schema['columns']:
                    nullable = "NULL" if column.get('nullable', True) else "NOT NULL"
                    default = f" DEFAULT {column['default']}" if 'default' in column else ""
                    pk = " PRIMARY KEY" if column['name'] in schema['primary_keys'] else ""
                    lines.append(f"- {column['name']}: {column['type']} {nullable}{default}{pk}")
                
                # Primary Keys
                if schema['primary_keys']:
                    lines.append("\n#### Primary Keys")
                    for pk in schema['primary_keys']:
                        lines.append(f"- {pk}")
                
                # Foreign Keys
                if schema['foreign_keys']:
                    lines.append("\n#### Foreign Keys")
                    for fk in schema['foreign_keys']:
                        lines.append(f"- {fk['column']}  {fk['ref_table']}.{fk['ref_column']}")
                
                # Indices
                if schema['indices']:
                    lines.append("\n#### Indices")
                    for idx in schema['indices']:
                        unique = "UNIQUE " if idx['unique'] else ""
                        lines.append(f"- {unique}INDEX {idx['name']} ({', '.join(idx['columns'])})")
        
        # Module Dependencies Section
        if self.import_dependencies:
            lines.append("\n## Module Dependencies")
            
            # Group dependencies by source
            by_source = defaultdict(list)
            for dep in self.import_dependencies:
                if 'source' in dep:
                    by_source[dep['source']].append(dep)
            
            # Take the top most imported modules
            top_modules = sorted(by_source.items(), key=lambda x: len(x[1]), reverse=True)[:10]
            
            lines.append("\n### Top Imported Modules")
            lines.append("| Module | Import Count | Types |")
            lines.append("|--------|--------------|-------|")
            
            for source, deps in top_modules:
                named = len([d for d in deps if d.get('type') == 'named'])
                default = len([d for d in deps if d.get('type') == 'default'])
                side_effect = len([d for d in deps if d.get('type') == 'side_effect'])
                
                types = []
                if named > 0:
                    types.append(f"{named} named")
                if default > 0:
                    types.append(f"{default} default")
                if side_effect > 0:
                    types.append(f"{side_effect} side-effect")
                
                lines.append(f"| {source} | {len(deps)} | {', '.join(types)} |")
        
        # Type System Analysis
        if self.complex_types:
            lines.append("\n## Type System Analysis")
            
            # Count interfaces and types
            interfaces = [t for t in self.complex_types if 'properties' in t]
            types = [t for t in self.complex_types if 'definition' in t]
            
            if interfaces:
                lines.append(f"\n### Interfaces ({len(interfaces)} defined)")
                
                # Show top 5 most complex interfaces
                complex_interfaces = sorted(interfaces, key=lambda x: len(x.get('properties', [])), reverse=True)[:5]
                
                lines.append("| Interface | Properties | Extends |")
                lines.append("|-----------|------------|---------|")
                
                for interface in complex_interfaces:
                    extends = interface.get('extends', 'N/A')
                    lines.append(f"| {interface['name']} | {len(interface.get('properties', []))} | {extends} |")
            
            if types:
                lines.append(f"\n### Type Aliases ({len(types)} defined)")
                
                # Count by category
                categories = {}
                for t in types:
                    cat = t.get('category', 'unknown')
                    categories[cat] = categories.get(cat, 0) + 1
                
                lines.append("| Category | Count |")
                lines.append("|----------|-------|")
                
                for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
                    lines.append(f"| {cat} | {count} |")
        
        # Enhanced API Endpoints
        if self.enhanced_api_endpoints:
            lines.append("\n## Enhanced API Documentation")
            
            # Group by method
            by_method = defaultdict(list)
            for endpoint in self.enhanced_api_endpoints:
                by_method[endpoint['method']].append(endpoint)
            
            method_count = {method: len(endpoints) for method, endpoints in by_method.items()}
            
            lines.append("| HTTP Method | Endpoint Count |")
            lines.append("|------------|---------------|")
            
            for method, count in sorted(method_count.items(), key=lambda x: x[1], reverse=True):
                lines.append(f"| {method} | {count} |")
            
            lines.append("\n### Sample Endpoints")
            for method, endpoints in sorted(by_method.items(), key=lambda x: len(x[1]), reverse=True)[:3]:
                lines.append(f"\n#### {method} Endpoints (showing top 3)")
                for endpoint in endpoints[:3]:
                    lines.append(f"- `{endpoint['endpoint']}`")
                    if endpoint.get('function'):
                        lines.append(f"  - Function: `{endpoint['function']}`")
        
        # Security Analysis
        if self.security_patterns:
            lines.append("\n## Security Analysis")
            
            # Group by issue type
            by_issue = defaultdict(list)
            for concern in self.security_patterns:
                by_issue[concern['issue']].append(concern)
            
            lines.append("| Security Concern | Occurrences |")
            lines.append("|------------------|-------------|")
            
            for issue, concerns in sorted(by_issue.items(), key=lambda x: len(x[1]), reverse=True):
                lines.append(f"| {issue} | {len(concerns)} |")
        
        return "\n".join(lines)

    def format_file_summary(self, file_path: str, rel_path: str, file_info: Dict[str, Any]) -> List[str]:
        """Format the summary of a file for the output"""
        ext = os.path.splitext(file_path)[1].lower()
        lines = []
        
        if ext in ['.tsx', '.ts', '.jsx', '.js']:
            # Add imports summary
            if file_info.get('imports'):
                lines.append("# Imports:")
                for import_info in file_info['imports'][:5]:  # Show first 5 imports
                    module = import_info['module']
                    imports = ", ".join(import_info['imports'])
                    lines.append(f"# import {{ {imports} }} from '{module}'")
                
                if len(file_info['imports']) > 5:
                    lines.append(f"# ... and {len(file_info['imports']) - 5} more imports")
                
                lines.append("")
            
            # Add components
            if file_info.get('components'):
                lines.append("# Components:")
                for component in file_info['components']:
                    lines.extend(self.format_component_info(component))
                    lines.append("")
            
            # Add hooks
            if file_info.get('hooks'):
                lines.append("# Hooks:")
                for hook in file_info['hooks']:
                    lines.extend(self.format_hook_info(hook))
                    lines.append("")
            
            # Add services
            if file_info.get('services'):
                lines.append("# Services:")
                for service in file_info['services']:
                    lines.extend(self.format_service_info(service))
                    lines.append("")
            
            # Add types
            if file_info.get('types') and any(file_info['types'].values()):
                lines.append("# Type Definitions:")
                lines.extend(self.format_type_info(file_info['types']))
                lines.append("")
            
            # Add navigation
            if file_info.get('navigation'):
                lines.append("# Navigation:")
                lines.extend(self.format_navigation_info(file_info['navigation']))
                lines.append("")
            
            # Add state management
            if file_info.get('state_management'):
                lines.append("# State Management:")
                lines.extend(self.format_state_management_info(file_info['state_management']))
                lines.append("")
        
        elif ext == '.json':
            # For JSON files, try to parse and summarize
            try:
                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    json_data = json.load(f)
                
                lines.append("# JSON Structure:")
                
                # For package.json, show dependencies
                if file_path.endswith('package.json'):
                    if 'dependencies' in json_data:
                        lines.append("# Dependencies:")
                        for dep, version in list(json_data['dependencies'].items())[:10]:
                            lines.append(f"#   {dep}: {version}")
                        
                        if len(json_data['dependencies']) > 10:
                            lines.append(f"#   ... and {len(json_data['dependencies']) - 10} more dependencies")
                    
                    if 'devDependencies' in json_data:
                        lines.append("# Dev Dependencies:")
                        for dep, version in list(json_data['devDependencies'].items())[:5]:
                            lines.append(f"#   {dep}: {version}")
                        
                        if len(json_data['devDependencies']) > 5:
                            lines.append(f"#   ... and {len(json_data['devDependencies']) - 5} more dev dependencies")
                    
                    if 'scripts' in json_data:
                        lines.append("# Scripts:")
                        for script, command in list(json_data['scripts'].items())[:5]:
                            lines.append(f"#   {script}: {command}")
                        
                        if len(json_data['scripts']) > 5:
                            lines.append(f"#   ... and {len(json_data['scripts']) - 5} more scripts")
                else:
                    # For other JSON files, show top-level keys
                    lines.append("# Top-level keys:")
                    for key in json_data.keys():
                        value_type = type(json_data[key]).__name__
                        lines.append(f"#   {key}: {value_type}")
            
            except json.JSONDecodeError:
                lines.append("# Invalid JSON file")
            
            lines.append("")
        
        else:
            # Basic info for other file types
            lines.append(f"# {ext[1:]} file - detailed extraction not supported")
        
        return lines

    def process_file(self, file_path: str) -> Dict[str, Any]:
        """Process a file based on its type"""
        ext = os.path.splitext(file_path)[1].lower()
        result = {}
        
        if ext in ['.tsx', '.ts', '.jsx', '.js']:
            result = self.process_tsx_file(file_path)
        elif ext == '.json':
            try:
                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    json_data = json.load(f)
                result = {'json_data': json_data}
            except json.JSONDecodeError:
                result = {'error': 'Invalid JSON file'}
        else:
            # Just return basic info for other file types
            result = {"type": ext[1:], "info": f"File summary not available for {ext} files"}
        
        # Add database schema extraction
        try:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
            
            # Extract database schema regardless of file type
            db_schemas = self.extract_database_schema(content, file_path)
            if db_schemas.get('schemas'):
                result['database_schemas'] = db_schemas
                # Add to global list of schemas
                self.database_schemas.extend(db_schemas['schemas'])
            
            # Apply new enhanced analysis functions
            if ext in ['.tsx', '.ts', '.jsx', '.js']:
                # Import dependencies
                import_deps = self.extract_import_dependencies(content, file_path)
                if import_deps.get('dependencies'):
                    result['import_dependencies'] = import_deps
                    self.import_dependencies.extend(import_deps['dependencies'])
                
                # Complex type analysis
                if ext in ['.ts', '.tsx']:
                    complex_types = self.extract_complex_types(content, file_path)
                    if complex_types.get('interfaces') or complex_types.get('types'):
                        result['complex_types'] = complex_types
                        if complex_types.get('interfaces'):
                            self.complex_types.extend(complex_types['interfaces'])
                        if complex_types.get('types'):
                            self.complex_types.extend(complex_types['types'])
                
                # Enhanced API endpoint analysis
                api_endpoints = self.extract_api_endpoints(content, file_path)
                if api_endpoints.get('api_endpoints'):
                    result['api_endpoints_enhanced'] = api_endpoints
                    self.enhanced_api_endpoints.extend(api_endpoints['api_endpoints'])
                
                # Style pattern analysis
                style_patterns = self.extract_style_patterns(content, file_path)
                if any(style_patterns.values()):
                    result['style_patterns'] = style_patterns
                    if style_patterns.get('style_definitions'):
                        self.style_patterns.extend(style_patterns['style_definitions'])
                
                # Hook usage analysis
                hook_analysis = self.analyze_hook_usage(content, file_path)
                if any(hook_analysis.values()):
                    result['hook_analysis'] = hook_analysis
                    if hook_analysis.get('hook_definitions'):
                        self.hook_usages_analysis.extend(hook_analysis['hook_definitions'])
                
                # Navigation route analysis
                nav_routes = self.extract_navigation_routes(content, file_path)
                if any(nav_routes.values()):
                    result['navigation_routes_enhanced'] = nav_routes
                    if nav_routes.get('routes'):
                        self.enhanced_navigation.extend(nav_routes['routes'])
                
                # Security pattern analysis
                security_patterns = self.analyze_security_patterns(content, file_path)
                if any(security_patterns.values()):
                    result['security_patterns'] = security_patterns
                    if security_patterns.get('security_concerns'):
                        self.security_patterns.extend(security_patterns['security_concerns'])
                
        except Exception as e:
            print(f"Error in enhanced analysis for {file_path}: {str(e)}")
        
        return result

    def extract_context(self, root_dir: str, output_file: str, format='text') -> None:
        """Extract context from codebase and write to output file"""
        print(f"Processing project directory: {root_dir}")
        print(f"Using configuration:")
        print(f"  - Exclude directories: {self.config['exclude_dirs']}")
        print(f"  - Include directories: {self.config['include_dirs']}")
        print(f"  - Exclude files: {self.config['exclude_files']}")
        print(f"  - File extensions: {self.config['extensions']}")
        print(f"  - Output format: {format}")
        
        # Collect files
        try:
            self.files = self.collect_files(root_dir)
            print(f"Found {len(self.files)} eligible files")
            self.files.sort(key=lambda x: x[1])  # Sort by relative path
        except Exception as e:
            print(f"Error collecting files: {str(e)}")
            return
        
        # Process all files to gather relationships
        processed_count = 0
        excluded_count = 0
        error_count = 0
        
        for file_path, rel_path in self.files:
            # Skip processing if we've hit line limit
            if self.total_lines >= self.config["max_lines"]:
                print(f"Reached line limit of {self.config['max_lines']} lines. Stopping...")
                break
                
            try:
                # Process the file
                file_info = self.process_file(file_path)
                processed_count += 1
                
                # Format the file summary
                summary_lines = self.format_file_summary(file_path, rel_path, file_info)
                
                # Skip if no useful info extracted
                if not summary_lines:
                    excluded_count += 1
                    continue
                    
                # Check if adding this file would exceed our line limit
                if self.total_lines + len(summary_lines) + 3 > self.config["max_lines"]:
                    print(f"Reached target line limit ({self.config['max_lines']}). Stopping...")
                    break
                    
                # Add file info with header
                self.file_summaries.append({
                    "path": rel_path,
                    "lines": summary_lines
                })
                
                self.total_lines += len(summary_lines) + 3  # +3 for separator and file name lines
                
                # Periodically report progress
                if processed_count % 10 == 0:
                    print(f"Processed {processed_count} files, total lines: {self.total_lines}")
            
            except Exception as e:
                print(f"Error processing file {rel_path}: {str(e)}")
                error_count += 1
        
        print(f"Processing complete:")
        print(f"  - Processed: {processed_count} files")
        print(f"  - Excluded (no useful info): {excluded_count} files")
        print(f"  - Errors: {error_count} files")
        
        # Now generate output in the requested format
        try:
            output_content = self.generate_output(format)
            with open(output_file, 'w', encoding='utf-8') as out:
                out.write(output_content)
            
            print(f"Context extraction complete! Generated output in {format} format to {output_file}")
        except Exception as e:
            print(f"Error writing to output file: {str(e)}")

    def process_tsx_file(self, file_path: str) -> Dict[str, Any]:
        """Process a TypeScript/JavaScript file and extract information"""
        result = {}
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
                
            # Extract components
            components = self.extract_react_component(content, file_path)
            if components:
                result['components'] = components
                
            # Extract hooks
            hooks = self.extract_hooks(content, file_path)
            if hooks:
                result['hooks'] = hooks
                
            # Extract services
            services = self.extract_services(content, file_path)
            if services:
                result['services'] = services
                
            # Extract type information
            types = self.extract_types(content, file_path)
            if any(types.values()):
                result['types'] = types
                
            # Extract navigation information
            navigation = self.extract_navigation(content, file_path)
            if navigation:
                result['navigation'] = navigation
                
            # Extract state management
            state_management = self.extract_state_management(content, file_path)
            if state_management:
                result['state_management'] = state_management
                
            # Extract import information (basic version)
            imports = []
            import_pattern = r'import\s+(?:{([^}]+)}|(\w+))\s+from\s+[\'"]([^\'"]+)[\'"]'
            import_matches = re.finditer(import_pattern, content)
            
            for match in import_matches:
                if match.group(1):  # Named imports
                    imports_list = [name.strip() for name in match.group(1).split(',')]
                    imports.append({
                        'module': match.group(3),
                        'imports': imports_list
                    })
                elif match.group(2):  # Default import
                    imports.append({
                        'module': match.group(3),
                        'imports': [match.group(2)]
                    })
                    
            if imports:
                result['imports'] = imports
            
        except Exception as e:
            print(f"Error processing {file_path}: {str(e)}")
            return {'error': str(e)}
            
        return result

    def generate_text_output(self):
        """Generate text-based output"""
        lines = []
        
        # Header
        lines.append("=== AI KNOWLEDGE BASE CODE CONTEXT ===")
        lines.append(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"Total files processed: {len(self.files)}")
        lines.append("")
        
        # Component Complexity Section
        if self.component_complexity:
            lines.append("=== COMPONENT COMPLEXITY ===")
            lines.append("(Components with complexity > 10, sorted by complexity)")
            lines.append("Component Name | Complexity | File")
            lines.append("--------------|------------|-----")
            
            sorted_components = sorted(self.component_complexity, key=lambda x: x['complexity'], reverse=True)
            for component in sorted_components[:20]:  # Show top 20
                file_name = os.path.basename(component['file_path'])
                lines.append(f"{component['name']} | {component['complexity']} | {file_name}")
            
            lines.append("")
            lines.append("Complexity Guidelines:")
            lines.append("- 0-5: Simple component")
            lines.append("- 6-10: Moderate complexity")
            lines.append("- 11-20: Complex component")
            lines.append("- 21+: Very complex, consider refactoring")
            lines.append("")
        
        # Hooks Section
        if self.hooks:
            lines.append("=== CUSTOM HOOKS ===")
            for hook in self.hooks:
                lines.append(f"Hook: {hook['name']} (from {os.path.basename(hook['file_path'])})")
                
                if hook['params']:
                    lines.append("  Parameters:")
                    for param in hook['params']:
                        lines.append(f"    - {param['name']}: {param.get('type', 'any')}")
                
                if hook['returns']:
                    lines.append("  Returns:")
                    for ret in hook['returns']:
                        lines.append(f"    - {ret}")
                
                if hook['uses_hooks']:
                    lines.append("  Uses hooks:")
                    for used_hook in hook['uses_hooks']:
                        lines.append(f"    - {used_hook}")
                
                if hook['api_calls']:
                    lines.append("  API calls:")
                    for api_call in hook['api_calls']:
                        lines.append(f"    - {api_call}")
                
                lines.append("")
        
        # Services Section
        if self.services:
            lines.append("=== SERVICES ===")
            for service in self.services:
                singleton = " (Singleton)" if service.get('is_singleton') else ""
                parent = f" extends {service['parent_class']}" if service.get('parent_class') else ""
                lines.append(f"Service: {service['name']}{singleton}{parent} (from {os.path.basename(service['file_path'])})")
                
                if service['methods']:
                    lines.append("  Methods:")
                    for method in service['methods']:
                        params = ', '.join([f"{p['name']}: {p['type']}" for p in method['params']])
                        return_type = f" -> {method['return_type']}" if method.get('return_type') else ""
                        lines.append(f"    - {method['name']}({params}){return_type}")
                
                if service['api_endpoints']:
                    lines.append("  API Endpoints:")
                    for endpoint in service['api_endpoints']:
                        lines.append(f"    - {endpoint}")
                
                lines.append("")
        
        # API Endpoints Section
        if self.api_endpoints:
            lines.append("=== API ENDPOINTS ===")
            for endpoint in self.api_endpoints:
                lines.append(f"Endpoint: {endpoint['endpoint']}")
                lines.append(f"  Service: {endpoint['service']}")
                lines.append(f"  File: {os.path.basename(endpoint['file_path'])}")
                lines.append("")
        
        # Navigation Routes Section
        if self.navigation_routes:
            lines.append("=== NAVIGATION ROUTES ===")
            for route in self.navigation_routes:
                component = f" -> {route['component']}" if route.get('component') else ""
                lines.append(f"Route: {route['name']}{component}")
                lines.append(f"  File: {os.path.basename(route['file_path'])}")
                lines.append("")
        
        # State Management Section
        if self.state_management:
            lines.append("=== STATE MANAGEMENT ===")
            
            # Group by type
            state_by_type = {}
            for state in self.state_management:
                if state['type'] not in state_by_type:
                    state_by_type[state['type']] = []
                state_by_type[state['type']].append(state)
            
            for state_type, states in state_by_type.items():
                lines.append(f"{state_type.replace('_', ' ').title()}:")
                for state in states:
                    lines.append(f"  - {state['name']} (from {os.path.basename(state['file_path'])})")
                lines.append("")
        
        # Database Schemas Section
        if self.database_schemas:
            lines.append("=== DATABASE SCHEMAS ===")
            for schema in self.database_schemas:
                lines.append(f"Table: {schema['table_name']} (from {os.path.basename(schema['file_path'])})")
                
                # Columns
                lines.append("  Columns:")
                for column in schema['columns']:
                    nullable = "NULL" if column.get('nullable', True) else "NOT NULL"
                    default = f" DEFAULT {column['default']}" if 'default' in column else ""
                    pk = " PRIMARY KEY" if column['name'] in schema['primary_keys'] else ""
                    lines.append(f"    - {column['name']}: {column['type']} {nullable}{default}{pk}")
                
                # Primary Keys
                if schema['primary_keys']:
                    lines.append("  Primary Keys:")
                    for pk in schema['primary_keys']:
                        lines.append(f"    - {pk}")
                
                # Foreign Keys
                if schema['foreign_keys']:
                    lines.append("  Foreign Keys:")
                    for fk in schema['foreign_keys']:
                        lines.append(f"    - {fk['column']}  {fk['ref_table']}.{fk['ref_column']}")
                
                # Indices
                if schema['indices']:
                    lines.append("  Indices:")
                    for idx in schema['indices']:
                        unique = "UNIQUE " if idx['unique'] else ""
                        lines.append(f"    - {unique}INDEX {idx['name']} ({', '.join(idx['columns'])})")
                
                lines.append("")
        
        # Module Dependencies Section
        if self.import_dependencies:
            lines.append("=== MODULE DEPENDENCIES ===")
            
            # Group dependencies by source
            by_source = defaultdict(list)
            for dep in self.import_dependencies:
                if 'source' in dep:
                    by_source[dep['source']].append(dep)
            
            # Take top 20 most imported modules
            top_modules = sorted(by_source.items(), key=lambda x: len(x[1]), reverse=True)[:20]
            
            for source, deps in top_modules:
                named = len([d for d in deps if d.get('type') == 'named'])
                default = len([d for d in deps if d.get('type') == 'default'])
                side_effect = len([d for d in deps if d.get('type') == 'side_effect'])
                
                types = []
                if named > 0:
                    types.append(f"{named} named")
                if default > 0:
                    types.append(f"{default} default")
                if side_effect > 0:
                    types.append(f"{side_effect} side-effect")
                
                lines.append(f"Module: {source} - {len(deps)} imports ({', '.join(types)})")
            
            lines.append("")
        
        # Type System Analysis
        if self.complex_types:
            lines.append("=== TYPE SYSTEM ANALYSIS ===")
            
            # Count interfaces and types
            interfaces = [t for t in self.complex_types if 'properties' in t]
            types = [t for t in self.complex_types if 'definition' in t]
            
            lines.append(f"Total Interfaces: {len(interfaces)}")
            lines.append(f"Total Type Aliases: {len(types)}")
            lines.append("")
            
            if interfaces:
                lines.append("Most Complex Interfaces:")
                
                # Show top 5 most complex interfaces
                complex_interfaces = sorted(interfaces, key=lambda x: len(x.get('properties', [])), reverse=True)[:5]
                
                for interface in complex_interfaces:
                    extends = f" extends {interface['extends']}" if interface.get('extends') else ""
                    lines.append(f"- {interface['name']}{extends} - {len(interface.get('properties', []))} properties")
            
            lines.append("")
            
            if types:
                lines.append("Type Alias Categories:")
                
                # Count by category
                categories = {}
                for t in types:
                    cat = t.get('category', 'unknown')
                    categories[cat] = categories.get(cat, 0) + 1
                
                for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
                    lines.append(f"- {cat}: {count}")
            
            lines.append("")
        
        # Enhanced API Documentation
        if self.enhanced_api_endpoints:
            lines.append("=== ENHANCED API DOCUMENTATION ===")
            
            # Group by method
            by_method = defaultdict(list)
            for endpoint in self.enhanced_api_endpoints:
                by_method[endpoint['method']].append(endpoint)
            
            for method, endpoints in sorted(by_method.items()):
                lines.append(f"{method} Endpoints ({len(endpoints)}):")
                for endpoint in endpoints[:10]:  # Show top 10 of each method
                    lines.append(f"- {endpoint['endpoint']}")
                    if endpoint.get('function'):
                        lines.append(f"  Function: {endpoint['function']}")
                    if endpoint.get('return_type'):
                        lines.append(f"  Returns: {endpoint['return_type']}")
                
                if len(endpoints) > 10:
                    lines.append(f"  ... and {len(endpoints) - 10} more {method} endpoints")
                
                lines.append("")
        
        # Style Patterns
        if self.style_patterns:
            lines.append("=== STYLE PATTERNS ===")
            
            total_style_rules = sum(len(style.get('style_patterns', [])) for style in self.style_patterns) 
            lines.append(f"Total StyleSheet Rules: {total_style_rules}")
            
            inline_count = sum(1 for pattern in self.style_patterns if pattern.get('inline_styles'))
            if inline_count > 0:
                lines.append(f"Components with Inline Styles: {inline_count}")
            
            lines.append("")
        
        # Hook Usage Analysis
        if self.hook_usages_analysis:
            lines.append("=== ENHANCED HOOK ANALYSIS ===")
            
            for hook in self.hook_usages_analysis:
                lines.append(f"Hook: {hook['name']}")
                
                if hook.get('states'):
                    lines.append(f"  State Variables: {len(hook['states'])}")
                    for state in hook['states'][:3]:  # Show first 3
                        initial = f" = {state['initial_value']}" if state.get('initial_value') else ""
                        lines.append(f"    - {state['name']}{initial}")
                    
                    if len(hook['states']) > 3:
                        lines.append(f"    ... and {len(hook['states']) - 3} more state variables")
                
                if hook.get('effects'):
                    lines.append(f"  Effects: {len(hook['effects'])}")
                    for effect in hook['effects'][:2]:  # Show first 2
                        deps = ", ".join(effect['dependencies']) if effect['dependencies'] else "[]"
                        lines.append(f"    - Dependencies: [{deps}]")
                    
                    if len(hook['effects']) > 2:
                        lines.append(f"    ... and {len(hook['effects']) - 2} more effects")
                
                if hook.get('memoized'):
                    callbacks = len([m for m in hook['memoized'] if m['type'] == 'callback'])
                    memos = len([m for m in hook['memoized'] if m['type'] == 'memo'])
                    
                    if callbacks > 0:
                        lines.append(f"  Callbacks: {callbacks}")
                    
                    if memos > 0:
                        lines.append(f"  Memoized Values: {memos}")
                    
                    lines.append("")
        
        # Navigation Routes Analysis
        if self.enhanced_navigation:
            lines.append("=== ENHANCED NAVIGATION ROUTES ===")
            
            # Group by type
            routes_by_type = defaultdict(list)
            for route in self.enhanced_navigation:
                routes_by_type[route.get('type', 'Unknown')].append(route)
            
            for route_type, routes in routes_by_type.items():
                lines.append(f"{route_type} Routes ({len(routes)}):")
                
                for route in routes[:10]:  # Show top 10 of each type
                    options = f" (with options)" if route.get('options') else ""
                    lines.append(f"- {route['name']}{options}")
                
                if len(routes) > 10:
                    lines.append(f"  ... and {len(routes) - 10} more {route_type} routes")
                
                lines.append("")
        
        # Security Analysis
        if self.security_patterns:
            lines.append("=== SECURITY ANALYSIS ===")
            
            # Group by issue
            issues_by_type = defaultdict(list)
            for issue in self.security_patterns:
                issues_by_type[issue.get('issue', 'Unknown')].append(issue)
            
            for issue_type, issues in sorted(issues_by_type.items(), key=lambda x: len(x[1]), reverse=True):
                lines.append(f"{issue_type} ({len(issues)} occurrences):")
                
                for i, issue in enumerate(issues[:5]):  # Show first 5 examples
                    file_name = os.path.basename(issue['file_path'])
                    context = issue['context'][:100] + "..." if len(issue['context']) > 100 else issue['context']
                    lines.append(f"- In {file_name}: `{context}`")
                
                if len(issues) > 5:
                    lines.append(f"  ... and {len(issues) - 5} more occurrences")
                
                lines.append("")
        
        # File Summaries
        if self.file_summaries:
            lines.append("=== FILE SUMMARIES ===")
            
            for file_info in self.file_summaries:
                lines.append(f"=== {file_info['path']} ===")
                lines.extend(file_info['lines'])
                lines.append("")
                lines.append("-" * 80)
                lines.append("")
        
        return "\n".join(lines)

    def format_component_info(self, component: Dict[str, Any]) -> List[str]:
        """Format component information for the output"""
        lines = []
        lines.append(f"Component: {component['name']} ({component['type']})")
        
        if component.get('props'):
            lines.append("  Props:")
            for prop in component['props']:
                lines.append(f"    - {prop['name']}: {prop.get('type', 'any')}")
        
        if component.get('hooks_used'):
            lines.append("  Hooks used:")
            for hook in component['hooks_used']:
                lines.append(f"    - {hook}")
        
        if component.get('api_calls'):
            lines.append("  API calls:")
            for api_call in component['api_calls']:
                lines.append(f"    - {api_call}")
        
        if component.get('performance_issues'):
            lines.append("  Performance issues:")
            for issue in component['performance_issues']:
                lines.append(f"    - {issue}")
        
        if component.get('react_native_issues'):
            lines.append("  React Native issues:")
            for issue in component['react_native_issues']:
                lines.append(f"    - {issue}")
        
        return lines
    
    def format_hook_info(self, hook: Dict[str, Any]) -> List[str]:
        """Format hook information for the output"""
        lines = []
        lines.append(f"Hook: {hook['name']}")
        
        if hook.get('params'):
            lines.append("  Parameters:")
            for param in hook['params']:
                lines.append(f"    - {param['name']}: {param.get('type', 'any')}")
        
        if hook.get('returns'):
            lines.append("  Returns:")
            for ret in hook['returns']:
                lines.append(f"    - {ret}")
        
        if hook.get('uses_hooks'):
            lines.append("  Uses hooks:")
            for used_hook in hook['uses_hooks']:
                lines.append(f"    - {used_hook}")
        
        if hook.get('api_calls'):
            lines.append("  API calls:")
            for api_call in hook['api_calls']:
                lines.append(f"    - {api_call}")
        
        return lines
    
    def format_service_info(self, service: Dict[str, Any]) -> List[str]:
        """Format service information for the output"""
        lines = []
        singleton = " (Singleton)" if service.get('is_singleton') else ""
        parent = f" extends {service['parent_class']}" if service.get('parent_class') else ""
        lines.append(f"Service: {service['name']}{singleton}{parent}")
        
        if service.get('methods'):
            lines.append("  Methods:")
            for method in service['methods']:
                params = ', '.join([f"{p['name']}: {p['type']}" for p in method['params']])
                return_type = f" -> {method['return_type']}" if method.get('return_type') else ""
                lines.append(f"    - {method['name']}({params}){return_type}")
        
        if service.get('api_endpoints'):
            lines.append("  API Endpoints:")
            for endpoint in service['api_endpoints']:
                lines.append(f"    - {endpoint}")
        
        return lines
    
    def format_type_info(self, types: Dict[str, List[Dict[str, Any]]]) -> List[str]:
        """Format type information for the output"""
        lines = []
        
        if types.get('interfaces'):
            lines.append("  Interfaces:")
            for interface in types['interfaces']:
                parent = f" extends {interface['parent']}" if interface.get('parent') else ""
                lines.append(f"    - {interface['name']}{parent}")
                
                if interface.get('properties'):
                    for prop in interface['properties']:
                        lines.append(f"      - {prop['name']}: {prop['type']}")
        
        if types.get('types'):
            lines.append("  Type Aliases:")
            for type_alias in types['types']:
                lines.append(f"    - {type_alias['name']} = {type_alias['definition']}")
        
        if types.get('enums'):
            lines.append("  Enums:")
            for enum in types['enums']:
                lines.append(f"    - {enum['name']}")
                
                if enum.get('values'):
                    for val in enum['values']:
                        value = f" = {val['value']}" if val.get('value') else ""
                        lines.append(f"      - {val['name']}{value}")
        
        return lines
    
    def format_navigation_info(self, navigation: List[Dict[str, Any]]) -> List[str]:
        """Format navigation information for the output"""
        lines = []
        
        for route in navigation:
            component_str = f" -> {route['component']}" if route.get('component') else ""
            lines.append(f"  Route: {route['name']}{component_str}")
        
        return lines
    
    def format_state_management_info(self, state_management: List[Dict[str, Any]]) -> List[str]:
        """Format state management information for the output"""
        lines = []
        
        # Group by type
        state_by_type = {}
        for state in state_management:
            if state['type'] not in state_by_type:
                state_by_type[state['type']] = []
            state_by_type[state['type']].append(state)
        
        for state_type, states in state_by_type.items():
            lines.append(f"  {state_type.replace('_', ' ').title()}:")
            for state in states:
                lines.append(f"    - {state['name']}")
        
        return lines
    
    def format_database_schema(self, schema: Dict[str, Any]) -> List[str]:
        """Format database schema information for the output"""
        lines = []
        
        for db_schema in schema.get('schemas', []):
            lines.append(f"  Table: {db_schema['table_name']}")
            
            # Columns
            lines.append("    Columns:")
            for column in db_schema['columns']:
                nullable = "NULL" if column.get('nullable', True) else "NOT NULL"
                default = f" DEFAULT {column['default']}" if 'default' in column else ""
                pk = " PRIMARY KEY" if column['name'] in db_schema['primary_keys'] else ""
                lines.append(f"      - {column['name']}: {column['type']} {nullable}{default}{pk}")
            
            # Primary Keys
            if db_schema['primary_keys']:
                lines.append("    Primary Keys:")
                for pk in db_schema['primary_keys']:
                    lines.append(f"      - {pk}")
            
            # Foreign Keys
            if db_schema['foreign_keys']:
                lines.append("    Foreign Keys:")
                for fk in db_schema['foreign_keys']:
                    lines.append(f"      - {fk['column']}  {fk['ref_table']}.{fk['ref_column']}")
            
            # Indices
            if db_schema['indices']:
                lines.append("    Indices:")
                for idx in db_schema['indices']:
                    unique = "UNIQUE " if idx['unique'] else ""
                    lines.append(f"      - {unique}INDEX {idx['name']} ({', '.join(idx['columns'])})")
        
        return lines

def main():
    """Main function to execute the script"""
    parser = argparse.ArgumentParser(description="Extract structured context from a React Native/TypeScript codebase")
    parser.add_argument("output_file", nargs="?", default="code_context.txt", 
                      help="Output file path (default: code_context.txt)")
    parser.add_argument("--root-dir", "-d", default=os.getcwd(),
                      help="Root directory to process (default: current directory)")
    parser.add_argument("--exclude", "-e", action="append", default=[],
                      help="Additional directories to exclude (can be used multiple times)")
    parser.add_argument("--include", "-i", action="append", default=[],
                      help="Additional directories to include (can be used multiple times)")
    parser.add_argument("--max-lines", "-m", type=int, default=DEFAULT_CONFIG["max_lines"],
                      help=f"Maximum number of lines in output (default: {DEFAULT_CONFIG['max_lines']})")
    parser.add_argument("--format", "-f", choices=["text", "json", "markdown", "html"], default="text",
                      help="Output format (default: text)")
    parser.add_argument("--analyze-performance", "-p", action="store_true",
                      help="Include performance analysis")
    parser.add_argument("--analyze-data-flow", "-df", action="store_true",
                      help="Include data flow analysis")
    parser.add_argument("--show-component-tree", "-t", action="store_true",
                      help="Include component hierarchy tree")
    parser.add_argument("--analyze-react-native", "-rn", action="store_true",
                      help="Include React Native specific analysis")
    
    args = parser.parse_args()
    
    # Create a copy of the default config
    config = DEFAULT_CONFIG.copy()
    
    # Update config with command-line args
    config["exclude_dirs"].extend(args.exclude)
    config["include_dirs"].extend(args.include)
    config["max_lines"] = args.max_lines
    config["analyze_performance"] = args.analyze_performance
    config["analyze_data_flow"] = args.analyze_data_flow
    config["show_component_tree"] = args.show_component_tree
    config["analyze_react_native"] = args.analyze_react_native
    
    try:
        extractor = CodeContextExtractor(config)
        extractor.extract_context(args.root_dir, args.output_file, format=args.format)
    except KeyboardInterrupt:
        print("\nExtraction stopped by user.")
    except Exception as e:
        print(f"Error during extraction: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()

================================================================================
File: ios/Podfile.properties.json
================================================================================

{
  "expo.jsEngine": "hermes",
  "EX_DEV_CLIENT_NETWORK_INSPECTOR": "true",
  "newArchEnabled": "true"
}


================================================================================
File: package.json
================================================================================

{
  "name": "mouthguard-monitor",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.4",
    "@react-native-async-storage/async-storage": "^1.23.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "commander": "^13.1.0",
    "expo": "~52.0.37",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.7",
    "expo-dev-client": "~5.0.12",
    "expo-device": "^7.0.2",
    "expo-file-system": "^18.0.12",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.0",
    "expo-linear-gradient": "~14.0.2",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.17",
    "expo-sharing": "^13.0.1",
    "expo-splash-screen": "^0.29.22",
    "expo-sqlite": "~15.1.2",
    "expo-status-bar": "~2.0.0",
    "expo-symbols": "~0.2.2",
    "expo-system-ui": "~4.0.8",
    "expo-web-browser": "~14.0.2",
    "install": "^0.13.0",
    "lucide-react": "^0.475.0",
    "papaparse": "^5.5.2",
    "parse": "^3.5.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-native": "^0.76.5",
    "react-native-base64": "^0.2.1",
    "react-native-ble-plx": "^3.5.0",
    "react-native-chart-kit": "^6.12.0",
    "react-native-dotenv": "^3.4.11",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.7",
    "react-native-root-siblings": "^5.0.1",
    "react-native-safe-area-context": "^4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "^15.11.2",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.9",
    "@babel/parser": "^7.26.10",
    "@babel/traverse": "^7.26.10",
    "@react-native-community/cli": "^15.1.3",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/react": "~18.3.12",
    "@types/react-native-base64": "^0.2.2",
    "@types/react-test-renderer": "^18.3.1",
    "@types/uuid": "^10.0.0",
    "jest": "^29.7.0",
    "jest-expo": "~52.0.5",
    "react-test-renderer": "^18.3.1",
    "typescript": "^5.7.3"
  },
  "private": true
}


================================================================================
File: README.md
================================================================================

# Mouthguard Monitoring App

This app allows monitoring of mouthguard sensors for athlete tracking and impact detection.

## Development Setup

1. Make sure you have Node.js and npm installed
2. Install Expo CLI: `npm install -g expo-cli`
3. Install dependencies: `npm install`
4. Run the app: `npx expo start`

## Troubleshooting

### App Not Rendering/Blank Screen

If you encounter a blank screen or the app is not rendering properly:

1. Try clearing the app data with our reset script:
   ```
   node reset-app.js
   ```
   This will:
   - Clear AsyncStorage
   - Reset the Metro bundler cache
   - Set up a one-time reset for the app on next launch

2. If the app is still having issues, you can manually reset by:
   - Deleting the AsyncStorage values:
     ```
     npx react-native-async-storage-dev-menu reset
     ```
   - Clearing Metro cache:
     ```
     npx expo start --clear
     ```

### Common Issues

1. **Missing Components Error**: The app may reference components that were removed during cleanup. Check the specific error message for the file that's causing the issue and remove it or update its imports.

2. **Database Migration Issues**: If you encounter database migration problems, check:
   - The `src/migrations` folder for current migrations
   - The `src/DatabaseManager.ts` file for database init logic

3. **Build Errors**: If you encounter errors while building, make sure to check for references to removed components:
   ```
   grep -r "removedComponent" ./app
   ```
   
4. **Navigation Issues**: Make sure all screens referenced in navigation are available in the codebase.

## Project Structure

- `/app` - Main application screens and navigation
  - `/(tabs)` - Tab-based navigation screens
  - `/components` - Reusable components
  - `/context` - React context providers

- `/src` - Core application logic
  - `/contexts` - Context providers for app state
  - `/migrations` - Database migrations
  - `/providers` - App state providers
  - `/repositories` - Data access layer
  - `/services` - Business logic services
  - `/utils` - Utility functions

## Reset Process

The app includes a one-time reset process that runs automatically after code changes. This helps prevent issues with stale data or incompatible database schemas.

If you want to force a reset, you can:

1. Delete the `RESET_PERFORMED` key from AsyncStorage
2. Run the app again

Or simply run the reset script:
```
node reset-app.js
```

## App Features

- Dashboard for monitoring athletes and devices
- Live monitoring of sensor data
- Reports and analytics
- Device management
- Athlete profile management # MouthguardMonitor


================================================================================
File: reset-app.js
================================================================================

const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

console.log(' Starting app reset process...');

// 1. Clear AsyncStorage on Android emulator
const clearAsyncStorage = () => {
  return new Promise((resolve, reject) => {
    console.log('Clearing AsyncStorage...');
    exec('adb shell pm clear expo.canovareactnativeapp', (error, stdout, stderr) => {
      if (error) {
        console.warn(' Warning: Could not clear package data:', error.message);
        console.log('Will create a helper file to clear AsyncStorage on next app launch...');
        
        // Create a file that will clear AsyncStorage on next app launch
        const clearAsyncStorageCode = `
// This file is auto-generated to clear AsyncStorage on next app launch
// It should be imported in app/_layout.tsx

import AsyncStorage from '@react-native-async-storage/async-storage';

export async function clearAppData() {
  console.log('[AppReset] Clearing AsyncStorage...');
  try {
    await AsyncStorage.clear();
    console.log('[AppReset] AsyncStorage cleared successfully');
    // Delete the DB version key so migrations run again
    await AsyncStorage.removeItem('dbVersion');
    console.log('[AppReset] Database version reset');
    return true;
  } catch (error) {
    console.error('[AppReset] Error clearing AsyncStorage:', error);
    return false;
  }
}
`;
        fs.writeFileSync('./src/utils/resetAppData.ts', clearAsyncStorageCode);
        console.log(' Created resetAppData.ts helper file');
        
        // Now add an import for this file in _layout.tsx
        try {
          const layoutPath = './app/_layout.tsx';
          if (fs.existsSync(layoutPath)) {
            let layoutContent = fs.readFileSync(layoutPath, 'utf8');
            
            // Check if the import already exists
            if (!layoutContent.includes('import { clearAppData }')) {
              // Add the import and call it in useEffect
              const importStatement = `import { clearAppData } from '../src/utils/resetAppData';\n`;
              
              // Find the first useEffect in the RootLayout function
              const rootLayoutRegex = /export default function RootLayout\(\) {([\s\S]*?)return/;
              const match = rootLayoutRegex.exec(layoutContent);
              
              if (match && match[1]) {
                const updatedContent = match[1].includes('useEffect')
                  ? layoutContent.replace(
                      /useEffect\(\(\) => {/,
                      `useEffect(() => {\n    // Clear app data on startup\n    clearAppData().catch(err => console.error('[AppReset] Error:', err));\n`
                    )
                  : layoutContent.replace(
                      /export default function RootLayout\(\) {/,
                      `export default function RootLayout() {\n  useEffect(() => {\n    // Clear app data on startup\n    clearAppData().catch(err => console.error('[AppReset] Error:', err));\n  }, []);\n`
                    );
                
                fs.writeFileSync(layoutPath, importStatement + updatedContent);
                console.log(' Updated _layout.tsx to clear data on next launch');
              } else {
                console.warn(' Could not find RootLayout function in _layout.tsx');
              }
            } else {
              console.log(' _layout.tsx already has the clearAppData import');
            }
          } else {
            console.warn(' Could not find app/_layout.tsx');
          }
        } catch (layoutError) {
          console.warn(' Error updating _layout.tsx:', layoutError);
        }
        
        resolve();
      } else {
        console.log(' AsyncStorage cleared successfully');
        resolve();
      }
    });
  });
};

// 2. Reset Metro bundler cache
const resetMetroCache = () => {
  return new Promise((resolve, reject) => {
    console.log('Clearing Metro bundler cache...');
    exec('npx react-native start --reset-cache', (error, stdout, stderr) => {
      // This will keep running, so we need to kill it after a few seconds
      setTimeout(() => {
        exec('pkill -f "react-native start"', () => {
          console.log(' Metro cache reset completed');
          resolve();
        });
      }, 5000);
    });
  });
};

// 3. Delete database files
const clearDatabaseFiles = () => {
  console.log('Looking for database files to clean up...');
  const dbPath = path.join(__dirname, 'assets', 'db');
  
  if (fs.existsSync(dbPath)) {
    console.log(`Found database directory at ${dbPath}`);
    try {
      const files = fs.readdirSync(dbPath);
      files.forEach(file => {
        if (file.endsWith('.db') || file.endsWith('.sqlite')) {
          const filePath = path.join(dbPath, file);
          console.log(`Deleting ${filePath}...`);
          fs.unlinkSync(filePath);
        }
      });
      console.log(' Database files cleared');
    } catch (err) {
      console.error(' Error clearing database files:', err);
    }
  } else {
    console.log('No database directory found at expected location');
  }
  
  return Promise.resolve();
};

// 4. Restart app
const restartApp = () => {
  console.log('Restarting the app...');
  exec('npx expo start --clear', (error, stdout, stderr) => {
    if (error) {
      console.error(' Error restarting app:', error);
      return;
    }
    console.log(stdout);
  });
};

// Run the reset process
async function resetApp() {
  try {
    await clearAsyncStorage();
    await resetMetroCache();
    await clearDatabaseFiles();
    console.log(' Reset process completed! Starting app...');
    restartApp();
  } catch (error) {
    console.error(' Reset process failed:', error);
    process.exit(1);
  }
}

resetApp();


================================================================================
File: src/bleConstants.ts
================================================================================

// BLE UUID Constants matching Arduino code

// Service UUIDs
export const UUID_SERVICE_HRM = "a329162e-bf3d-4f73-9a1a-bb8ccfe142e7";
export const UUID_SERVICE_HTM = "d2a95330-d754-4a5b-bb74-b1b09bef98f5";
export const UUID_SERVICE_IMU = "5f07ce79-170a-4c45-b8ca-eae29004e45f";
export const UUID_SERVICE_FSR = "56f38df0-e65b-4190-a3da-9f941c9d1763";

// Characteristic UUIDs
export const UUID_CHARACTERISTIC_HRMC = "0a21fc6f-6edb-4086-9460-0eccb35150fb"; // HRM Data
export const UUID_CHARACTERISTIC_HTMC = "6896072b-24ce-4982-ac6a-899fa7183069"; // HTM Data
export const UUID_CHARACTERISTIC_IMUC = "d2e9a9c2-a94b-42cb-b11d-b76549e7a164"; // IMU Data
export const UUID_CHARACTERISTIC_BITE_FORCE = "f86a2066-5203-4bed-b090-ac0b89e68d81"; // FSR Data

// Standard service/characteristic UUIDs
export const UUID_SERVICE_BATTERY = "180f"; // Standard Battery Service
export const UUID_CHARACTERISTIC_BATTERY_LEVEL = "2a19"; // Standard Battery Level

// Group for easier access
export const MOUTHGUARD_UUIDS = {
  services: {
    hrm: UUID_SERVICE_HRM,
    htm: UUID_SERVICE_HTM,
    imu: UUID_SERVICE_IMU,
    fsr: UUID_SERVICE_FSR,
    battery: UUID_SERVICE_BATTERY,
  },
  characteristics: {
    hrmData: UUID_CHARACTERISTIC_HRMC,
    htmData: UUID_CHARACTERISTIC_HTMC,
    imuData: UUID_CHARACTERISTIC_IMUC,
    fsrData: UUID_CHARACTERISTIC_BITE_FORCE,
    batteryLevel: UUID_CHARACTERISTIC_BATTERY_LEVEL,
  }
}; 

================================================================================
File: src/constants.ts
================================================================================

// src/constants.ts

// Database Name (Using a single DB as per current structure)
export const MOUTHGUARD_DB_NAME: string = "mouthguardMonitor.db";

// --- LIGHT MODE COLORS ---
export const COLORS = {
  // Core Palette
  primary: '#005432',       // Evergreen (For buttons, active icons, highlights)
  background: '#EDEBD1',    // Changed from White to Sand (Main app background)
  card: '#FFFFFF',          // White (Card backgrounds, slightly elevated)
  secondaryBackground: '#EDEBD1', // Sand (Subtle backgrounds, dividers, or inactive states)

  // Text Palette
  textPrimary: '#303434',    // Soft Black (Primary text)
  textSecondary: '#4F6069',  // Slate (Secondary text, subtitles)
  textTertiary: '#7E96A0',   // Gray (Placeholder text, disabled text, subtle info)
  textOnPrimary: '#FFFFFF', // White (Text on Evergreen buttons/elements)
  textAccent: '#005432',     // Evergreen (Links, highlighted values)

  // Accents (Use Sparingly!)
  accent1: '#9CCB3B',        // Apple (Maybe for specific highlights or success states)
  accent2: '#009374',        // Teal (Alternative accent, info indicators)
  accent3: '#006484',        // Storm (Another alternative accent)
  accent4: '#DBE442',        // Lemongrass (Could be a warning indicator)
  accent5: '#80B0A6',        // Seaglass (Subtle accent or background)

  // Semantic Colors
  success: '#34C759',        // Standard Green (Overriding Apple Green for clarity)
  warning: '#FF9500',        // Standard Orange (Using standard warning) - Lemongrass might be too subtle
  error: '#FF3B30',          // Standard Red (Using standard error)
  info: '#006484',           // Storm (For informational messages/icons)

  // Neutrals & Borders
  border: '#CAD2D8',          // Silver (Subtle borders and dividers)
  borderLight: '#EAEAEA',    // Lighter border option
  inputBackground: '#F0F0F0',// Light gray for input fields
  disabled: '#CAD2D8',        // Silver (Disabled elements background/text)
  shadow: '#000000',         // Black for shadows (used with low opacity)

  // Institutional (Use as needed for branding)
  instGreen: '#006747',
  instGold: '#CFC493',
  
  // Legacy structure maintained for backward compatibility
  text: {
    primary: '#303434',    // Map to textPrimary
    secondary: '#4F6069',  // Map to textSecondary
    tertiary: '#7E96A0',   // Map to textTertiary
    onPrimary: '#FFFFFF',  // Add this for consistency
  },
  cardBackground: '#FFFFFF', // Map to card
};

// --- NEW: Simulated Data based on Device Packets ---

export const DEVICE_ID_SIM = "simulated_mouthguard_1";

export const SIMULATED_MOTION_PACKET = {
  gyro: [10, -5, 2],          // Example raw values
  accel16: [100, -50, 1020],  // Example raw values (~1g Z if LSB = 1mg)
  accel200: [20, -10, 200],   // Example raw values
  mag: [300, -150, 500],      // Example raw values
  bite_l: 500,                // Example raw ADC value
  bite_r: 480,                // Example raw ADC value
  timestamp: Date.now(), // Use milliseconds for testing clarity
};

export const SIMULATED_FSR_PACKET = {
  left_bite: 510,             // Example raw value
  right_bite: 495,            // Example raw value
  timestamp: Date.now(), // Use milliseconds for testing clarity
};

// Simulating the raw byte format might be overly complex.
// Let's simulate the *parsed* data the app would likely use.
export const SIMULATED_HRM_DATA = {
  flags: 0b00000110, // uint8, sensor contact supported and detected
  heartRate: 75,
  appTimestamp: Date.now(), // Using current time
};

export const SIMULATED_HTM_DATA = {
  flags: 0b00000101, // Fahrenheit, Temp type present, no timestamp
  temperature: 98.6, // Parsed value in Fahrenheit
  type: 6, // Mouth location
  appTimestamp: Date.now(), // Using current time
};

// You might want an array for bulk injection
export const BULK_SIMULATED_MOTION = [
  { ...SIMULATED_MOTION_PACKET, timestamp: Date.now() },
  {
    gyro: [15, -8, 5], accel16: [110, -55, 1030], accel200: [25, -15, 210], mag: [310, -155, 505],
    bite_l: 550, bite_r: 530, timestamp: Date.now()
  },
  {
    gyro: [12, -7, 3], accel16: [105, -52, 1025], accel200: [22, -12, 205], mag: [305, -152, 502],
    bite_l: 520, bite_r: 500, timestamp: Date.now()
  },
];

export const BULK_SIMULATED_FSR = [
  { ...SIMULATED_FSR_PACKET, timestamp: Date.now() },
  { left_bite: 600, right_bite: 580, timestamp: Date.now() },
  { left_bite: 550, right_bite: 540, timestamp: Date.now() },
];

// --- KEEP Player Data and Other Constants ---

export const playerData = {
  id: "player_john_smith", // Added an ID
  name: "John Smith",
  sessions: [
    // --- Session 1 (Example with High Risk) ---
    {
      id: "session_abc_1",
      type: "Training",
      date: "02/19/2015", // Keep date format for now
      sport: "Football", // Added sport tag
      stats: {
        heartRate: { avg: 156, max: 190 },
        temperature: 98.2, // Assuming F
        caloriesBurned: 743,
        acceleration: 12, // Assuming mph
        biteForce: 162, // Add units in display
        concussionRisk: "High", // CRITICAL for alert logic
        duration: "1h 21m",
      },
    },
    // --- Session 2 (Example with Low Risk) ---
    {
      id: "session_def_2",
      type: "Game",
      date: "02/10/2015",
      sport: "Football",
      stats: {
        heartRate: { avg: 165, max: 198 },
        temperature: 98.6,
        caloriesBurned: 1105,
        acceleration: 15,
        biteForce: 140,
        concussionRisk: "Low",
        duration: "2h 05m",
      },
    },
    // --- Add more sessions for history ---
    {
      id: "session_ghi_3",
      type: "Training",
      date: "02/05/2015",
      sport: "Football",
      stats: {
        heartRate: { avg: 140, max: 175 },
        temperature: 98.0,
        caloriesBurned: 650,
        acceleration: 10,
        biteForce: 155,
        concussionRisk: "Low",
        duration: "1h 10m",
      },
    },
  ],
  // --- Simulated Device Connection ---
  isDeviceConnected: true, // Toggle this to test connection status UI
};

export const coachData = {
    players: [
        // Include John Smith using the playerData structure
        { ...playerData },
        // Add other simulated players if needed for Coach View testing
        {
            id: 'player_jane_doe',
            name: 'Jane Doe',
            sessions: [
                {
                    id: "session_jkl_1",
                    type: "Training",
                    date: "02/19/2015",
                    sport: "Soccer",
                    stats: {
                        heartRate: { avg: 160, max: 185 },
                        temperature: 98.4,
                        caloriesBurned: 700,
                        acceleration: 14,
                        biteForce: 130,
                        concussionRisk: "Low",
                        duration: "1h 30m",
                    },
                },
            ],
            isDeviceConnected: true,
        },
        {
            id: 'player_bob_w',
            name: 'Bob Williams',
            sessions: [
                 {
                    id: "session_mno_1",
                    type: "Game",
                    date: "02/18/2015",
                    sport: "Hockey",
                    stats: {
                        heartRate: { avg: 170, max: 200 },
                        temperature: 98.8,
                        caloriesBurned: 1200,
                        acceleration: 18,
                        biteForce: 180,
                        concussionRisk: "Moderate", // Example other risk
                        duration: "2h 15m",
                    },
                },
            ],
            isDeviceConnected: false,
        }
    ]
};

// Sample Data for Testing

// --- Sample Athletes ---
const athlete1Id = 'athlete_1';
const athlete2Id = 'athlete_2';
const athlete3Id = 'athlete_3';

export const SAMPLE_ATHLETES = [
  {
    id: athlete1Id,
    name: 'Alice Johnson',
    team: 'Varsity Soccer',
    position: 'Forward',
    age: 17,
    height: '5\'7"',
    weight: '135 lbs',
    deviceId: 'mouthguard_A', // Assign a device
    notes: 'Previous concussion history (mild).',
    createdAt: Date.now() - 5 * 24 * 60 * 60 * 1000, // 5 days ago
    updatedAt: Date.now() - 1 * 24 * 60 * 60 * 1000, // 1 day ago
  },
  {
    id: athlete2Id,
    name: 'Bob Williams',
    team: 'Varsity Football',
    position: 'Linebacker',
    age: 18,
    height: '6\'1"',
    weight: '210 lbs',
    deviceId: 'mouthguard_B', // Assign a device
    notes: 'No known concussion history.',
    createdAt: Date.now() - 10 * 24 * 60 * 60 * 1000, // 10 days ago
    updatedAt: Date.now() - 2 * 24 * 60 * 60 * 1000, // 2 days ago
  },
  {
    id: athlete3Id,
    name: 'Charlie Brown',
    team: 'JV Hockey',
    position: 'Defenseman',
    age: 16,
    height: '5\'10"',
    weight: '175 lbs',
    deviceId: null, // Unassigned device
    notes: '',
    createdAt: Date.now() - 2 * 24 * 60 * 60 * 1000, // 2 days ago
    updatedAt: Date.now() - 2 * 24 * 60 * 60 * 1000, // 2 days ago
  },
];

// --- Sample Sensor Readings (Illustrative - Generating many is verbose) ---
// Structure: { table: string, data: Array<object> }
// Timestamps should be epoch milliseconds

const generateSensorData = (deviceId: string, sensorId: number, count: number, timeOffsetMs: number) => {
  const data = [];
  const now = Date.now();
  for (let i = 0; i < count; i++) {
    const timestamp = now - timeOffsetMs + (i * 100); // 10Hz data example
    data.push({
      deviceId: deviceId,
      sensorId: sensorId,
      timestamp: timestamp,
      x: (Math.random() - 0.5) * 10, // Example value range
      y: (Math.random() - 0.5) * 10,
      z: (Math.random() - 0.5) * 10,
      createdAt: now,
    });
  }
  return data;
};

export const SAMPLE_SENSOR_READINGS = [
  {
    table: 'imu_data',
    data: [
      ...generateSensorData('mouthguard_A', 1, 5, 60000), // 5 readings, 1 min ago
      ...generateSensorData('mouthguard_B', 1, 3, 30000), // 3 readings, 30 sec ago
    ]
  },
  {
    table: 'accelerometer_data',
    data: [
      // Example high-G reading
      {
        deviceId: 'mouthguard_B', sensorId: 1, timestamp: Date.now() - 10000, // 10 sec ago
        x: 10.5, y: -50.2, z: 95.1, magnitude: 108.3, createdAt: Date.now()
      },
      // Normal readings
      {
        deviceId: 'mouthguard_A', sensorId: 1, timestamp: Date.now() - 5000, // 5 sec ago
        x: 0.1, y: -0.5, z: 1.1, magnitude: 1.2, createdAt: Date.now()
      },
    ]
  },
  {
    table: 'temperature_data',
    data: [
      { deviceId: 'mouthguard_A', sensorId: 1, timestamp: Date.now() - 120000, temperature: 36.5, createdAt: Date.now() },
      { deviceId: 'mouthguard_B', sensorId: 1, timestamp: Date.now() - 110000, temperature: 37.1, createdAt: Date.now() },
    ]
  },
  {
    table: 'force_data',
    data: [
      { deviceId: 'mouthguard_A', sensorId: 1, timestamp: Date.now() - 90000, force: 150.5, createdAt: Date.now() },
      { deviceId: 'mouthguard_B', sensorId: 2, timestamp: Date.now() - 85000, force: 210.0, createdAt: Date.now() },
    ]
  },
  {
    table: 'heart_rate_data',
    data: [
      { deviceId: 'mouthguard_A', timestamp: Date.now() - 15000, heartRate: 85, createdAt: Date.now() },
      { deviceId: 'mouthguard_B', timestamp: Date.now() - 10000, heartRate: 110, createdAt: Date.now() },
    ]
  }
];

// --- Sample Impact Events ---
export const SAMPLE_IMPACT_EVENTS = [
  {
    // id: Automatically generated
    deviceId: 'mouthguard_B',
    athleteId: athlete2Id, // Link to Bob Williams
    timestamp: Date.now() - 10000, // Matches accelerometer reading
    magnitude: 108.3,
    x: 10.5,
    y: -50.2,
    z: 95.1,
    durationMs: 15, // Example duration
    processed: false,
    severity: 'severe', // Example severity
    notes: 'Hit during tackle drill.',
    createdAt: Date.now(),
  },
  {
    deviceId: 'mouthguard_A',
    athleteId: athlete1Id,
    timestamp: Date.now() - 3 * 60 * 1000, // 3 mins ago
    magnitude: 75.2,
    x: -40.1,
    y: 60.5,
    z: 15.0,
    durationMs: 12,
    processed: false,
    severity: 'moderate',
    notes: null,
    createdAt: Date.now(),
  },
];

// --- Sample Sessions ---
const session1Id = 'session_1';
const session2Id = 'session_2';

export const SAMPLE_SESSIONS = [
  {
    id: session1Id,
    name: 'Morning Practice - Soccer',
    startTime: Date.now() - 2 * 60 * 60 * 1000, // 2 hours ago
    endTime: Date.now() - 1 * 60 * 60 * 1000, // 1 hour ago
    team: 'Varsity Soccer',
    createdAt: Date.now() - 2 * 60 * 60 * 1000,
    notes: 'Focused on endurance.',
  },
  {
    id: session2Id,
    name: 'Scrimmage - Football',
    startTime: Date.now() - 26 * 60 * 60 * 1000, // Yesterday
    endTime: Date.now() - 24 * 60 * 60 * 1000, // Yesterday
    team: 'Varsity Football',
    createdAt: Date.now() - 26 * 60 * 60 * 1000,
    notes: 'Full contact scrimmage.',
  }
];

// --- Sample Session Athletes (Link athletes to sessions) ---
export const SAMPLE_SESSION_ATHLETES = [
  { sessionId: session1Id, athleteId: athlete1Id, startTime: Date.now() - 2 * 60 * 60 * 1000, endTime: Date.now() - 1 * 60 * 60 * 1000 },
  { sessionId: session2Id, athleteId: athlete2Id, startTime: Date.now() - 26 * 60 * 60 * 1000, endTime: Date.now() - 24 * 60 * 60 * 1000 },
  // Add more links as needed
];

// --- Sample Calibration Data ---
export const SAMPLE_CALIBRATION_DATA = [
  {
    deviceId: 'mouthguard_A',
    sensorType: 'accelerometer',
    timestamp: Date.now() - 7 * 24 * 60 * 60 * 1000, // 7 days ago
    offsetX: 0.1, offsetY: -0.05, offsetZ: 0.02,
    scaleX: 1.01, scaleY: 0.99, scaleZ: 1.00,
    createdAt: Date.now() - 7 * 24 * 60 * 60 * 1000,
  },
  {
    deviceId: 'mouthguard_B',
    sensorType: 'imu',
    timestamp: Date.now() - 6 * 24 * 60 * 60 * 1000, // 6 days ago
    offsetX: -0.2, offsetY: 0.1, offsetZ: -0.08,
    scaleX: 0.98, scaleY: 1.02, scaleZ: 0.99,
    createdAt: Date.now() - 6 * 24 * 60 * 60 * 1000,
  }
];

// Function to generate OLD Canova insert statements (REMOVE LATER)
export function getInsertStatements(): string {
    return(`
insert into BongHits (timestamp, duration_ms) values ('2024-12-26 18:28:33', 27050);
insert into BongHits (timestamp, duration_ms) values ('2025-01-03 03:31:57', 12228);
insert into BongHits (timestamp, duration_ms) values ('2024-12-30 23:51:43', 13319);
insert into BongHits (timestamp, duration_ms) values ('2024-12-28 17:23:17', 18857);
insert into BongHits (timestamp, duration_ms) values ('2024-12-30 11:04:59', 10164);
insert into BongHits (timestamp, duration_ms) values ('2025-01-05 12:15:16', 17533);
insert into BongHits (timestamp, duration_ms) values ('2024-12-24 14:02:16', 6253);
insert into BongHits (timestamp, duration_ms) values ('2024-12-29 08:19:24', 16822);
insert into BongHits (timestamp, duration_ms) values ('2024-12-26 08:59:23', 22545);
insert into BongHits (timestamp, duration_ms) values ('2025-01-03 00:18:00', 8259);
insert into BongHits (timestamp, duration_ms) values ('2024-12-24 04:04:13', 2611);
`)
}

================================================================================
File: src/contexts/BluetoothContext.ts
================================================================================

import { createContext } from "react";
import { Alert, PermissionsAndroid, Platform } from "react-native";
import * as ExpoDevice from "expo-device";
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';
import base64 from "react-native-base64";
import { parseRawTimestamp } from "../utils/functions";
import AsyncStorage from "@react-native-async-storage/async-storage";

// Storage key for device UUIDs
const DEVICE_UUIDS_STORAGE_KEY = "MOUTHGUARD_DEVICE_UUIDS";

// Define UUIDs for mouthguard services
const SERVICE_UUIDS = {
  BATTERY: '0x180F',
  IMU: 'c8553001-5a23-4b2e-b161-b22252abb885', // Custom UUID for IMU
  ACCELEROMETER: 'c8553002-5a23-4b2e-b161-b22252abb885', // Custom UUID for accelerometer
  TEMPERATURE: 'c8553003-5a23-4b2e-b161-b22252abb885', // Custom UUID for temperature
  FORCE: 'c8553004-5a23-4b2e-b161-b22252abb885', // Custom UUID for force sensor
  HEART_RATE: '0x180D' // Standard UUID for heart rate
};

// Define UUIDs for characteristics
const CHARACTERISTIC_UUIDS = {
  BATTERY_LEVEL: '0x2A19',
  IMU_1: 'c8553101-5a23-4b2e-b161-b22252abb885',
  IMU_2: 'c8553102-5a23-4b2e-b161-b22252abb885',
  ACCEL_1: 'c8553201-5a23-4b2e-b161-b22252abb885',
  ACCEL_2: 'c8553202-5a23-4b2e-b161-b22252abb885',
  TEMP_1: 'c8553301-5a23-4b2e-b161-b22252abb885',
  TEMP_2: 'c8553302-5a23-4b2e-b161-b22252abb885',
  FORCE_1: 'c8553401-5a23-4b2e-b161-b22252abb885',
  FORCE_2: 'c8553402-5a23-4b2e-b161-b22252abb885',
  HEART_RATE_MEASUREMENT: '0x2A37'
};

// Interface for state restoration event based on react-native-ble-plx implementation
interface StateRestoredEvent {
    connectedPeripherals: Device[];
}

// Updated to support multiple sensor data
type SensorData = {
  timestamp: number;
  values: number[];
};

// Updated to handle multiple service/characteristic pairs
type ConnectedDevice = {
    device: Device;
    services: {
      [key: string]: {
        uuid: string;
        characteristics: {
          [key: string]: string;
        }
      }
    }
}

type StoredDeviceUUIDs = {
    [deviceId: string]: {
        services: {
          [serviceName: string]: {
            uuid: string;
            characteristics: {
              [characteristicName: string]: string;
            }
          }
        }
    }
}

// Callbacks for different sensor types
export interface SensorCallbacks {
  onImuData?: (deviceId: string, sensorId: number, data: SensorData) => void;
  onAccelerometerData?: (deviceId: string, sensorId: number, data: SensorData) => void;
  onTemperatureData?: (deviceId: string, sensorId: number, data: SensorData) => void;
  onForceData?: (deviceId: string, sensorId: number, data: SensorData) => void;
  onHeartRateData?: (deviceId: string, heartRate: number) => void;
  onBatteryLevel?: (deviceId: string, level: number) => void;
}

// Create a context with a default undefined value
export const BluetoothContext = createContext<BluetoothHandler | undefined>(undefined);

export class BluetoothHandler {
    private manager: BleManager;
    private connectedDevices: Map<string, ConnectedDevice>; // Support multiple devices
    private callbacks: SensorCallbacks = {};
    private isRestoringState: boolean = false;

    constructor() {
        console.log('[BluetoothHandler] Initializing BleManager with state restoration');
        this.manager = new BleManager({
            // Unique identifier for state restoration
            restoreStateIdentifier: "MouthguardAppBluetoothRestoreID",

            // Function called when state is restored
            restoreStateFunction: this.handleStateRestoration.bind(this)
        });
        this.connectedDevices = new Map();
    }

    /**
     * Handle BLE state restoration when app is relaunched in background
     */
    private async handleStateRestoration(restoredState: StateRestoredEvent | null) {
        try {
            if (!restoredState) {
                console.log("[BluetoothHandler] No BLE state to restore.");
                return;
            }
            
            this.isRestoringState = true;
            console.log("[BluetoothHandler] Restoring BLE state...");
            
            // Get the previously connected peripherals
            const connectedPeripherals = restoredState.connectedPeripherals || [];
            console.log(`[BluetoothHandler] Found ${connectedPeripherals.length} connected peripheral(s) in restored state.`);
            
            if (connectedPeripherals.length === 0) {
                console.log("[BluetoothHandler] No connected peripherals to restore.");
                this.isRestoringState = false;
                return;
            }
            
            try {
                // Get stored device UUIDs from AsyncStorage
                const storedUUIDs = await this.getStoredUUIDs();
                
                for (const peripheral of connectedPeripherals) {
                    if (!peripheral || !peripheral.id) {
                        console.warn("[BluetoothHandler] Invalid peripheral in restored state");
                        continue;
                    }
                    
                    console.log(`[BluetoothHandler] Attempting to restore connection for device: ${peripheral.id}`);
                    
                    // Check if we have stored UUIDs for this device
                    if (storedUUIDs && storedUUIDs[peripheral.id]) {
                        const deviceServices = storedUUIDs[peripheral.id].services;
                        
                        if (!deviceServices) {
                            console.warn(`[BluetoothHandler] No service UUIDs for device ${peripheral.id}`);
                            continue;
                        }
                        
                        // Create connected device object to store
                        const connectedDevice: ConnectedDevice = {
                            device: peripheral,
                            services: deviceServices
                        };
                        
                        // Add to connected devices map
                        this.connectedDevices.set(peripheral.id, connectedDevice);
                        
                        // Re-establish characteristic monitoring for all services/characteristics
                        this.setupMonitoringForDevice(peripheral.id);
                    } else {
                        console.warn(`[BluetoothHandler] No stored UUIDs found for device ${peripheral.id}`);
                    }
                }
            } catch (storageError) {
                console.error('[BluetoothHandler] Error accessing stored UUIDs:', storageError);
            }
        } catch (error) {
            console.error('[BluetoothHandler] Error during state restoration:', error);
        } finally {
            // Always reset the restoration flag to prevent lock-ups
            this.isRestoringState = false;
        }
    }

    /**
     * Get stored service and characteristic UUIDs for devices
     */
    private async getStoredUUIDs(): Promise<StoredDeviceUUIDs | null> {
        try {
            const uuidsJson = await AsyncStorage.getItem(DEVICE_UUIDS_STORAGE_KEY);
            if (!uuidsJson) return null;
            
            // Safely parse JSON
            try {
                return JSON.parse(uuidsJson);
            } catch (parseError) {
                console.error('[BluetoothHandler] Error parsing stored UUIDs JSON:', parseError);
                return null;
            }
        } catch (error) {
            console.error('[BluetoothHandler] Error retrieving stored UUIDs:', error);
            // Don't throw error, just return null to prevent app crashes
            return null;
        }
    }

    /**
     * Store service and characteristic UUIDs for a device
     */
    private async storeDeviceUUIDs(deviceId: string, services: ConnectedDevice['services']): Promise<void> {
        try {
            // Get existing stored UUIDs
            const existingUUIDs = await this.getStoredUUIDs() || {};
            
            // Add or update the UUIDs for this device
            existingUUIDs[deviceId] = { services };
            
            // Store the updated UUIDs
            const jsonValue = JSON.stringify(existingUUIDs);
            await AsyncStorage.setItem(DEVICE_UUIDS_STORAGE_KEY, jsonValue);
            console.log(`[BluetoothHandler] Stored UUIDs for device ${deviceId}`);
        } catch (error) {
            // Log but don't throw to prevent app crashes
            console.error('[BluetoothHandler] Error storing device UUIDs:', error);
        }
    }

    // Set callbacks for sensor data
    public setSensorCallbacks(callbacks: SensorCallbacks): void {
        this.callbacks = { ...this.callbacks, ...callbacks };
    }

    public async connectToDevice(deviceId: string) {
        try {
            console.log(`[BluetoothHandler] Connecting to device ${deviceId}`);
            const deviceConnection: Device = await this.manager.connectToDevice(deviceId);
            await deviceConnection.discoverAllServicesAndCharacteristics();
            
            const services = await deviceConnection.services();
            console.log(`[BluetoothHandler] Discovered ${services.length} services`);
            
            // Initialize empty structure for service/characteristic UUIDs
            const connectedDevice: ConnectedDevice = {
                device: deviceConnection,
                services: {}
            };
            
            for (const service of services) {
                console.log(`[BluetoothHandler] Processing service: ${service.uuid}`);
                const characteristics = await service.characteristics();
                
                // Initialize empty characteristics mapping
                connectedDevice.services[service.uuid] = {
                    uuid: service.uuid,
                    characteristics: {}
                };
                
                for (const characteristic of characteristics) {
                    console.log(`[BluetoothHandler] - Characteristic: ${characteristic.uuid}`);
                    connectedDevice.services[service.uuid].characteristics[characteristic.uuid] = characteristic.uuid;
                }
            }
            
            // Store the device in our map
            this.connectedDevices.set(deviceId, connectedDevice);
            
            // Store UUIDs for later restoration
            await this.storeDeviceUUIDs(deviceId, connectedDevice.services);
            
            // Set up monitoring for all characteristics
            this.setupMonitoringForDevice(deviceId);
            
            console.log(`[BluetoothHandler] Successfully connected to device ${deviceId}`);
            
            return true;
        } catch (error) {
            console.error(`[BluetoothHandler] Error connecting to device ${deviceId}:`, error);
            throw error;
        } finally {
            this.manager.stopDeviceScan();
        }
    }

    private setupMonitoringForDevice(deviceId: string) {
        const device = this.connectedDevices.get(deviceId);
        if (!device) {
            console.error(`[BluetoothHandler] Device ${deviceId} not found for monitoring setup`);
            return;
        }
        
        console.log(`[BluetoothHandler] Setting up monitoring for device ${deviceId}`);
        
        // For each service
        Object.entries(device.services).forEach(([serviceUuid, service]) => {
            // For each characteristic in the service
            Object.entries(service.characteristics).forEach(([characteristicUuid, _]) => {
                try {
                    console.log(`[BluetoothHandler] - Monitoring ${serviceUuid}/${characteristicUuid}`);
                    
                    // Set up monitoring for this characteristic
                    device.device.monitorCharacteristicForService(
                        serviceUuid,
                        characteristicUuid,
                        (error, characteristic) => this.handleCharacteristicUpdate(
                            deviceId, serviceUuid, characteristicUuid, error, characteristic
                        )
                    );
                } catch (error) {
                    console.error(`[BluetoothHandler] Error setting up monitoring for ${serviceUuid}/${characteristicUuid}:`, error);
                }
            });
        });
        
        console.log(`[BluetoothHandler] Monitoring setup complete for device ${deviceId}`);
    }

    public disconnectFromDevice(deviceId: string) {
        const device = this.connectedDevices.get(deviceId)?.device;
        if (device) {
            this.manager.cancelDeviceConnection(deviceId);
            this.connectedDevices.delete(deviceId);
            console.log(`[BluetoothHandler] Disconnected from device ${deviceId}`);
        } else {
            console.warn(`[BluetoothHandler] Attempted to disconnect from unknown device ${deviceId}`);
        }
    }

    private handleCharacteristicUpdate(
        deviceId: string, 
        serviceUuid: string, 
        characteristicUuid: string,
        error: BleError | null, 
        characteristic: Characteristic | null
    ) {
        if (error) {
            console.error(`[BluetoothHandler] Error from ${serviceUuid}/${characteristicUuid}:`, error);
            return;
        }
        
        if (!characteristic?.value) {
            console.warn(`[BluetoothHandler] No data received from ${serviceUuid}/${characteristicUuid}`);
            return;
        }
        
        try {
            const buffer = Buffer.from(characteristic.value, 'base64');
            
            // Process based on service/characteristic
            if (serviceUuid === SERVICE_UUIDS.BATTERY && characteristicUuid === CHARACTERISTIC_UUIDS.BATTERY_LEVEL) {
                // Handle battery level
                const level = buffer.readUInt8(0);
                console.log(`[BluetoothHandler] Battery level: ${level}%`);
                if (this.callbacks.onBatteryLevel) {
                    this.callbacks.onBatteryLevel(deviceId, level);
                }
            } 
            else if (serviceUuid === SERVICE_UUIDS.HEART_RATE && characteristicUuid === CHARACTERISTIC_UUIDS.HEART_RATE_MEASUREMENT) {
                // Handle heart rate
                // Format according to GATT specification for Heart Rate Measurement
                const flags = buffer.readUInt8(0);
                const heartRate = (flags & 0x1) === 0 ? buffer.readUInt8(1) : buffer.readUInt16LE(1);
                console.log(`[BluetoothHandler] Heart rate: ${heartRate} BPM`);
                if (this.callbacks.onHeartRateData) {
                    this.callbacks.onHeartRateData(deviceId, heartRate);
                }
            } 
            else if (serviceUuid === SERVICE_UUIDS.IMU) {
                // Handle IMU data
                const sensorId = characteristicUuid === CHARACTERISTIC_UUIDS.IMU_1 ? 1 : 2;
                const timestamp = buffer.readUInt32LE(0);
                const x = buffer.readInt16LE(4);
                const y = buffer.readInt16LE(6);
                const z = buffer.readInt16LE(8);
                console.log(`[BluetoothHandler] IMU ${sensorId} data: t=${timestamp}, x=${x}, y=${y}, z=${z}`);
                if (this.callbacks.onImuData) {
                    this.callbacks.onImuData(deviceId, sensorId, {
                        timestamp,
                        values: [x, y, z]
                    });
                }
            } 
            else if (serviceUuid === SERVICE_UUIDS.ACCELEROMETER) {
                // Handle accelerometer data
                const sensorId = characteristicUuid === CHARACTERISTIC_UUIDS.ACCEL_1 ? 1 : 2;
                const timestamp = buffer.readUInt32LE(0);
                const x = buffer.readInt16LE(4);
                const y = buffer.readInt16LE(6);
                const z = buffer.readInt16LE(8);
                console.log(`[BluetoothHandler] Accelerometer ${sensorId} data: t=${timestamp}, x=${x}, y=${y}, z=${z}`);
                if (this.callbacks.onAccelerometerData) {
                    this.callbacks.onAccelerometerData(deviceId, sensorId, {
                        timestamp,
                        values: [x, y, z]
                    });
                }
            } 
            else if (serviceUuid === SERVICE_UUIDS.TEMPERATURE) {
                // Handle temperature data
                const sensorId = characteristicUuid === CHARACTERISTIC_UUIDS.TEMP_1 ? 1 : 2;
                const timestamp = buffer.readUInt32LE(0);
                const temperature = buffer.readInt16LE(4); // Temperature in 0.01 degree units
                console.log(`[BluetoothHandler] Temperature ${sensorId} data: t=${timestamp}, temp=${temperature/100}C`);
                if (this.callbacks.onTemperatureData) {
                    this.callbacks.onTemperatureData(deviceId, sensorId, {
                        timestamp,
                        values: [temperature]
                    });
                }
            } 
            else if (serviceUuid === SERVICE_UUIDS.FORCE) {
                // Handle force sensor data
                const sensorId = characteristicUuid === CHARACTERISTIC_UUIDS.FORCE_1 ? 1 : 2;
                const timestamp = buffer.readUInt32LE(0);
                const force = buffer.readUInt8(4); // Force as 8-bit value
                console.log(`[BluetoothHandler] Force ${sensorId} data: t=${timestamp}, force=${force}`);
                if (this.callbacks.onForceData) {
                    this.callbacks.onForceData(deviceId, sensorId, {
                        timestamp,
                        values: [force]
                    });
                }
            }
        } catch (error) {
            console.error(`[BluetoothHandler] Error processing data from ${serviceUuid}/${characteristicUuid}:`, error);
        }
    }

    /**
     * Sync time with all connected mouthguard devices
     */
    public async syncTimeWithAllDevices(): Promise<void> {
        for (const [deviceId, _] of this.connectedDevices) {
            await this.syncTimeWithDevice(deviceId);
        }
    }

    /**
     * Sync time with a specific mouthguard device
     */
    private async syncTimeWithDevice(deviceId: string): Promise<boolean> {
        const device = this.connectedDevices.get(deviceId);
        if (!device) {
            console.error(`[BluetoothHandler] Device ${deviceId} not found for time sync`);
            return false;
        }
        
        try {
            // Calculate current timestamp and timezone offset
            const timestamp = Math.floor(Date.now() / 1000); // Seconds, not milliseconds
            const gmtOffset = new Date().getTimezoneOffset() * 60;  // Offset in seconds
            const base64Timestamp = base64.encode(`${timestamp},${gmtOffset}`);
            
            // Find the time sync characteristic (choose one that's appropriate)
            // We'll use IMU service for time sync as a convention
            const imuService = Object.entries(device.services).find(([uuid, _]) => uuid === SERVICE_UUIDS.IMU);
            
            if (!imuService) {
                console.error(`[BluetoothHandler] IMU service not found for time sync`);
                return false;
            }
            
            const [serviceUuid, service] = imuService;
            const characteristicUuid = Object.keys(service.characteristics)[0]; // Use first characteristic
            
            if (!characteristicUuid) {
                console.error(`[BluetoothHandler] No characteristic found for time sync`);
                return false;
            }
            
            // Write the timestamp
            await this.manager.writeCharacteristicWithResponseForDevice(
                deviceId,
                serviceUuid,
                characteristicUuid,
                base64Timestamp
            );
            
            console.log(`[BluetoothHandler] Time sync sent to device ${deviceId}: ${timestamp}, GMT offset ${gmtOffset}`);
            return true;
        } catch (error) {
            console.error(`[BluetoothHandler] Error syncing time with device ${deviceId}:`, error);
            return false;
        }
    }

    public getBLEManager(): BleManager {
        return this.manager;
    }

    public getConnectedDevices(): Map<string, Device> {
        // Return just the Device objects, not the full ConnectedDevice
        const devices = new Map<string, Device>();
        for (const [deviceId, connectedDevice] of this.connectedDevices) {
            devices.set(deviceId, connectedDevice.device);
        }
        return devices;
    }

    /*
     * Requests bluetooth permissions, accounting for platform differences
     */
    public async requestPermissions() {
        if (Platform.OS === "android") {
            if ((ExpoDevice.platformApiLevel ?? -1) < 31) {
                // Android version below 31
                const granted = await PermissionsAndroid.request(
                    PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
                    {
                        title: "Location Permission",
                        message: "Bluetooth Low Energy requires Location",
                        buttonPositive: "OK",
                    }
                );
                return granted === PermissionsAndroid.RESULTS.GRANTED;
            } else {
                // Android version above 31
                const isAndroid31PermissionsGranted = await this.requestAndroid31Permissions();

                return isAndroid31PermissionsGranted;
            }
        } else {
            //ios
            return true;
        }
    }

    private async requestAndroid31Permissions() {
        const bluetoothScanPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_SCAN,
            {
                title: "Bluetooth Scan Permission",
                message: "Required to discover mouthguard devices",
                buttonPositive: "OK",
            }
        );
        const bluetoothConnectPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_CONNECT,
            {
                title: "Bluetooth Connect Permission",
                message: "Required to connect to mouthguard devices",
                buttonPositive: "OK",
            }
        );
        const fineLocationPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );

        return (
            bluetoothScanPermission === "granted" &&
            bluetoothConnectPermission === "granted" &&
            fineLocationPermission === "granted"
        );
    }
}


================================================================================
File: src/DatabaseManager.ts
================================================================================

// File: src/DatabaseManager.ts
// Refactored DatabaseManager that focuses on database connection management and migrations.

import AsyncStorage from "@react-native-async-storage/async-storage";
import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import { migrations } from "./migrations";
import * as FileSystem from 'expo-file-system';
import { Platform } from 'react-native';

// Export constants for use by other modules
export const DB_VERSION_KEY = "dbVersion";
export const CURRENT_DB_VERSION = 3;
export const MOUTHGUARD_DB_NAME = "mouthguardMonitor.db";

/**
 * DatabaseManager: Handles database connections and migrations
 */
export class DatabaseManager {
  private databaseConnections: Map<string, SQLiteDatabase> = new Map();
  private initialized: boolean = false;
  private initializationPromise: Promise<void> | null = null;
  private static instance: DatabaseManager;
  private instanceId: number; // Add unique ID for debugging

  /**
   * Get the singleton instance of DatabaseManager
   */
  public static getInstance(): DatabaseManager {
    if (!DatabaseManager.instance) {
      console.log('[DatabaseManager getInstance] Creating FIRST instance...');
      DatabaseManager.instance = new DatabaseManager();
    } else {
      // Log the ID of the existing instance being returned
      console.log(`[DatabaseManager getInstance] Returning EXISTING instance ID: ${DatabaseManager.instance.instanceId}`);
    }
    return DatabaseManager.instance;
  }

  /**
   * Constructor for DatabaseManager
   */
  public constructor() {
    this.instanceId = Math.random(); // Assign unique ID
    console.log(`[DatabaseManager CONSTRUCTOR] New instance created with ID: ${this.instanceId}`);
  }

  /**
   * Initializes all databases and manages migrations
   */
  public async initialize(options: { forceCleanup?: boolean, forceRun?: boolean } = {}): Promise<void> {
    // If forced cleanup is requested, close existing connections first
    if (options.forceCleanup) {
      await this.cleanup();
      this.initialized = false; // Reset initialized state after cleanup
    }

    // If already initialized, return immediately unless forceRun is true
    if (this.initialized && !options.forceRun) {
      return;
    }
    
    // If initialization is in progress, wait for it to complete
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    
    console.info('[DatabaseManager] Initializing databases...');
    
    // Create a promise for initialization
    this.initializationPromise = this.doInitialize(options.forceRun).finally(() => {
      this.initializationPromise = null;
    });
    
    return this.initializationPromise;
  }

  /**
   * Internal method to perform actual initialization logic
   */
  private async doInitialize(forceRun: boolean = false): Promise<void> {
    try {
      console.log('[DatabaseManager] Starting database initialization...');
      
      // Get current DB version
      const storedVersion = parseInt(await AsyncStorage.getItem(DB_VERSION_KEY) || '0');
      console.log(`[DatabaseManager] Current stored database version: ${storedVersion}, Latest version: ${CURRENT_DB_VERSION}`);
      
      // Check if we need to update/initialize
      if (storedVersion < CURRENT_DB_VERSION || forceRun) {
        // First open the database connection directly without using getDatabase
        // to avoid circular dependencies
        let dbName = MOUTHGUARD_DB_NAME;
        // Ensure dbName has .db extension
        if (!dbName.endsWith('.db')) {
          dbName = `${dbName}.db`;
        }
        console.log(`[DatabaseManager] Opening database for migrations directly: ${dbName}`);
        const db = await openDatabaseAsync(dbName);
        console.log(`[DatabaseManager] Database connection obtained for migrations`);
        
        // Store the connection
        this.databaseConnections.set(dbName, db);
        
        // Run migrations
        await this.runMigrations(forceRun ? 0 : storedVersion, db);
      } else {
        // Open main database through normal path
        await this.getDatabase(MOUTHGUARD_DB_NAME);
      }
      
      this.initialized = true;
      console.log('[DatabaseManager] Database initialization complete');
    } catch (error) {
      console.error('[DatabaseManager] Initialization error', error);
      throw error;
    }
  }

  /**
   * Run database migrations from current version to latest
   */
  private async runMigrations(currentVersion: number, db: SQLiteDatabase): Promise<void> {
    console.log(`[DatabaseManager] Running migrations from version ${currentVersion} to ${CURRENT_DB_VERSION}`);

    // Apply sequential migrations
    for (let ver = currentVersion + 1; ver <= CURRENT_DB_VERSION; ver++) {
      console.log(`[DatabaseManager] Applying migration to version ${ver}`);
      const migration = migrations[ver];
      
      if (!migration) {
        console.warn(`[DatabaseManager] Migration for version ${ver} not found`);
        continue;
      }
      
      console.log(`[DatabaseManager] Starting migration for version ${ver}`);
      try {
        // Execute migration directly
        await migration.up(db);
        console.log(`[DatabaseManager] Migration to version ${ver} succeeded`);
      } catch (error) {
        console.error(`[DatabaseManager] Migration to version ${ver} failed:`, error);
        throw error;
      }
    }
    
    // Update stored version in AsyncStorage
    console.log(`[DatabaseManager] Updating stored DB version to ${CURRENT_DB_VERSION}`);
    await AsyncStorage.setItem(DB_VERSION_KEY, CURRENT_DB_VERSION.toString());
    console.log(`[DatabaseManager] Migrations complete. Current version: ${CURRENT_DB_VERSION}`);
  }

  /**
   * Ensure database manager is initialized
   */
  public async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }

  /**
   * Get a database connection by name
   */
  public async getDatabase(dbName: string): Promise<SQLiteDatabase> {
    // Ensure consistent naming with .db extension
    if (!dbName.endsWith('.db')) {
      dbName = `${dbName}.db`;
      console.log(`[DatabaseManager getDatabase] Added .db extension to ensure consistency: ${dbName}`);
    }
  
    // Check if we already have a connection
    if (this.databaseConnections.has(dbName)) {
      const existingDb = this.databaseConnections.get(dbName)!;
      console.log(`[DatabaseManager getDatabase] Returning existing connection for ${dbName} from instance ID: ${this.instanceId}`);
      return existingDb;
    }
    
    console.log(`[DatabaseManager getDatabase] Opening database: ${dbName} from instance ID: ${this.instanceId}`);
    
    try {
      // Open database connection
      const db = await openDatabaseAsync(dbName);
      console.log(`[DatabaseManager getDatabase] Opened NEW connection for ${dbName} from instance ID: ${this.instanceId}`);
      
      // Store connection
      this.databaseConnections.set(dbName, db);
      
      return db;
    } catch (error) {
      console.error(`[DatabaseManager] Error opening database ${dbName}:`, error);
      throw error;
    }
  }

  /**
   * Close all database connections
   */
  public async cleanup(): Promise<void> {
    const promises: Promise<void>[] = [];
    
    console.log('[DatabaseManager] Cleaning up database connections');
    
    // Close each connection - convert Map.entries() to Array first to fix iterator issues
    const connections = Array.from(this.databaseConnections.entries());
    for (const [name, db] of connections) {
      console.log(`[DatabaseManager] Closing database: ${name}`);
      promises.push(db.closeAsync());
    }
    
    // Wait for all connections to close
    await Promise.all(promises);
    
    // Clear connection map
    this.databaseConnections.clear();
  }

  /**
   * Reset database by removing all data
   */
  public async resetDatabase(): Promise<void> {
    try {
      console.log('[DatabaseManager] Resetting database...');
      
      // First close all connections
      await this.cleanup();
      
      // Clear version from AsyncStorage
      await AsyncStorage.removeItem(DB_VERSION_KEY);
      
      // On iOS, we can delete the database files directly
      if (Platform.OS === 'ios') {
        const databaseDir = `${FileSystem.documentDirectory}SQLite`;
        const entries = await FileSystem.readDirectoryAsync(databaseDir);
        
        for (const entry of entries) {
          if (entry.endsWith('.db') || entry.endsWith('-journal') || entry.endsWith('-wal') || entry.endsWith('-shm')) {
            await FileSystem.deleteAsync(`${databaseDir}/${entry}`, { idempotent: true });
          }
        }
      }
      
      // Re-initialize databases
      this.initialized = false;
      await this.initialize();
      
      console.log('[DatabaseManager] Database reset complete');
    } catch (error) {
      console.error('[DatabaseManager] Error resetting database:', error);
      throw error;
    }
  }
}

// Export a singleton instance
export const databaseManager = DatabaseManager.getInstance(); 

================================================================================
File: src/dbchecker/dbValidator.ts
================================================================================

import { databaseManager } from "../DatabaseManager";
import { 
  BONG_HITS_DATABASE_NAME, 
  STRAINS_DATABASE_NAME 
} from "../constants";
import { DatabaseResponse, Strain } from "../types";

/**
 * DbValidator - Utility to validate the database implementation
 * Runs a series of checks to verify that everything is working correctly
 */
export class DbValidator {
  public static async validateDatabaseSetup(): Promise<ValidationResult> {
    console.log('[DbValidator] Starting database validation...');
    const results: ValidationResult = {
      success: true,
      errors: [],
      warnings: [],
      componentResults: {},
    };

    // Validate database manager
    try {
      await this.validateDatabaseManager(results);
    } catch (error) {
      results.success = false;
      results.errors.push(`DatabaseManager validation failed: ${error instanceof Error ? error.message : String(error)}`);
    }

    console.log('[DbValidator] Database validation completed.');
    console.log('[DbValidator] Success:', results.success);
    
    if (results.errors.length) {
      console.error('[DbValidator] Errors:', results.errors);
    }
    
    if (results.warnings.length) {
      console.warn('[DbValidator] Warnings:', results.warnings);
    }

    return results;
  }

  private static async validateDatabaseManager(results: ValidationResult): Promise<void> {
    console.log('[DbValidator] Validating DatabaseManager...');
    
    // Check if we can initialize
    await databaseManager.ensureInitialized();
    
    // Check if database connections work
    const bongHitsDb = await databaseManager.getDatabase(BONG_HITS_DATABASE_NAME);
    const strainsDb = await databaseManager.getDatabase(STRAINS_DATABASE_NAME);
    
    // Validate BongHits table exists
    try {
      const bongHitsTableInfo = await bongHitsDb.getAllAsync('PRAGMA table_info(bong_hits)');
      results.componentResults.bongHitsTableExists = bongHitsTableInfo.length > 0;
      
      if (!results.componentResults.bongHitsTableExists) {
        results.warnings.push('BongHits table does not exist');
      }
    } catch (error) {
      results.componentResults.bongHitsTableExists = false;
      results.warnings.push(`Error checking BongHits table: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Validate Strains table exists
    try {
      const strainsTableInfo = await strainsDb.getAllAsync('PRAGMA table_info(strains)');
      results.componentResults.strainsTableExists = strainsTableInfo.length > 0;
      
      if (!results.componentResults.strainsTableExists) {
        results.warnings.push('Strains table does not exist');
      }
    } catch (error) {
      results.componentResults.strainsTableExists = false;
      results.warnings.push(`Error checking Strains table: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if transactions work
    try {
      await databaseManager.executeTransactionByName(BONG_HITS_DATABASE_NAME, async (db) => {
        const result = await db.getAllAsync('SELECT 1 as test');
        return result;
      });
      results.componentResults.transactionsWork = true;
    } catch (error) {
      results.componentResults.transactionsWork = false;
      results.errors.push(`Transactions failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can get weekly stats
    try {
      const weeklyStats = await databaseManager.getWeeklyStats();
      results.componentResults.weeklyStatsWork = weeklyStats.success;
      
      if (!weeklyStats.success) {
        results.warnings.push(`Weekly stats failed: ${weeklyStats.error}`);
      }
    } catch (error) {
      results.componentResults.weeklyStatsWork = false;
      results.warnings.push(`Weekly stats failed with exception: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can get strain data
    try {
      const popularStrains: Strain[] = await databaseManager.getPopularStrains(1);
      if (popularStrains && popularStrains.length > 0) {
        results.componentResults.strainsDataWorks = true;
      } else {
        results.componentResults.strainsDataWorks = false;
        results.warnings.push('No strain data returned');
      }
    } catch (error) {
      results.componentResults.strainsDataWorks = false;
      results.warnings.push(`Strain data retrieval failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can perform AsyncStorage operations
    try {
      const testKey = 'dbValidator_test';
      const testValue = { test: true, timestamp: Date.now() };
      
      await databaseManager.setValue(testKey, testValue);
      const retrievedValue = await databaseManager.getValue<{ test: boolean; timestamp: number }>(testKey);
      
      results.componentResults.asyncStorageWorks = 
        retrievedValue !== null && typeof retrievedValue === 'object' && 'test' in retrievedValue;
      
      // Clean up
      await databaseManager.removeValue(testKey);
    } catch (error) {
      results.componentResults.asyncStorageWorks = false;
      results.errors.push(`AsyncStorage operations failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    console.log('[DbValidator] DatabaseManager validation completed');
  }
}

export interface ValidationResult {
  success: boolean;
  errors: string[];
  warnings: string[];
  componentResults: {
    [key: string]: boolean | undefined;
    bongHitsTableExists?: boolean;
    strainsTableExists?: boolean;
    transactionsWork?: boolean;
    asyncStorageWorks?: boolean;
    expoSqliteWorks?: boolean;
    weeklyStatsWork?: boolean;
    strainsDataWorks?: boolean;
  };
}

// Export a function to run the validation
export async function validateDatabase(): Promise<ValidationResult> {
  return DbValidator.validateDatabaseSetup();
}

export default validateDatabase; 

================================================================================
File: src/migrations/index.ts
================================================================================

// src/migrations/index.ts
// Registry for all migrations to enable static imports

import * as v1 from './v1';
// Import future migration versions here
import * as v2 from './v2';
import * as v3 from './v3';

/**
 * Migration module interface
 */
export interface MigrationModule {
  up: (db: any) => Promise<void>;
  down?: (db: any) => Promise<void>;
}

/**
 * Migrations registry
 * Maps version numbers to migration modules
 */
export const migrations: Record<number, MigrationModule> = {
  1: v1,
  // Add future migrations here as they are created
  2: v2,
  3: v3,
}; 

================================================================================
File: src/migrations/v1.ts
================================================================================

import { SQLiteDatabase } from 'expo-sqlite';

// Helper to execute schema - breaking statements by semicolons
async function executeSchema(db: SQLiteDatabase, schema: string): Promise<void> {
  console.log(`[executeSchema] Starting execution of schema with ${schema.split(';').filter(s => s.trim() !== '').length} statements`);
  const statements = schema.split(';').filter(s => s.trim() !== '');
  for (let i = 0; i < statements.length; i++) {
    const statement = statements[i].trim() + ';';
    try {
      console.log(`[executeSchema] Executing statement ${i+1}/${statements.length}: ${statement.substring(0, 50)}...`);
      await db.execAsync(statement);
      console.log(`[executeSchema] Statement ${i+1} executed successfully`);
    } catch (error) {
      console.error(`[executeSchema] Error executing statement ${i+1}: ${error}`);
      console.error(`[executeSchema] Full statement that failed: ${statement}`);
      throw error;
    }
  }
  console.log(`[executeSchema] Schema execution completed successfully`);
}

/**
 * Migration v1: Creates initial schemas for all databases
 */
export async function up(db: SQLiteDatabase): Promise<void> {
  console.log('[Migration V1] Applying migration...');

  try {
    // Athletes Table Schema
    const athletesSchema = `
      CREATE TABLE IF NOT EXISTS athletes (
        id TEXT PRIMARY KEY NOT NULL,
        name TEXT NOT NULL,
        team TEXT,
        position TEXT,
        age INTEGER,
        height TEXT,
        weight TEXT,
        device_id TEXT,
        notes TEXT,
        number TEXT,
        active BOOLEAN DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_athlete_name ON athletes(name);
      CREATE INDEX IF NOT EXISTS idx_athlete_team ON athletes(team);
      CREATE INDEX IF NOT EXISTS idx_athlete_device ON athletes(device_id)
    `;
    await executeSchema(db, athletesSchema);
    console.log('[Migration V1] Athletes schema applied.');

    // IMU Data Table Schema
    const imuDataSchema = `
      CREATE TABLE IF NOT EXISTS imu_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_id TEXT NOT NULL,
        sensor_id INTEGER NOT NULL,
        timestamp INTEGER NOT NULL,
        x REAL NOT NULL,
        y REAL NOT NULL,
        z REAL NOT NULL,
        created_at INTEGER NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_imu_device_id ON imu_data(device_id);
      CREATE INDEX IF NOT EXISTS idx_imu_timestamp ON imu_data(timestamp)
    `;
    await executeSchema(db, imuDataSchema);
    console.log('[Migration V1] IMU data schema applied.');

    // Accelerometer Data Table Schema
    const accelerometerDataSchema = `
      CREATE TABLE IF NOT EXISTS accelerometer_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_id TEXT NOT NULL,
        sensor_id INTEGER NOT NULL,
        timestamp INTEGER NOT NULL,
        x REAL NOT NULL,
        y REAL NOT NULL,
        z REAL NOT NULL,
        magnitude REAL NOT NULL,
        created_at INTEGER NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_accel_device_id ON accelerometer_data(device_id);
      CREATE INDEX IF NOT EXISTS idx_accel_timestamp ON accelerometer_data(timestamp);
      CREATE INDEX IF NOT EXISTS idx_accel_magnitude ON accelerometer_data(magnitude)
    `;
    await executeSchema(db, accelerometerDataSchema);
    console.log('[Migration V1] Accelerometer data schema applied.');

    // Temperature Data Table Schema
    const temperatureDataSchema = `
      CREATE TABLE IF NOT EXISTS temperature_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_id TEXT NOT NULL,
        sensor_id INTEGER NOT NULL,
        timestamp INTEGER NOT NULL,
        temperature REAL NOT NULL,
        created_at INTEGER NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_temp_device_id ON temperature_data(device_id);
      CREATE INDEX IF NOT EXISTS idx_temp_timestamp ON temperature_data(timestamp)
    `;
    await executeSchema(db, temperatureDataSchema);
    console.log('[Migration V1] Temperature data schema applied.');

    // Force Data Table Schema
    const forceDataSchema = `
      CREATE TABLE IF NOT EXISTS force_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_id TEXT NOT NULL,
        sensor_id INTEGER NOT NULL,
        timestamp INTEGER NOT NULL,
        force REAL NOT NULL,
        created_at INTEGER NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_force_device_id ON force_data(device_id);
      CREATE INDEX IF NOT EXISTS idx_force_timestamp ON force_data(timestamp)
    `;
    await executeSchema(db, forceDataSchema);
    console.log('[Migration V1] Force data schema applied.');

    // Heart Rate Data Table Schema
    const heartRateDataSchema = `
      CREATE TABLE IF NOT EXISTS heart_rate_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_id TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        heart_rate INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_hr_device_id ON heart_rate_data(device_id);
      CREATE INDEX IF NOT EXISTS idx_hr_timestamp ON heart_rate_data(timestamp)
    `;
    await executeSchema(db, heartRateDataSchema);
    console.log('[Migration V1] Heart Rate data schema applied.');

    // Impact Events Table Schema
    const impactEventsSchema = `
      CREATE TABLE IF NOT EXISTS impact_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_id TEXT NOT NULL,
        athlete_id TEXT,
        timestamp INTEGER NOT NULL,
        magnitude REAL NOT NULL,
        x REAL NOT NULL,
        y REAL NOT NULL,
        z REAL NOT NULL,
        duration_ms INTEGER,
        location TEXT,
        processed BOOLEAN DEFAULT 0,
        severity TEXT,
        notes TEXT,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (athlete_id) REFERENCES athletes(id)
      );
      CREATE INDEX IF NOT EXISTS idx_impact_device_id ON impact_events(device_id);
      CREATE INDEX IF NOT EXISTS idx_impact_athlete_id ON impact_events(athlete_id);
      CREATE INDEX IF NOT EXISTS idx_impact_timestamp ON impact_events(timestamp);
      CREATE INDEX IF NOT EXISTS idx_impact_magnitude ON impact_events(magnitude);
      CREATE INDEX IF NOT EXISTS idx_impact_processed ON impact_events(processed)
    `;
    await executeSchema(db, impactEventsSchema);
    console.log('[Migration V1] Impact Events schema applied.');

    // Sessions Table Schema
    const sessionsSchema = `
      CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY NOT NULL,
        name TEXT NOT NULL,
        start_time INTEGER NOT NULL,
        end_time INTEGER,
        team TEXT,
        created_at INTEGER NOT NULL,
        notes TEXT
      );
      CREATE INDEX IF NOT EXISTS idx_session_start ON sessions(start_time);
      CREATE INDEX IF NOT EXISTS idx_session_team ON sessions(team)
    `;
    await executeSchema(db, sessionsSchema);
    console.log('[Migration V1] Sessions schema applied.');

    // Session Athletes Table Schema (many-to-many)
    const sessionAthletesSchema = `
      CREATE TABLE IF NOT EXISTS session_athletes (
        session_id TEXT NOT NULL,
        athlete_id TEXT NOT NULL,
        start_time INTEGER NOT NULL,
        end_time INTEGER,
        PRIMARY KEY (session_id, athlete_id),
        FOREIGN KEY (session_id) REFERENCES sessions(id),
        FOREIGN KEY (athlete_id) REFERENCES athletes(id)
      );
      CREATE INDEX IF NOT EXISTS idx_sa_session ON session_athletes(session_id);
      CREATE INDEX IF NOT EXISTS idx_sa_athlete ON session_athletes(athlete_id)
    `;
    await executeSchema(db, sessionAthletesSchema);
    console.log('[Migration V1] Session Athletes schema applied.');

    // Calibration Data Table Schema
    const calibrationSchema = `
      CREATE TABLE IF NOT EXISTS calibration_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_id TEXT NOT NULL,
        sensor_type TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        offset_x REAL,
        offset_y REAL,
        offset_z REAL,
        scale_x REAL,
        scale_y REAL,
        scale_z REAL,
        created_at INTEGER NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_calib_device_id ON calibration_data(device_id);
      CREATE UNIQUE INDEX IF NOT EXISTS idx_calib_device_sensor ON calibration_data(device_id, sensor_type)
    `;
    await executeSchema(db, calibrationSchema);
    console.log('[Migration V1] Calibration Data schema applied.');

    console.log('[Migration V1] Migration completed successfully.');
  } catch (error) {
    console.error('[Migration V1] Migration failed with error:', error);
    throw error;
  }
}

/**
 * Optional down migration to revert changes
 */
export async function down(db: SQLiteDatabase): Promise<void> {
  console.log('[Migration V1] Rolling back migration...');
  
  // Drop tables in reverse order of creation (for proper foreign key constraints)
  await db.execAsync('DROP TABLE IF EXISTS calibration_data');
  await db.execAsync('DROP TABLE IF EXISTS session_athletes');
  await db.execAsync('DROP TABLE IF EXISTS sessions');
  await db.execAsync('DROP TABLE IF EXISTS impact_events');
  await db.execAsync('DROP TABLE IF EXISTS heart_rate_data');
  await db.execAsync('DROP TABLE IF EXISTS force_data');
  await db.execAsync('DROP TABLE IF EXISTS temperature_data');
  await db.execAsync('DROP TABLE IF EXISTS accelerometer_data');
  await db.execAsync('DROP TABLE IF EXISTS imu_data');
  await db.execAsync('DROP TABLE IF EXISTS athletes');
  
  console.log('[Migration V1] Migration rolled back successfully.');
} 

================================================================================
File: src/migrations/v2.ts
================================================================================

import { SQLiteDatabase } from 'expo-sqlite';

// Define a type for the SQLite table column info
interface TableColumnInfo {
  cid: number;
  name: string;
  type: string;
  notnull: number;
  dflt_value: string | null;
  pk: number;
}

/**
 * Migration v2: Add sport column to athletes table
 */
export async function up(db: SQLiteDatabase): Promise<void> {
  console.log('[Migration V2] Applying migration...');

  try {
    let sportColumnExists = false;
    
    try {
      // First check if the column already exists using PRAGMA
      const tableInfoResult = await db.getAllAsync("PRAGMA table_info(athletes)");
      
      // Try different ways to access the data based on the database driver implementation
      if (tableInfoResult && typeof tableInfoResult === 'object') {
        // SQLite result might be in .rows property
        if ('rows' in tableInfoResult && Array.isArray(tableInfoResult.rows)) {
          sportColumnExists = tableInfoResult.rows.some((col: any) => col.name === 'sport');
        } 
        // Or it might be an array directly
        else if (Array.isArray(tableInfoResult)) {
          sportColumnExists = tableInfoResult.some((col: any) => col.name === 'sport');
        }
      }
      
      console.log(`[Migration V2] Sport column exists check result: ${sportColumnExists}`);
    } catch (checkError) {
      console.warn('[Migration V2] Error checking if column exists, will try to add anyway:', checkError);
      // Continue with migration even if check fails - the ALTER TABLE will fail
      // if the column already exists and we'll catch that error
    }
    
    if (!sportColumnExists) {
      // Add sport column to athletes table only if it doesn't exist
      console.log('[Migration V2] Adding sport column to athletes table');
      await db.execAsync('ALTER TABLE athletes ADD COLUMN sport TEXT;');
      console.log('[Migration V2] Sport column added successfully');
    } else {
      console.log('[Migration V2] Sport column already exists, skipping migration');
    }
    
    console.log('[Migration V2] Migration completed successfully.');
  } catch (error) {
    // Check if the error is about duplicate column - that's actually success
    const errorMessage = String(error);
    if (errorMessage.includes('duplicate column name: sport')) {
      console.log('[Migration V2] Sport column already exists, counting migration as successful');
      return; // Exit without throwing error - migration is successful
    }
    
    console.error('[Migration V2] Migration failed with error:', error);
    throw error;
  }
}

/**
 * Optional down migration to revert changes
 * Note: SQLite does not support dropping columns without recreating the table
 * This is left as a placeholder since we cannot easily revert this change
 */
export async function down(db: SQLiteDatabase): Promise<void> {
  console.log('[Migration V2] SQLite does not support dropping columns without recreating the table.');
  console.log('[Migration V2] The sport column will remain in the athletes table.');
} 

================================================================================
File: src/migrations/v3.ts
================================================================================

import { SQLiteDatabase } from 'expo-sqlite';

// Helper (can be moved to a shared utils file)
async function executeSchema(db: SQLiteDatabase, schema: string): Promise<void> {
  const statements = schema.split(';').filter(s => s.trim() !== '');
  for (const statement of statements) {
    await db.execAsync(statement.trim() + ';');
  }
}

/**
 * Migration v3: Add tables for raw device packets
 */
export async function up(db: SQLiteDatabase): Promise<void> {
  console.log('[Migration V3] Applying migration...');

  const motionPacketSchema = `
    CREATE TABLE IF NOT EXISTS motion_packets (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      device_id TEXT NOT NULL,
      device_timestamp INTEGER NOT NULL, -- Store the uint32_t directly
      gyro_x INTEGER NOT NULL,
      gyro_y INTEGER NOT NULL,
      gyro_z INTEGER NOT NULL,
      accel16_x INTEGER NOT NULL,
      accel16_y INTEGER NOT NULL,
      accel16_z INTEGER NOT NULL,
      accel200_x INTEGER NOT NULL,
      accel200_y INTEGER NOT NULL,
      accel200_z INTEGER NOT NULL,
      mag_x INTEGER NOT NULL,
      mag_y INTEGER NOT NULL,
      mag_z INTEGER NOT NULL,
      bite_l INTEGER NOT NULL,
      bite_r INTEGER NOT NULL,
      app_timestamp INTEGER NOT NULL -- When the app received/recorded it
    );
    CREATE INDEX IF NOT EXISTS idx_motion_device_time ON motion_packets(device_id, device_timestamp);
  `;
  await executeSchema(db, motionPacketSchema);
  console.log('[Migration V3] motion_packets schema applied.');

  const fsrPacketSchema = `
    CREATE TABLE IF NOT EXISTS fsr_packets (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      device_id TEXT NOT NULL,
      device_timestamp INTEGER NOT NULL, -- Store the uint32_t directly
      left_bite REAL NOT NULL, -- Changed to REAL to store unscaled force values
      right_bite REAL NOT NULL, -- Changed to REAL to store unscaled force values
      app_timestamp INTEGER NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_fsr_device_time ON fsr_packets(device_id, device_timestamp);
  `;
  await executeSchema(db, fsrPacketSchema);
  console.log('[Migration V3] fsr_packets schema applied.');

  const hrmPacketSchema = `
    CREATE TABLE IF NOT EXISTS hrm_packets (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      device_id TEXT NOT NULL,
      flags INTEGER NOT NULL,
      heart_rate INTEGER NOT NULL,
      app_timestamp INTEGER NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_hrm_device_time ON hrm_packets(device_id, app_timestamp);
  `;
  await executeSchema(db, hrmPacketSchema);
  console.log('[Migration V3] hrm_packets schema applied.');

   const htmPacketSchema = `
    CREATE TABLE IF NOT EXISTS htm_packets (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      device_id TEXT NOT NULL,
      flags INTEGER NOT NULL,
      temperature REAL NOT NULL, -- Store parsed temp
      type INTEGER,
      app_timestamp INTEGER NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_htm_device_time ON htm_packets(device_id, app_timestamp);
  `;
  await executeSchema(db, htmPacketSchema);
  console.log('[Migration V3] htm_packets schema applied.');

  console.log('[Migration V3] Migration completed successfully.');
}

export async function down(db: SQLiteDatabase): Promise<void> {
  console.log('[Migration V3] Rolling back migration...');
  await db.execAsync('DROP TABLE IF EXISTS motion_packets;');
  await db.execAsync('DROP TABLE IF EXISTS fsr_packets;');
  await db.execAsync('DROP TABLE IF EXISTS hrm_packets;');
  await db.execAsync('DROP TABLE IF EXISTS htm_packets;');
  console.log('[Migration V3] Migration rolled back successfully.');
} 

================================================================================
File: src/providers/AppProvider.tsx
================================================================================

import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { View, Text, ActivityIndicator, AppState, Platform } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DatabaseManager, databaseManager } from '../DatabaseManager';
import { StorageService } from '../services/StorageService';
import { DeviceService } from '../services/DeviceService';
import { BluetoothService } from '../services/BluetoothService';
import { AppSetupService } from '../services/AppSetupService';
import { AthleteRepository } from '../repositories/AthleteRepository';
import { SensorDataRepository } from '../repositories/SensorDataRepository';
import { BluetoothHandler } from '../contexts/BluetoothContext';

// Define the AppContext type
interface AppContextType {
  databaseManager: DatabaseManager;
  storageService: StorageService;
  deviceService: DeviceService;
  bluetoothService: BluetoothService;
  appSetupService: AppSetupService;
  athleteRepository: AthleteRepository;
  sensorDataRepository: SensorDataRepository;
  initialized: boolean;
}

// Create the context with a default value
const AppContext = createContext<AppContextType | null>(null);

// Define the provider props
interface AppProviderProps {
  children: ReactNode;
  bluetoothHandler?: BluetoothHandler; // Optional existing bluetoothHandler
}

/**
 * AppProvider component that initializes all services and repositories
 * and provides them via React Context
 */
export const AppProvider: React.FC<AppProviderProps> = ({ children, bluetoothHandler }) => {
  const [initialized, setInitialized] = useState(false);
  const [services, setServices] = useState<AppContextType | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isBackgroundLaunch, setIsBackgroundLaunch] = useState<boolean>(false);

  useEffect(() => {
    // Check if app is starting in background (iOS only)
    if (Platform.OS === 'ios' && AppState.currentState !== 'active') {
      console.log('[AppProvider] App appears to be starting in background mode');
      setIsBackgroundLaunch(true);
    }

    // Direct AsyncStorage test
    const testAsyncStorage = async () => {
      try {
        const testKey = 'asyncStorageTestKey';
        const testValue = `test-${Date.now()}`;
        console.log(`[AppProvider] AsyncStorage Test: Setting ${testKey} to ${testValue}`);
        await AsyncStorage.setItem(testKey, testValue);
        console.log(`[AppProvider] AsyncStorage Test: Set completed. Now getting ${testKey}`);
        const retrievedValue = await AsyncStorage.getItem(testKey);
        console.log(`[AppProvider] AsyncStorage Test: Retrieved value: ${retrievedValue}`);
        if (retrievedValue === testValue) {
          console.log('[AppProvider] AsyncStorage Test: SUCCESS - Value matched!');
        } else {
          console.error('[AppProvider] AsyncStorage Test: FAILURE - Value mismatch!');
        }
        // Clean up
        await AsyncStorage.removeItem(testKey);
      } catch (e) {
        console.error('[AppProvider] AsyncStorage Test: FAILED with error:', e);
      }
    };
    // Run the test
    testAsyncStorage();

    async function setupApp() {
      try {
        console.log('[AppProvider] Setting up app dependencies...');
        
        // Use singleton database manager instance
        const storageService = new StorageService();

        // Run direct AsyncStorage test early to verify functionality
        console.log('[AppProvider] Will run direct AsyncStorage test first...');
        
        // Check if hasLaunched flag exists
        const hasLaunchedKey = 'hasLaunched';
        const hasLaunchedRaw = await AsyncStorage.getItem(hasLaunchedKey);
        console.log(`[AppProvider] Current 'hasLaunched' value: ${hasLaunchedRaw}`);
        
        // Initialize database connections
        console.log('[AppProvider] BEFORE databaseManager.initialize()');
        await databaseManager.initialize();
        console.log('[AppProvider] AFTER databaseManager.initialize()');
        
        // Use a single database connection for all repositories
        console.log('[AppProvider] BEFORE getDatabase for mouthguardMonitor');
        const db = await databaseManager.getDatabase('mouthguardMonitor');
        console.log('[AppProvider] AFTER getDatabase for mouthguardMonitor');
        
        // Initialize repositories with the database connection
        console.log('[AppProvider] Initializing repositories...');
        const athleteRepository = new AthleteRepository(db);
        const sensorDataRepository = new SensorDataRepository(db);
        console.log('[AppProvider] Repositories initialized');
        
        // Initialize services that depend on repositories
        const deviceService = new DeviceService(storageService);
        
        // Prioritize Bluetooth service creation for background mode
        const bluetoothService = new BluetoothService(
          deviceService,
          sensorDataRepository,
          athleteRepository,
          bluetoothHandler
        );

        // In background mode, we prioritize getting the Bluetooth service ready
        // and defer other non-critical initializations
        if (isBackgroundLaunch) {
          console.log('[AppProvider] Background launch detected, prioritizing Bluetooth service initialization');
          
          // Create minimal appSetupService to avoid null references
          const minimalAppSetupService = new AppSetupService(
            storageService,
            databaseManager
          );
          
          // Set core services needed for Bluetooth background operation
          setServices({
            databaseManager,
            storageService,
            deviceService,
            bluetoothService,
            appSetupService: minimalAppSetupService,
            athleteRepository,
            sensorDataRepository,
            initialized: true
          });
          
          setInitialized(true);
          console.log('[AppProvider] Core services initialized for background operation');
          
          // Listen for app coming to foreground to complete remaining setup
          const subscription = AppState.addEventListener('change', (nextAppState) => {
            if (nextAppState === 'active') {
              console.log('[AppProvider] App came to foreground, completing full initialization');
              // Complete remaining setup when app comes to foreground
              completeSetup(storageService, databaseManager, bluetoothService);
              // Remove listener once we've handled the transition
              subscription.remove();
            }
          });
        } else {
          // Normal foreground launch - complete full setup immediately
          const appSetupService = new AppSetupService(
            storageService,
            databaseManager
          );
          
          // Check if this is first launch and perform setup if needed
          console.log('[AppProvider] BEFORE appSetupService.ensureInitialized()');
          await appSetupService.ensureInitialized();
          console.log('[AppProvider] AFTER appSetupService.ensureInitialized()');
          
          // Set all services in state for context
          console.log('[AppProvider] Setting services and initialized state...');
          setServices({
            databaseManager,
            storageService,
            deviceService,
            bluetoothService,
            appSetupService,
            athleteRepository,
            sensorDataRepository,
            initialized: true
          });
          
          setInitialized(true);
          console.log('[AppProvider] App dependencies setup complete');
        }
      } catch (err: any) {
        console.error('[AppProvider] DETAILED setup error:', err, err.stack);
        setError(err.message || 'Failed to initialize app');
      }
    }
    
    // Helper function to complete setup when app comes to foreground
    async function completeSetup(
      storageService: StorageService,
      databaseManager: DatabaseManager,
      bluetoothService: BluetoothService
    ) {
      try {
        const appSetupService = new AppSetupService(
          storageService,
          databaseManager
        );
        
        // Ensure app is properly initialized
        await appSetupService.ensureInitialized();
        
        // Update services with the appSetupService
        setServices(prevServices => {
          if (!prevServices) return null;
          return {
            ...prevServices,
            appSetupService
          };
        });
        
        console.log('[AppProvider] Deferred initialization completed successfully');
      } catch (err: any) {
        console.error('[AppProvider] Error during deferred initialization:', err);
      }
    }
    
    setupApp();
    
    // Cleanup function
    return () => {
      // Close database connections when app is unmounted
      if (services?.databaseManager) {
        services.databaseManager.cleanup().catch(err => {
          console.error('[AppProvider] Error cleaning up database connections:', err);
        });
      }
    };
  }, [bluetoothHandler]);

  // Loading state - don't show this in background mode
  if ((!initialized || !services) && !isBackgroundLaunch) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#00e676" />
        <Text style={{ marginTop: 20, color: '#fff' }}>Initializing app...</Text>
      </View>
    );
  }

  // Error state - don't show this in background mode
  if (error && !isBackgroundLaunch) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text style={{ color: '#ff4444', fontSize: 16, marginBottom: 10 }}>
          Error: {error}
        </Text>
        <Text style={{ color: '#fff', textAlign: 'center', marginHorizontal: 20 }}>
          Please restart the app or contact support.
        </Text>
      </View>
    );
  }

  return (
    <AppContext.Provider value={services!}>
      {children}
    </AppContext.Provider>
  );
};

/**
 * Custom hook to access the app context
 * @throws Error if used outside of AppProvider
 */
export function useAppContext(): AppContextType {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
}

/**
 * Custom hook to access the storage service
 */
export function useStorageService(): StorageService {
  const { storageService } = useAppContext();
  return storageService;
}

/**
 * Custom hook to access the device service
 */
export function useDeviceService(): DeviceService {
  const { deviceService } = useAppContext();
  return deviceService;
}

/**
 * Custom hook to access the bluetooth service
 */
export function useBluetoothService(): BluetoothService {
  const { bluetoothService } = useAppContext();
  return bluetoothService;
}

/**
 * Custom hook to access the app setup service
 */
export function useAppSetupService(): AppSetupService {
  const { appSetupService } = useAppContext();
  return appSetupService;
}

/**
 * Custom hook to access the athlete repository
 */
export function useAthleteRepository(): AthleteRepository {
  const { athleteRepository } = useAppContext();
  return athleteRepository;
}

/**
 * Custom hook to access the sensor data repository
 */
export function useSensorDataRepository(): SensorDataRepository {
  const { sensorDataRepository } = useAppContext();
  return sensorDataRepository;
} 

================================================================================
File: src/repositories/AthleteRepository.ts
================================================================================

import { SQLiteDatabase } from 'expo-sqlite';
import { Athlete } from '../types';
import { BaseRepository } from './BaseRepository';

/**
 * Repository for managing athletes
 */
export class AthleteRepository extends BaseRepository {
  constructor(db: SQLiteDatabase) {
    super(db);
    console.log('[AthleteRepository CONSTRUCTOR] Received DB object:', this.db);
  }

  /**
   * Get all athletes
   */
  public async getAllAthletes(): Promise<Athlete[]> {
    console.log('[AthleteRepository getAllAthletes] Attempting query using DB object:', this.db);
    try {
      const result = await this.db.getAllAsync('SELECT * FROM athletes ORDER BY name ASC');
      console.log('[AthleteRepository getAllAthletes] Query result:', result);
      
      // Check if result or result.rows is undefined/null
      if (!result || !result.rows) {
        console.log('[AthleteRepository getAllAthletes] No rows returned, returning empty array');
        return [];
      }
      
      return result.rows.map(row => ({
        id: row.id,
        name: row.name,
        team: row.team,
        position: row.position,
        age: row.age,
        height: row.height,
        weight: row.weight,
        deviceId: row.device_id,
        notes: row.notes,
        number: row.number,
        active: row.active === 1,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));
    } catch (error) {
      console.error('Error getting all athletes:', error);
      console.error('[AthleteRepository getAllAthletes] Failed using DB object:', this.db);
      throw error;
    }
  }

  /**
   * Get athlete by ID
   */
  public async getAthleteById(id: string): Promise<Athlete | null> {
    try {
      const result = await this.db.getAllAsync('SELECT * FROM athletes WHERE id = ?', [id]);
      console.log('[AthleteRepository getAthleteById] Query result:', result);
      
      // Check if result or result.rows is undefined/null
      if (!result || !result.rows || !result.rows.length) {
        console.log('[AthleteRepository getAthleteById] No athlete found with ID:', id);
        return null;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        name: row.name,
        team: row.team,
        position: row.position,
        age: row.age,
        height: row.height,
        weight: row.weight,
        deviceId: row.device_id,
        notes: row.notes,
        number: row.number,
        active: row.active === 1,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      };
    } catch (error) {
      console.error(`Error getting athlete by ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Get athlete by device ID
   */
  public async getAthleteByDeviceId(deviceId: string): Promise<Athlete | null> {
    try {
      const result = await this.db.getAllAsync('SELECT * FROM athletes WHERE device_id = ?', [deviceId]);
      
      if (!result || !result.length) {
        console.log('[AthleteRepository getAthleteByDeviceId] No athlete found with device ID:', deviceId);
        return null;
      }
      
      const row = result[0];
      return {
        id: row.id,
        name: row.name,
        team: row.team,
        position: row.position,
        age: row.age,
        height: row.height,
        weight: row.weight,
        deviceId: row.device_id,
        notes: row.notes,
        number: row.number,
        active: row.active === 1,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      };
    } catch (error) {
      console.error(`Error getting athlete by device ID ${deviceId}:`, error);
      throw error;
    }
  }

  /**
   * Get athletes by team
   */
  public async getAthletesByTeam(team: string): Promise<Athlete[]> {
    try {
      const result = await this.db.getAllAsync('SELECT * FROM athletes WHERE team = ? ORDER BY name ASC', [team]);
      
      if (!result || !result.length) {
        console.log(`[AthleteRepository getAthletesByTeam] No athletes found in team: ${team}`);
        return [];
      }
      
      return result.map(row => ({
        id: row.id,
        name: row.name,
        team: row.team,
        position: row.position,
        age: row.age,
        height: row.height,
        weight: row.weight,
        deviceId: row.device_id,
        notes: row.notes,
        number: row.number,
        active: row.active === 1,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));
    } catch (error) {
      console.error(`Error getting athletes by team ${team}:`, error);
      throw error;
    }
  }

  /**
   * Add a new athlete
   */
  public async addAthlete(athlete: Omit<Athlete, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    try {
      const now = Date.now();
      const id = `athlete_${now}_${Math.floor(Math.random() * 10000)}`;
      
      await this.db.runAsync(
        `INSERT INTO athletes (
          id, name, team, position, age, height, weight, device_id, notes, number, active, sport, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          athlete.name,
          athlete.team || null,
          athlete.position || null,
          athlete.age || null,
          athlete.height || null,
          athlete.weight || null,
          athlete.deviceId || null,
          athlete.notes || null,
          athlete.number || null,
          athlete.active === false ? 0 : 1,
          athlete.sport || null,
          now,
          now
        ]
      );
      
      return id;
    } catch (error) {
      console.error('Error adding athlete:', error);
      throw error;
    }
  }

  /**
   * Update an existing athlete
   */
  public async updateAthlete(athlete: Athlete): Promise<void> {
    try {
      const now = Date.now();
      
      await this.db.runAsync(
        `UPDATE athletes SET 
          name = ?, 
          team = ?, 
          position = ?, 
          age = ?, 
          height = ?, 
          weight = ?, 
          device_id = ?, 
          notes = ?, 
          number = ?, 
          active = ?,
          sport = ?,
          updated_at = ? 
        WHERE id = ?`,
        [
          athlete.name,
          athlete.team || null,
          athlete.position || null,
          athlete.age || null,
          athlete.height || null,
          athlete.weight || null,
          athlete.deviceId || null,
          athlete.notes || null,
          athlete.number || null,
          athlete.active === false ? 0 : 1,
          athlete.sport || null,
          now,
          athlete.id
        ]
      );
    } catch (error) {
      console.error(`Error updating athlete ${athlete.id}:`, error);
      throw error;
    }
  }

  /**
   * Assign device to athlete
   */
  public async assignDeviceToAthlete(athleteId: string, deviceId: string): Promise<void> {
    try {
      const now = Date.now();
      
      await this.executeTransaction(async (tx) => {
        // First, remove this device from any other athletes that may have it
        await tx.executeSqlAsync(
          'UPDATE athletes SET device_id = NULL, updated_at = ? WHERE device_id = ?',
          [now, deviceId]
        );
        
        // Then assign it to this athlete
        await tx.executeSqlAsync(
          'UPDATE athletes SET device_id = ?, updated_at = ? WHERE id = ?',
          [deviceId, now, athleteId]
        );
      });
    } catch (error) {
      console.error('Error assigning device to athlete:', error);
      throw error;
    }
  }

  /**
   * Remove device from athlete
   */
  public async removeDeviceFromAthlete(deviceId: string): Promise<void> {
    try {
      const now = Date.now();
      
      await this.db.runAsync(
        'UPDATE athletes SET device_id = NULL, updated_at = ? WHERE device_id = ?',
        [now, deviceId]
      );
    } catch (error) {
      console.error('Error removing device from athlete:', error);
      throw error;
    }
  }

  /**
   * Delete an athlete
   */
  public async deleteAthlete(id: string): Promise<void> {
    try {
      await this.db.runAsync('DELETE FROM athletes WHERE id = ?', [id]);
    } catch (error) {
      console.error('Error deleting athlete:', error);
      throw error;
    }
  }
} 

================================================================================
File: src/repositories/BaseRepository.ts
================================================================================

import { SQLiteDatabase } from "expo-sqlite";
import { DatabaseResponse } from "../types";

/**
 * Base Repository class that all repositories will extend
 * Provides common functionality like transaction management
 */
export class BaseRepository {
  protected db: SQLiteDatabase;

  /**
   * Constructor for the repository
   * @param db SQLiteDatabase instance from DatabaseManager
   */
  constructor(db: SQLiteDatabase) {
    this.db = db;
    console.log('[BaseRepository CONSTRUCTOR] Received DB object:', db);
  }

  /**
   * Execute multiple database operations in a transaction
   * @param operations Function containing database operations to execute in transaction
   * @returns Result of operations
   */
  protected async executeTransaction<T>(operations: () => Promise<T>): Promise<T> {
    try {
      console.log('[Transaction] Beginning transaction...');
      await this.db.execAsync('BEGIN TRANSACTION');
      console.log('[Transaction] Transaction started, executing operations...');
      
      const result = await operations();
      
      console.log('[Transaction] Operations completed successfully, committing transaction...');
      await this.db.execAsync('COMMIT');
      console.log('[Transaction] Transaction committed.');
      return result;
    } catch (error) {
      console.error('[Transaction] Error during transaction, rolling back:', error);
      
      // Try to get more specific error info
      let errorMessage = 'Unknown error';
      if (error instanceof Error) {
        errorMessage = error.message;
        console.error('[Transaction] Error details:', {
          message: error.message,
          name: error.name,
          stack: error.stack
        });
      } else {
        console.error('[Transaction] Non-Error object thrown:', error);
      }
      
      try {
        console.log('[Transaction] Attempting to roll back transaction...');
        await this.db.execAsync('ROLLBACK');
        console.log('[Transaction] Transaction rolled back successfully.');
      } catch (rollbackError) {
        console.error('[Transaction] Error rolling back transaction:', rollbackError);
        if (rollbackError instanceof Error) {
          console.error('[Transaction] Rollback error details:', {
            message: rollbackError.message,
            name: rollbackError.name,
            stack: rollbackError.stack
          });
        }
      }
      
      throw error;
    }
  }

  /**
   * Standard error handler for database operations
   * @param error The error that occurred
   * @param operation Description of the operation that failed
   * @returns Standardized error response
   */
  protected handleError<T>(error: unknown, operation: string): DatabaseResponse<T> {
    const errorMessage = error instanceof Error ? error.message : `Failed to ${operation}`;
    console.error(`[Repository] Error in ${operation}:`, error);
    return {
      success: false,
      error: errorMessage
    };
  }
} 

================================================================================
File: src/repositories/SensorDataRepository.ts
================================================================================

import { SQLiteDatabase } from 'expo-sqlite';
import { dataChangeEmitter, dbEvents } from '../utils/EventEmitter';
import { MotionPacket, FSRPacket, HRMPacket, HTMPacket, ImpactEvent, AccelerometerData, TemperatureData, HeartRateData } from '../types';

/**
 * Repository for managing sensor data from mouthguard devices
 */
export class SensorDataRepository {
  private db: SQLiteDatabase;

  constructor(db: SQLiteDatabase) {
    this.db = db;
  }

  /**
   * Record IMU data from a device
   */
  public async recordImuData(
    deviceId: string,
    sensorId: number,
    timestamp: number,
    x: number,
    y: number,
    z: number
  ): Promise<void> {
    const now = Date.now();
    try {
      await this.db.runAsync(
        `INSERT INTO imu_data (device_id, sensor_id, timestamp, x, y, z, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [deviceId, sensorId, timestamp, x, y, z, now]
      );
    } catch (error) {
      console.error('Error inserting IMU data:', error);
      throw error;
    }
  }

  /**
   * Record accelerometer data from a device
   */
  public async recordAccelerometerData(
    data: AccelerometerData
  ): Promise<void> {
    const now = Date.now();
    const thresholdG = 80; // Example threshold

    // Use a transaction if inserting into multiple tables conditionally
    await this.db.withTransactionAsync(async () => {
      try {
        await this.db.runAsync(
          `INSERT INTO accelerometer_data (device_id, sensor_id, timestamp, x, y, z, magnitude, created_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          [data.deviceId, data.sensorId, data.timestamp, data.x, data.y, data.z, data.magnitude, data.createdAt || now]
        );

        // Check if this is a potential concussion event (high-g impact)
        if (data.magnitude > thresholdG) {
          await this.recordImpactEventInternal(
            data.deviceId, undefined, data.timestamp, 
            data.magnitude, data.x, data.y, data.z, 
            data.createdAt || now
          ); // Use internal helper
        }
      } catch (error) {
        console.error('Error inserting accelerometer data or impact event:', error);
        throw error; // Re-throw to ensure transaction rollback
      }
    });
  }

  /**
   * Record temperature data from a device
   */
  public async recordTemperatureData(
    data: TemperatureData
  ): Promise<void> {
    const now = Date.now();
    try {
      await this.db.runAsync(
        `INSERT INTO temperature_data (device_id, sensor_id, timestamp, temperature, created_at)
         VALUES (?, ?, ?, ?, ?)`,
        [data.deviceId, data.sensorId, data.timestamp, data.temperature, data.createdAt || now]
      );
    } catch (error) {
      console.error('Error inserting temperature data:', error);
      throw error;
    }
  }

  /**
   * Record force sensor data from a device
   */
  public async recordForceData(
    deviceId: string,
    sensorId: number,
    timestamp: number,
    force: number
  ): Promise<void> {
    const now = Date.now();
    try {
      await this.db.runAsync(
        `INSERT INTO force_data (device_id, sensor_id, timestamp, force, created_at)
         VALUES (?, ?, ?, ?, ?)`,
        [deviceId, sensorId, timestamp, force, now]
      );
    } catch (error) {
      console.error('Error inserting force data:', error);
      throw error;
    }
  }

  /**
   * Record heart rate data from a device
   */
  public async recordHeartRateData(
    data: HeartRateData
  ): Promise<void> {
    const now = Date.now();
    try {
      await this.db.runAsync(
        `INSERT INTO heart_rate_data (device_id, timestamp, heart_rate, created_at)
         VALUES (?, ?, ?, ?)`,
        [data.deviceId, data.timestamp, data.heartRate, data.createdAt || now]
      );
    } catch (error) {
      console.error('Error inserting heart rate data:', error);
      throw error;
    }
  }

  /**
   * Internal helper to record an impact event (used by other methods)
   */
  private async recordImpactEventInternal(
    deviceId: string,
    athleteId: string | undefined,
    timestamp: number,
    magnitude: number,
    x: number,
    y: number,
    z: number,
    createdAt: number,
    severity?: string,
    durationMs?: number,
    location?: string,
    notes?: string
  ): Promise<void> {
    console.warn(`SensorDataRepository: Recording potential impact event: ${magnitude.toFixed(1)}g`);
    await this.db.runAsync(
      `INSERT INTO impact_events (device_id, athlete_id, timestamp, magnitude, x, y, z, duration_ms, location, processed, severity, notes, created_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        deviceId,
        athleteId ?? null,
        timestamp,
        magnitude,
        x, y, z,
        durationMs ?? null,
        location ?? null,
        0, // processed = false
        severity ?? null,
        notes ?? null,
        createdAt
      ]
    );
    // Emit concussion detected event
    dataChangeEmitter.emit(dbEvents.CONCUSSION_DETECTED, {
      deviceId,
      timestamp,
      magnitude,
      athleteId // Pass athleteId if available
    });
  }

  /**
   * Record a raw Motion Packet and potentially an impact event
   */
  public async recordMotionPacket(deviceId: string, packet: MotionPacket): Promise<number> {
    const appTimestamp = Date.now();
    console.log(`[SensorDataRepo] Recording Motion Packet for ${deviceId} at ${appTimestamp}, device timestamp: ${packet.timestamp}`);

    try {
      // Calculate G-forces for impact detection
      const SENSITIVITY_200G = 16384 / 200; // Example conversion factor - adjust based on actual sensor
      const gForceX = packet.accel200[0] / SENSITIVITY_200G;
      const gForceY = packet.accel200[1] / SENSITIVITY_200G;
      const gForceZ = packet.accel200[2] / SENSITIVITY_200G;
      const magnitude = Math.sqrt(gForceX**2 + gForceY**2 + gForceZ**2);

      // Insert the raw packet data
      const result = await this.db.runAsync(
        `INSERT INTO motion_packets (
          device_id, device_timestamp,
          gyro_x, gyro_y, gyro_z,
          accel16_x, accel16_y, accel16_z,
          accel200_x, accel200_y, accel200_z,
          mag_x, mag_y, mag_z,
          bite_l, bite_r, app_timestamp
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          deviceId, packet.timestamp, // Device timestamp
          packet.gyro[0], packet.gyro[1], packet.gyro[2],
          packet.accel16[0], packet.accel16[1], packet.accel16[2],
          packet.accel200[0], packet.accel200[1], packet.accel200[2],
          packet.mag[0], packet.mag[1], packet.mag[2],
          packet.bite_l, packet.bite_r, appTimestamp // App timestamp
        ]
      );

      console.log(`[SensorDataRepo] Motion Packet recorded successfully. ID: ${result.lastInsertRowId}, Changes: ${result.changes}`);

      // Check for potential impact event
      const thresholdG = 80; // 80G threshold for potential concussion
      if (magnitude > thresholdG) {
        await this.recordImpactEventInternal(
          deviceId, undefined, packet.timestamp, 
          magnitude, gForceX, gForceY, gForceZ,
          appTimestamp
        );
      }

      dataChangeEmitter.emit(dbEvents.DATA_CHANGED, { type: 'motion', deviceId });
      return result.lastInsertRowId;
    } catch (error) {
      console.error('[SensorDataRepo] FAILED to insert Motion Packet:', error);
      throw error;
    }
  }

  /**
   * Record a raw FSR (bite force) Packet
   */
  public async recordFSRPacket(deviceId: string, packet: FSRPacket): Promise<number> {
    const appTimestamp = Date.now();
    console.log(`[SensorDataRepo] Recording FSR Packet for ${deviceId} at ${appTimestamp}, device timestamp: ${packet.timestamp}`);
    
    // Insert the FSR packet data (storing unscaled forces)
    const result = await this.db.runAsync(
      `INSERT INTO fsr_packets (
        device_id, device_timestamp, left_bite, right_bite, app_timestamp
      ) VALUES (?, ?, ?, ?, ?)`,
      [
        deviceId, packet.timestamp, // Device timestamp
        packet.left_bite, // Already unscaled in BluetoothService
        packet.right_bite, // Already unscaled in BluetoothService  
        appTimestamp
      ]
    );

    dataChangeEmitter.emit(dbEvents.DATA_CHANGED, { type: 'fsr', deviceId });
    return result.lastInsertRowId;
  }

  /**
   * Record a Heart Rate Measurement Packet
   */
  public async recordHRMPacket(deviceId: string, packet: HRMPacket): Promise<number> {
    console.log(`[SensorDataRepo] Recording HRM Packet for ${deviceId}, HR: ${packet.heartRate}`);
    
    // Insert the HRM packet data
    const result = await this.db.runAsync(
      `INSERT INTO hrm_packets (
        device_id, flags, heart_rate, app_timestamp
      ) VALUES (?, ?, ?, ?)`,
      [
        deviceId, 
        packet.flags,
        packet.heartRate,
        packet.appTimestamp
      ]
    );

    dataChangeEmitter.emit(dbEvents.DATA_CHANGED, { type: 'hrm', deviceId });
    return result.lastInsertRowId;
  }

  /**
   * Record a Health Thermometer Measurement Packet
   */
  public async recordHTMPacket(deviceId: string, packet: HTMPacket): Promise<number> {
    console.log(`[SensorDataRepo] Recording HTM Packet for ${deviceId}, Temp: ${packet.temperature}`);
    
    // Insert the HTM packet data
    const result = await this.db.runAsync(
      `INSERT INTO htm_packets (
        device_id, flags, temperature, type, app_timestamp
      ) VALUES (?, ?, ?, ?, ?)`,
      [
        deviceId, 
        packet.flags,
        packet.temperature, // Already unscaled in BluetoothService
        packet.type ?? null,
        packet.appTimestamp
      ]
    );

    dataChangeEmitter.emit(dbEvents.DATA_CHANGED, { type: 'htm', deviceId });
    return result.lastInsertRowId;
  }

  /**
   * Get sensor data for a specific device within a time range
   */
  public async getSensorData(
    deviceId: string,
    sensorType: 'motion_packets' | 'fsr_packets' | 'hrm_packets' | 'htm_packets' | 'impact_events',
    startTime: number,
    endTime: number
  ): Promise<any[]> {
    // Use app_timestamp for date range queries for ALL packet types
    const timestampField = 'app_timestamp';

    // Define the timestamp field for impact_events. If it's named 'timestamp',
    // ensure recordImpactEventInternal stores app_timestamp there.
    const impactTimestampField = 'timestamp'; // Or 'app_timestamp' if you add that column

    let query: string;

    // Construct the query based on the sensor type
    if (sensorType === 'impact_events') {
         // Make sure the 'timestamp' column in impact_events reliably stores app_timestamp
         // or add an 'app_timestamp' column to impact_events in a new migration.
         // For now, assuming 'timestamp' holds app_timestamp for impacts.
         query = `SELECT * FROM ${sensorType}
                  WHERE device_id = ? AND ${impactTimestampField} BETWEEN ? AND ?
                  ORDER BY ${impactTimestampField} ASC`;
    } else {
         query = `SELECT * FROM ${sensorType}
                  WHERE device_id = ? AND ${timestampField} BETWEEN ? AND ?
                  ORDER BY ${timestampField} ASC`;
    }

    console.log(`[SensorDataRepo getSensorData] Querying ${sensorType} for device ${deviceId} between ${new Date(startTime).toISOString()} and ${new Date(endTime).toISOString()}`);
    console.log(`[SensorDataRepo getSensorData] Query: ${query}`);
    console.log(`[SensorDataRepo getSensorData] Params: [${deviceId}, ${startTime}, ${endTime}]`);

    try {
        // Execute the query using the new async API
        const results = await this.db.getAllAsync(query, [deviceId, startTime, endTime]);
        console.log(`[SensorDataRepo getSensorData] Fetched ${results?.length ?? 0} ${sensorType} results.`);
        return results ?? []; // Return empty array if results are null/undefined
    } catch (error) {
        console.error(`[SensorDataRepo getSensorData] Error querying ${sensorType} data:`, error);
        throw error;
    }
  }

  /**
   * Get concussion events for a specific device
   */
  public async getConcussionEvents(deviceId: string): Promise<ImpactEvent[]> {
    try {
      const results = await this.db.getAllAsync<ImpactEvent>(
        `SELECT * FROM impact_events
         WHERE device_id = ?
         ORDER BY timestamp DESC`,
        [deviceId]
      );
      return results ?? [];
    } catch (error) {
      console.error('Error querying concussion events:', error);
      throw error;
    }
  }

  /**
   * Update concussion event with notes and processed status
   */
  public async updateConcussionEvent(
    id: number,
    notes: string,
    processed: boolean
  ): Promise<void> {
    try {
      await this.db.runAsync(
        `UPDATE impact_events
         SET notes = ?, processed = ?
         WHERE id = ?`,
        [notes, processed ? 1 : 0, id]
      );
    } catch (error) {
      console.error('Error updating concussion event:', error);
      throw error;
    }
  }

  /**
   * Get the most recent data for a specific device
   */
  public async getLatestPacketData(deviceId: string): Promise<any> {
    const result: any = {};
    try {
      const motion = await this.db.getFirstAsync<MotionPacket>(
        `SELECT * FROM motion_packets WHERE device_id = ? ORDER BY app_timestamp DESC LIMIT 1`,
        [deviceId]
      );
      result.motion = motion;

      const fsr = await this.db.getFirstAsync<FSRPacket>(
        `SELECT * FROM fsr_packets WHERE device_id = ? ORDER BY app_timestamp DESC LIMIT 1`,
        [deviceId]
      );
      result.fsr = fsr;

      const hrm = await this.db.getFirstAsync<HRMPacket>(
        `SELECT * FROM hrm_packets WHERE device_id = ? ORDER BY app_timestamp DESC LIMIT 1`,
        [deviceId]
      );
      result.hrm = hrm;

      const htm = await this.db.getFirstAsync<HTMPacket>(
        `SELECT * FROM htm_packets WHERE device_id = ? ORDER BY app_timestamp DESC LIMIT 1`,
        [deviceId]
      );
      result.htm = htm;

      return result;
    } catch (error) {
      console.error('Error querying latest packet data:', error);
      throw error;
    }
  }

  /**
   * Clean up old data to manage database size
   * Keeps only the last 7 days of packet data. Keeps impact events indefinitely.
   */
  public async cleanupOldData(): Promise<void> {
    const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000); // Milliseconds

    await this.db.withTransactionAsync(async () => {
      try {
        // Don't delete impact_events
        console.log(`[SensorDataRepo] Cleaning up data older than ${new Date(sevenDaysAgo).toISOString()}`);

        const tablesToClean = ['motion_packets', 'fsr_packets', 'hrm_packets', 'htm_packets'];
        // Also clean older *parsed* tables if you keep them
        // const tablesToClean = ['motion_packets', 'fsr_packets', 'hrm_packets', 'htm_packets', 'imu_data', 'accelerometer_data', 'temperature_data', 'force_data', 'heart_rate_data'];

        for (const table of tablesToClean) {
          const timestampField = (table === 'motion_packets' || table === 'fsr_packets') ? 'device_timestamp' : 'app_timestamp';
          // Adjust query based on whether timestamp is seconds or milliseconds
          const timestampCondition = timestampField === 'device_timestamp'
            ? `WHERE ${timestampField} < ?` // Assuming device_timestamp is seconds
            : `WHERE ${timestampField} < ?`; // Assuming app_timestamp is milliseconds

          const timestampValue = timestampField === 'device_timestamp'
            ? Math.floor(sevenDaysAgo / 1000)
            : sevenDaysAgo;

          const result = await this.db.runAsync(
            `DELETE FROM ${table} ${timestampCondition}`,
            [timestampValue]
          );
          console.log(`[SensorDataRepo] Deleted ${result.changes} old records from ${table}`);
        }
      } catch (error) {
        console.error('Transaction error cleaning up old data:', error);
        throw error; // Ensure transaction rollback
      }
    });
  }

  /**
   * Record an impact event
   */
  public async recordImpactEvent(
    event: Omit<ImpactEvent, 'id' | 'processed'> // Expect an object
  ): Promise<number> { // Return the inserted ID
    console.warn(`SensorDataRepository: Recording potential impact event: ${event.magnitude.toFixed(1)}g`);
    const result = await this.db.runAsync(
      `INSERT INTO impact_events (device_id, athlete_id, timestamp, magnitude, x, y, z, duration_ms, location, processed, severity, notes, created_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        event.deviceId,
        event.athleteId ?? null,
        event.createdAt, // Use createdAt (app timestamp) for the main timestamp column
        event.magnitude,
        event.x, event.y, event.z,
        event.durationMs ?? null,
        event.location ?? null,
        0, // processed = false
        event.severity ?? null,
        event.notes ?? null,
        event.createdAt // Also store in created_at
      ]
    );
    // Emit concussion detected event
    dataChangeEmitter.emit(dbEvents.CONCUSSION_DETECTED, {
      deviceId: event.deviceId,
      timestamp: event.timestamp,
      magnitude: event.magnitude,
      athleteId: event.athleteId // Pass athleteId if available
    });
    return result.lastInsertRowId; // Return the ID
  }
} 

================================================================================
File: src/services/AppSetupService.ts
================================================================================

import AsyncStorage from '@react-native-async-storage/async-storage';
import { DatabaseManager } from '../DatabaseManager';
import { StorageService } from './StorageService';
import { AthleteRepository } from '../repositories/AthleteRepository';
import { SensorDataRepository } from '../repositories/SensorDataRepository';

/**
 * Service for handling app setup/initialization tasks
 */
export class AppSetupService {
  private storageService: StorageService;
  private databaseManager: DatabaseManager;
  
  /**
   * Constructor
   * @param storageService Injected storage service
   * @param databaseManager Injected database manager
   */
  constructor(
    storageService: StorageService,
    databaseManager: DatabaseManager
  ) {
    this.storageService = storageService;
    this.databaseManager = databaseManager;
  }
  
  /**
   * Test AsyncStorage operation by setting and getting a value
   * @returns Promise that resolves with true if test passed, false otherwise
   */
  public async testAsyncStorage(): Promise<boolean> {
    try {
      const testKey = 'asyncStorageTestValue';
      const testValue = `test-${Date.now()}`;
      
      // Set the test value
      await AsyncStorage.setItem(testKey, testValue);
      
      // Get the test value
      const retrieved = await AsyncStorage.getItem(testKey);
      
      // Clean up
      await AsyncStorage.removeItem(testKey);
      
      // Check if test passed
      return retrieved === testValue;
    } catch (error) {
      console.error('[AppSetupService] AsyncStorage test failed:', error);
      return false;
    }
  }
  
  /**
   * Check if this is the first launch and initialize if needed
   */
  public async ensureInitialized(): Promise<void> {
    const hasLaunchedKey = 'hasLaunched';
    
    try {
      const hasLaunched = await this.storageService.getValue<boolean>(hasLaunchedKey);
      
      // Always initialize database to ensure tables exist
      console.log('[AppSetupService] Initializing database...');
      await this.databaseManager.initialize({ forceRun: true });
      
      if (!hasLaunched) {
        console.log('[AppSetupService] First launch detected, performing initialization...');
        
        // Call the first-time setup method
        await this.performFirstTimeSetup();
      } else {
        console.log('[AppSetupService] Not first launch, skipping first-time setup');
      }
    } catch (error) {
      console.error('[AppSetupService] Error during initialization:', error);
      throw error;
    }
  }
  
  /**
   * Reset the app to "first launch" state
   * Warning: This will clear all data
   */
  public async resetAppState(): Promise<void> {
    try {
      // Clear AsyncStorage
      await AsyncStorage.clear();
      
      // Reset database
      await this.databaseManager.resetDatabase();
      
      console.log('[AppSetupService] App state reset complete');
    } catch (error) {
      console.error('[AppSetupService] Error resetting app state:', error);
      throw error;
    }
  }
  
  /**
   * Perform first-time initialization tasks
   */
  private async performFirstTimeSetup(): Promise<void> {
    try {
      console.log('[AppSetupService] Performing first-time initialization...');
      
      // Get database connection
      const db = await this.databaseManager.getDatabase('mouthguardMonitor');
      
      // Create repositories
      const athleteRepository = new AthleteRepository(db);
      const sensorDataRepository = new SensorDataRepository(db);
      
      // Create sample data for testing
      await this.createSampleData(athleteRepository);
      
      // Mark initialization as complete
      await AsyncStorage.setItem('hasLaunched', 'true');
      
      console.log('[AppSetupService] First-time initialization complete');
    } catch (error) {
      console.error('[AppSetupService] First-time initialization failed:', error);
      throw error;
    }
  }
  
  /**
   * Create sample data for testing
   */
  private async createSampleData(athleteRepository: AthleteRepository): Promise<void> {
    try {
      console.log('[AppSetupService] Creating sample athletes for testing...');
      
      // Add some test athletes
      const sampleAthletes = [
        {
          name: 'John Doe',
          team: 'Blue Team',
          position: 'Forward',
          age: 19,
          height: '6\'2"',
          weight: '185 lbs',
          deviceId: undefined,
          notes: 'Sample athlete 1',
          number: '23',
          active: true
        },
        {
          name: 'Jane Smith',
          team: 'Red Team',
          position: 'Defense',
          age: 20,
          height: '5\'9"',
          weight: '165 lbs',
          deviceId: undefined,
          notes: 'Sample athlete 2',
          number: '45',
          active: true
        }
      ];
      
      // Add each athlete
      for (const athlete of sampleAthletes) {
        console.log(`[AppSetupService] Adding sample athlete: ${athlete.name}`);
        await athleteRepository.addAthlete(athlete);
      }
      
      console.log('[AppSetupService] Sample data creation complete');
    } catch (error) {
      console.error('[AppSetupService] Error creating sample data:', error);
      // Don't throw error here - we don't want to fail initialization because of sample data
      console.log('[AppSetupService] Continuing initialization despite sample data error');
    }
  }
} 

================================================================================
File: src/services/BluetoothService.ts
================================================================================

import { Alert, PermissionsAndroid, Platform, AppState } from "react-native";
import * as ExpoDevice from "expo-device";
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';
import base64 from "react-native-base64";
import { Buffer } from 'buffer'; // Import Buffer for binary data parsing
import { BluetoothHandler, SensorCallbacks } from "../contexts/BluetoothContext";
import { DeviceService } from "./DeviceService";
import { SensorDataRepository } from "../repositories/SensorDataRepository";
import { AthleteRepository } from "../repositories/AthleteRepository";
import { DeviceStatus, LiveDataPoint, Session, MotionPacket, FSRPacket, HRMPacket, HTMPacket, ConcussionAlert } from "../types";
import { dataChangeEmitter, dbEvents } from "../utils/EventEmitter";
import { v4 as uuidv4 } from 'uuid';
import { MOUTHGUARD_UUIDS } from '../bleConstants'; // Import the new UUIDs

// Event key for device status updates
const DEVICE_STATUS_UPDATE_EVENT = 'deviceStatusUpdate';
const SENSOR_DATA_EVENT = 'sensorDataEvent';

// Add threshold constants at the top of the file
const CONCUSSION_THRESHOLD_G = 80; // 80g threshold for potential concussion
const MAX_HR_THRESHOLD = 190; // Maximum heart rate threshold
const MIN_HR_THRESHOLD = 40; // Minimum heart rate threshold
const MAX_TEMP_THRESHOLD = 39; // Maximum temperature threshold in Celsius
const MIN_TEMP_THRESHOLD = 35; // Minimum temperature threshold in Celsius

type DeviceStatusSubscription = {
  remove: () => void;
};

type SensorDataSubscription = {
  remove: () => void;
};

/**
 * BluetoothService uses composition with BluetoothHandler and integrates with DeviceService
 * for saving connected devices and with SensorDataRepository for recording sensor data
 */
export class BluetoothService {
  private bluetoothHandler: BluetoothHandler;
  private deviceService: DeviceService;
  private sensorDataRepository: SensorDataRepository;
  private athleteRepository: AthleteRepository;
  private deviceStatusMap: Map<string, DeviceStatus> = new Map();
  private currentSession: Session | null = null;
  private manager: BleManager; // BLE manager instance
  private connectedDevices: Map<string, Device> = new Map(); // Store Device directly

  /**
   * Constructor
   * @param deviceService Service for saving devices
   * @param sensorDataRepository Repository for recording sensor data
   * @param athleteRepository Repository for athlete data
   * @param bluetoothHandler Optional BluetoothHandler instance (creates one if not provided)
   */
  constructor(
    deviceService: DeviceService, 
    sensorDataRepository: SensorDataRepository,
    athleteRepository: AthleteRepository,
    bluetoothHandler?: BluetoothHandler
  ) {
    this.bluetoothHandler = bluetoothHandler || new BluetoothHandler();
    this.deviceService = deviceService;
    this.sensorDataRepository = sensorDataRepository;
    this.athleteRepository = athleteRepository;
    this.manager = new BleManager();
    
    // Set up the callbacks to handle data from bluetooth
    this.setupSensorCallbacks();
    
    // Listen for app state changes to manage connections
    AppState.addEventListener('change', this.handleAppStateChange);
  }

  /**
   * Handle app state changes
   */
  private handleAppStateChange = (nextAppState: string): void => {
    if (nextAppState === 'active') {
      // App came to foreground
      console.log('[BluetoothService] App is active, syncing time with all devices');
      this.bluetoothHandler.syncTimeWithAllDevices();
      
      // Refresh device status
      this.refreshAllDeviceStatus();
    }
  };

  /**
   * Refresh status for all connected devices
   */
  private async refreshAllDeviceStatus(): Promise<void> {
    try {
      // Get all connected devices
      const connectedDevices = this.bluetoothHandler.getConnectedDevices();
      
      // Process each device
      for (const [deviceId, device] of connectedDevices.entries()) {
        await this.updateDeviceStatus(deviceId, true);
      }
    } catch (error) {
      console.error('[BluetoothService] Error refreshing device status:', error);
    }
  }

  /**
   * Update status for a specific device
   */
  private async updateDeviceStatus(deviceId: string, isConnected: boolean): Promise<void> {
    try {
      // Get device details
      let deviceStatus: DeviceStatus = {
        id: deviceId,
        name: 'Unknown Device',
        connected: isConnected,
        lastSeen: Date.now()
      };
      
      // Try to get saved device
      const savedDevices = await this.deviceService.getSavedDevices();
      const savedDevice = savedDevices.find(d => d.id === deviceId);
      
      if (savedDevice) {
        deviceStatus.name = savedDevice.name;
        deviceStatus.batteryLevel = savedDevice.batteryLevel;
      }
      
      // Try to get assigned athlete
      if (savedDevice?.athleteId) {
        const athlete = await this.athleteRepository.getAthleteById(savedDevice.athleteId);
        if (athlete) {
          deviceStatus.athleteInfo = {
            id: athlete.id,
            name: athlete.name
          };
        }
      } else {
        // Or check if this device is assigned to any athlete
        const athlete = await this.athleteRepository.getAthleteByDeviceId(deviceId);
        if (athlete) {
          deviceStatus.athleteInfo = {
            id: athlete.id,
            name: athlete.name
          };
          
          // Update saved device with athlete ID if not already set
          if (savedDevice && !savedDevice.athleteId) {
            await this.deviceService.updateDeviceAthleteAssignment(deviceId, athlete.id);
          }
        }
      }
      
      // Store in the map
      this.deviceStatusMap.set(deviceId, deviceStatus);
      
      // Emit update event
      dataChangeEmitter.emit(DEVICE_STATUS_UPDATE_EVENT, deviceStatus);
      
    } catch (error) {
      console.error(`[BluetoothService] Error updating status for device ${deviceId}:`, error);
    }
  }

  /**
   * Subscribe to device status updates
   */
  public subscribeToDeviceStatusUpdates(callback: (status: DeviceStatus) => void): DeviceStatusSubscription {
    const handler = (status: DeviceStatus) => {
      callback(status);
    };
    
    dataChangeEmitter.on(DEVICE_STATUS_UPDATE_EVENT, handler);
    
    // Initial status emission for all known devices
    for (const status of this.deviceStatusMap.values()) {
      callback(status);
    }
    
    return {
      remove: () => {
        dataChangeEmitter.off(DEVICE_STATUS_UPDATE_EVENT, handler);
      }
    };
  }

  /**
   * Setup callbacks for different sensor types
   */
  private setupSensorCallbacks(): void {
    const callbacks: SensorCallbacks = {
      onImuData: this.handleImuData.bind(this),
      onAccelerometerData: this.handleAccelerometerData.bind(this),
      onTemperatureData: this.handleTemperatureData.bind(this),
      onForceData: this.handleForceData.bind(this),
      onHeartRateData: this.handleHeartRateData.bind(this),
      onBatteryLevel: this.handleBatteryLevel.bind(this)
    };
    
    this.bluetoothHandler.setSensorCallbacks(callbacks);
  }

  /**
   * Handle IMU data from the device
   */
  private async handleImuData(deviceId: string, sensorId: number, data: { timestamp: number, values: number[] }): Promise<void> {
    try {
      const [x, y, z] = data.values;
      // console.log(`[BluetoothService] IMU data from ${deviceId} sensor ${sensorId}: x=${x}, y=${y}, z=${z}`);
      
      // Update device's last seen timestamp
      await this.updateDeviceLastSeen(deviceId);
      
      // Emit live data event
      const liveDataPoint: LiveDataPoint = {
        deviceId,
        timestamp: data.timestamp,
        type: 'imu',
        values: [x, y, z]
      };
      dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, liveDataPoint);
      
      // Save to repository
      await this.sensorDataRepository.recordImuData(deviceId, sensorId, data.timestamp, x, y, z);
      
      // Emit data change event
      dataChangeEmitter.emit(dbEvents.DATA_CHANGED);
    } catch (error) {
      console.error('[BluetoothService] Error processing IMU data:', error);
    }
  }

  /**
   * Handle Accelerometer data from the device
   */
  private async handleAccelerometerData(deviceId: string, sensorId: number, data: { timestamp: number, values: number[] }): Promise<void> {
    try {
      const [x, y, z, magnitude] = data.values;
      // console.log(`[BluetoothService] Accelerometer data from ${deviceId} sensor ${sensorId}: x=${x}, y=${y}, z=${z}, magnitude=${magnitude}`);
      
      // Update device's last seen timestamp
      await this.updateDeviceLastSeen(deviceId);
      
      // Emit live data event for real-time display
      const liveDataPoint: LiveDataPoint = {
        deviceId,
        timestamp: data.timestamp,
        type: 'accelerometer',
        values: data.values
      };
      dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, liveDataPoint);
      
      // If we have a high-G event, detect potential concussion
      if (magnitude > CONCUSSION_THRESHOLD_G) {
        console.log(`[BluetoothService] HIGH-G IMPACT DETECTED: ${magnitude.toFixed(1)}g from device ${deviceId}`);
        
        // Get athlete info if available
        let athleteId: string | undefined;
        let athleteName: string | undefined;
        
        try {
          const savedDevices = await this.deviceService.getSavedDevices();
          const device = savedDevices.find(d => d.id === deviceId);
          
          if (device?.athleteId) {
            const athlete = await this.athleteRepository.getAthleteById(device.athleteId);
            if (athlete) {
              athleteId = athlete.id;
              athleteName = athlete.name;
            }
          }
        } catch (error) {
          console.error('[BluetoothService] Error getting athlete info for impact alert:', error);
        }
        
        // Generate a concussion alert
        const alertId = `alert_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
        const severity = 
          magnitude > 120 ? 'critical' :
          magnitude > 100 ? 'severe' :
          magnitude > 80 ? 'moderate' : 'low';
          
        const alert: ConcussionAlert = {
          id: alertId,
          deviceId,
          athleteId,
          athleteName,
          timestamp: data.timestamp,
          magnitude,
          severity: severity as any,
          acknowledged: false
        };
        
        // COMMENT OUT: Emit alert event
        // dataChangeEmitter.emit('ALERT_TRIGGERED', alert);
        
        // Record impact event
        try {
          await this.sensorDataRepository.recordImpactEvent({
            deviceId,
            athleteId,
            timestamp: data.timestamp,
            magnitude,
            x, y, z,
            severity: severity as any,
            createdAt: Date.now()
          });
        } catch (error) {
          console.error('[BluetoothService] Error recording impact event:', error);
        }
      }
      
      // Record the accelerometer data
      await this.sensorDataRepository.recordAccelerometerData({
        deviceId,
        sensorId,
        timestamp: data.timestamp,
        x, y, z,
        magnitude,
        createdAt: Date.now()
      });
    } catch (error) {
      console.error(`[BluetoothService] Error handling accelerometer data: ${error}`);
    }
  }

  /**
   * Handle Temperature data from the device
   */
  private async handleTemperatureData(deviceId: string, sensorId: number, data: { timestamp: number, values: number[] }): Promise<void> {
    try {
      const temperature = data.values[0];
      // console.log(`[BluetoothService] Temperature data from ${deviceId} sensor ${sensorId}: ${temperature}C`);
      
      // Update device's last seen timestamp
      await this.updateDeviceLastSeen(deviceId);
      
      // Emit live data for real-time display
      const liveDataPoint: LiveDataPoint = {
        deviceId,
        timestamp: data.timestamp,
        type: 'temperature',
        values: data.values
      };
      dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, liveDataPoint);
      
      // Check for temperature threshold violations
      if (temperature > MAX_TEMP_THRESHOLD || temperature < MIN_TEMP_THRESHOLD) {
        console.log(`[BluetoothService] TEMPERATURE ALERT: ${temperature.toFixed(1)}C from device ${deviceId}`);
        
        // Get athlete info if available
        let athleteId: string | undefined;
        let athleteName: string | undefined;
        
        try {
          const savedDevices = await this.deviceService.getSavedDevices();
          const device = savedDevices.find(d => d.id === deviceId);
          
          if (device?.athleteId) {
            const athlete = await this.athleteRepository.getAthleteById(device.athleteId);
            if (athlete) {
              athleteId = athlete.id;
              athleteName = athlete.name;
            }
          }
        } catch (error) {
          console.error('[BluetoothService] Error getting athlete info for temperature alert:', error);
        }
        
        // Generate an alert
        const alertId = `alert_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
        const severity = 
          temperature > MAX_TEMP_THRESHOLD ? 'severe' :
          temperature < MIN_TEMP_THRESHOLD ? 'moderate' : 'low';
          
        const alert: ConcussionAlert = {
          id: alertId,
          deviceId,
          athleteId,
          athleteName,
          timestamp: data.timestamp,
          magnitude: temperature, // Using temperature as magnitude
          severity: severity as any,
          acknowledged: false,
          notes: `Temperature: ${temperature.toFixed(1)}C (${temperature > MAX_TEMP_THRESHOLD ? 'above maximum threshold' : 'below minimum threshold'})`
        };
        
        // Emit alert event
        dataChangeEmitter.emit('ALERT_TRIGGERED', alert);
      }
      
      // Record the temperature data
      await this.sensorDataRepository.recordTemperatureData({
        deviceId,
        sensorId,
        timestamp: data.timestamp,
        temperature,
        createdAt: Date.now()
      });
    } catch (error) {
      console.error(`[BluetoothService] Error handling temperature data: ${error}`);
    }
  }

  /**
   * Handle Force data from the device
   */
  private async handleForceData(deviceId: string, sensorId: number, data: { timestamp: number, values: number[] }): Promise<void> {
    try {
      const force = data.values[0];
      // console.log(`[BluetoothService] Force data from ${deviceId} sensor ${sensorId}: force=${force}N`);
      
      // Update device's last seen timestamp
      await this.updateDeviceLastSeen(deviceId);
      
      // Emit live data event
      const liveDataPoint: LiveDataPoint = {
        deviceId,
        timestamp: data.timestamp,
        type: 'force',
        values: [force]
      };
      dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, liveDataPoint);
      
      // Save to repository
      await this.sensorDataRepository.recordForceData(deviceId, sensorId, data.timestamp, force);
      
      // Emit data change event
      dataChangeEmitter.emit(dbEvents.DATA_CHANGED);
    } catch (error) {
      console.error('[BluetoothService] Error processing force data:', error);
    }
  }

  /**
   * Handle Heart Rate data from the device
   */
  private async handleHeartRateData(deviceId: string, heartRate: number): Promise<void> {
    try {
      // Update device's last seen timestamp
      await this.updateDeviceLastSeen(deviceId);
      
      // Emit live data for real-time display
      const liveDataPoint: LiveDataPoint = {
        deviceId,
        timestamp: Date.now(),
        type: 'heartRate',
        values: [heartRate]
      };
      dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, liveDataPoint);
      
      // Check for heart rate threshold violations
      if (heartRate > MAX_HR_THRESHOLD || heartRate < MIN_HR_THRESHOLD) {
        console.log(`[BluetoothService] HEART RATE ALERT: ${heartRate} bpm from device ${deviceId}`);
        
        // Get athlete info if available
        let athleteId: string | undefined;
        let athleteName: string | undefined;
        
        try {
          const savedDevices = await this.deviceService.getSavedDevices();
          const device = savedDevices.find(d => d.id === deviceId);
          
          if (device?.athleteId) {
            const athlete = await this.athleteRepository.getAthleteById(device.athleteId);
            if (athlete) {
              athleteId = athlete.id;
              athleteName = athlete.name;
            }
          }
        } catch (error) {
          console.error('[BluetoothService] Error getting athlete info for heart rate alert:', error);
        }
        
        // Generate an alert
        const alertId = `alert_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
        const severity = 
          heartRate > MAX_HR_THRESHOLD ? 'severe' :
          heartRate < MIN_HR_THRESHOLD ? 'critical' : 'moderate';
          
        const alert: ConcussionAlert = {
          id: alertId,
          deviceId,
          athleteId,
          athleteName,
          timestamp: Date.now(),
          magnitude: heartRate, // Using heartRate as magnitude for visualization
          severity: severity as any,
          acknowledged: false,
          notes: `Heart rate: ${heartRate} bpm (${heartRate > MAX_HR_THRESHOLD ? 'above maximum threshold' : 'below minimum threshold'})`
        };
        
        // Emit alert event
        dataChangeEmitter.emit('ALERT_TRIGGERED', alert);
      }
      
      // Record the heart rate data
      await this.sensorDataRepository.recordHeartRateData({
        deviceId,
        timestamp: Date.now(),
        heartRate,
        createdAt: Date.now()
      });
    } catch (error) {
      console.error(`[BluetoothService] Error handling heart rate data: ${error}`);
    }
  }

  /**
   * Handle Battery Level data from the device
   */
  private async handleBatteryLevel(deviceId: string, level: number): Promise<void> {
    try {
      console.log(`[BluetoothService] Battery level from ${deviceId}: ${level}%`);
      
      // Update device battery level in storage
      await this.deviceService.updateDeviceBatteryLevel(deviceId, level);
      
      // Update device status map
      if (this.deviceStatusMap.has(deviceId)) {
        const updatedStatus = {
          ...this.deviceStatusMap.get(deviceId)!,
          batteryLevel: level,
          lastSeen: Date.now()
        };
        this.deviceStatusMap.set(deviceId, updatedStatus);
        
        // Emit update
        dataChangeEmitter.emit(DEVICE_STATUS_UPDATE_EVENT, updatedStatus);
      }
      
      // Low battery warning
      if (level < 20 && AppState.currentState === 'active') {
        // Get device name
        let deviceName = `Device ${deviceId}`;
        if (this.deviceStatusMap.has(deviceId)) {
          deviceName = this.deviceStatusMap.get(deviceId)!.name;
        }
        
        Alert.alert('Low Battery', `${deviceName} battery level is ${level}%. Please charge soon.`);
      }
    } catch (error) {
      console.error('[BluetoothService] Error processing battery level data:', error);
    }
  }

  /**
   * Update the last seen timestamp for a device
   */
  private async updateDeviceLastSeen(deviceId: string): Promise<void> {
    // Update the status map
    if (this.deviceStatusMap.has(deviceId)) {
      const currentStatus = this.deviceStatusMap.get(deviceId)!;
      // Only update if it's been more than 5 seconds since the last update
      // to avoid excessive update events
      if (!currentStatus.lastSeen || Date.now() - currentStatus.lastSeen > 5000) {
        const updatedStatus = {
          ...currentStatus,
          lastSeen: Date.now()
        };
        this.deviceStatusMap.set(deviceId, updatedStatus);
        
        // Emit update
        dataChangeEmitter.emit(DEVICE_STATUS_UPDATE_EVENT, updatedStatus);
      }
    }
  }

  /**
   * Connect to a device by ID and save it to storage
   * @param deviceId ID of the device to connect to
   */
  public async connectToDevice(deviceId: string): Promise<void> {
    try {
      console.log(`[BluetoothService] Connecting to device: ${deviceId}`);
      
      // Check if already connected
      if (this.connectedDevices.has(deviceId)) {
        console.log(`[BluetoothService] Device ${deviceId} already connected`);
        this.updateDeviceStatus(deviceId, true);
        return;
      }
      
      // Attempt connection
      const device = await this.manager.connectToDevice(deviceId);
      console.log(`[BluetoothService] Connected to device: ${deviceId}`);
      
      // Store in connected devices map
      this.connectedDevices.set(deviceId, device);
      
      // Update device status
      this.updateDeviceStatus(deviceId, true);

      // Discover services and characteristics
      console.log(`[BluetoothService] Discovering services for device: ${deviceId}`);
      await device.discoverAllServicesAndCharacteristics();
      console.log(`[BluetoothService] Services discovered for device: ${deviceId}`);
      
      // Setup monitoring for relevant characteristics
      this.setupMonitoringForDevice(deviceId);
      
      // Update saved device with lastConnected
      const savedDevices = await this.deviceService.getSavedDevices();
      const savedDevice = savedDevices.find(d => d.id === deviceId);
      
      if (savedDevice) {
        await this.deviceService.updateDeviceLastConnected(deviceId);
      } else {
        // Save the actual Device object
        await this.deviceService.saveDevice(device);
      }
      
    } catch (error) {
      console.error(`[BluetoothService] Error connecting to device ${deviceId}:`, error);
      throw error;
    }
  }

  /**
   * Scan for BLE devices
   * @param onDeviceFound Callback function for each device found
   * @param timeoutMs Optional scan timeout in milliseconds
   * @returns Promise that resolves when scan is complete
   */
  public async scanForDevices(
    onDeviceFound: (device: Device) => void,
    timeoutMs: number = 10000
  ): Promise<void> {
    try {
      // Get BLE manager from handler
      const manager = this.bluetoothHandler.getBLEManager();
      
      // Request permissions first
      const hasPermission = await this.bluetoothHandler.requestPermissions();
      if (!hasPermission) {
        throw new Error('Bluetooth permissions not granted');
      }
      
      // Start scanning
      console.log('[BluetoothService] Starting device scan...');
      manager.startDeviceScan(null, null, (error, device) => {
        if (error) {
          console.error('[BluetoothService] Scan error:', error);
          return;
        }
        
        if (device && device.name) {
          // Call the callback with the found device
          onDeviceFound(device);
        }
      });
      
      // Stop scan after timeout
      return new Promise((resolve) => {
        setTimeout(() => {
          manager.stopDeviceScan();
          console.log('[BluetoothService] Device scan stopped');
          resolve();
        }, timeoutMs);
      });
    } catch (error) {
      console.error('[BluetoothService] Error scanning for devices:', error);
      throw error;
    }
  }

  /**
   * Disconnect from a device
   * @param deviceId ID of the device to disconnect from
   */
  public disconnectFromDevice(deviceId: string): void {
    try {
      this.bluetoothHandler.disconnectFromDevice(deviceId);
      
      // Update status
      if (this.deviceStatusMap.has(deviceId)) {
        const disconnectedStatus = {
          ...this.deviceStatusMap.get(deviceId)!,
          connected: false,
          lastSeen: Date.now()
        };
        this.deviceStatusMap.set(deviceId, disconnectedStatus);
        dataChangeEmitter.emit(DEVICE_STATUS_UPDATE_EVENT, disconnectedStatus);
      }
    } catch (error) {
      console.error(`[BluetoothService] Error disconnecting from device ${deviceId}:`, error);
    }
  }

  /**
   * Get all connected devices
   * @returns Map of connected devices
   */
  public getConnectedDevices(): Map<string, Device> {
    // Return a copy of the connected devices map
    return new Map(this.connectedDevices);
  }

  /**
   * Get saved devices from storage
   */
  public async getSavedDevices() {
    return this.deviceService.getSavedDevices();
  }

  /**
   * Get all device statuses
   */
  public getDeviceStatuses(): DeviceStatus[] {
    return Array.from(this.deviceStatusMap.values());
  }

  /**
   * Subscribe to sensor data updates
   * @param callback Called when new sensor data is received
   * @returns Subscription object with remove method
   */
  public subscribeSensorData(
    callback: (deviceId: string, dataPoint: LiveDataPoint) => void
  ): SensorDataSubscription {
    const handler = (deviceId: string, dataPoint: LiveDataPoint) => {
      callback(deviceId, dataPoint);
    };
    
    dataChangeEmitter.on(SENSOR_DATA_EVENT, handler);
    
    return {
      remove: () => {
        dataChangeEmitter.off(SENSOR_DATA_EVENT, handler);
      }
    };
  }

  /**
   * Start a monitoring session
   * Creates a new session in the database
   */
  public async startSession(): Promise<string> {
    if (this.currentSession) {
      throw new Error('A session is already active. Stop it before starting a new one.');
    }
    
    try {
      // Create session ID
      const sessionId = `session_${uuidv4()}`;
      const now = Date.now();
      
      // Create session object
      this.currentSession = {
        id: sessionId,
        name: `Session ${new Date(now).toLocaleString()}`,
        startTime: now,
        createdAt: now
      };
      
      // Save session to database
      // TODO: Implement SessionRepository and save session
      console.log(`[BluetoothService] Started session ${sessionId}`);
      
      // Get all connected devices with athletes
      const connectedDevices = Array.from(this.deviceStatusMap.values())
        .filter(device => device.connected && device.athleteInfo);
      
      // Record session-athlete associations
      for (const device of connectedDevices) {
        if (device.athleteInfo) {
          // TODO: Save session-athlete relationship in database
          console.log(`[BluetoothService] Added athlete ${device.athleteInfo.id} to session ${sessionId}`);
        }
      }
      
      return sessionId;
    } catch (error) {
      console.error('[BluetoothService] Error starting session:', error);
      throw error;
    }
  }

  /**
   * Stop the current monitoring session
   */
  public async stopSession(): Promise<void> {
    if (!this.currentSession) {
      throw new Error('No active session to stop.');
    }
    
    try {
      const now = Date.now();
      
      // Update session with end time
      this.currentSession.endTime = now;
      
      // Save updated session to database
      // TODO: Implement SessionRepository and update session
      console.log(`[BluetoothService] Stopped session ${this.currentSession.id}`);
      
      // Update session-athlete records with end time
      // TODO: Implement SessionAthleteRepository and update records
      
      // Clear current session
      this.currentSession = null;
    } catch (error) {
      console.error('[BluetoothService] Error stopping session:', error);
      throw error;
    }
  }

  /**
   * Setup monitoring for BLE characteristics for a connected device
   */
  private setupMonitoringForDevice(deviceId: string) {
    const device = this.connectedDevices.get(deviceId);
    if (!device) {
        console.error(`[BluetoothService] Device ${deviceId} not found for monitoring setup`);
        return;
    }

    console.log(`[BluetoothService] Setting up monitoring for device ${deviceId}`);

    // Characteristics to monitor
    const characteristicsToMonitor = [
        { service: MOUTHGUARD_UUIDS.services.hrm, characteristic: MOUTHGUARD_UUIDS.characteristics.hrmData },
        { service: MOUTHGUARD_UUIDS.services.htm, characteristic: MOUTHGUARD_UUIDS.characteristics.htmData },
        { service: MOUTHGUARD_UUIDS.services.imu, characteristic: MOUTHGUARD_UUIDS.characteristics.imuData },
        { service: MOUTHGUARD_UUIDS.services.fsr, characteristic: MOUTHGUARD_UUIDS.characteristics.fsrData },
        // Add battery if needed
        { service: MOUTHGUARD_UUIDS.services.battery, characteristic: MOUTHGUARD_UUIDS.characteristics.batteryLevel },
    ];

    characteristicsToMonitor.forEach(({ service, characteristic }) => {
        try {
            console.log(`[BluetoothService] - Monitoring ${service}/${characteristic}`);
            device.monitorCharacteristicForService(
                service,
                characteristic,
                (error, char) => this.handleCharacteristicUpdate(
                    deviceId, service, characteristic, error, char
                )
            );
        } catch (error) {
            console.error(`[BluetoothService] Error setting up monitoring for ${service}/${characteristic}:`, error);
        }
    });

    console.log(`[BluetoothService] Monitoring setup complete for device ${deviceId}`);
  }

  /**
   * Parse and handle incoming BLE characteristic updates from the device
   */
  private handleCharacteristicUpdate = async (
    deviceId: string,
    serviceUuid: string,
    characteristicUuid: string,
    error: BleError | null,
    characteristic: Characteristic | null
  ): Promise<void> => {
    if (error) {
        // Handle connection errors, log them, potentially update device status
        console.error(`[BluetoothService] Error monitoring ${characteristicUuid}:`, error.message);
        if (error.errorCode === 201 || error.errorCode === 205) { // Device disconnected codes
             this.updateDeviceStatus(deviceId, false); // Update status to disconnected
             this.connectedDevices.delete(deviceId);
        }
        return;
    }

    if (!characteristic?.value) {
        console.warn(`[BluetoothService] No data received from ${characteristicUuid}`);
        return;
    }

    try {
        // Decode Base64 value to a Buffer
        const buffer = Buffer.from(characteristic.value, 'base64');
        const appTimestamp = Date.now(); // Timestamp when app received data

        // --- PARSING LOGIC BASED ON CHARACTERISTIC UUID ---

        // --- HRM Data ---
        if (characteristicUuid.toLowerCase() === MOUTHGUARD_UUIDS.characteristics.hrmData.toLowerCase()) {
            if (buffer.length >= 5) { // Expected size: 1 byte HR + 4 bytes timestamp
                const hrmPacket: HRMPacket = {
                    heartRate: buffer.readUInt8(0),
                    // Assuming device_timestamp is uint32_t LE at offset 1
                    deviceTimestamp: buffer.readUInt32LE(1),
                    flags: 0, // Flags aren't in your custom struct, set default or derive if needed
                    appTimestamp: appTimestamp
                };
                console.log(`[BluetoothService] Parsed HRM: HR=${hrmPacket.heartRate}, DevTS=${hrmPacket.deviceTimestamp}`);
                this.sensorDataRepository.recordHRMPacket(deviceId, hrmPacket); // Store raw packet
                dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, { type: 'heartRate', deviceId, timestamp: appTimestamp, values: [hrmPacket.heartRate] } as LiveDataPoint);
                dataChangeEmitter.emit(dbEvents.DATA_CHANGED, { type: 'hrm', deviceId });
            } else {
                 console.warn(`[BluetoothService] HRM data has unexpected length: ${buffer.length} bytes`);
            }
        }

        // --- HTM Data ---
        else if (characteristicUuid.toLowerCase() === MOUTHGUARD_UUIDS.characteristics.htmData.toLowerCase()) {
             if (buffer.length >= 6) { // Expected size: 2 bytes temp + 4 bytes timestamp
                // Read temperature (int16_t, scaled by 100)
                const rawTempValue = buffer.readInt16LE(0);
                const temperatureCelsius = rawTempValue / 100.0; // Reverse the scaling
                const deviceTimestamp = buffer.readUInt32LE(2);

                const htmPacket: HTMPacket = {
                     temperature: temperatureCelsius, // Store the actual temperature
                     timestamp: deviceTimestamp, // Use the timestamp property from the interface
                     flags: 0, // Flags aren't in your custom struct
                     appTimestamp: appTimestamp
                };
                console.log(`[BluetoothService] Parsed HTM: Temp=${htmPacket.temperature.toFixed(2)}C, DevTS=${htmPacket.timestamp}`);
                this.sensorDataRepository.recordHTMPacket(deviceId, htmPacket); // Store parsed packet
                dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, { type: 'temperature', deviceId, timestamp: appTimestamp, values: [htmPacket.temperature] } as LiveDataPoint);
                dataChangeEmitter.emit(dbEvents.DATA_CHANGED, { type: 'htm', deviceId });
            } else {
                 console.warn(`[BluetoothService] HTM data has unexpected length: ${buffer.length} bytes`);
            }
        }

        // --- IMU Data ---
        else if (characteristicUuid.toLowerCase() === MOUTHGUARD_UUIDS.characteristics.imuData.toLowerCase()) {
            const EXPECTED_IMU_LENGTH = 32; // Define expected length
            if (buffer.length >= EXPECTED_IMU_LENGTH) {
                // Parse only if length is sufficient
                const motionPacket: MotionPacket = {
                    gyro: [buffer.readInt16LE(0), buffer.readInt16LE(2), buffer.readInt16LE(4)],
                    accel16: [buffer.readInt16LE(6), buffer.readInt16LE(8), buffer.readInt16LE(10)],
                    accel200: [buffer.readInt16LE(12), buffer.readInt16LE(14), buffer.readInt16LE(16)],
                    mag: [buffer.readInt16LE(18), buffer.readInt16LE(20), buffer.readInt16LE(22)],
                    bite_l: buffer.readUInt16LE(24),
                    bite_r: buffer.readUInt16LE(26),
                    timestamp: buffer.readUInt32LE(28) // Device timestamp
                };
                console.log(`[BluetoothService] Parsed IMU: Gyro=${motionPacket.gyro[0]}, Acc16=${motionPacket.accel16[0]}, Acc200=${motionPacket.accel200[0]}, Mag=${motionPacket.mag[0]}, BiteL=${motionPacket.bite_l}, DevTS=${motionPacket.timestamp}`);
                // Use await here to catch potential errors from the repository
                await this.sensorDataRepository.recordMotionPacket(deviceId, motionPacket);
                // Emit specific live data points as needed (e.g., high-G accel)
                const SENSITIVITY_200G = 16384 / 200; // Example, adjust as needed
                const gForceX = motionPacket.accel200[0] / SENSITIVITY_200G;
                const gForceY = motionPacket.accel200[1] / SENSITIVITY_200G;
                const gForceZ = motionPacket.accel200[2] / SENSITIVITY_200G;
                const magnitude = Math.sqrt(gForceX**2 + gForceY**2 + gForceZ**2);
                dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, { type: 'accelerometer', deviceId, timestamp: appTimestamp, values: [gForceX, gForceY, gForceZ, magnitude] } as LiveDataPoint);
                dataChangeEmitter.emit(dbEvents.DATA_CHANGED, { type: 'motion', deviceId });
            } else {
                // Log the warning and skip processing this packet
                console.warn(`[BluetoothService] IMU data has unexpected length: ${buffer.length} bytes (expected >= ${EXPECTED_IMU_LENGTH}). Skipping packet.`);
                // DO NOT attempt to parse or save incomplete data
            }
        }

        // --- FSR (Bite Force) Data ---
        else if (characteristicUuid.toLowerCase() === MOUTHGUARD_UUIDS.characteristics.fsrData.toLowerCase()) {
            if (buffer.length >= 8) { // Expected size: 2 bytes left + 2 bytes right + 4 bytes timestamp
                // Read bite forces (int16_t, scaled by 100)
                const rawLeftBite = buffer.readInt16LE(0);
                const rawRightBite = buffer.readInt16LE(2);
                const leftBiteForce = rawLeftBite / 100.0;   // Reverse scaling
                const rightBiteForce = rawRightBite / 100.0; // Reverse scaling
                const deviceTimestamp = buffer.readUInt32LE(4);

                const fsrPacket: FSRPacket = {
                    left_bite: leftBiteForce,  // Store actual force
                    right_bite: rightBiteForce, // Store actual force
                    timestamp: deviceTimestamp // Device timestamp
                };
                console.log(`[BluetoothService] Parsed FSR: L=${fsrPacket.left_bite.toFixed(2)}, R=${fsrPacket.right_bite.toFixed(2)}, DevTS=${fsrPacket.timestamp}`);
                this.sensorDataRepository.recordFSRPacket(deviceId, fsrPacket); // Store parsed packet
                dataChangeEmitter.emit(SENSOR_DATA_EVENT, deviceId, { type: 'force', deviceId, timestamp: appTimestamp, values: [fsrPacket.left_bite, fsrPacket.right_bite] } as LiveDataPoint);
                dataChangeEmitter.emit(dbEvents.DATA_CHANGED, { type: 'fsr', deviceId });
            } else {
                 console.warn(`[BluetoothService] FSR data has unexpected length: ${buffer.length} bytes`);
            }
        }

        // --- Battery Level ---
         else if (characteristicUuid.toLowerCase() === MOUTHGUARD_UUIDS.characteristics.batteryLevel.toLowerCase()) {
            const level = buffer.readUInt8(0);
            this.handleBatteryLevel(deviceId, level); // Use existing handler
        }

        // --- Add other characteristic handling if needed ---

        else {
            // Optional: Log data from characteristics you don't explicitly handle
            // console.log(`[BluetoothService] Data from unhandled characteristic ${characteristicUuid}: ${buffer.toString('hex')}`);
        }

         // Update last seen timestamp after successful processing
        this.updateDeviceLastSeen(deviceId);

    } catch (parseError) {
        console.error(`[BluetoothService] Error parsing data from ${characteristicUuid}:`, parseError);
        console.error(`[BluetoothService] Raw Base64 Data: ${characteristic.value}`);
    }
  }
} 

================================================================================
File: src/services/DeviceService.ts
================================================================================

import { Device } from 'react-native-ble-plx';
import { SavedDevice } from '../types';
import { StorageService } from './StorageService';

const SAVED_DEVICES_KEY = 'savedDevices';

/**
 * Service for managing saved devices
 */
export class DeviceService {
  private storageService: StorageService;

  /**
   * Constructor
   * @param storageService Injected storage service
   */
  constructor(storageService: StorageService) {
    this.storageService = storageService;
  }

  /**
   * Get all saved devices
   * @returns Array of saved devices
   */
  public async getSavedDevices(): Promise<SavedDevice[]> {
    try {
      const devices = await this.storageService.getValue<SavedDevice[]>(SAVED_DEVICES_KEY);
      return devices || [];
    } catch (error) {
      console.error('[DeviceService] Error getting saved devices:', error);
      return [];
    }
  }

  /**
   * Save a single device to storage
   * @param device BLE device to save
   */
  public async saveDevice(device: Device): Promise<void> {
    try {
      // Get existing devices
      const existingDevices = await this.getSavedDevices();
      
      // Create SavedDevice from Device
      const savedDevice: SavedDevice = {
        id: device.id,
        name: device.name || 'Unknown Device',
        lastConnected: Date.now(),
        batteryLevel: undefined // Will be updated when we get battery data
      };
      
      // Check if device already exists
      const existingIndex = existingDevices.findIndex(d => d.id === device.id);
      
      if (existingIndex !== -1) {
        // Update existing device
        existingDevices[existingIndex] = {
          ...existingDevices[existingIndex],
          name: savedDevice.name,
          lastConnected: savedDevice.lastConnected
          // Preserve existing battery level and athlete ID
        };
      } else {
        // Add new device
        existingDevices.push(savedDevice);
      }
      
      // Save to storage
      await this.storageService.setValue(SAVED_DEVICES_KEY, existingDevices);
      
      console.log(`[DeviceService] Saved device: ${device.id}`);
    } catch (error) {
      console.error('[DeviceService] Error saving device:', error);
      throw error;
    }
  }

  /**
   * Save devices to storage
   * @param devices Array of BLE devices to save
   */
  public async saveDevices(devices: Device[]): Promise<void> {
    try {
      // Get existing devices
      const existingDevices = await this.getSavedDevices();
      
      // Map new devices to SavedDevice format
      const newDevices: SavedDevice[] = devices.map(device => ({
        id: device.id,
        name: device.name || 'Unknown Device',
        lastConnected: Date.now()
      }));
      
      // Combine with existing, avoiding duplicates
      const combinedDevices = [...existingDevices];
      
      for (const newDevice of newDevices) {
        const existingIndex = combinedDevices.findIndex(d => d.id === newDevice.id);
        if (existingIndex !== -1) {
          // Update the existing device with a new lastConnected timestamp
          combinedDevices[existingIndex] = {
            ...combinedDevices[existingIndex],
            lastConnected: Date.now()
          };
        } else {
          // Add the new device
          combinedDevices.push(newDevice);
        }
      }
      
      // Save to storage
      await this.storageService.setValue(SAVED_DEVICES_KEY, combinedDevices);
      
      console.log(`[DeviceService] Saved ${newDevices.length} devices, total: ${combinedDevices.length}`);
    } catch (error) {
      console.error('[DeviceService] Error saving devices:', error);
      throw error;
    }
  }

  /**
   * Update the battery level for a device
   * @param deviceId ID of the device to update
   * @param batteryLevel Battery level (0-100)
   */
  public async updateDeviceBatteryLevel(deviceId: string, batteryLevel: number): Promise<void> {
    try {
      const devices = await this.getSavedDevices();
      const deviceIndex = devices.findIndex(d => d.id === deviceId);
      
      if (deviceIndex !== -1) {
        // Update the battery level
        devices[deviceIndex] = {
          ...devices[deviceIndex],
          batteryLevel
        };
        
        // Save to storage
        await this.storageService.setValue(SAVED_DEVICES_KEY, devices);
        console.log(`[DeviceService] Updated battery level for device ${deviceId}: ${batteryLevel}%`);
      }
    } catch (error) {
      console.error('[DeviceService] Error updating device battery level:', error);
      throw error;
    }
  }

  /**
   * Update the athlete assignment for a device
   * @param deviceId ID of the device to update
   * @param athleteId ID of the athlete to assign
   */
  public async updateDeviceAthleteAssignment(deviceId: string, athleteId: string | undefined): Promise<void> {
    try {
      const devices = await this.getSavedDevices();
      const deviceIndex = devices.findIndex(d => d.id === deviceId);
      
      if (deviceIndex !== -1) {
        // Update the athlete assignment
        devices[deviceIndex] = {
          ...devices[deviceIndex],
          athleteId
        };
        
        // Save to storage
        await this.storageService.setValue(SAVED_DEVICES_KEY, devices);
        console.log(`[DeviceService] Updated athlete assignment for device ${deviceId}: ${athleteId}`);
      }
    } catch (error) {
      console.error('[DeviceService] Error updating device athlete assignment:', error);
      throw error;
    }
  }

  /**
   * Get device by ID
   * @param deviceId ID of the device to get
   */
  public async getDeviceById(deviceId: string): Promise<SavedDevice | null> {
    try {
      const devices = await this.getSavedDevices();
      return devices.find(d => d.id === deviceId) || null;
    } catch (error) {
      console.error(`[DeviceService] Error getting device by ID (${deviceId}):`, error);
      return null;
    }
  }

  /**
   * Remove a device from saved devices
   * @param device Device or deviceId to remove
   */
  public async removeDevice(device: SavedDevice | string): Promise<void> {
    try {
      const devices = await this.getSavedDevices();
      const deviceId = typeof device === 'string' ? device : device.id;
      const filteredDevices = devices.filter(d => d.id !== deviceId);
      
      if (filteredDevices.length !== devices.length) {
        await this.storageService.setValue(SAVED_DEVICES_KEY, filteredDevices);
        console.log(`[DeviceService] Removed device: ${deviceId}`);
      }
    } catch (error) {
      console.error(`[DeviceService] Error removing device:`, error);
      throw error;
    }
  }

  /**
   * Clear all saved devices
   */
  public async clearDevices(): Promise<void> {
    try {
      await this.storageService.setValue(SAVED_DEVICES_KEY, []);
      console.log('[DeviceService] Cleared all saved devices');
    } catch (error) {
      console.error('[DeviceService] Error clearing devices:', error);
      throw error;
    }
  }

  /**
   * Update the last connected timestamp for a device
   * @param deviceId ID of the device to update
   */
  public async updateDeviceLastConnected(deviceId: string): Promise<void> {
    try {
      const devices = await this.getSavedDevices();
      const deviceIndex = devices.findIndex(d => d.id === deviceId);

      if (deviceIndex !== -1) {
        // Update the lastConnected timestamp
        devices[deviceIndex] = {
          ...devices[deviceIndex],
          lastConnected: Date.now() // Set to current time
        };

        // Save updated list back to storage
        await this.storageService.setValue(SAVED_DEVICES_KEY, devices);
        console.log(`[DeviceService] Updated lastConnected for device ${deviceId}`);
      } else {
        console.warn(`[DeviceService] Device ${deviceId} not found when trying to update lastConnected`);
      }
    } catch (error) {
      console.error('[DeviceService] Error updating device lastConnected:', error);
      // Don't throw, maybe log or handle differently
    }
  }
} 

================================================================================
File: src/services/StorageService.ts
================================================================================

import AsyncStorage from "@react-native-async-storage/async-storage";

/**
 * Service for managing AsyncStorage operations
 */
export class StorageService {
  /**
   * Store a value in AsyncStorage with retry logic
   * @param key Storage key
   * @param value Value to store (will be JSON stringified)
   * @param retries Number of retries if operation fails
   */
  public async setValue<T>(key: string, value: T, retries: number = 3): Promise<void> {
    try {
      const jsonValue = JSON.stringify(value);
      console.log(`[StorageService] Attempting to set key: '${key}' with value: ${jsonValue}`);
      await AsyncStorage.setItem(key, jsonValue);
      
      // Verify the value was actually set
      const verifyValue = await AsyncStorage.getItem(key);
      if (verifyValue === null) {
        console.warn(`[StorageService] Verification failed for key: '${key}' - value was not persisted!`);
        if (retries > 0) {
          console.log(`[StorageService] Retrying set operation for key: '${key}', ${retries} attempts left`);
          // Add a small delay before retry
          await new Promise(resolve => setTimeout(resolve, 100));
          return this.setValue(key, value, retries - 1);
        } else {
          throw new Error(`Failed to persist value for key: '${key}' after multiple attempts`);
        }
      }
      
      console.log(`[StorageService] Successfully set and verified key: '${key}'`);
    } catch (error) {
      console.error(`[StorageService] Error setting value for key '${key}':`, error);
      
      if (retries > 0) {
        console.log(`[StorageService] Retrying set operation for key: '${key}', ${retries} attempts left`);
        // Add a small delay before retry
        await new Promise(resolve => setTimeout(resolve, 100));
        return this.setValue(key, value, retries - 1);
      }
      
      throw error;
    }
  }

  /**
   * Get a value from AsyncStorage
   * @param key Storage key
   * @returns Retrieved value or null if not found
   */
  public async getValue<T>(key: string): Promise<T | null> {
    try {
      console.log(`[StorageService] Attempting to get value for key: '${key}'`);
      const jsonValue = await AsyncStorage.getItem(key);
      console.log(`[StorageService] Raw value for key '${key}': ${jsonValue === null ? 'null' : jsonValue}`);
      if (jsonValue !== null) {
        try {
          const parsedValue = JSON.parse(jsonValue) as T;
          console.log(`[StorageService] Parsed value for key '${key}':`, parsedValue);
          return parsedValue;
        } catch (parseError) {
          console.error(`[StorageService] Error parsing JSON for key '${key}':`, parseError, `Raw value: ${jsonValue}`);
          return null;
        }
      } else {
        return null;
      }
    } catch (error) {
      console.error(`[StorageService] Error getting value for key '${key}':`, error);
      return null;
    }
  }

  /**
   * Remove a value from AsyncStorage
   * @param key Storage key to remove
   */
  public async removeValue(key: string): Promise<void> {
    try {
      console.log(`[StorageService] Attempting to remove key: '${key}'`);
      await AsyncStorage.removeItem(key);
      console.log(`[StorageService] Successfully removed key: '${key}'`);
    } catch (error) {
      console.error(`[StorageService] Error removing key '${key}':`, error);
      throw error;
    }
  }

  /**
   * Clear all values from AsyncStorage
   * Use with caution!
   */
  public async clearAll(): Promise<void> {
    try {
      console.warn('[StorageService] Attempting to clear all AsyncStorage data!');
      await AsyncStorage.clear();
      console.log('[StorageService] Successfully cleared all AsyncStorage data.');
    } catch (error) {
      console.error('[StorageService] Error clearing AsyncStorage:', error);
      throw error;
    }
  }

  /**
   * Check if a key exists in AsyncStorage
   * @param key Storage key to check
   * @returns Boolean indicating if key exists
   */
  public async hasKey(key: string): Promise<boolean> {
    try {
      console.log(`[StorageService] Checking existence of key: '${key}'`);
      const value = await AsyncStorage.getItem(key);
      const keyExists = value !== null;
      console.log(`[StorageService] Key '${key}' ${keyExists ? 'exists' : 'does NOT exist'}. Raw value: ${value === null ? 'null' : value}`);
      return keyExists;
    } catch (error) {
      console.error(`[StorageService] Error checking key '${key}':`, error);
      return false;
    }
  }

  /**
   * Get multiple values from AsyncStorage
   * @param keys Array of storage keys
   * @returns Object mapping keys to their values
   */
  public async getMultipleValues(keys: string[]): Promise<Record<string, any>> {
    try {
      const result: Record<string, any> = {};
      console.log(`[StorageService] Getting multiple keys: ${keys.join(', ')}`);
      const keyValuePairs = await AsyncStorage.multiGet(keys);
      
      keyValuePairs.forEach(([key, value]) => {
        if (value !== null) {
          try {
            result[key] = JSON.parse(value);
          } catch {
            result[key] = value; // Use raw value if not valid JSON
          }
        }
      });
      
      console.log(`[StorageService] Retrieved multiple values:`, result);
      return result;
    } catch (error) {
      console.error('[StorageService] Error getting multiple values:', error);
      return {};
    }
  }
} 

================================================================================
File: src/SimpleApp.tsx
================================================================================

// Simple app to test basic rendering
import React, { useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Alert } from 'react-native';

export default function SimpleApp() {
  useEffect(() => {
    console.log('[SimpleApp] Component mounted');
    return () => {
      console.log('[SimpleApp] Component unmounted');
    };
  }, []);
  
  const handlePress = () => {
    console.log('[SimpleApp] Button pressed');
    Alert.alert('Success', 'App is working correctly!');
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Mouthguard Monitor</Text>
      <Text style={styles.subtitle}>Simple Test App</Text>
      
      <View style={styles.statusContainer}>
        <Text style={styles.statusText}> App is running</Text>
        <Text style={styles.statusText}> React Native is working</Text>
        <Text style={styles.statusText}> UI is rendering</Text>
      </View>
      
      <TouchableOpacity style={styles.button} onPress={handlePress}>
        <Text style={styles.buttonText}>Test Interaction</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#0C0C0E',
    padding: 20
  },
  title: {
    color: '#FFFFFF',
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 8
  },
  subtitle: {
    color: '#A0A0A0',
    fontSize: 18,
    marginBottom: 40
  },
  statusContainer: {
    alignSelf: 'stretch',
    backgroundColor: '#1A1A1A',
    padding: 20,
    borderRadius: 8,
    marginBottom: 40
  },
  statusText: {
    color: '#FFFFFF',
    fontSize: 16,
    marginBottom: 8
  },
  button: {
    backgroundColor: '#00BFA5',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold'
  }
}); 

================================================================================
File: src/types.ts
================================================================================

// Core data types
export interface Athlete {
    id: string;
    name: string;
    team?: string;
    position?: string;
    age?: number;
    height?: string;
    weight?: string;
    deviceId?: string;
    notes?: string;
    number?: string;
    active?: boolean;
    createdAt: number;
    updatedAt: number;
}

export interface SensorData {
    timestamp: number;
    values: number[];
}

export interface ImuData {
    id?: number;
    deviceId: string;
    sensorId: number;
    timestamp: number;
    x: number;
    y: number;
    z: number;
    createdAt: number;
}

export interface AccelerometerData {
    id?: number;
    deviceId: string;
    sensorId: number;
    timestamp: number;
    x: number;
    y: number;
    z: number;
    magnitude: number;
    createdAt: number;
}

export interface TemperatureData {
    id?: number;
    deviceId: string;
    sensorId: number;
    timestamp: number;
    temperature: number;
    createdAt: number;
}

export interface ForceData {
    id?: number;
    deviceId: string;
    sensorId: number;
    timestamp: number;
    force: number;
    createdAt: number;
}

export interface HeartRateData {
    id?: number;
    deviceId: string;
    timestamp: number;
    heartRate: number;
    createdAt: number;
}

export interface ImpactEvent {
    id?: number;
    deviceId: string;
    athleteId?: string;
    timestamp: number;
    magnitude: number;
    x: number;
    y: number;
    z: number;
    durationMs?: number;
    location?: string;
    processed: boolean;
    severity?: 'low' | 'moderate' | 'severe' | 'critical';
    notes?: string;
    createdAt: number;
}

// --- Device Packet Structures ---

// Matches C struct motion_packet
export interface MotionPacket {
  // All values are raw sensor readings
  gyro: [number, number, number];       // int16_t[3]
  accel16: [number, number, number];    // int16_t[3] (16g accelerometer)
  accel200: [number, number, number];   // int16_t[3] (200g accelerometer)
  mag: [number, number, number];        // int16_t[3]
  bite_l: number;                       // uint16_t
  bite_r: number;                       // uint16_t
  timestamp: number;                    // uint32_t (Device timestamp, likely seconds or custom epoch)
}

// Matches C struct fsr_packet
export interface FSRPacket {
  left_bite: number;                    // int16_t
  right_bite: number;                   // int16_t
  timestamp: number;                    // uint32_t (Device timestamp)
}

// Represents the Heart Rate Measurement characteristic data
export interface HRMPacket {
  flags: number;                        // uint8_t
  heartRate: number;                    // uint8_t or uint16_t depending on flags
  // Optional fields based on flags (energy expended, rr-interval) not included for simplicity
  deviceTimestamp?: number;             // Optional: Add if you plan to parse/estimate device time
  appTimestamp: number;                 // Timestamp when received by the app
}

// Represents the Health Thermometer Measurement characteristic data
export interface HTMPacket {
  flags: number;                        // uint8_t
  temperature: number;                  // IEEE-11073 float (parsed to a standard number)
  timestamp?: number;                   // Optional: Device timestamp if included based on flags
  type?: number;                        // Optional: Location type if included
  appTimestamp: number;                 // Timestamp when received by the app
}

export interface Session {
    id: string;
    name: string;
    startTime: number;
    endTime?: number;
    team?: string;
    notes?: string;
    createdAt: number;
}

export interface SessionAthlete {
    sessionId: string;
    athleteId: string;
    startTime: number;
    endTime?: number;
}

export interface CalibrationData {
    id?: number;
    deviceId: string;
    sensorType: string;
    timestamp: number;
    offsetX?: number;
    offsetY?: number;
    offsetZ?: number;
    scaleX?: number;
    scaleY?: number;
    scaleZ?: number;
    createdAt: number;
}

// Chart-specific types
export interface ChartDataPoint {
    label: string;
    value: number;
}

export interface ChartDataset {
    data: number[];
    color: (opacity?: number) => string;
    strokeWidth: number;
}

export interface ChartData {
    labels: string[];
    datasets: ChartDataset[];
    legend?: string[];
}

// Database types
export interface DatabaseRow {
    [key: string]: any;
}

// API Response types
export interface DatabaseResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}

export interface SavedDevice {
    id: string;
    name: string;
    lastConnected?: number; // Timestamp in milliseconds
    batteryLevel?: number; // Battery level (0-100)
    athleteId?: string; // ID of the athlete this device is assigned to
}

// Device status for multi-device management
export interface DeviceStatus {
    id: string;
    name: string;
    connected: boolean;
    batteryLevel?: number;
    lastSeen?: number;
    signalStrength?: number;
    athleteInfo?: {
        id: string;
        name: string;
    }
}

// Concussion alert/detection
export interface ConcussionAlert {
    id: string;
    deviceId: string;
    athleteId?: string;
    athleteName?: string;
    timestamp: number;
    magnitude: number;
    severity: 'low' | 'moderate' | 'severe' | 'critical';
    acknowledged: boolean;
    notes?: string;
    alertType?: 'impact' | 'temperature' | 'heartRate';
}

// Stats summaries
export interface SensorStats {
    deviceId: string;
    athleteId?: string;
    sensorType: 'imu' | 'accelerometer' | 'temperature' | 'force' | 'heartRate';
    min: number;
    max: number;
    avg: number;
    count: number;
    startTime: number;
    endTime: number;
}

// Live monitoring data point
export interface LiveDataPoint {
    deviceId: string;
    timestamp: number;
    type: 'imu' | 'accelerometer' | 'temperature' | 'force' | 'heartRate';
    values: number[];
}

// Session summary
export interface SessionSummary {
    id: string;
    name: string;
    startTime: number;
    endTime?: number;
    athleteCount: number;
    impactCount: number;
    averageImpactMagnitude: number;
    maxImpactMagnitude: number;
    alerts: number;
}

// Reports
export interface ReportParameters {
    startTime: number;
    endTime: number;
    athleteIds?: string[];
    teamName?: string;
    includeAccelerometer?: boolean;
    includeImu?: boolean;
    includeTemperature?: boolean;
    includeForce?: boolean;
    includeHeartRate?: boolean;
    aggregation?: 'none' | 'minute' | 'hour' | 'day';
}

export interface AggregatedSensorData {
    timestamp: number;
    min: number;
    max: number;
    avg: number;
    count: number;
}

export interface AthleteReport {
    athlete: Athlete;
    totalSessions: number;
    totalImpacts: number;
    maxImpact: number;
    averageImpact: number;
    impactsByLevel: {
        low: number;
        moderate: number;
        severe: number;
        critical: number;
    };
    heartRateStats?: {
        min: number;
        max: number;
        avg: number;
    };
    sessionSummaries: Array<{
        sessionId: string;
        sessionName: string;
        date: number;
        impactCount: number;
        maxImpact: number;
    }>;
}

// State management types
export interface DataState {
    isLoading: boolean;
    error: string | null;
}

// Real-time monitoring session state
export interface MonitoringSessionState {
    active: boolean;
    sessionId?: string;
    sessionName?: string;
    startTime?: number;
    connectedDevices: DeviceStatus[];
    activeAlerts: ConcussionAlert[];
}


================================================================================
File: src/utils/animations.ts
================================================================================

import { useCallback } from 'react';
import { Platform } from 'react-native';
import {
  FadeIn,
  FadeInDown,
  FadeInUp,
  withSpring,
  withTiming,
  WithTimingConfig,
  Easing,
  useSharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

// Optimized spring configuration
export const SPRING_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100,
  restDisplacementThreshold: 0.01,
  restSpeedThreshold: 0.01,
} as const;

// Optimized timing configuration
export const TIMING_CONFIG: WithTimingConfig = {
  duration: 300,
  easing: Easing.bezier(0.25, 0.1, 0.25, 1),
} as const;

// Shared animation factory
export const createSharedAnimation = (delay: number = 0) => {
  return Platform.select({
    ios: FadeInDown.duration(300)
      .springify()
      .delay(delay)
      .damping(SPRING_CONFIG.damping)
      .mass(SPRING_CONFIG.mass),
    android: FadeIn.duration(250)
      .delay(delay)
  });
};

// Optimized press animation hook
export const useAnimatedPress = (scale: number = 0.98) => {
  const pressed = useSharedValue(false);
  
  const animatedStyle = useAnimatedStyle(() => {
    'worklet';
    return {
      transform: [{
        scale: withSpring(
          pressed.value ? scale : 1, 
          SPRING_CONFIG
        )
      }]
    };
  });

  return {
    animatedStyle,
    pressHandlers: {
      onPressIn: useCallback(() => {
        pressed.value = true;
      }, []),
      onPressOut: useCallback(() => {
        pressed.value = false;
      }, [])
    }
  };
};

// Gradient optimization utilities
export const GRADIENT_PROPS = Platform.select({
  ios: {
    shouldRasterizeIOS: true,
  },
  android: {
    renderToHardwareTextureAndroid: true,
  },
});

// Chart animation configuration
export const CHART_ANIMATION_CONFIG = {
  animationEnabled: true,
  animationDuration: 300,
  animationEasing: Easing.ease,
  propsForLabels: {
    fontSize: 10,
    fontWeight: '400'
  }
} as const;

// Optimized layout animation configuration
export const LAYOUT_ANIMATION_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100
} as const; 

================================================================================
File: src/utils/dataProcessing.ts
================================================================================

import { MotionPacket, FSRPacket, HRMPacket, HTMPacket, ImpactEvent, ChartData, ChartDataset } from '../types';
import { formatChartTimestamp } from './timeUtils';

// --- Constants ---
const ACCEL_200G_SENSITIVITY = 16384 / 200; // Adjust based on actual sensor spec
const MAX_CHART_POINTS = 100; // Limit points for performance

// --- Helper: Subsample data ---
export function subsampleData<T>(data: T[], maxPoints: number = MAX_CHART_POINTS): T[] {
  if (!data || data.length <= maxPoints) return data;
  const step = Math.ceil(data.length / maxPoints);
  return data.filter((_, index) => index % step === 0);
}

// --- Processing Functions ---

/**
 * Processes HRM packets for heart rate visualization
 */
export function processHrmForChart(packets: HRMPacket[]): { 
  chartData: ChartData, 
  avgHr: number | null, 
  minHr: number | null, 
  maxHr: number | null 
} {
  if (!packets || packets.length === 0) {
    return { 
      chartData: { labels: [], datasets: [] }, 
      avgHr: null, 
      minHr: null, 
      maxHr: null 
    };
  }

  // Filter invalid data and sort by timestamp
  const validPackets = packets
    .filter(p => typeof p.heartRate === 'number' && !isNaN(p.heartRate) && p.heartRate > 0)
    .sort((a, b) => a.appTimestamp - b.appTimestamp);

  // If no valid data after filtering, return empty result
  if (validPackets.length === 0) {
    return { 
      chartData: { labels: [], datasets: [] }, 
      avgHr: null, 
      minHr: null, 
      maxHr: null 
    };
  }

  // Subsample for better chart performance
  const subsampled = subsampleData(validPackets);
  
  // Format data for chart
  const labels = subsampled.map(p => formatChartTimestamp(p.appTimestamp));
  const data = subsampled.map(p => p.heartRate);

  // Calculate statistics
  const validHrs = validPackets.map(p => p.heartRate);
  const avgHr = validHrs.length > 0 ? 
    Math.round(validHrs.reduce((a, b) => a + b, 0) / validHrs.length) : null;
  const minHr = validHrs.length > 0 ? Math.min(...validHrs) : null;
  const maxHr = validHrs.length > 0 ? Math.max(...validHrs) : null;

  const datasets: ChartDataset[] = [{
    data: data,
    color: (opacity = 1) => `rgba(255, 59, 48, ${opacity})`, // Red for HR
    strokeWidth: 2,
  }];

  return { chartData: { labels, datasets }, avgHr, minHr, maxHr };
}

/**
 * Processes HTM packets for temperature visualization
 */
export function processTempForChart(packets: HTMPacket[]): { 
  chartData: ChartData, 
  avgTemp: number | null, 
  minTemp: number | null, 
  maxTemp: number | null, 
  currentTemp: number | null 
} {
  if (!packets || packets.length === 0) {
    return { 
      chartData: { labels: [], datasets: [] }, 
      avgTemp: null, 
      minTemp: null, 
      maxTemp: null, 
      currentTemp: null 
    };
  }

  // Filter invalid data and sort by timestamp
  const validPackets = packets
    .filter(p => typeof p.temperature === 'number' && !isNaN(p.temperature))
    .sort((a, b) => a.appTimestamp - b.appTimestamp);

  // If no valid data after filtering, return empty result
  if (validPackets.length === 0) {
    return { 
      chartData: { labels: [], datasets: [] }, 
      avgTemp: null, 
      minTemp: null, 
      maxTemp: null, 
      currentTemp: null 
    };
  }

  // Subsample for better chart performance
  const subsampled = subsampleData(validPackets);
  
  // Format data for chart
  const labels = subsampled.map(p => formatChartTimestamp(p.appTimestamp));
  const data = subsampled.map(p => p.temperature);

  // Calculate statistics
  const validTemps = validPackets.map(p => p.temperature);
  const avgTemp = validTemps.length > 0 ? 
    parseFloat((validTemps.reduce((a, b) => a + b, 0) / validTemps.length).toFixed(1)) : null;
  const minTemp = validTemps.length > 0 ? Math.min(...validTemps) : null;
  const maxTemp = validTemps.length > 0 ? Math.max(...validTemps) : null;
  const currentTemp = validPackets.length > 0 ? validPackets[validPackets.length - 1].temperature : null;

  const datasets: ChartDataset[] = [{
    data: data,
    color: (opacity = 1) => `rgba(255, 149, 0, ${opacity})`, // Orange for Temp
    strokeWidth: 2,
  }];

  return { chartData: { labels, datasets }, avgTemp, minTemp, maxTemp, currentTemp };
}

/**
 * Processes FSR packets for bite force visualization
 */
export function processFsrForChart(packets: FSRPacket[]): { 
  chartData: ChartData, 
  avgLeft: number | null, 
  avgRight: number | null, 
  avgTotal: number | null,
  maxForce: number | null 
} {
  if (!packets || packets.length === 0) {
    return { 
      chartData: { labels: [], datasets: [] }, 
      avgLeft: null, 
      avgRight: null, 
      avgTotal: null,
      maxForce: null
    };
  }

  // Filter and sort by timestamp
  const validPackets = packets
    .filter(p => (
      (typeof p.left_bite === 'number' && !isNaN(p.left_bite)) || 
      (typeof p.right_bite === 'number' && !isNaN(p.right_bite))
    ))
    .sort((a, b) => {
      // Use timestamp from FSRPacket
      return a.timestamp - b.timestamp;
    });

  if (validPackets.length === 0) {
    return { 
      chartData: { labels: [], datasets: [] }, 
      avgLeft: null, 
      avgRight: null, 
      avgTotal: null,
      maxForce: null
    };
  }

  // Subsample for better chart performance
  const subsampled = subsampleData(validPackets);
  
  // Format data for chart
  const labels = subsampled.map(p => formatChartTimestamp(p.timestamp));
  const leftData = subsampled.map(p => typeof p.left_bite === 'number' ? p.left_bite : 0);
  const rightData = subsampled.map(p => typeof p.right_bite === 'number' ? p.right_bite : 0);

  // Calculate statistics from all valid data
  const validLeft = validPackets
    .map(p => p.left_bite)
    .filter(v => typeof v === 'number' && !isNaN(v));
    
  const validRight = validPackets
    .map(p => p.right_bite)
    .filter(v => typeof v === 'number' && !isNaN(v));
    
  const avgLeft = validLeft.length > 0 ? 
    Math.round(validLeft.reduce((a, b) => a + b, 0) / validLeft.length) : null;
    
  const avgRight = validRight.length > 0 ? 
    Math.round(validRight.reduce((a, b) => a + b, 0) / validRight.length) : null;
    
  const allValid = [...validLeft, ...validRight];
  const avgTotal = allValid.length > 0 ? 
    Math.round(allValid.reduce((a, b) => a + b, 0) / allValid.length) : null;
    
  const maxForce = allValid.length > 0 ? Math.max(...allValid) : null;

  const datasets: ChartDataset[] = [
    { 
      data: leftData, 
      color: (opacity = 1) => `rgba(0, 176, 118, ${opacity})`, // Green for Left
      strokeWidth: 2 
    },
    { 
      data: rightData, 
      color: (opacity = 1) => `rgba(0, 122, 255, ${opacity})`, // Blue for Right
      strokeWidth: 2 
    }
  ];

  return { 
    chartData: { labels, datasets, legend: ['Left', 'Right'] }, 
    avgLeft, 
    avgRight, 
    avgTotal,
    maxForce
  };
}

/**
 * Processes motion packets for acceleration visualization
 */
export function processMotionForChart(packets: MotionPacket[]): { 
  accelMagnitudeChart: ChartData, 
  peakAccel: number | null
} {
  if (!packets || packets.length === 0) {
    return { 
      accelMagnitudeChart: { labels: [], datasets: [] }, 
      peakAccel: null 
    };
  }

  // Sort by timestamp
  const sortedPackets = packets.sort((a, b) => {
    // Use appTimestamp if available, fallback to device timestamp
    const aTime = (a as any).appTimestamp || a.timestamp;
    const bTime = (b as any).appTimestamp || b.timestamp;
    return aTime - bTime;
  });

  // Calculate G-force magnitudes
  const magnitudes = sortedPackets.map(p => {
    // Convert raw values to G-force
    const gx = (p.accel200[0] ?? 0) / ACCEL_200G_SENSITIVITY;
    const gy = (p.accel200[1] ?? 0) / ACCEL_200G_SENSITIVITY;
    const gz = (p.accel200[2] ?? 0) / ACCEL_200G_SENSITIVITY;
    // Calculate magnitude (vector length)
    return Math.sqrt(gx*gx + gy*gy + gz*gz);
  });

  // Find peak acceleration
  const peakAccel = magnitudes.length > 0 ? 
    parseFloat(Math.max(...magnitudes).toFixed(2)) : null;

  // Subsample for better chart performance
  const subsampled = subsampleData(sortedPackets);
  
  // Format data for chart
  const labels = subsampled.map(p => 
    formatChartTimestamp((p as any).appTimestamp || p.timestamp));
    
  const subsampledMagnitudes = subsampled.map((_, i) => {
    const originalIndex = Math.floor(i * (sortedPackets.length / subsampled.length));
    return magnitudes[originalIndex];
  });

  const datasets: ChartDataset[] = [{
    data: subsampledMagnitudes,
    color: (opacity = 1) => `rgba(80, 80, 80, ${opacity})`, // Gray for magnitude
    strokeWidth: 2,
  }];

  return { 
    accelMagnitudeChart: { labels, datasets }, 
    peakAccel 
  };
}

/**
 * Processes impact events for timeline and distribution visualizations
 */
export function processImpactsForCharts(impacts: ImpactEvent[]): {
  timelineChart: ChartData,
  severityDistribution: { labels: string[], data: number[] },
  cumulativeExposureChart: ChartData,
  totalImpacts: number,
  highImpacts: number,
  maxG: number | null,
  concussionRisk: 'Low' | 'Moderate' | 'High' | 'Critical'
} {
  if (!impacts || impacts.length === 0) {
    return {
      timelineChart: { labels: [], datasets: [] },
      severityDistribution: { labels: [], data: [] },
      cumulativeExposureChart: { labels: [], datasets: [] },
      totalImpacts: 0,
      highImpacts: 0,
      maxG: null,
      concussionRisk: 'Low'
    };
  }

  // Sort by timestamp
  const sortedImpacts = impacts.sort((a, b) => a.timestamp - b.timestamp);

  // Timeline Chart
  const subsampledTimeline = subsampleData(sortedImpacts);
  const timelineLabels = subsampledTimeline.map(p => formatChartTimestamp(p.timestamp));
  const timelineData = subsampledTimeline.map(p => p.magnitude);
  const timelineChart: ChartData = {
    labels: timelineLabels,
    datasets: [{ 
      data: timelineData, 
      color: (opacity = 1) => `rgba(0, 176, 118, ${opacity})`, 
      strokeWidth: 2 
    }]
  };

  // Severity Distribution
  const severityCounts = { 
    low: 0, 
    moderate: 0, 
    severe: 0, 
    critical: 0 
  };
  
  let highImpactCount = 0;
  
  impacts.forEach(p => {
    const severity = p.severity ?? 'low'; // Default to low if undefined
    if (severityCounts.hasOwnProperty(severity)) {
      severityCounts[severity]++;
    }
    if (severity === 'severe' || severity === 'critical') {
      highImpactCount++;
    }
  });
  
  const severityDistribution = {
    labels: Object.keys(severityCounts).map(k => k.charAt(0).toUpperCase() + k.slice(1)),
    data: Object.values(severityCounts)
  };

  // Cumulative Exposure
  let cumulativeG = 0;
  const cumulativeData = sortedImpacts.map(p => {
    cumulativeG += p.magnitude;
    return cumulativeG;
  });
  
  const subsampledCumulative = subsampleData(cumulativeData);
  const cumulativeLabels = subsampleData(sortedImpacts).map(p => formatChartTimestamp(p.timestamp));
  
  const cumulativeExposureChart: ChartData = {
    labels: cumulativeLabels,
    datasets: [{ 
      data: subsampledCumulative, 
      color: (opacity = 1) => `rgba(0, 122, 255, ${opacity})`, 
      strokeWidth: 2 
    }]
  };

  // Calculate KPIs
  const magnitudes = impacts.map(p => p.magnitude);
  const maxG = magnitudes.length > 0 ? 
    parseFloat(Math.max(...magnitudes).toFixed(2)) : null;
    
  // Determine risk level
  let concussionRisk: 'Low' | 'Moderate' | 'High' | 'Critical' = 'Low';
  
  if (highImpactCount >= 3 || (maxG !== null && maxG >= 150)) {
    concussionRisk = 'Critical';
  } else if (highImpactCount >= 2 || (maxG !== null && maxG >= 120)) {
    concussionRisk = 'High';
  } else if (highImpactCount >= 1 || (maxG !== null && maxG >= 90)) {
    concussionRisk = 'Moderate';
  }

  return {
    timelineChart,
    severityDistribution,
    cumulativeExposureChart,
    totalImpacts: impacts.length,
    highImpacts: highImpactCount,
    maxG,
    concussionRisk
  };
} 

================================================================================
File: src/utils/EventEmitter.ts
================================================================================

/**
 * Simple event emitter for communicating between services and hooks
 */
export class EventEmitter {
  private listeners: Record<string, Function[]> = {};

  /**
   * Add event listener
   * @param event Event name
   * @param callback Function to call when event is emitted
   */
  on(event: string, callback: Function) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  }

  /**
   * Remove event listener
   * @param event Event name
   * @param callback Function to remove
   */
  off(event: string, callback: Function) {
    if (!this.listeners[event]) return;
    this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
  }

  /**
   * Emit event to all listeners
   * @param event Event name
   * @param args Arguments to pass to listeners
   */
  emit(event: string, ...args: any[]) {
    if (!this.listeners[event]) return;
    this.listeners[event].forEach(callback => {
      try {
        callback(...args);
      } catch (error) {
        console.error(`[EventEmitter] Error in event listener for ${event}:`, error);
      }
    });
  }
}

// Create and export singleton instance
export const dataChangeEmitter = new EventEmitter();

// Define common event names
export const dbEvents = {
  DATA_CHANGED: 'dataChanged',
  CONCUSSION_DETECTED: 'concussionDetected'
}; 

================================================================================
File: src/utils/filters.ts
================================================================================

import { StrainSearchFilters } from '../DatabaseManager';

export const hasActiveFilters = (filters: StrainSearchFilters): boolean => {
  return !!(
    filters.geneticType ||
    (filters.effects && filters.effects.length > 0) ||
    filters.minTHC ||
    filters.maxTHC ||
    (filters.sort && filters.sort !== 'rating')
  );
}; 

================================================================================
File: src/utils/functions.ts
================================================================================

const monthStringToInt: { [key: string]: string } = {
    "January": "01",
    "February": "02",
    "March": "03",
    "April": "04",
    "May": "05",
    "June": "06",
    "July": "07",
    "August": "08",
    "September": "09",
    "October": "10",
    "November": "11",
    "December": "12",
};

/**
 * Parses raw timestamp from device into a standard ISO format
 * @param rawTimestamp Raw timestamp string from device (e.g., "Thursday, March 27 2025 23:19:34")
 * @returns ISO 8601 formatted timestamp string (e.g., "2025-03-27T23:19:34.000Z")
 */
export function parseRawTimestamp(rawTimestamp: string): string {
    try {
        // Remove day, then separate by spaces
        const parts: string[] = rawTimestamp.split(',')[1].trim().split(' ');
        
        if (parts.length < 4) {
            console.error('Invalid timestamp format received:', rawTimestamp);
            throw new Error('Invalid timestamp parts');
        }
        
        const monthStr: string = parts[0];
        const day: string = parts[1].padStart(2, '0');
        const year: string = parts[2];
        const time: string = parts[3];
        
        // Get month number and pad with zero if needed
        const monthNum = monthStringToInt[monthStr];
        if (!monthNum) {
            console.error(`Unknown month: ${monthStr}`);
            throw new Error('Unknown month');
        }
        const month: string = monthNum;
        
        // Create a Date object from the local time
        // This correctly parses as local time, not UTC
        const localDate = new Date(`${year}-${month}-${day}T${time}`);
        
        // Check if the date is valid
        if (isNaN(localDate.getTime())) {
            console.error('Created invalid date:', localDate);
            throw new Error('Invalid resulting date');
        }
        
        // Convert to UTC ISO string - this will apply the proper timezone offset
        const utcTimestamp = localDate.toISOString();
        console.log(`[parseRawTimestamp] Local timestamp: ${localDate.toString()}, UTC: ${utcTimestamp}`);
        
        return utcTimestamp;
    } catch (error) {
        console.error('Error parsing timestamp:', error);
        // Fallback - create a current timestamp in ISO format
        return new Date().toISOString();
    }
}

================================================================================
File: src/utils/QueryBuilder.ts
================================================================================

/**
 * QueryBuilder - A simple SQL query builder for SQLite
 * 
 * This class provides a fluent interface for building SQL queries
 * without having to write raw SQL strings.
 */
export class QueryBuilder {
  private selectCols: string[] = [];
  private fromTableName: string = '';
  private whereConditions: string[] = [];
  private orderByClauses: string[] = [];
  private groupByClauses: string[] = [];
  private limitValue: number | null = null;
  private offsetValue: number | null = null;
  private paramValues: any[] = [];
  
  /**
   * Select columns to include in the query
   * @param columns Column names to select
   * @returns this instance for chaining
   */
  selectColumns(columns: string | string[]): QueryBuilder {
    if (Array.isArray(columns)) {
      this.selectCols.push(...columns);
    } else {
      this.selectCols.push(columns);
    }
    return this;
  }
  
  /**
   * Set the table to query from
   * @param table Table name
   * @returns this instance for chaining
   */
  from(table: string): QueryBuilder {
    this.fromTableName = table;
    return this;
  }
  
  /**
   * Add a WHERE condition with parameters
   * @param condition SQL condition as string
   * @param params Parameters to bind to the condition
   * @returns this instance for chaining
   */
  whereClause(condition: string, ...params: any[]): QueryBuilder {
    this.whereConditions.push(condition);
    this.paramValues.push(...params);
    return this;
  }

  /**
   * Add an ORDER BY clause
   * @param column Column to order by
   * @param direction Sort direction (ASC or DESC)
   * @returns this instance for chaining
   */
  orderByColumn(column: string, direction: 'ASC' | 'DESC' = 'ASC'): QueryBuilder {
    this.orderByClauses.push(`${column} ${direction}`);
    return this;
  }

  /**
   * Add a GROUP BY clause
   * @param columns Columns to group by
   * @returns this instance for chaining
   */
  groupByColumns(columns: string | string[]): QueryBuilder {
    if (Array.isArray(columns)) {
      this.groupByClauses.push(...columns);
    } else {
      this.groupByClauses.push(columns);
    }
    return this;
  }

  /**
   * Set LIMIT clause
   * @param limit Maximum number of rows to return
   * @returns this instance for chaining
   */
  limitTo(limit: number): QueryBuilder {
    this.limitValue = limit;
    return this;
  }

  /**
   * Set OFFSET clause
   * @param offset Number of rows to skip
   * @returns this instance for chaining
   */
  offsetBy(offset: number): QueryBuilder {
    this.offsetValue = offset;
    return this;
  }
  
  /**
   * Build the final SQL query and parameters
   * @returns Object containing the query string and parameters array
   */
  build(): { query: string, params: any[] } {
    const parts: string[] = [];
    
    // SELECT clause
    parts.push(`SELECT ${this.selectCols.length > 0 ? this.selectCols.join(', ') : '*'}`);
    
    // FROM clause
    parts.push(`FROM ${this.fromTableName}`);
    
    // WHERE clause
    if (this.whereConditions.length > 0) {
      parts.push(`WHERE ${this.whereConditions.join(' AND ')}`);
    }
    
    // GROUP BY clause
    if (this.groupByClauses.length > 0) {
      parts.push(`GROUP BY ${this.groupByClauses.join(', ')}`);
    }
    
    // ORDER BY clause
    if (this.orderByClauses.length > 0) {
      parts.push(`ORDER BY ${this.orderByClauses.join(', ')}`);
    }
    
    // LIMIT clause
    if (this.limitValue !== null) {
      parts.push(`LIMIT ${this.limitValue}`);
    }
    
    // OFFSET clause
    if (this.offsetValue !== null) {
      parts.push(`OFFSET ${this.offsetValue}`);
    }
    
    return {
      query: parts.join(' '),
      params: this.paramValues
    };
  }
} 

================================================================================
File: src/utils/resetAppData.ts
================================================================================


// This file is auto-generated to clear AsyncStorage on next app launch
// It should be imported in app/_layout.tsx

import AsyncStorage from '@react-native-async-storage/async-storage';

export async function clearAppData() {
  console.log('[AppReset] Clearing AsyncStorage...');
  try {
    await AsyncStorage.clear();
    console.log('[AppReset] AsyncStorage cleared successfully');
    // Delete the DB version key so migrations run again
    await AsyncStorage.removeItem('dbVersion');
    console.log('[AppReset] Database version reset');
    return true;
  } catch (error) {
    console.error('[AppReset] Error clearing AsyncStorage:', error);
    return false;
  }
}


================================================================================
File: src/utils/SqlTemplates.ts
================================================================================

/**
 * SQL Templates
 * 
 * This file contains template functions for commonly used SQL queries.
 * It helps to keep the SQL queries organized, maintainable, and separated
 * from the database logic.
 */

/**
 * Get the query for usage statistics
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getUsageStatsQuery(tableName: string): string {
  // Date filter clause will be added externally
  return `
    WITH FilteredData AS (
      SELECT timestamp, duration_ms
      FROM ${tableName}
      -- DATE FILTER ADDED EXTERNALLY
    ),
    DailyStats AS (
      SELECT
        strftime('%Y-%m-%d', timestamp, 'utc') as day,
        strftime('%w', timestamp, 'utc') as weekday,
        COUNT(*) as daily_hits,
        AVG(duration_ms) as avg_duration_per_day,
        MIN(duration_ms) as min_duration,
        MAX(duration_ms) as max_duration,
        SUM(duration_ms) as total_duration_per_day
      FROM FilteredData
      GROUP BY day
    ),
    TotalStats AS (
      SELECT
        COUNT(*) as total_hits,
        COUNT(DISTINCT strftime('%Y-%m-%d', timestamp, 'utc')) as active_days,
        AVG(duration_ms) as overall_avg_duration,
        SUM(duration_ms) as total_duration
      FROM FilteredData
    ),
    DayOfWeekStats AS (
      SELECT
        weekday,
        COUNT(*) as total_hits,
        AVG(daily_hits) as avg_hits_per_day
      FROM DailyStats
      GROUP BY weekday
    ),
    HourlyStats AS (
       SELECT
         CAST(strftime('%H', timestamp, 'utc') AS INTEGER) as hour,
         COUNT(*) as hits
       FROM FilteredData
       GROUP BY hour
    )
    SELECT
      COALESCE((SELECT total_hits FROM TotalStats), 0) as total_hits,
      COALESCE((SELECT active_days FROM TotalStats), 0) as active_days,
      CASE WHEN COALESCE((SELECT active_days FROM TotalStats), 0) > 0
           THEN CAST(COALESCE((SELECT total_hits FROM TotalStats), 0) AS REAL) / (SELECT active_days FROM TotalStats)
           ELSE 0
      END as avg_hits_per_active_day,
      COALESCE((SELECT overall_avg_duration FROM TotalStats), 0) as avg_duration_ms,
      COALESCE((SELECT total_duration FROM TotalStats), 0) as total_duration_ms,
      COALESCE((SELECT MAX(daily_hits) FROM DailyStats), 0) as max_hits_in_day,
      COALESCE((SELECT MIN(daily_hits) FROM DailyStats WHERE daily_hits > 0), 0) as min_hits_in_day,
      COALESCE((SELECT MAX(max_duration) FROM DailyStats), 0) as longest_hit,
      COALESCE((SELECT MIN(min_duration) FROM DailyStats WHERE min_duration > 0), 0) as shortest_hit,
      COALESCE((SELECT hour FROM HourlyStats ORDER BY hits DESC LIMIT 1), -1) as most_active_hour,
      COALESCE((SELECT hour FROM HourlyStats ORDER BY hits ASC LIMIT 1), -1) as least_active_hour
  `;
}

/**
 * Get the query for time distribution of usage
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getTimeDistributionQuery(tableName: string): string {
  // Date filter clause will be added externally
  return `
    WITH HourlyHits AS (
      SELECT
        CAST(strftime('%H', timestamp, 'utc') AS INTEGER) as hour,
        COUNT(*) as hits
      FROM ${tableName}
      -- DATE FILTER ADDED EXTERNALLY
      GROUP BY hour
    ),
    TotalHits AS (
      -- Use COALESCE to ensure total is not NULL if HourlyHits is empty
      SELECT COALESCE(SUM(hits), 0) as total FROM HourlyHits
    )
    SELECT
      -- Use MAX(1, ...) to prevent division by zero
      CAST(COALESCE((SELECT SUM(hits) FROM HourlyHits WHERE hour >= 5 AND hour < 12), 0) AS REAL) / MAX(1, (SELECT total FROM TotalHits)) as morning,
      CAST(COALESCE((SELECT SUM(hits) FROM HourlyHits WHERE hour >= 12 AND hour < 17), 0) AS REAL) / MAX(1, (SELECT total FROM TotalHits)) as afternoon,
      CAST(COALESCE((SELECT SUM(hits) FROM HourlyHits WHERE hour >= 17 AND hour < 22), 0) AS REAL) / MAX(1, (SELECT total FROM TotalHits)) as evening,
      CAST(COALESCE((SELECT SUM(hits) FROM HourlyHits WHERE hour >= 22 OR hour < 5), 0) AS REAL) / MAX(1, (SELECT total FROM TotalHits)) as night
  `;
}

/**
 * Get the query for weekly stats
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getWeeklyStatsQuery(tableName: string): string {
  // Date filter clause will be added externally
  return `
    SELECT
      strftime('%w', timestamp, 'utc') as day_of_week,
      COUNT(*) as count,
      AVG(duration_ms) as avg_duration
    FROM ${tableName}
    -- DATE FILTER ADDED EXTERNALLY
    GROUP BY day_of_week
    ORDER BY day_of_week ASC
  `;
}

/**
 * Get the query for monthly stats
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getMonthlyStatsQuery(tableName: string): string {
  // Date filter clause will be added externally
  return `
    SELECT
      strftime('%m', timestamp, 'utc') as month,
      COUNT(*) as count
    FROM ${tableName}
    -- DATE FILTER ADDED EXTERNALLY
    GROUP BY month
    ORDER BY month ASC
  `;
}

/**
 * Get query for finding strains with filter conditions
 * @param filters Filter conditions 
 * @returns SQL query parts (where clause, params)
 */
export function buildStrainFilterQuery(
  query: string,
  filters: {
    genetic_type?: string;
    effects?: string[];
    minThc?: number;
    maxThc?: number;
  }
): { whereClause: string, params: any[] } {
  const whereClauses = [];
  const params: any[] = [];

  // Search by name if query is provided
  if (query && query.trim() !== '') {
    whereClauses.push('(name LIKE ? OR genetic_type LIKE ? OR effects LIKE ?)');
    const searchTerm = `%${query}%`;
    params.push(searchTerm, searchTerm, searchTerm);
  }

  // Filter by genetic type
  if (filters.genetic_type) {
    whereClauses.push('genetic_type = ?');
    params.push(filters.genetic_type);
  }

  // Filter by effects
  if (filters.effects && filters.effects.length > 0) {
    const effectClauses = filters.effects.map(() => 'effects LIKE ?');
    whereClauses.push(`(${effectClauses.join(' OR ')})`);
    filters.effects.forEach(effect => params.push(`%${effect}%`));
  }

  // Filter by THC range
  if (filters.minThc !== undefined) {
    whereClauses.push('thc_rating >= ?');
    params.push(filters.minThc);
  }

  if (filters.maxThc !== undefined) {
    whereClauses.push('thc_rating <= ?');
    params.push(filters.maxThc);
  }

  return {
    whereClause: whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '',
    params
  };
}

// Helper function to create WHERE clause for date filtering using ISO strings
export function getDateRangeFilter(startDate?: string, endDate?: string): { clause: string, params: string[] } {
  if (!startDate && !endDate) {
    // No date range specified, return empty clause and params
    return { clause: '', params: [] };
  }

  const conditions: string[] = [];
  const params: string[] = [];

  if (startDate) {
    console.log(`[SqlTemplates] Adding start date condition: timestamp >= ${startDate}`);
    conditions.push(`timestamp >= ?`);
    params.push(startDate); // Pass the ISO string as a parameter
  }

  if (endDate) {
    console.log(`[SqlTemplates] Adding end date condition: timestamp <= ${endDate}`);
    conditions.push(`timestamp <= ?`);
    params.push(endDate); // Pass the ISO string as a parameter
  }

  // Combine conditions with AND
  const clause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  return { clause, params };
} 

================================================================================
File: src/utils/timeUtils.ts
================================================================================

/**
 * Utility functions for calculating date ranges in the local timezone.
 */

/**
 * Gets the start and end of the current day in the local timezone.
 * @returns { startDate: Date, endDate: Date }
 */
export function getTodayRangeLocal(): { startDate: Date, endDate: Date } {
  const now = new Date();
  const startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0); // Start of today (local)
  const endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999); // End of today (local)
  console.log(`[timeUtils] Today Range (Local): ${startDate.toISOString()} to ${endDate.toISOString()}`);
  return { startDate, endDate };
}

/**
 * Gets the start of the current week (Sunday) and the end of the current day in the local timezone.
 * @param weekStartsOnSunday If true, week starts Sunday(0). If false, starts Monday(1). Default true.
 * @returns { startDate: Date, endDate: Date }
 */
export function getCurrentWeekProgressRangeLocal(weekStartsOnSunday: boolean = true): { startDate: Date, endDate: Date } {
  const now = new Date();
  const currentDayOfWeek = now.getDay(); // 0 = Sunday, 6 = Saturday

  const startDate = new Date(now);
  const dayOffset = weekStartsOnSunday ? currentDayOfWeek : (currentDayOfWeek === 0 ? 6 : currentDayOfWeek - 1);
  startDate.setDate(now.getDate() - dayOffset);
  startDate.setHours(0, 0, 0, 0); // Start of the first day of the week (local)

  const endDate = new Date(); // End of today (local)
  endDate.setHours(23, 59, 59, 999);

  console.log(`[timeUtils] Current Week Progress Range (Local): ${startDate.toISOString()} to ${endDate.toISOString()}`);
  return { startDate, endDate };
}

/**
 * Gets the start and end of the current full week (e.g., Sun-Sat) in the local timezone.
 * @param weekStartsOnSunday If true, week starts Sunday(0). If false, starts Monday(1). Default true.
 * @returns { startDate: Date, endDate: Date }
 */
export function getCurrentFullWeekRangeLocal(weekStartsOnSunday: boolean = true): { startDate: Date, endDate: Date } {
  const { startDate: startOfWeek } = getCurrentWeekProgressRangeLocal(weekStartsOnSunday);
  const endDate = new Date(startOfWeek);
  endDate.setDate(startOfWeek.getDate() + 6); // Go to the end of the week (Saturday or Sunday)
  endDate.setHours(23, 59, 59, 999);

  console.log(`[timeUtils] Current Full Week Range (Local): ${startOfWeek.toISOString()} to ${endDate.toISOString()}`);
  return { startDate: startOfWeek, endDate };
}

/**
 * Gets the start and end for the last N days, ending today.
 * @param days Number of days to look back.
 * @returns { startDate: Date, endDate: Date }
 */
export function getLastNDaysRangeLocal(days: number): { startDate: Date, endDate: Date } {
  const endDate = new Date(); // End of today
  endDate.setHours(23, 59, 59, 999);

  const startDate = new Date();
  startDate.setDate(endDate.getDate() - (days - 1)); // Go back N-1 days to include today
  startDate.setHours(0, 0, 0, 0); // Start of the first day

  console.log(`[timeUtils] Last ${days} Days Range (Local): ${startDate.toISOString()} to ${endDate.toISOString()}`);
  return { startDate, endDate };
}

/**
 * Format a timestamp for chart display, showing time only
 * @param timestamp - Timestamp in milliseconds
 * @returns Formatted time string (HH:MM:SS)
 */
export function formatChartTimestamp(timestamp: number): string {
  // Guard against invalid timestamps
  if (!timestamp || isNaN(timestamp)) {
    return '';
  }
  
  const date = new Date(timestamp);
  
  // Check if date is valid (catches the 1970 issue)
  if (date.getFullYear() <= 1970 && timestamp > 0) {
    // If timestamp seems to be in seconds rather than milliseconds, convert
    const dateFromSeconds = new Date(timestamp * 1000);
    if (dateFromSeconds.getFullYear() > 1970) {
      return dateFromSeconds.toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
      });
    }
  }
  
  // Standard formatting for valid dates
  return date.toLocaleTimeString([], { 
    hour: '2-digit', 
    minute: '2-digit',
    hour12: false 
  });
}

/**
 * Format a timestamp for user-friendly display, including contextual date info
 * @param timestamp - Timestamp in milliseconds
 * @returns Formatted date/time string
 */
export function formatUserFriendlyDateTime(timestamp: number): string {
  // Guard against invalid timestamps
  if (!timestamp || isNaN(timestamp)) {
    return 'Invalid date';
  }
  
  const date = new Date(timestamp);
  
  // Check if date is valid (catches the 1970 issue)
  if (date.getFullYear() <= 1970 && timestamp > 0) {
    // If timestamp seems to be in seconds rather than milliseconds, convert
    const dateFromSeconds = new Date(timestamp * 1000);
    if (dateFromSeconds.getFullYear() > 1970) {
      return formatDateTimeRelative(dateFromSeconds);
    }
    return 'Invalid date';
  }
  
  return formatDateTimeRelative(date);
}

/**
 * Helper function to format date with relative terms (Today, Yesterday)
 */
function formatDateTimeRelative(date: Date): string {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1);

  if (date.toDateString() === today.toDateString()) {
    return `Today, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
  } else if (date.toDateString() === yesterday.toDateString()) {
    return `Yesterday, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
  } else {
    return date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + 
           ', ' + date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
  }
} 

================================================================================
File: src/utils/validators.ts
================================================================================

import { BongHit, Strain, JournalEntry, SafetyRecord } from '../types';

/**
 * Validators utility
 * 
 * Contains domain-specific validation functions for various data types
 * used throughout the application.
 */

/**
 * Validate a BongHit object
 * @param hit The BongHit to validate
 * @returns Error message if invalid, null if valid
 */
export function validateBongHit(hit: BongHit): string | null {
  if (!hit) return 'Bong hit data is required';
  if (!hit.timestamp) return 'Timestamp is required';
  if (!isValidISOTimestamp(hit.timestamp)) return 'Invalid timestamp format';
  if (typeof hit.duration_ms !== 'number') return 'Duration must be a number';
  if (hit.duration_ms <= 0) return 'Duration must be positive';
  return null; // Valid
}

/**
 * Validate a Strain object
 * @param strain The Strain to validate
 * @returns Error message if invalid, null if valid
 */
export function validateStrain(strain: Strain): string | null {
  if (!strain) return 'Strain data is required';
  if (!strain.name || strain.name.trim() === '') return 'Strain name is required';
  if (!strain.genetic_type) return 'Genetic type is required';
  if (strain.thc_rating != null && (typeof strain.thc_rating !== 'number' || strain.thc_rating < 0 || strain.thc_rating > 100)) {
    return 'THC rating must be a number between 0 and 100';
  }
  return null; // Valid
}

/**
 * Validate a SafetyRecord object
 * @param record The SafetyRecord to validate
 * @returns Error message if invalid, null if valid
 */
export function validateSafetyRecord(record: SafetyRecord): string | null {
  if (!record) return 'Safety record is required';
  if (!record.id) return 'Safety record ID is required';
  if (!record.user_id) return 'User ID is required';
  if (!record.concern_type) return 'Concern type is required';
  if (!record.concern_details || record.concern_details.trim() === '') return 'Concern details are required';
  if (!record.created_at) return 'Created timestamp is required';
  return null; // Valid
}

/**
 * Validate a JournalEntry object
 * @param entry The JournalEntry to validate
 * @returns Error message if invalid, null if valid
 */
export function validateJournalEntry(entry: JournalEntry): string | null {
  if (!entry) return 'Journal entry is required';
  if (!entry.id) return 'Entry ID is required';
  if (!entry.user_id) return 'User ID is required';
  if (!entry.created_at) return 'Created timestamp is required';
  if (!isValidISOTimestamp(entry.created_at)) return 'Invalid timestamp format';
  return null; // Valid
}

/**
 * Check if a string is a valid ISO timestamp
 * @param timestamp The timestamp string to validate
 * @returns Whether the string is a valid ISO timestamp
 */
export function isValidISOTimestamp(timestamp: string): boolean {
  try {
    if (typeof timestamp !== 'string') {
      console.error(`[Validators] Invalid timestamp type: ${typeof timestamp}`);
      return false;
    }
    
    // Check for ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ)
    // This regex checks for the basic pattern but isn't exhaustive
    if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/.test(timestamp)) {
      console.error(`[Validators] Timestamp doesn't match ISO format: ${timestamp}`);
      return false;
    }
    
    const date = new Date(timestamp);
    const isValid = !isNaN(date.getTime());
    
    // Extra validation: Check that the timestamp is truly ISO format by ensuring
    // toISOString() produces the exact same string
    const roundTrip = isValid && date.toISOString() === timestamp;
    
    if (!isValid) {
      console.error(`[Validators] Invalid date from timestamp: ${timestamp}`);
    } else if (!roundTrip) {
      console.error(`[Validators] Timestamp not in canonical ISO format. Original: ${timestamp}, Parsed: ${date.toISOString()}`);
    }
    
    return isValid && roundTrip;
  } catch (error) {
    console.error(`[Validators] Error validating timestamp: ${error}`);
    return false;
  }
}

/**
 * Validate that a value is not empty (null, undefined, or empty string)
 * @param value The value to validate
 * @param fieldName The name of the field for the error message
 * @throws Error if the value is empty
 */
export function validateNotEmpty(value: any, fieldName: string): void {
  if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
    throw new Error(`${fieldName} is required and cannot be empty`);
  }
}

/**
 * Create a validation error result
 * @param code Error code
 * @param message Error message
 * @param data Optional data related to the error
 * @returns Validation error result object
 */
export function createValidationError<T>(code: string, message: string, data?: any): { 
  success: false, 
  error: string, 
  code: string, 
  data?: any 
} {
  return {
    success: false,
    error: message,
    code,
    data
  };
}

/**
 * Create a successful validation result
 * @param data The validated data
 * @returns Successful validation result object
 */
export function createValidationSuccess<T>(data: T): {
  success: true,
  data: T
} {
  return {
    success: true,
    data
  };
}

/**
 * Validation result type
 */
export type ValidationResult<T> = 
  | { success: true, data: T }
  | { success: false, error: string, code: string, data?: any }; 

================================================================================
File: tsconfig.json
================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}