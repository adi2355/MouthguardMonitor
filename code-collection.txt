
================================================================================
File: app/ai/recommendations.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity, 
  Alert,
  TextInput
} from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { RecommendationRequest, StrainRecommendation, UserProfile } from '../../src/types/ai';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Extended StrainRecommendation for UI purposes
interface UIStrainRecommendation extends StrainRecommendation {
  name: string;
  type: string;
  effects: string[];
  reason: string;
}

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

export default function RecommendationsScreen() {
  const router = useRouter();
  const { 
    loading, 
    error, 
    recommendations, 
    safetyValidation,
    getRecommendations 
  } = useAIRecommendations();
  
  const [desiredEffects, setDesiredEffects] = useState<string[]>(['relaxed', 'creative']);
  const [context, setContext] = useState<'recreational' | 'medical'>('recreational');
  const [customEffect, setCustomEffect] = useState('');
  
  // Fetch recommendations on initial load
  useEffect(() => {
    fetchRecommendations();
  }, []);
  
  // Handle fetching recommendations
  const fetchRecommendations = async () => {
    const request: RecommendationRequest = {
      userProfile: mockUserProfile,
      desiredEffects,
      context,
      medicalNeeds: context === 'medical' ? mockUserProfile.medical_needs : []
    };
    
    await getRecommendations(request);
  };
  
  // Add custom effect
  const handleAddEffect = () => {
    if (customEffect.trim() && !desiredEffects.includes(customEffect.trim().toLowerCase())) {
      setDesiredEffects([...desiredEffects, customEffect.trim().toLowerCase()]);
      setCustomEffect('');
    }
  };
  
  // Remove effect
  const handleRemoveEffect = (effect: string) => {
    setDesiredEffects(desiredEffects.filter(e => e !== effect));
  };
  
  // Transform StrainRecommendation to UIStrainRecommendation
  const enhanceRecommendation = (recommendation: StrainRecommendation): UIStrainRecommendation => {
    // Extract genetic type from the reasoning factors if available
    let type = 'hybrid'; // Default to hybrid
    
    if (recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors)) {
      // Look for the genetic type in the reasoning factors
      const typeFactors = recommendation.reasoningFactors.filter(factor => 
        factor.factor.includes('Indica') || 
        factor.factor.includes('Sativa') || 
        factor.factor.includes('Hybrid')
      );
      
      if (typeFactors.length > 0) {
        const typeFactor = typeFactors[0].factor.toLowerCase();
        
        if (typeFactor.includes('indica')) {
          type = 'indica';
        } else if (typeFactor.includes('sativa')) {
          type = 'sativa';
        } else if (typeFactor.includes('hybrid')) {
          type = 'hybrid';
        }
      }
    }
    
    // Extract effects from the reasoning factors
    let effects = ['Relaxed', 'Happy']; // Default effects
    
    if (recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors)) {
      const effectsFactor = recommendation.reasoningFactors.find(factor => 
        factor.factor.includes('Matches') && factor.factor.includes('effects')
      );
      
      if (effectsFactor) {
        // Try to extract the effects from the factor text
        effects = effectsFactor.factor
          .replace('Matches', '')
          .replace('of your desired effects', '')
          .trim()
          .split(',')
          .map(e => e.trim())
          .filter(e => e.length > 0);
        
        // If we couldn't extract effects, use the desired effects from the request
        if (effects.length === 0 || (effects.length === 1 && !isNaN(parseInt(effects[0])))) {
          effects = desiredEffects.map(e => e.charAt(0).toUpperCase() + e.slice(1));
        }
      }
    }
    
    return {
      ...recommendation,
      name: recommendation.strainName,
      type: type,
      effects: effects,
      reason: recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors) 
        ? recommendation.reasoningFactors.map(f => f.factor).join('. ')
        : 'Recommended based on your preferences'
    };
  };
  
  // Render recommendation card
  const renderRecommendationCard = (recommendation: StrainRecommendation, index: number) => {
    const enhancedRecommendation = enhanceRecommendation(recommendation);
    
    return (
      <TouchableOpacity 
        key={`recommendation-${index}`}
        style={styles.recommendationCard}
        onPress={() => Alert.alert('Strain Details', `View detailed information about ${enhancedRecommendation.name}`)}
      >
        <View style={[
          styles.strainTypeIndicator,
          { backgroundColor: getStrainTypeColor(enhancedRecommendation.type) }
        ]} />
        <View style={styles.recommendationContent}>
          <Text style={styles.strainName}>{enhancedRecommendation.name}</Text>
          <Text style={styles.strainType}>{enhancedRecommendation.type}</Text>
          <Text style={styles.matchScore}>
            {enhancedRecommendation.matchScore}% Match
          </Text>
          <Text style={styles.reasonText}>{enhancedRecommendation.reason}</Text>
          
          <View style={styles.effectsContainer}>
            {enhancedRecommendation.effects.slice(0, 3).map((effect, i) => (
              <View key={`effect-${i}`} style={styles.effectTag}>
                <Text style={styles.effectText}>{effect}</Text>
              </View>
            ))}
          </View>
        </View>
      </TouchableOpacity>
    );
  };
  
  // Get color based on strain type
  const getStrainTypeColor = (type: string): string => {
    switch(type.toLowerCase()) {
      case 'indica':
        return '#3949ab'; // Indigo color
      case 'sativa':
        return COLORS.primary; // Primary green color
      case 'hybrid':
        return '#7b1fa2'; // Purple color
      default:
        return '#757575'; // Gray color
    }
  };
  
  // Render safety warnings if any
  const renderSafetyWarnings = () => {
    if (!safetyValidation || !safetyValidation.safetyFlags) return null;
    
    return (
      <View style={styles.safetyWarningsContainer}>
        <View style={styles.safetyHeader}>
          <MaterialCommunityIcons 
            name="alert-circle-outline" 
            size={20} 
            color={safetyValidation.warningLevel === 'warning' ? '#ffb300' : '#2196f3'} 
          />
          <Text style={styles.safetyHeaderText}>Safety Information</Text>
        </View>
        
        {safetyValidation.safetyFlags.map((flag, index) => (
          <Text key={`flag-${index}`} style={styles.safetyFlag}>
            • {flag}
          </Text>
        ))}
      </View>
    );
  };
  
  if (loading) {
    return <LoadingView />;
  }
  
  if (error && !recommendations) {
    return <ErrorView error={error} />;
  }
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          title: 'AI Strain Recommendations'
        }} 
      />
      
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.contentContainer} showsVerticalScrollIndicator={false}>
        {/* Context Selector */}
        <View style={styles.contextSelector}>
          <Text style={styles.sectionTitle}>Purpose</Text>
          <View style={styles.timeRangeButtons}>
            <TouchableOpacity
              style={[
                styles.timeRangeButton,
                context === 'recreational' && styles.timeRangeButtonActive
              ]}
              onPress={() => setContext('recreational')}
            >
              <Text style={[
                styles.timeRangeButtonText,
                context === 'recreational' && styles.timeRangeButtonTextActive
              ]}>
                Recreational
              </Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={[
                styles.timeRangeButton,
                context === 'medical' && styles.timeRangeButtonActive
              ]}
              onPress={() => setContext('medical')}
            >
              <Text style={[
                styles.timeRangeButtonText,
                context === 'medical' && styles.timeRangeButtonTextActive
              ]}>
                Medical
              </Text>
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Desired Effects */}
        <View style={styles.effectsSection}>
          <Text style={styles.sectionTitle}>Desired Effects</Text>
          
          <View style={styles.selectedEffectsContainer}>
            {desiredEffects.map((effect, index) => (
              <View key={`selected-${index}`} style={styles.selectedEffect}>
                <Text style={styles.selectedEffectText}>{effect}</Text>
                <TouchableOpacity onPress={() => handleRemoveEffect(effect)}>
                  <MaterialCommunityIcons name="close-circle" size={16} color={COLORS.text.primary} />
                </TouchableOpacity>
              </View>
            ))}
          </View>
          
          <View style={styles.addEffectContainer}>
            <TextInput
              style={styles.effectInput}
              placeholder="Add desired effect..."
              placeholderTextColor={COLORS.text.tertiary}
              value={customEffect}
              onChangeText={setCustomEffect}
              onSubmitEditing={handleAddEffect}
            />
            <TouchableOpacity 
              style={styles.addEffectButton}
              onPress={handleAddEffect}
            >
              <MaterialCommunityIcons name="plus" size={20} color={COLORS.text.primary} />
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Get Recommendations Button */}
        <TouchableOpacity 
          style={styles.getRecommendationsButton}
          onPress={fetchRecommendations}
        >
          <Text style={styles.getRecommendationsText}>
            Get Recommendations
          </Text>
        </TouchableOpacity>
        
        {/* Safety Warnings */}
        {renderSafetyWarnings()}
        
        {/* Error Message */}
        {error && recommendations && (
          <View style={styles.errorContainer}>
            <MaterialCommunityIcons name="alert-circle" size={24} color="#ff6b6b" />
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}
        
        {/* Recommendations */}
        {recommendations && recommendations.recommendations && Array.isArray(recommendations.recommendations) && recommendations.recommendations.length > 0 ? (
          <View style={styles.recommendationsContainer}>
            <Text style={styles.sectionTitle}>
              Your Personalized Recommendations
            </Text>
            
            {recommendations.recommendations.map((recommendation, index) => 
              renderRecommendationCard(recommendation, index)
            )}
            
            {/* Disclaimers */}
            {recommendations.disclaimers && Array.isArray(recommendations.disclaimers) && recommendations.disclaimers.length > 0 && (
              <View style={styles.disclaimersContainer}>
                <Text style={styles.insightTitle}>Important Information</Text>
                {recommendations.disclaimers.map((disclaimer, index) => (
                  <Text key={`disclaimer-${index}`} style={styles.disclaimerText}>
                    • {disclaimer}
                  </Text>
                ))}
              </View>
            )}
          </View>
        ) : (
          <View style={styles.noRecommendationsContainer}>
            <Text style={styles.noRecommendationsText}>
              No recommendations available. Try adjusting your preferences or try again later.
            </Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    paddingHorizontal: 16,
    paddingBottom: 32,
  },
  contextSelector: {
    marginTop: 16,
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  timeRangeButtons: {
    flexDirection: 'row',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 12,
    padding: 4,
  },
  timeRangeButton: {
    flex: 1,
    paddingVertical: 10,
    alignItems: 'center',
    borderRadius: 8,
  },
  timeRangeButtonActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
  },
  timeRangeButtonText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  timeRangeButtonTextActive: {
    color: COLORS.primary,
    fontWeight: '600',
  },
  effectsSection: {
    marginBottom: 20,
  },
  selectedEffectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
  },
  selectedEffect: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
    borderRadius: 16,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  selectedEffectText: {
    color: COLORS.primary,
    marginRight: 6,
    fontWeight: '500',
  },
  addEffectContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  effectInput: {
    flex: 1,
    backgroundColor: COLORS.cardBackground,
    borderRadius: 8,
    padding: 12,
    color: COLORS.text.primary,
    marginRight: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  addEffectButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
    borderRadius: 8,
    padding: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  getRecommendationsButton: {
    backgroundColor: COLORS.primary,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    marginBottom: 20,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  getRecommendationsText: {
    color: '#fff',
    fontWeight: '700',
    fontSize: 16,
  },
  loadingIndicator: {
    marginLeft: 10,
  },
  safetyWarningsContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 2,
  },
  safetyHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  safetyHeaderText: {
    color: COLORS.text.primary,
    fontWeight: '600',
    marginLeft: 8,
    fontSize: 16,
  },
  safetyFlag: {
    color: COLORS.text.secondary,
    marginBottom: 4,
    lineHeight: 20,
  },
  errorContainer: {
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    borderRadius: 16,
    padding: 16,
    marginBottom: 20,
    flexDirection: 'row',
    alignItems: 'center',
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
  recommendationsContainer: {
    marginBottom: 20,
  },
  recommendationCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    marginBottom: 16,
    overflow: 'hidden',
    flexDirection: 'row',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
  },
  strainTypeIndicator: {
    width: 8,
    height: '100%',
  },
  recommendationContent: {
    padding: 16,
    flex: 1,
  },
  strainName: {
    fontSize: 18,
    fontWeight: '700',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  strainType: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 8,
    textTransform: 'capitalize'
  },
  matchScore: {
    fontSize: 16,
    fontWeight: '700',
    color: COLORS.primary,
    marginBottom: 8,
  },
  reasonText: {
    fontSize: 14,
    color: COLORS.text.secondary,
    marginBottom: 12,
    lineHeight: 20,
  },
  effectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  effectTag: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    borderRadius: 16,
    paddingVertical: 4,
    paddingHorizontal: 10,
    marginRight: 8,
    marginBottom: 4,
  },
  effectText: {
    color: COLORS.primary,
    fontSize: 12,
    fontWeight: '500',
  },
  disclaimersContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  insightTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
  },
  disclaimerText: {
    color: COLORS.text.secondary,
    marginBottom: 4,
    lineHeight: 20,
  },
  noRecommendationsContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginTop: 20,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  noRecommendationsText: {
    color: COLORS.text.secondary,
    fontSize: 16,
    textAlign: 'center',
    lineHeight: 22,
  },
});

================================================================================
File: app/components/ai/RecommendationFeedback.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, TextInput, ActivityIndicator } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { AIService } from '../../../src/services/ai';

interface RecommendationFeedbackProps {
  userId: string;
  recommendationId: string;
  onClose: () => void;
}

export default function RecommendationFeedback({ 
  userId, 
  recommendationId, 
  onClose 
}: RecommendationFeedbackProps) {
  const [helpful, setHelpful] = useState<boolean | null>(null);
  const [accurateEffects, setAccurateEffects] = useState<boolean | null>(null);
  const [wouldTryAgain, setWouldTryAgain] = useState<boolean | null>(null);
  const [comments, setComments] = useState('');
  const [submitting, setSubmitting] = useState(false);
  
  // Get AIService instance
  const aiService = AIService.getInstance();
  
  const handleSubmit = async () => {
    if (helpful === null) return;
    
    setSubmitting(true);
    
    try {
      // Calculate relevance score (1-5) based on user feedback
      const relevance = calculateRelevanceScore(helpful, accurateEffects, wouldTryAgain);
      
      await aiService.submitRecommendationFeedback(
        userId,
        recommendationId,
        helpful,
        accurateEffects || false,
        relevance,
        comments
      );
      
      onClose();
    } catch (error) {
      console.error('Error submitting feedback:', error);
    } finally {
      setSubmitting(false);
    }
  };
  
  // Calculate a relevance score (1-5) based on user feedback
  const calculateRelevanceScore = (
    helpful: boolean, 
    accurateEffects: boolean | null, 
    wouldTryAgain: boolean | null
  ): number => {
    if (!helpful) return 1; // Not helpful at all
    
    // Base score for helpful
    let score = 3;
    
    // Add points for accurate effects
    if (accurateEffects) score += 1;
    
    // Add points for would try again
    if (wouldTryAgain) score += 1;
    
    return Math.min(score, 5); // Cap at 5
  };
  
  return (
    <View style={styles.container}>
      <Text style={styles.title}>How was this recommendation?</Text>
      
      <View style={styles.questionContainer}>
        <Text style={styles.questionText}>Was this recommendation helpful?</Text>
        <View style={styles.buttonGroup}>
          <TouchableOpacity 
            style={[
              styles.optionButton,
              helpful === true && styles.selectedButton
            ]}
            onPress={() => setHelpful(true)}
          >
            <MaterialCommunityIcons 
              name="thumb-up" 
              size={20} 
              color={helpful === true ? '#FFFFFF' : '#AAAAAA'} 
            />
            <Text style={[
              styles.optionText,
              helpful === true && styles.selectedOptionText
            ]}>Yes</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[
              styles.optionButton,
              helpful === false && styles.selectedButton
            ]}
            onPress={() => setHelpful(false)}
          >
            <MaterialCommunityIcons 
              name="thumb-down" 
              size={20} 
              color={helpful === false ? '#FFFFFF' : '#AAAAAA'} 
            />
            <Text style={[
              styles.optionText,
              helpful === false && styles.selectedOptionText
            ]}>No</Text>
          </TouchableOpacity>
        </View>
      </View>
      
      {helpful !== null && (
        <>
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>Were the effects as described?</Text>
            <View style={styles.buttonGroup}>
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  accurateEffects === true && styles.selectedButton
                ]}
                onPress={() => setAccurateEffects(true)}
              >
                <Text style={[
                  styles.optionText,
                  accurateEffects === true && styles.selectedOptionText
                ]}>Yes</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  accurateEffects === false && styles.selectedButton
                ]}
                onPress={() => setAccurateEffects(false)}
              >
                <Text style={[
                  styles.optionText,
                  accurateEffects === false && styles.selectedOptionText
                ]}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>Would you try this strain again?</Text>
            <View style={styles.buttonGroup}>
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  wouldTryAgain === true && styles.selectedButton
                ]}
                onPress={() => setWouldTryAgain(true)}
              >
                <Text style={[
                  styles.optionText,
                  wouldTryAgain === true && styles.selectedOptionText
                ]}>Yes</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  wouldTryAgain === false && styles.selectedButton
                ]}
                onPress={() => setWouldTryAgain(false)}
              >
                <Text style={[
                  styles.optionText,
                  wouldTryAgain === false && styles.selectedOptionText
                ]}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          <View style={styles.commentsContainer}>
            <Text style={styles.questionText}>Additional comments (optional)</Text>
            <TextInput
              style={styles.commentsInput}
              placeholder="Share your experience..."
              placeholderTextColor="#888888"
              value={comments}
              onChangeText={setComments}
              multiline
              maxLength={500}
            />
          </View>
          
          <TouchableOpacity 
            style={styles.submitButton}
            onPress={handleSubmit}
            disabled={submitting}
          >
            {submitting ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <Text style={styles.submitButtonText}>Submit Feedback</Text>
            )}
          </TouchableOpacity>
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#1A1A1A',
    borderRadius: 16,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 20,
    textAlign: 'center',
  },
  questionContainer: {
    marginBottom: 20,
  },
  questionText: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 12,
  },
  buttonGroup: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  optionButton: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginHorizontal: 6,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  selectedButton: {
    backgroundColor: '#4CAF50',
  },
  optionText: {
    color: '#AAAAAA',
    fontSize: 16,
    marginLeft: 8,
  },
  selectedOptionText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  commentsContainer: {
    marginBottom: 20,
  },
  commentsInput: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 8,
    padding: 12,
    color: '#FFFFFF',
    height: 100,
    textAlignVertical: 'top',
  },
  submitButton: {
    backgroundColor: '#4CAF50',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
  },
  submitButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
}); 




  =========================================================
File: src/hooks/useAIRecommendations.ts
================================================================================

import { useState, useEffect, useCallback, useRef } from 'react';
import { AIService } from '../services/ai';
import { ChatRequest } from '../services/ai/types/requests';
import SafetyService from '../services/SafetyService';
import { 
  RecommendationRequest, 
  RecommendationResponse, 
  ChatMessage, 
  UserProfile,
  JournalEntry,
  SafetyValidationResult
} from '../types/ai';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Cache keys
const RECOMMENDATIONS_CACHE_KEY = 'ai_recommendations_cache';
const RECOMMENDATIONS_CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

export const useAIRecommendations = () => {
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [recommendations, setRecommendations] = useState<RecommendationResponse | null>(null);
  const [safetyValidation, setSafetyValidation] = useState<SafetyValidationResult | null>(null);
  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  
  // Track initialization state
  const isInitialized = useRef<boolean>(false);
  const cleanupCalled = useRef<boolean>(false);
  
  // Get AIService instance
  const aiService = AIService.getInstance();
  
  // Initialize services
  useEffect(() => {
    const initServices = async () => {
      if (isInitialized.current) return;
      
      try {
        await aiService.initialize();
        await SafetyService.initialize();
        isInitialized.current = true;
      } catch (err) {
        console.error('Error initializing AI or Safety services:', err);
        setError('Failed to initialize recommendation services');
      }
    };
    
    initServices();
    
    // Load cached recommendations if available
    loadCachedRecommendations();
    
    return () => {
      // Cleanup only if not already called
      if (!cleanupCalled.current) {
        cleanupCalled.current = true;
        SafetyService.cleanup().catch(err => {
          console.error('Error during SafetyService cleanup:', err);
        });
      }
    };
  }, []);
  
  // Load cached recommendations
  const loadCachedRecommendations = async () => {
    try {
      const cachedData = await AsyncStorage.getItem(RECOMMENDATIONS_CACHE_KEY);
      
      if (cachedData) {
        const { recommendations: cachedRecommendations, timestamp } = JSON.parse(cachedData);
        
        // Check if cache is still valid
        if (Date.now() - timestamp < RECOMMENDATIONS_CACHE_EXPIRY) {
          setRecommendations(cachedRecommendations);
        }
      }
    } catch (err) {
      console.warn('Error loading cached recommendations:', err);
      // Non-critical error, don't set error state
    }
  };
  
  // Cache recommendations
  const cacheRecommendations = async (recommendations: RecommendationResponse) => {
    try {
      await AsyncStorage.setItem(
        RECOMMENDATIONS_CACHE_KEY,
        JSON.stringify({
          recommendations,
          timestamp: Date.now()
        })
      );
    } catch (err) {
      console.warn('Error caching recommendations:', err);
      // Non-critical error, don't set error state
    }
  };
  
  // Get strain recommendations with safety checks
  const getRecommendations = useCallback(async (
    request: RecommendationRequest,
    recentEntries: JournalEntry[] = []
  ): Promise<RecommendationResponse | null> => {
    setLoading(true);
    setError(null);
    
    try {
      // Validate request for safety concerns
      const validationResult = await SafetyService.validateRecommendationRequest(request);
      setSafetyValidation(validationResult);
      
      // If request is invalid due to safety concerns, return early
      if (!validationResult.valid) {
        setError(validationResult.reason || 'Request failed safety validation');
        setLoading(false);
        return null;
      }
      
      // Apply any safety modifications to the request
      const safeRequest = validationResult.modifications 
        ? { ...request, ...validationResult.modifications }
        : request;
      
      // Get recommendations from AI service
      const rawRecommendations = await aiService.getRecommendations(safeRequest);
      
      // Process recommendations through safety service
      const safeRecommendations = await SafetyService.processRecommendationResponse(
        rawRecommendations,
        request.userProfile,
        recentEntries
      );
      
      // Update state and cache
      setRecommendations(safeRecommendations);
      cacheRecommendations(safeRecommendations);
      
      setLoading(false);
      return safeRecommendations;
      
    } catch (err) {
      console.error('Error getting recommendations:', err);
      setError('Failed to get recommendations. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [aiService]);
  
  // Get chat response
  const getChatResponse = useCallback(async (
    message: string,
    userProfile: UserProfile
  ): Promise<ChatMessage | null> => {
    setLoading(true);
    setError(null);
    
    try {
      // Add user message to history
      const userMessage: ChatMessage = {
        id: `user_${Date.now()}`,
        content: message,
        role: 'user',
        timestamp: new Date().toISOString()
      };
      
      setChatHistory(prev => [...prev, userMessage]);
      
      // Create chat request - convert ChatMessage to the simplified format expected by AIService
      const chatRequest: ChatRequest = {
        message,
        userProfile,
        // Only include the role and content properties that AIService needs
        previousMessages: chatHistory.length > 0 
          ? chatHistory.map(msg => ({ 
              role: msg.role, 
              content: msg.content 
            })) as any // Use type assertion to bypass the type check
          : undefined
      };
      
      // Get AI response
      const aiResponseData = await aiService.getChatResponse(chatRequest);
      
      // Create chat message from response
      const aiResponseMessage: ChatMessage = {
        id: `assistant_${Date.now()}`,
        content: aiResponseData.response,
        role: 'assistant',
        timestamp: new Date().toISOString()
      };
      
      // Add AI response to history
      setChatHistory(prev => [...prev, aiResponseMessage]);
      
      setLoading(false);
      return aiResponseMessage;
      
    } catch (err) {
      console.error('Error getting chat response:', err);
      setError('Failed to get response. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [chatHistory, aiService]);
  
  // Analyze journal patterns
  const analyzeJournalPatterns = useCallback(async (
    entries: JournalEntry[],
    userProfile: UserProfile
  ) => {
    setLoading(true);
    setError(null);
    
    try {
      const analysis = await aiService.analyzeJournalEntries(userProfile.id, entries);
      setLoading(false);
      return analysis;
      
    } catch (err) {
      console.error('Error analyzing journal patterns:', err);
      setError('Failed to analyze journal entries. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [aiService]);
  
  // Clear chat history
  const clearChatHistory = useCallback(() => {
    setChatHistory([]);
  }, []);
  
  // Get safety history
  const getSafetyHistory = useCallback(async (userId: string) => {
    try {
      return await SafetyService.getSafetyHistory(userId);
    } catch (err) {
      console.error('Error getting safety history:', err);
      return [];
    }
  }, []);
  
  return {
    loading,
    error,
    recommendations,
    safetyValidation,
    chatHistory,
    getRecommendations,
    getChatResponse,
    analyzeJournalPatterns,
    clearChatHistory,
    getSafetyHistory
  };
};

export default useAIRecommendations; 

================================================================================
File: src/hooks/useDataService.ts
================================================================================

import { useState, useEffect } from 'react';
import { DataService } from '@/src/services/DataService';
import { DataState, ChartDataPoint, UsageStats, WeekdayStats } from '@/src/types';

const DEFAULT_STATE: DataState = {
  weeklyData: [],
  monthlyData: [],
  usageStats: {
    averageHitsPerDay: 0,
    totalHits: 0,
    peakDayHits: 0,
    lowestDayHits: 0,
    averageDuration: 0,
    longestHit: 0,
    shortestHit: 0,
    mostActiveHour: 0,
    leastActiveHour: 0,
    totalDuration: 0,
    averageHitsPerHour: 0,
    consistency: 0,
    weekdayStats: {
      weekday: { avg: 0, total: 0 },
      weekend: { avg: 0, total: 0 }
    }
  },
  timeDistribution: {
    morning: 0,
    afternoon: 0,
    evening: 0,
    night: 0
  },
  isLoading: true,
  error: null
};

export function useDataService() {
  const [state, setState] = useState<DataState>(DEFAULT_STATE);

  useEffect(() => {
    let isMounted = true;
    const service = DataService.getInstance();

    const loadData = async () => {
      try {
        // Log for debugging
        console.log('[useDataService] Starting data fetch...');

        // Set initial loading state
        if (!isMounted) return;
        setState(prev => ({ ...prev, isLoading: true, error: null }));

        // Fetch data sequentially to avoid race conditions
        console.log('[useDataService] Fetching weekly stats...');
        const weeklyStats = await service.getWeeklyStats();
        if (!isMounted) return;
        console.log('[useDataService] Weekly stats:', weeklyStats);

        console.log('[useDataService] Fetching monthly stats...');
        const monthlyStats = await service.getMonthlyStats();
        if (!isMounted) return;
        console.log('[useDataService] Monthly stats:', monthlyStats);

        console.log('[useDataService] Fetching usage stats...');
        const usageStats = await service.getUsageStats();
        if (!isMounted) return;
        console.log('[useDataService] Usage stats:', usageStats);

        console.log('[useDataService] Fetching time distribution...');
        const timeDistribution = await service.getTimeDistribution();
        if (!isMounted) return;
        console.log('[useDataService] Time distribution:', timeDistribution);

        // Collect any errors from the responses
        const errors: string[] = [];
        if (!weeklyStats.success) errors.push(`Weekly stats: ${weeklyStats.error}`);
        if (!monthlyStats.success) errors.push(`Monthly stats: ${monthlyStats.error}`);
        if (!usageStats.success) errors.push(`Usage stats: ${usageStats.error}`);
        if (!timeDistribution.success) errors.push(`Time distribution: ${timeDistribution.error}`);

        if (errors.length > 0) {
          const errorMessage = errors.join('; ');
          console.error('[useDataService] Data fetch errors:', errorMessage);
          if (isMounted) {
            setState(prev => ({
              ...prev,
              isLoading: false,
              error: errorMessage
            }));
          }
          return;
        }

        // Update state only if all requests succeeded and component is mounted
        console.log('[useDataService] All data fetched successfully, updating state...');
        if (isMounted) {
          setState({
            ...DEFAULT_STATE,
            weeklyData: weeklyStats.data!,
            monthlyData: monthlyStats.data!,
            usageStats: {
              ...DEFAULT_STATE.usageStats,
              ...usageStats.data!
            },
            timeDistribution: timeDistribution.data!,
            isLoading: false,
            error: null
          });
        }
      } catch (error) {
        console.error('[useDataService] Unexpected error in loadData:', error);
        if (isMounted) {
          setState(prev => ({
            ...prev,
            isLoading: false,
            error: error instanceof Error ? error.message : 'An unexpected error occurred while fetching data'
          }));
        }
      }
    };

    loadData();

    return () => {
      console.log('[useDataService] Cleaning up...');
      isMounted = false;
      service.cleanup().catch(error => {
        console.error('[useDataService] Error during cleanup:', error);
      });
    };
  }, []); // Empty dependency array as we only want to run this once

  return state;
} 

================================================================================
File: src/hooks/useStrains.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import StrainService, { StrainSearchFilters } from '../services/StrainService';
import { Strain } from '../dbManager';

export interface UseStrainState {
  strains: Strain[];
  popularStrains: Strain[];
  categories: { [key: string]: number };
  isLoading: boolean;
  error: string | null;
  pagination: {
    total: number;
    currentPage: number;
    totalPages: number;
    hasMore: boolean;
  };
}

export interface UseStrainActions {
  searchStrains: (query: string, filters: StrainSearchFilters) => Promise<void>;
  loadMore: () => void;
  toggleFavorite: (strainId: number) => Promise<void>;
  isFavorite: (strainId: number) => boolean;
  clearSearch: () => void;
  getStrainDetails: (id: number) => Promise<Strain | null>;
  getRelatedStrains: (strain: Strain) => Promise<Strain[]>;
}

const INITIAL_STATE: UseStrainState = {
  strains: [],
  popularStrains: [],
  categories: {},
  isLoading: false,
  error: null,
  pagination: {
    total: 0,
    currentPage: 1,
    totalPages: 1,
    hasMore: false
  }
};

export function useStrains(): UseStrainState & UseStrainActions {
  const [state, setState] = useState<UseStrainState>(INITIAL_STATE);
  const [filters, setFilters] = useState<StrainSearchFilters>({});
  const [favoriteStrains, setFavoriteStrains] = useState<number[]>([]);

  // Load initial data
  useEffect(() => {
    loadInitialData();
  }, []);

  const loadInitialData = async () => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      
      const [popularStrains, categories] = await Promise.all([
        StrainService.getPopularStrains(),
        StrainService.getStrainCategories()
      ]);

      setState(prev => ({
        ...prev,
        popularStrains,
        categories,
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Failed to load initial data',
        isLoading: false
      }));
    }
  };

  const searchStrains = useCallback(async (
    query: string,
    newFilters: StrainSearchFilters = {},
    page: number = 1
  ) => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      setFilters(newFilters);

      const result = await StrainService.searchStrains(query, newFilters, { page, limit: 10 });

      setState(prev => ({
        ...prev,
        strains: page === 1 ? result.data : [...prev.strains, ...result.data],
        pagination: {
          total: result.total,
          currentPage: result.currentPage,
          totalPages: result.totalPages,
          hasMore: result.hasMore
        },
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Search failed',
        isLoading: false
      }));
    }
  }, []);

  const loadMore = useCallback(() => {
    if (state.pagination.hasMore && !state.isLoading) {
      const nextPage = state.pagination.currentPage + 1;
      searchStrains('', filters, nextPage);
    }
  }, [state.pagination, state.isLoading, filters, searchStrains]);

  const toggleFavorite = useCallback(async (strainId: number) => {
    setFavoriteStrains(prev => {
      const isFavorited = prev.includes(strainId);
      return isFavorited 
        ? prev.filter(id => id !== strainId)
        : [...prev, strainId];
    });
  }, []);

  const isFavorite = useCallback((strainId: number) => {
    return favoriteStrains.includes(strainId);
  }, [favoriteStrains]);

  const clearSearch = useCallback(() => {
    setState(prev => ({
      ...prev,
      strains: [],
      pagination: {
        total: 0,
        currentPage: 1,
        totalPages: 1,
        hasMore: false
      }
    }));
  }, []);

  const getStrainDetails = useCallback(async (id: number): Promise<Strain | null> => {
    try {
      return await StrainService.getStrainById(id);
    } catch (error) {
      console.error('[useStrains] Error getting strain details:', error);
      return null;
    }
  }, []);

  const getRelatedStrains = useCallback(async (strain: Strain): Promise<Strain[]> => {
    try {
      return await StrainService.getRelatedStrains(strain);
    } catch (error) {
      console.error('[useStrains] Error getting related strains:', error);
      return [];
    }
  }, []);

  return {
    ...state,
    searchStrains,
    loadMore,
    toggleFavorite,
    isFavorite,
    clearSearch,
    getStrainDetails,
    getRelatedStrains
  };
} 

================================================================================
File: src/hooks/useTimeRangeData.ts
================================================================================

import { useState, useCallback, useEffect } from 'react';
import { useDataService } from './useDataService';

export type TimeRange = 'D' | 'W' | 'M' | 'Y';

interface TimeRangeData {
  chartData: number[];
  chartLabels: string[];
  averageValue: number;
  maxValue: number;
  minValue: number;
  weekdayAvg?: number;
  weekendAvg?: number;
}

export function useTimeRangeData(initialRange: TimeRange = 'W') {
  const { weeklyData, monthlyData, usageStats, isLoading: isDataLoading, error: dataError } = useDataService();
  const [timeRange, setTimeRange] = useState<TimeRange>(initialRange);
  const [data, setData] = useState<TimeRangeData>({
    chartData: [],
    chartLabels: [],
    averageValue: 0,
    maxValue: 0,
    minValue: 0,
    weekdayAvg: 0,
    weekendAvg: 0
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Function to fetch data based on time range
  const fetchDataByTimeRange = useCallback(async (range: TimeRange) => {
    if (isDataLoading || dataError) return;
    const averageValue = usageStats.averageHitsPerDay;
    const maxValue = usageStats.peakDayHits; // Use the peak day value
    const minValue = usageStats.lowestDayHits > 0 ? usageStats.lowestDayHits : 0;
    setIsLoading(true);
    setError(null);
    
    try {
      // In a real implementation, this would call your data service
      // For now, we'll use the existing data and simulate different time ranges
      let chartData: number[] = [];
      let chartLabels: string[] = [];
      
      switch(range) {
        case 'D': // Daily (hours)
          // Simulate hourly data for today
          chartData = Array.from({ length: 24 }, () => Math.floor(Math.random() * 10));
          chartLabels = Array.from({ length: 24 }, (_, i) => `${i}:00`);
          break;
        case 'W': // Weekly (days)
          // Use the existing weekly data
          chartData = weeklyData.map(d => d.value);
          chartLabels = weeklyData.map(d => d.label);
          break;
        case 'M': // Monthly (days)
          // Simulate daily data for a month
          chartData = Array.from({ length: 30 }, () => Math.floor(Math.random() * 20));
          chartLabels = Array.from({ length: 30 }, (_, i) => `${i+1}`);
          break;
        case 'Y': // Yearly (months)
          // Use the existing monthly data
          chartData = monthlyData.map(d => d.value);
          chartLabels = monthlyData.map(d => d.label);
          break;
      }

      let weekdayAvg = usageStats.weekdayStats?.weekday.avg || 0;
      let weekendAvg = usageStats.weekdayStats?.weekend.avg || 0;
      
      if (range !== 'W') {
        // Simulate different stats for other time ranges
        weekdayAvg = averageValue * 0.9; // Slightly lower for weekdays
        weekendAvg = averageValue * 1.2; // Slightly higher for weekends
      }
      
      setData({
        chartData,
        chartLabels,
        averageValue,
        maxValue,
        minValue,
        weekdayAvg,
        weekendAvg
      });
    } catch (err) {
      console.error("Error fetching time range data:", err);
      setError(err instanceof Error ? err.message : "An unknown error occurred");
    } finally {
      setIsLoading(false);
    }
  }, [weeklyData, monthlyData, usageStats, isDataLoading, dataError]);

  // Update data when time range changes
  useEffect(() => {
    fetchDataByTimeRange(timeRange);
  }, [timeRange, fetchDataByTimeRange]);

  return {
    timeRange,
    setTimeRange,
    data,
    isLoading: isLoading || isDataLoading,
    error: error || dataError,
    fetchDataByTimeRange
  };
} 

================================================================================
File: src/services/ai/AIService.ts
================================================================================

import * as Logger from './utils/logging';
import { DatabaseManager } from './database/DatabaseManager';
import { CacheManager } from './cache/CacheManager';
import { FeedbackService } from './feedback/FeedbackService';
import { AnthropicAPI } from './api/AnthropicAPI';
import { AIServiceError, AIServiceErrorType } from './types/errors';
import { 
  RecommendationRequest, 
  ChatRequest 
} from './types/requests';
import { 
  RecommendationResponse, 
  ChatResponse,
  JournalAnalysisResult,
  SafetyValidationResult,
  DrugInteractionResult,
  OveruseDetectionResult
} from './types/responses';
import { UserFeedback, QualityScore } from './types/feedback';
import { DEFAULT_CACHE_TTL } from './types/common';
// Import types from the main app types
import { 
  UserProfile, 
  JournalEntry, 
  StrainRecommendation, 
  DosageSuggestion,
  ChatMessage
} from '../../types/ai';
import { MemoryCache } from './cache/MemoryCache';
import { PersistentCache } from './cache/PersistentCache';
import { StrainService } from '../StrainService';
import { Strain } from '../../dbManager';

const MODULE_NAME = 'AIService';

/**
 * AI Service
 * Main service for AI-powered features in the Canova app
 */
export class AIService {
  private static instance: AIService;
  private databaseManager: DatabaseManager;
  private cacheManager: CacheManager;
  private feedbackService: FeedbackService;
  private api: AnthropicAPI;
  private strainService: StrainService;
  private initialized: boolean = false;
  private useMockResponses: boolean = false;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {
    this.databaseManager = DatabaseManager.getInstance();
    this.cacheManager = CacheManager.getInstance();
    this.feedbackService = FeedbackService.getInstance();
    this.api = new AnthropicAPI();
    this.strainService = StrainService.getInstance();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of AIService
   */
  public static getInstance(): AIService {
    if (!AIService.instance) {
      AIService.instance = new AIService();
    }
    return AIService.instance;
  }

  /**
   * Initialize the AI service and its dependencies
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing AI service');
      
      // Initialize dependencies
      try {
        await this.databaseManager.initialize();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database manager, continuing with limited functionality');
      }
      
      try {
        await this.cacheManager.initialize();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize cache manager, continuing with limited functionality');
      }
      
      try {
        await this.feedbackService.initialize();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback service, continuing with limited functionality');
      }
      
      this.initialized = true;
      Logger.info(MODULE_NAME, 'AI service initialized successfully');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize AI service');
      // Set initialized to true anyway to prevent repeated initialization attempts
      this.initialized = true;
    }
  }

  /**
   * Configure the AI service
   */
  public configure(options: {
    useMockResponses?: boolean;
    cacheEnabled?: boolean;
    cacheTtl?: number;
    cacheMaxSize?: number;
  }): void {
    if (options.useMockResponses !== undefined) {
      this.useMockResponses = options.useMockResponses;
      Logger.info(MODULE_NAME, `Mock responses ${this.useMockResponses ? 'enabled' : 'disabled'}`);
    }
    
    // Configure cache if options provided
    if (options.cacheEnabled !== undefined || options.cacheTtl !== undefined || options.cacheMaxSize !== undefined) {
      try {
        this.cacheManager.configure(
          options.cacheEnabled ?? true,
          options.cacheTtl ?? DEFAULT_CACHE_TTL,
          options.cacheMaxSize ?? 100
        );
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to configure cache manager');
      }
    }
  }

  /**
   * Check if the service is initialized
   */
  private checkInitialized(): void {
    if (!this.initialized) {
      // Auto-initialize instead of throwing an error
      Logger.warn(MODULE_NAME, 'AI service not initialized, initializing now...');
      this.initialize().catch(error => {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to auto-initialize AI service');
      });
    }
  }

  /**
   * Get real strain recommendations from the database based on user preferences
   */
  private async getRealStrainRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    try {
      Logger.info(MODULE_NAME, 'Getting real strain recommendations from database');
      
      // Extract desired effects from the request
      const { desiredEffects, context, medicalNeeds } = request;
      Logger.info(MODULE_NAME, `Desired effects: ${desiredEffects.join(', ')}`);
      
      // Get all strains from the database
      const allStrainsResult = await this.strainService.searchStrains('', {}, { page: 1, limit: 100 });
      Logger.info(MODULE_NAME, `All strains search result: Found ${allStrainsResult.data?.length || 0} strains`);
      
      if (!allStrainsResult.data || allStrainsResult.data.length === 0) {
        Logger.warn(MODULE_NAME, 'No strains found in database at all');
        return this.getMockRecommendations(request); // Fallback to mock data if no results
      }
      
      // Log some sample effects from the database to understand what's available
      const sampleEffects = allStrainsResult.data.slice(0, 5).map((strain: Strain) => {
        return `${strain.name}: ${strain.effects}`;
      });
      Logger.info(MODULE_NAME, `Sample effects in database: ${sampleEffects.join(' | ')}`);
      
      // Use the AI to interpret the natural language query and match it to strain effects
      const matchedStrains = await this.matchStrainsWithAI(desiredEffects, allStrainsResult.data, context, medicalNeeds);
      
      // If we don't have any recommendations, use mock data
      if (!matchedStrains || matchedStrains.length === 0) {
        Logger.warn(MODULE_NAME, 'No matching strains found after AI matching');
        return this.getMockRecommendations(request);
      }
      
      // Log the top 5 scored strains
      const topScores = matchedStrains.slice(0, 5).map(s => `${s.strain.name}: ${s.matchScore}%`);
      Logger.info(MODULE_NAME, `Top scored strains: ${topScores.join(', ')}`);
      
      // Take top 5 recommendations
      const topRecommendations = matchedStrains
        .slice(0, 5)
        .map(s => ({
          strainId: s.strain.id || 0,
          strainName: s.strain.name,
          matchScore: s.matchScore,
          reasoningFactors: s.reasoningFactors,
          alternativeStrains: [] // Could be populated with similar strains
        }));
      
      Logger.info(MODULE_NAME, `Returning ${topRecommendations.length} recommendations`);
      
      return {
        recommendations: topRecommendations,
        reasoning: `Based on your request for "${desiredEffects.join(', ')}", I've found strains that are likely to match your preferences.`,
        confidenceScore: 90,
        disclaimers: [
          'Individual experiences may vary',
          'Start with a low dose and gradually increase as needed',
          'Consult with a healthcare professional before use, especially if you have medical conditions or take medications'
        ],
        dosageSuggestion: {
          minDosage: 5,
          maxDosage: 10,
          unit: 'mg THC',
          gradualApproach: true,
          notes: 'Start low and go slow. Wait at least 2 hours before consuming more edibles.'
        },
        safetyNotes: [
          'Do not drive or operate heavy machinery after use',
          'Keep out of reach of children and pets',
          'Store in a cool, dry place away from direct sunlight'
        ]
      };
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get real strain recommendations');
      // Fallback to mock data if there's an error
      return this.getMockRecommendations(request);
    }
  }

  /**
   * Use AI to match strains with natural language queries
   */
  private async matchStrainsWithAI(
    desiredEffects: string[], 
    strains: Strain[], 
    context?: string,
    medicalNeeds?: string[]
  ): Promise<Array<{
    strain: Strain;
    matchScore: number;
    reasoningFactors: Array<{ factor: string; weight: number }>;
  }>> {
    try {
      // If we're not using the real API, use a simpler matching approach
      if (this.useMockResponses) {
        return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
      }
      
      // Create a prompt for the AI to match strains
      const prompt = `
        You are an expert cannabis strain matcher. I need you to match the following user's desired effects with the most appropriate strains from our database.
        
        User's desired effects: "${desiredEffects.join(', ')}"
        ${context ? `Context: ${context}` : ''}
        ${medicalNeeds && medicalNeeds.length > 0 ? `Medical needs: ${medicalNeeds.join(', ')}` : ''}
        
        Here are the available strains with their effects:
        ${strains.slice(0, 50).map(strain => 
          `- ${strain.name} (${strain.genetic_type}, THC: ${strain.thc_range}): ${strain.effects}${strain.uses ? ` | Uses: ${strain.uses}` : ''}`
        ).join('\n')}
        
        Please analyze the user's request and match it with the most appropriate strains. For each matched strain, provide:
        1. The strain name
        2. A match score (0-100)
        3. 2-3 specific reasoning factors explaining why this strain matches the user's request
        
        Return your response as a JSON array with the following structure:
        [
          {
            "strainName": "Strain Name",
            "matchScore": 85,
            "reasoningFactors": [
              {"factor": "Specific reason this strain matches", "weight": 0.5},
              {"factor": "Another specific reason", "weight": 0.3},
              {"factor": "Additional information about the strain", "weight": 0.2}
            ]
          }
        ]
        
        Only include strains with a match score above 50. Limit your response to the top 10 matches.
      `;
      
      // Call the AI API
      const response = await this.api.sendMessage([
        { role: 'user', content: prompt }
      ], 2000, 0.7);
      
      // Parse the response
      try {
        // Extract JSON from the response (it might be wrapped in markdown code blocks)
        const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)\s*```/) || 
                          response.match(/\[\s*\{\s*"strainName"/);
        
        const jsonStr = jsonMatch ? jsonMatch[1] || response : response;
        const matches = JSON.parse(jsonStr);
        
        if (!Array.isArray(matches)) {
          throw new Error('Response is not an array');
        }
        
        // Map the AI matches to our strain objects
        const matchedStrains = matches.map(match => {
          // Find the corresponding strain object
          const strain = strains.find(s => s.name === match.strainName);
          
          if (!strain) {
            Logger.warn(MODULE_NAME, `Strain not found: ${match.strainName}`);
            return null;
          }
          
          return {
            strain,
            matchScore: match.matchScore,
            reasoningFactors: match.reasoningFactors
          };
        }).filter((match): match is { 
          strain: Strain; 
          matchScore: number; 
          reasoningFactors: Array<{ factor: string; weight: number }> 
        } => match !== null);
        
        Logger.info(MODULE_NAME, `AI matched ${matchedStrains.length} strains`);
        
        return matchedStrains;
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to parse AI strain matching response');
        // Fallback to simple matching
        return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to match strains with AI');
      // Fallback to simple matching
      return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
    }
  }
  
  /**
   * Simple strain matching algorithm as a fallback
   */
  private matchStrainsSimple(
    desiredEffects: string[], 
    strains: Strain[], 
    context?: string,
    medicalNeeds?: string[]
  ): Array<{
    strain: Strain;
    matchScore: number;
    reasoningFactors: Array<{ factor: string; weight: number }>;
  }> {
    // Common cannabis effects for basic matching
    const commonEffects = {
      'happy': ['euphoric', 'uplifted', 'joyful', 'cheerful', 'blissful'],
      'relaxed': ['calm', 'peaceful', 'tranquil', 'mellow', 'soothing'],
      'creative': ['inspired', 'imaginative', 'artistic', 'focused'],
      'energetic': ['active', 'lively', 'stimulating', 'invigorating'],
      'sleepy': ['sedated', 'drowsy', 'restful', 'sleep', 'tired'],
      'hungry': ['appetite', 'munchies', 'food'],
      'pain relief': ['analgesic', 'pain', 'ache', 'sore'],
      'stress relief': ['stress', 'anxiety', 'tension', 'worry']
    };
    
    // Score each strain
    const scoredStrains = strains.map(strain => {
      // Parse effects into an array
      const strainEffects = strain.effects.split(',').map(e => e.trim().toLowerCase());
      
      // Calculate a basic match score
      let matchScore = 0;
      const matchedEffects: string[] = [];
      
      // Check each desired effect against strain effects
      desiredEffects.forEach(desiredEffect => {
        const desiredLower = desiredEffect.toLowerCase();
        
        // Direct match
        const directMatch = strainEffects.some(effect => 
          effect.includes(desiredLower) || desiredLower.includes(effect)
        );
        
        if (directMatch) {
          matchScore += 25;
          matchedEffects.push(desiredEffect);
          return;
        }
        
        // Check against common effects
        for (const [effect, synonyms] of Object.entries(commonEffects)) {
          // If desired effect contains this effect or synonyms
          if (desiredLower.includes(effect) || synonyms.some(s => desiredLower.includes(s))) {
            // Check if strain has this effect
            const hasEffect = strainEffects.some(strainEffect => 
              strainEffect.includes(effect) || synonyms.some(s => strainEffect.includes(s))
            );
            
            if (hasEffect) {
              matchScore += 20;
              matchedEffects.push(effect);
              return;
            }
          }
        }
        
        // Check for partial word matches
        const desiredWords = desiredLower.split(/\s+/).filter(w => w.length > 3);
        const hasPartialMatch = strainEffects.some(effect => 
          desiredWords.some(word => effect.includes(word))
        );
        
        if (hasPartialMatch) {
          matchScore += 10;
        }
      });
      
      // Boost score for context matches
      if (context === 'medical' && strain.uses && 
          (strain.uses.toLowerCase().includes('medical') || 
           (medicalNeeds && medicalNeeds.some(need => strain.uses.toLowerCase().includes(need.toLowerCase()))))) {
        matchScore += 15;
      } else if (context === 'recreational' && strainEffects.some(e => e.includes('euphoric'))) {
        matchScore += 15;
      }
      
      // Cap score at 100
      matchScore = Math.min(matchScore, 100);
      
      // Create reasoning factors
      const reasoningFactors = [];
      
      if (matchedEffects.length > 0) {
        reasoningFactors.push({
          factor: `Matches your desired effects: ${matchedEffects.join(', ')}`,
          weight: 0.5
        });
      }
      
      if (context === 'medical' && strain.uses) {
        reasoningFactors.push({
          factor: `Good for medical use: ${strain.uses}`,
          weight: 0.3
        });
      }
      
      reasoningFactors.push({
        factor: `${strain.genetic_type} with ${strain.thc_range} THC content`,
        weight: 0.2
      });
      
      return {
        strain,
        matchScore,
        reasoningFactors
      };
    });
    
    // Sort by match score (highest first) and filter out low scores
    return scoredStrains
      .filter(s => s.matchScore > 0)
      .sort((a, b) => b.matchScore - a.matchScore);
  }

  /**
   * Get strain recommendations based on user profile and preferences
   */
  public async getRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Getting strain recommendations');
      
      // Generate a unique response ID
      const responseId = `rec_${Date.now()}`;
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey(request);
      const cachedResponse = await this.cacheManager.get<RecommendationResponse>(cacheKey);
      
      if (cachedResponse) {
        Logger.info(MODULE_NAME, 'Returning cached recommendations');
        // Add the responseId to the cached response
        return { ...cachedResponse, responseId };
      }
      
      // If using mock responses, return a mock response
      if (this.useMockResponses) {
        const mockResponse = this.getMockRecommendations(request);
        
        // Cache the response
        await this.cacheManager.set(cacheKey, mockResponse);
        
        Logger.info(MODULE_NAME, 'Returning mock recommendations');
        return { ...mockResponse, responseId };
      }
      
      // Get real recommendations from the database
      const realRecommendations = await this.getRealStrainRecommendations(request);
      
      // Add the responseId
      const result: RecommendationResponse = {
        ...realRecommendations,
        responseId
      };
      
      // Cache the response
      await this.cacheManager.set(cacheKey, result);
      
      Logger.info(MODULE_NAME, 'Recommendations generated successfully');
      return result;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get recommendations');
      throw error;
    }
  }

  /**
   * Format a recommendation prompt for the AI
   */
  private formatRecommendationPrompt(request: RecommendationRequest): string {
    // Create a detailed prompt for the AI
    return `
      You are an AI assistant for a cannabis recommendation app called Canova.
      Please provide personalized cannabis strain recommendations based on the following user profile and preferences:
      
      User Profile:
      ${JSON.stringify(request.userProfile, null, 2)}
      
      Desired Effects:
      ${request.desiredEffects.join(', ')}
      
      ${request.medicalNeeds ? `Medical Needs: ${request.medicalNeeds.join(', ')}` : ''}
      ${request.context ? `Context: ${request.context}` : ''}
      ${request.locationCode ? `Location Code: ${request.locationCode}` : ''}
      
      ${request.journalEntries ? `Recent Journal Entries:
      ${JSON.stringify(request.journalEntries, null, 2)}` : ''}
      
      Please provide:
      1. A list of 3-5 strain recommendations with detailed information about each
      2. A brief explanation of why each strain was recommended
      3. Suggested dosage guidelines
      4. Any safety considerations or warnings
      
      Format your response as a JSON object with the following structure:
      {
        "recommendations": [
          {
            "name": "Strain Name",
            "type": "Indica/Sativa/Hybrid",
            "thcContent": "THC percentage range",
            "cbdContent": "CBD percentage range",
            "effects": ["effect1", "effect2", ...],
            "medicalBenefits": ["benefit1", "benefit2", ...],
            "flavors": ["flavor1", "flavor2", ...],
            "description": "Detailed description"
          }
        ],
        "reasoning": "Explanation of recommendations",
        "confidenceScore": 0-100,
        "disclaimers": ["disclaimer1", "disclaimer2", ...],
        "dosageSuggestion": {
          "beginner": "Beginner dosage",
          "intermediate": "Intermediate dosage",
          "experienced": "Experienced dosage",
          "notes": "Additional notes"
        },
        "safetyNotes": ["note1", "note2", ...]
      }
    `;
  }

  /**
   * Parse the AI response into a structured recommendation
   */
  private parseRecommendationResponse(response: string): RecommendationResponse {
    try {
      // Try to parse the response as JSON
      const parsedResponse = JSON.parse(response) as RecommendationResponse;
      
      // Validate the response structure
      if (!parsedResponse.recommendations || !Array.isArray(parsedResponse.recommendations)) {
        throw new Error('Invalid response structure: recommendations array missing');
      }
      
      return parsedResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to parse recommendation response');
      
      // If parsing fails, try to extract information from the text response
      // This is a fallback mechanism for when the AI doesn't return valid JSON
      
      // For now, return a simple error response
      return {
        recommendations: [],
        reasoning: 'Failed to parse AI response',
        confidenceScore: 0,
        disclaimers: ['The AI response could not be properly parsed'],
        error: {
          message: 'Failed to parse AI response',
          type: 'parsing_error',
          recoverable: false
        }
      };
    }
  }

  /**
   * Generate mock recommendations for testing
   */
  private getMockRecommendations(request: RecommendationRequest): RecommendationResponse {
    return {
      recommendations: [
        {
          strainId: 1,
          strainName: 'Blue Dream',
          matchScore: 95,
          reasoningFactors: [
            { factor: 'Matches desired effects', weight: 0.5 },
            { factor: 'Good for stress relief', weight: 0.3 },
            { factor: 'Balanced hybrid', weight: 0.2 }
          ],
          alternativeStrains: [
            { strainId: 4, strainName: 'Harlequin', reason: 'Higher CBD content' }
          ]
        },
        {
          strainId: 2,
          strainName: 'OG Kush',
          matchScore: 90,
          reasoningFactors: [
            { factor: 'Strong pain relief', weight: 0.6 },
            { factor: 'Matches user experience level', weight: 0.4 }
          ],
          alternativeStrains: [
            { strainId: 5, strainName: 'Bubba Kush', reason: 'Similar effects with more sedation' }
          ]
        },
        {
          strainId: 3,
          strainName: 'Granddaddy Purple',
          matchScore: 85,
          reasoningFactors: [
            { factor: 'Good for sleep', weight: 0.7 },
            { factor: 'Matches flavor preferences', weight: 0.3 }
          ],
          alternativeStrains: [
            { strainId: 6, strainName: 'Northern Lights', reason: 'Similar relaxation effects' }
          ]
        }
      ],
      reasoning: `Based on the user's profile and preferences, I've recommended strains that align with their desired effects and medical needs. Blue Dream offers a balanced experience, OG Kush provides potent relief, and Granddaddy Purple is excellent for relaxation and sleep.`,
      confidenceScore: 85,
      disclaimers: [
        'Individual experiences may vary',
        'Start with a low dose and gradually increase as needed',
        'Consult with a healthcare professional before use, especially if you have medical conditions or take medications'
      ],
      dosageSuggestion: {
        minDosage: 5,
        maxDosage: 10,
        unit: 'mg THC',
        gradualApproach: true,
        notes: 'Start low and go slow. Wait at least 2 hours before consuming more edibles.'
      },
      safetyNotes: [
        'Do not drive or operate heavy machinery after use',
        'Keep out of reach of children and pets',
        'Store in a cool, dry place away from direct sunlight'
      ]
    };
  }

  /**
   * Submit user feedback for a recommendation
   */
  public async submitRecommendationFeedback(
    userId: string,
    responseId: string,
    helpful: boolean,
    accurate: boolean,
    relevance: number,
    comments?: string
  ): Promise<string> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Submitting recommendation feedback for response: ${responseId}`);
      
      const feedback: UserFeedback = {
        userId,
        responseId,
        responseType: 'recommendation',
        helpful,
        accurate,
        relevance,
        comments,
        timestamp: Date.now()
      };
      
      // Submit the feedback using the feedback service
      const feedbackId = await this.feedbackService.submitFeedback(feedback);
      
      Logger.info(MODULE_NAME, `Recommendation feedback submitted: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit recommendation feedback for response: ${responseId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to submit recommendation feedback',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while submitting your feedback. Please try again later.'
      );
    }
  }

  /**
   * Get a response to a user's chat message
   */
  public async getChatResponse(request: ChatRequest): Promise<ChatResponse> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Getting chat response');
      
      // Generate a unique response ID
      const responseId = `chat_${Date.now()}`;
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey(request);
      const cachedResponse = await this.cacheManager.get<ChatResponse>(cacheKey);
      
      if (cachedResponse) {
        Logger.info(MODULE_NAME, 'Returning cached chat response');
        return cachedResponse;
      }
      
      // If using mock responses, return a mock response
      if (this.useMockResponses) {
        const mockResponse = this.getMockChatResponse(request);
        
        // Cache the response
        await this.cacheManager.set(cacheKey, mockResponse);
        
        Logger.info(MODULE_NAME, 'Returning mock chat response');
        return mockResponse;
      }
      
      // Format messages for the API
      const messages = this.formatChatMessages(request);
      
      // Call the API
      const response = await this.api.sendMessage(messages, 2000, 0.7);
      
      // Parse the response
      const chatResponse = this.parseChatResponse(response);
      
      // Cache the response
      await this.cacheManager.set(cacheKey, chatResponse);
      
      Logger.info(MODULE_NAME, 'Chat response generated successfully');
      return chatResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get chat response');
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to get chat response',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while generating a response. Please try again later.'
      );
    }
  }

  /**
   * Format chat messages for the API
   */
  private formatChatMessages(request: ChatRequest): Array<{ role: 'user' | 'assistant'; content: string }> {
    const messages: Array<{ role: 'user' | 'assistant'; content: string }> = [];
    
    // Add system message with context
    messages.push({
      role: 'user',
      content: `You are an AI assistant for a cannabis app called Canova. You provide helpful, accurate, and educational information about cannabis. 
      
      User Profile:
      ${JSON.stringify(request.userProfile, null, 2)}
      
      ${request.locationCode ? `Location Code: ${request.locationCode}` : ''}
      
      Please provide informative, educational responses. Include relevant scientific information when appropriate. Always prioritize safety and responsible use. If you don't know something, say so rather than providing incorrect information.`
    });
    
    // Add previous messages if available
    if (request.previousMessages && request.previousMessages.length > 0) {
      request.previousMessages.forEach(msg => {
        messages.push({
          role: msg.role as 'user' | 'assistant',
          content: msg.content
        });
      });
    }
    
    // Add the current message
    messages.push({
      role: 'user',
      content: request.message
    });
    
    return messages;
  }

  /**
   * Parse the AI response into a structured chat response
   */
  private parseChatResponse(response: string): ChatResponse {
    // For chat, we can use the response text directly
    const chatResponse: ChatResponse = {
      response: response,
      // Extract educational links if present
      educationalLinks: this.extractLinks(response),
      // Add disclaimers
      disclaimers: [
        'This information is for educational purposes only and not medical advice.',
        'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
      ]
    };
    
    return chatResponse;
  }

  /**
   * Extract links from a text response
   */
  private extractLinks(text: string): string[] {
    const links: string[] = [];
    const linkRegex = /https?:\/\/[^\s]+/g;
    const matches = text.match(linkRegex);
    
    if (matches) {
      matches.forEach(link => {
        links.push(link);
      });
    }
    
    return links;
  }

  /**
   * Generate a mock chat response for testing
   */
  private getMockChatResponse(request: ChatRequest): ChatResponse {
    // Simple mock response based on the request message
    const message = request.message.toLowerCase();
    
    if (message.includes('strain') || message.includes('recommend')) {
      return {
        response: `Based on your profile, I'd recommend considering strains like Blue Dream, OG Kush, or Granddaddy Purple. Blue Dream is a balanced hybrid that provides relaxation without sedation, OG Kush offers potent relief from stress and pain, and Granddaddy Purple is excellent for sleep and deep relaxation. Always start with a low dose, especially if you're new to cannabis.`,
        educationalLinks: ['https://www.leafly.com/strains/blue-dream', 'https://www.leafly.com/strains/og-kush'],
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    } else if (message.includes('cbd') || message.includes('thc')) {
      return {
        response: `THC (tetrahydrocannabinol) and CBD (cannabidiol) are the two most well-known cannabinoids in cannabis. THC is primarily responsible for the psychoactive effects or "high," while CBD is non-intoxicating and associated with various potential therapeutic benefits. The ratio of THC to CBD in a strain can significantly influence its effects. High-THC strains tend to be more intoxicating, while high-CBD strains are often used for their potential therapeutic properties without strong psychoactive effects.`,
        educationalLinks: ['https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5345356/'],
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    } else {
      return {
        response: `Thank you for your question about cannabis. I'm here to provide educational information and guidance based on scientific research. If you have specific questions about strains, effects, consumption methods, or safety considerations, feel free to ask. Remember that individual experiences with cannabis can vary significantly based on factors like body chemistry, tolerance, and the specific product used.`,
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    }
  }

  /**
   * Submit user feedback for a chat response
   */
  public async submitChatFeedback(
    userId: string,
    responseId: string,
    helpful: boolean,
    accurate: boolean,
    relevance: number,
    comments?: string
  ): Promise<string> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Submitting chat feedback for response: ${responseId}`);
      
      const feedback: UserFeedback = {
        userId,
        responseId,
        responseType: 'chat',
        helpful,
        accurate,
        relevance,
        comments,
        timestamp: Date.now()
      };
      
      // Submit the feedback using the feedback service
      const feedbackId = await this.feedbackService.submitFeedback(feedback);
      
      Logger.info(MODULE_NAME, `Chat feedback submitted: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit chat feedback for response: ${responseId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to submit chat feedback',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while submitting your feedback. Please try again later.'
      );
    }
  }

  /**
   * Analyze journal entries for patterns and insights
   */
  public async analyzeJournalEntries(
    userId: string,
    journalEntries: JournalEntry[]
  ): Promise<JournalAnalysisResult> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Analyzing journal entries for user: ${userId}`);
      
      // If no entries, return empty analysis
      if (!journalEntries || journalEntries.length === 0) {
        Logger.info(MODULE_NAME, 'No journal entries to analyze');
        return {
          patterns: [],
          insights: [],
          recommendations: []
        };
      }
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey({
        userId,
        journalEntries: journalEntries.map(entry => ({
          id: entry.id,
          created_at: entry.created_at
        }))
      });
      
      const cachedAnalysis = await this.cacheManager.get<JournalAnalysisResult>(cacheKey);
      
      if (cachedAnalysis) {
        Logger.info(MODULE_NAME, 'Returning cached journal analysis');
        return cachedAnalysis;
      }
      
      // If using mock responses, return a mock analysis
      if (this.useMockResponses) {
        const mockAnalysis = this.getMockJournalAnalysis(journalEntries);
        
        // Cache the analysis
        await this.cacheManager.set(cacheKey, mockAnalysis);
        
        Logger.info(MODULE_NAME, 'Returning mock journal analysis');
        return mockAnalysis;
      }
      
      // Format the prompt for the AI
      const prompt = this.formatJournalAnalysisPrompt(journalEntries);
      
      // Call the API
      const response = await this.api.sendMessage([
        { role: 'user', content: prompt }
      ], 2000, 0.7);
      
      // Parse the response
      const analysis = this.parseJournalAnalysisResponse(response);
      
      // Cache the analysis
      await this.cacheManager.set(cacheKey, analysis);
      
      Logger.info(MODULE_NAME, 'Journal analysis completed successfully');
      return analysis;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to analyze journal entries for user: ${userId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to analyze journal entries',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while analyzing your journal entries. Please try again later.'
      );
    }
  }

  /**
   * Format a journal analysis prompt for the AI
   */
  private formatJournalAnalysisPrompt(journalEntries: JournalEntry[]): string {
    return `
      You are an AI assistant for a cannabis app called Canova.
      Please analyze the following journal entries to identify patterns, insights, and potential recommendations:
      
      Journal Entries:
      ${JSON.stringify(journalEntries, null, 2)}
      
      For each entry, consider:
      - Strain used
      - Dosage
      - Consumption method
      - Effects experienced
      - Time of day
      - User's mood before and after
      - Any side effects
      
      Please provide:
      1. Patterns you've identified across entries
      2. Insights about what works well and what doesn't for this user
      3. Recommendations for strains, dosages, or consumption methods based on the data
      4. Any safety flags or concerns that should be addressed
      
      Format your response as a JSON object with the following structure:
      {
        "patterns": ["pattern1", "pattern2", ...],
        "insights": ["insight1", "insight2", ...],
        "recommendations": ["recommendation1", "recommendation2", ...],
        "safetyFlags": ["flag1", "flag2", ...] // Optional, include only if relevant
      }
    `;
  }

  /**
   * Parse the AI response into a structured journal analysis
   */
  private parseJournalAnalysisResponse(response: string): JournalAnalysisResult {
    try {
      // Try to parse the response as JSON
      const parsedResponse = JSON.parse(response) as JournalAnalysisResult;
      
      // Validate the response structure
      if (!parsedResponse.patterns || !parsedResponse.insights || !parsedResponse.recommendations) {
        throw new Error('Invalid response structure: required fields missing');
      }
      
      return parsedResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to parse journal analysis response');
      
      // Return a simple error response
      return {
        patterns: ['Could not identify patterns due to parsing error'],
        insights: ['Could not generate insights due to parsing error'],
        recommendations: ['Please try again later or contact support']
      };
    }
  }

  /**
   * Generate mock journal analysis for testing
   */
  private getMockJournalAnalysis(journalEntries: JournalEntry[]): JournalAnalysisResult {
    // Simple mock analysis based on the number of entries
    if (journalEntries.length >= 5) {
      return {
        patterns: [
          'Higher satisfaction with indica strains in the evening',
          'Edibles tend to cause more anxiety than vaping',
          'Morning use of low-THC strains improves focus without impairment'
        ],
        insights: [
          'You respond well to balanced THC:CBD ratios for pain management',
          'Strains high in limonene terpenes seem to elevate your mood consistently',
          'Consumption 2-3 hours before bedtime improves sleep quality'
        ],
        recommendations: [
          'Try Granddaddy Purple for evening relaxation',
          'Consider microdosing with a 1:1 THC:CBD tincture for daytime pain relief',
          'Experiment with lower temperatures when vaping to reduce throat irritation'
        ]
      };
    } else {
      return {
        patterns: [
          'Not enough entries to identify reliable patterns yet',
          'Initial preference for hybrid strains noted'
        ],
        insights: [
          'More journal entries needed for meaningful insights',
          'Consider recording more details about effects and context'
        ],
        recommendations: [
          'Continue journaling consistently to build more data',
          'Try varying your consumption methods to compare effects',
          'Record your experience with different terpene profiles'
        ]
      };
    }
  }

  /**
   * Validate the safety of a recommendation request
   */
  public async validateRecommendationSafety(
    request: RecommendationRequest
  ): Promise<SafetyValidationResult> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Validating recommendation request safety');
      
      // Check for basic safety issues
      const basicSafetyCheck = this.performBasicSafetyCheck(request);
      if (!basicSafetyCheck.valid) {
        Logger.info(MODULE_NAME, `Safety validation failed: ${basicSafetyCheck.reason}`);
        return basicSafetyCheck;
      }
      
      // Check for potential drug interactions
      const interactionResult = await this.checkDrugInteractions(request);
      if (interactionResult.hasInteractions && interactionResult.severity === 'severe') {
        Logger.info(MODULE_NAME, 'Safety validation failed: Severe drug interactions detected');
        return {
          valid: false,
          reason: 'Potential severe drug interactions detected',
          safetyFlags: interactionResult.details,
          warningLevel: 'critical'
        };
      }
      
      // Check for potential overuse
      const overuseResult = await this.detectOveruse(request.userProfile.id);
      if (overuseResult.detected && overuseResult.level === 'severe') {
        Logger.info(MODULE_NAME, 'Safety validation failed: Severe overuse pattern detected');
        return {
          valid: false,
          reason: 'Potential overuse pattern detected',
          safetyFlags: [overuseResult.details || 'Frequent high-dose usage pattern detected'],
          warningLevel: 'critical'
        };
      }
      
      // If there are moderate concerns, return valid but with warnings
      if (
        (interactionResult.hasInteractions && interactionResult.severity === 'moderate') ||
        (overuseResult.detected && overuseResult.level === 'moderate')
      ) {
        const safetyFlags = [
          ...(interactionResult.hasInteractions ? interactionResult.details || [] : []),
          ...(overuseResult.detected && overuseResult.details ? [overuseResult.details] : [])
        ];
        
        Logger.info(MODULE_NAME, 'Safety validation passed with warnings');
        return {
          valid: true,
          safetyFlags,
          warningLevel: 'warning'
        };
      }
      
      // If there are mild concerns, return valid but with info
      if (
        (interactionResult.hasInteractions && interactionResult.severity === 'mild') ||
        (overuseResult.detected && overuseResult.level === 'mild')
      ) {
        const safetyFlags = [
          ...(interactionResult.hasInteractions ? interactionResult.details || [] : []),
          ...(overuseResult.detected && overuseResult.details ? [overuseResult.details] : [])
        ];
        
        Logger.info(MODULE_NAME, 'Safety validation passed with information');
        return {
          valid: true,
          safetyFlags,
          warningLevel: 'info'
        };
      }
      
      // All checks passed
      Logger.info(MODULE_NAME, 'Safety validation passed');
      return {
        valid: true
      };
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to validate recommendation safety');
      
      // Return a conservative result in case of error
      return {
        valid: true,
        reason: 'Safety validation could not be completed',
        safetyFlags: ['Safety validation encountered an error, proceed with caution'],
        warningLevel: 'warning'
      };
    }
  }

  /**
   * Perform basic safety checks on a recommendation request
   */
  private performBasicSafetyCheck(request: RecommendationRequest): SafetyValidationResult {
    // Check for underage users based on experience level
    if (request.userProfile.experience_level === 'beginner') {
      // For beginners, we'll add extra caution
      return {
        valid: true,
        safetyFlags: ['User is a beginner, recommend starting with low doses'],
        warningLevel: 'info'
      };
    }
    
    // Check for pregnancy or other medical conditions
    if (request.userProfile.medical_needs && 
        request.userProfile.medical_needs.some((condition: string) => 
          condition.toLowerCase().includes('pregnant') || 
          condition.toLowerCase().includes('pregnancy')
        )) {
      return {
        valid: false,
        reason: 'Cannabis use is not recommended during pregnancy',
        warningLevel: 'critical'
      };
    }
    
    // Check for severe mental health conditions
    const severeConditions = ['schizophrenia', 'psychosis', 'severe depression', 'bipolar disorder'];
    if (request.userProfile.medical_needs && 
        request.userProfile.medical_needs.some((condition: string) => 
          severeConditions.some(severe => condition.toLowerCase().includes(severe))
        )) {
      return {
        valid: false,
        reason: 'Cannabis use may exacerbate certain mental health conditions',
        warningLevel: 'critical'
      };
    }
    
    // All basic checks passed
    return {
      valid: true
    };
  }

  /**
   * Check for potential drug interactions
   */
  private async checkDrugInteractions(request: RecommendationRequest): Promise<DrugInteractionResult> {
    // In a real implementation, this would check against a database of known drug interactions
    // For now, we'll just check for some common medications that have known interactions
    
    const highRiskMedications = [
      'warfarin', 'clopidogrel', 'amiodarone', 'tacrolimus', 'cyclosporine',
      'sedative', 'benzodiazepine', 'opioid', 'alcohol'
    ];
    
    const moderateRiskMedications = [
      'antidepressant', 'ssri', 'antipsychotic', 'stimulant', 'adhd medication',
      'blood pressure', 'hypertension', 'beta blocker'
    ];
    
    if (!request.userProfile.medications || request.userProfile.medications.length === 0) {
      return {
        hasInteractions: false
      };
    }
    
    const highRiskFound = request.userProfile.medications.some((med: string) => 
      highRiskMedications.some(risk => med.toLowerCase().includes(risk))
    );
    
    if (highRiskFound) {
      return {
        hasInteractions: true,
        severity: 'severe',
        details: [
          'Potential severe interaction with one or more medications',
          'Cannabis may increase or decrease the effects of certain medications',
          'Consult with a healthcare provider before using cannabis'
        ],
        recommendations: [
          'Consult with a healthcare provider before using cannabis',
          'Consider alternative treatments',
          'If approved by a healthcare provider, start with very low doses and monitor closely'
        ]
      };
    }
    
    const moderateRiskFound = request.userProfile.medications.some((med: string) => 
      moderateRiskMedications.some(risk => med.toLowerCase().includes(risk))
    );
    
    if (moderateRiskFound) {
      return {
        hasInteractions: true,
        severity: 'moderate',
        details: [
          'Potential moderate interaction with one or more medications',
          'Cannabis may affect how your medications work'
        ],
        recommendations: [
          'Consult with a healthcare provider before using cannabis',
          'Start with low doses and monitor for any adverse effects',
          'Keep a journal of effects to share with your healthcare provider'
        ]
      };
    }
    
    // No known interactions found
    return {
      hasInteractions: false
    };
  }

  /**
   * Detect potential overuse patterns
   */
  private async detectOveruse(userId: string): Promise<OveruseDetectionResult> {
    // In a real implementation, this would analyze usage patterns from the user's history
    // For now, we'll just return a mock result
    
    // Simulate a 10% chance of detecting mild overuse
    const randomValue = Math.random();
    
    if (randomValue < 0.01) {
      // 1% chance of severe overuse
      return {
        detected: true,
        level: 'severe',
        details: 'Frequent high-dose usage pattern detected',
        recommendedAction: 'Consider taking a tolerance break and consulting with a healthcare provider',
        coolingOffPeriod: 14 // 14 days
      };
    } else if (randomValue < 0.05) {
      // 4% chance of moderate overuse
      return {
        detected: true,
        level: 'moderate',
        details: 'Increasing frequency of use detected',
        recommendedAction: 'Consider moderating use and monitoring effects more closely',
        coolingOffPeriod: 7 // 7 days
      };
    } else if (randomValue < 0.10) {
      // 5% chance of mild overuse
      return {
        detected: true,
        level: 'mild',
        details: 'Slight increase in usage frequency noted',
        recommendedAction: 'Be mindful of consumption patterns and consider occasional breaks',
        coolingOffPeriod: 2 // 2 days
      };
    }
    
    // No overuse detected
    return {
      detected: false
    };
  }
} 

================================================================================
File: src/services/ai/api/AnthropicAPI.ts
================================================================================

import * as Logger from '../utils/logging';
import { AIServiceError, AIServiceErrorType } from '../types/errors';
import { ANTHROPIC_API_URL, ANTHROPIC_API_VERSION, ANTHROPIC_API_KEY } from '../types/common';

const MODULE_NAME = 'AnthropicAPI';

/**
 * Anthropic API client
 * Handles communication with the Claude API
 */
export class AnthropicAPI {
  private apiKey: string;
  private apiUrl: string;
  private apiVersion: string;

  constructor(
    apiKey: string = "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",
    apiUrl: string = "https://api.anthropic.com/v1",
    apiVersion: string = "2023-06-01",
  ) {
    this.apiKey = apiKey;
    this.apiUrl = apiUrl;
    this.apiVersion = apiVersion;
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Send a message to the Claude API
   */
  public async sendMessage(
    messages: Array<{ role: 'user' | 'assistant'; content: string }>,
    maxTokens: number = 1000,
    temperature: number = 0.7,
    model: string = 'claude-3-sonnet-20240229'
  ): Promise<string> {
    try {
      Logger.debug(MODULE_NAME, `Sending message to Claude API, model: ${model}`);

      const response = await fetch(`${this.apiUrl}/messages`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': this.apiVersion,
        },
        body: JSON.stringify({
          model,
          messages,
          max_tokens: maxTokens,
          temperature,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        Logger.error(
          MODULE_NAME,
          `API error: ${response.status} ${response.statusText}`,
          errorData
        );

        let errorType = AIServiceErrorType.UNKNOWN;
        let retryable = false;
        let userMessage = 'An error occurred while processing your request.';

        // Determine error type based on status code
        if (response.status === 401 || response.status === 403) {
          errorType = AIServiceErrorType.AUTHENTICATION;
          userMessage = 'Authentication error. Please check your API key.';
        } else if (response.status === 429) {
          errorType = AIServiceErrorType.RATE_LIMIT;
          retryable = true;
          userMessage = 'Rate limit exceeded. Please try again later.';
        } else if (response.status >= 500) {
          errorType = AIServiceErrorType.SERVER;
          retryable = true;
          userMessage = 'Server error. Please try again later.';
        }

        throw new AIServiceError(
          `API error: ${response.status} ${response.statusText}`,
          errorType,
          response.status,
          retryable,
          userMessage
        );
      }

      const data = await response.json();
      Logger.debug(MODULE_NAME, 'Received response from Claude API');

      return data.content[0].text;
    } catch (error) {
      if (error instanceof AIServiceError) {
        throw error;
      }

      Logger.logError(MODULE_NAME, error as Error, 'Failed to send message to Claude API');
      throw new AIServiceError(
        'Failed to send message to Claude API',
        AIServiceErrorType.NETWORK,
        undefined,
        true,
        'Network error. Please check your internet connection and try again.'
      );
    }
  }

  /**
   * Send a completion request to the Claude API
   * @deprecated Use sendMessage instead
   */
  public async sendCompletion(
    prompt: string,
    maxTokens: number = 1000,
    temperature: number = 0.7,
    model: string = 'claude-3-sonnet-20240229'
  ): Promise<string> {
    try {
      Logger.debug(MODULE_NAME, `Sending completion to Claude API, model: ${model}`);

      const response = await fetch(`${this.apiUrl}/complete`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': this.apiVersion,
        },
        body: JSON.stringify({
          model,
          prompt,
          max_tokens_to_sample: maxTokens,
          temperature,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        Logger.error(
          MODULE_NAME,
          `API error: ${response.status} ${response.statusText}`,
          errorData
        );

        let errorType = AIServiceErrorType.UNKNOWN;
        let retryable = false;
        let userMessage = 'An error occurred while processing your request.';

        // Determine error type based on status code
        if (response.status === 401 || response.status === 403) {
          errorType = AIServiceErrorType.AUTHENTICATION;
          userMessage = 'Authentication error. Please check your API key.';
        } else if (response.status === 429) {
          errorType = AIServiceErrorType.RATE_LIMIT;
          retryable = true;
          userMessage = 'Rate limit exceeded. Please try again later.';
        } else if (response.status >= 500) {
          errorType = AIServiceErrorType.SERVER;
          retryable = true;
          userMessage = 'Server error. Please try again later.';
        }

        throw new AIServiceError(
          `API error: ${response.status} ${response.statusText}`,
          errorType,
          response.status,
          retryable,
          userMessage
        );
      }

      const data = await response.json();
      Logger.debug(MODULE_NAME, 'Received response from Claude API');

      return data.completion;
    } catch (error) {
      if (error instanceof AIServiceError) {
        throw error;
      }

      Logger.logError(MODULE_NAME, error as Error, 'Failed to send completion to Claude API');
      throw new AIServiceError(
        'Failed to send completion to Claude API',
        AIServiceErrorType.NETWORK,
        undefined,
        true,
        'Network error. Please check your internet connection and try again.'
      );
    }
  }
} 

================================================================================
File: src/services/ai/api/index.ts
================================================================================

export { AnthropicAPI } from './AnthropicAPI'; 

================================================================================
File: src/services/ai/cache/CacheManager.ts
================================================================================

import * as Logger from '../utils/logging';
import { MemoryCache } from './MemoryCache';
import { PersistentCache } from './PersistentCache';
import { SHA256 } from '../utils/hash';
import { DEFAULT_CACHE_TTL, MAX_CACHE_SIZE, CacheDbEntry } from '../types/common';

const MODULE_NAME = 'CacheManager';

/**
 * Cache Manager
 * Orchestrates both memory and persistent caches
 */
export class CacheManager {
  private static instance: CacheManager;
  private memoryCache: MemoryCache;
  private persistentCache: PersistentCache;
  private enabled: boolean = true;
  private defaultTtl: number = DEFAULT_CACHE_TTL;
  private initialized: boolean = false;

  private constructor() {
    this.memoryCache = new MemoryCache(MAX_CACHE_SIZE);
    this.persistentCache = new PersistentCache();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of CacheManager
   */
  public static getInstance(): CacheManager {
    if (!CacheManager.instance) {
      CacheManager.instance = new CacheManager();
    }
    return CacheManager.instance;
  }

  /**
   * Initialize the cache manager
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing cache manager');
      
      // Load frequently accessed entries into memory cache
      await this.loadFrequentEntries();
      
      // Delete expired entries
      await this.pruneCache();
      
      this.initialized = true;
      Logger.info(MODULE_NAME, 'Cache manager initialized successfully');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize cache manager');
      throw error;
    }
  }

  /**
   * Configure the cache
   */
  public configure(enabled: boolean, ttlMs: number = DEFAULT_CACHE_TTL, maxSize: number = MAX_CACHE_SIZE): void {
    this.enabled = enabled;
    this.defaultTtl = ttlMs;
    this.memoryCache.setMaxSize(maxSize);
    
    Logger.info(MODULE_NAME, `Cache configured: enabled=${enabled}, ttl=${ttlMs}ms, maxSize=${maxSize}`);
  }

  /**
   * Generate a cache key from request data
   */
  public generateKey(requestData: any): string {
    try {
      // Create a stable representation of the request data
      const stableRepresentation = this.createStableRepresentation(requestData);
      
      // Generate a hash of the stable representation
      const hash = SHA256(stableRepresentation);
      
      // Extract user ID if available for easier cache invalidation
      let userId = '';
      if (requestData.userProfile && requestData.userProfile.id) {
        userId = requestData.userProfile.id;
      } else if (requestData.userId) {
        userId = requestData.userId;
      }
      
      // Create a key with user ID prefix for easier user-specific cache invalidation
      const key = userId ? `user:${userId}:${hash}` : hash;
      
      Logger.debug(MODULE_NAME, `Generated cache key: ${key}`);
      return key;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to generate cache key');
      // Return a timestamp-based key as fallback
      return `fallback:${Date.now()}`;
    }
  }

  /**
   * Create a stable representation of an object
   * Ensures that the same object always produces the same string
   * regardless of property order
   */
  private createStableRepresentation(obj: any): string {
    if (obj === null || obj === undefined) {
      return '';
    }
    
    if (typeof obj !== 'object') {
      return String(obj);
    }
    
    if (Array.isArray(obj)) {
      return '[' + obj.map(item => this.createStableRepresentation(item)).join(',') + ']';
    }
    
    // Sort keys to ensure stable order
    const sortedKeys = Object.keys(obj).sort();
    
    return '{' + sortedKeys.map(key => {
      // Skip functions and undefined values
      if (typeof obj[key] === 'function' || obj[key] === undefined) {
        return '';
      }
      return `"${key}":${this.createStableRepresentation(obj[key])}`;
    }).filter(Boolean).join(',') + '}';
  }

  /**
   * Get a value from the cache
   */
  public async get<T>(key: string): Promise<T | null> {
    if (!this.enabled) {
      Logger.debug(MODULE_NAME, 'Cache is disabled, skipping get');
      return null;
    }
    
    try {
      // Check if initialized
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Cache not initialized, initializing now...');
        await this.initialize();
      }
      
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      // Try memory cache first
      const memoryEntry = this.memoryCache.get<T>(key);
      if (memoryEntry) {
        // Check if the entry is expired
        if (memoryEntry.expiresAt < Date.now()) {
          Logger.debug(MODULE_NAME, `Memory cache entry expired for key: ${key}`);
          this.memoryCache.delete(key);
          return null;
        }
        
        Logger.debug(MODULE_NAME, `Memory cache hit for key: ${key}`);
        return memoryEntry.data;
      }
      
      // Try persistent cache
      const persistentData = await this.persistentCache.get<T>(key);
      if (persistentData) {
        // Store in memory cache for faster access next time
        this.memoryCache.set(key, persistentData, this.defaultTtl);
        
        Logger.debug(MODULE_NAME, `Persistent cache hit for key: ${key}`);
        return persistentData;
      }
      
      Logger.debug(MODULE_NAME, `Cache miss for key: ${key}`);
      return null;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      return null;
    }
  }

  /**
   * Set a value in the cache
   */
  public async set<T>(key: string, data: T, ttl: number = this.defaultTtl): Promise<void> {
    if (!this.enabled) {
      Logger.debug(MODULE_NAME, 'Cache is disabled, skipping set');
      return;
    }
    
    if (data === null || data === undefined) {
      Logger.error(MODULE_NAME, `Cannot cache null or undefined data for key: ${key}`);
      return;
    }
    
    try {
      // Check if initialized
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Cache not initialized, initializing now...');
        await this.initialize();
      }
      
      Logger.debug(MODULE_NAME, `Setting cache entry with key: ${key}`);
      
      // Store in memory cache
      this.memoryCache.set(key, data, ttl);
      
      // Store in persistent cache
      await this.persistentCache.set(key, data, ttl);
      
      Logger.debug(MODULE_NAME, `Cache entry set for key: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to set cache entry: ${key}`);
      // If persistent cache fails, delete from memory cache to maintain consistency
      this.memoryCache.delete(key);
    }
  }

  /**
   * Delete a value from the cache
   */
  public async delete(key: string): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      
      // Delete from memory cache
      this.memoryCache.delete(key);
      
      // Delete from persistent cache
      await this.persistentCache.delete(key);
      
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
    }
  }

  /**
   * Delete all cache entries that match a pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      
      // Delete from memory cache
      const memoryCount = this.memoryCache.deleteByPattern(pattern);
      
      // Delete from persistent cache
      const persistentCount = await this.persistentCache.deleteByPattern(pattern);
      
      Logger.debug(MODULE_NAME, `Deleted ${memoryCount} memory cache entries and ${persistentCount} persistent cache entries matching pattern: ${pattern}`);
      return Math.max(memoryCount, persistentCount);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      return 0;
    }
  }

  /**
   * Clear all cache entries
   */
  public async clear(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      
      // Clear memory cache
      this.memoryCache.clear();
      
      // Clear persistent cache
      await this.persistentCache.clear();
      
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
    }
  }

  /**
   * Delete all cache entries for a specific user
   */
  public async deleteForUser(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entries for user: ${userId}`);
      
      // Delete from memory cache
      const memoryCount = this.memoryCache.deleteByPattern(`user:${userId}`);
      
      // Get all keys for the user from persistent cache
      const keys = await this.persistentCache.getKeysForUser(userId);
      
      // Delete each key from persistent cache
      for (const key of keys) {
        await this.persistentCache.delete(key);
      }
      
      Logger.debug(MODULE_NAME, `Deleted ${memoryCount} memory cache entries and ${keys.length} persistent cache entries for user: ${userId}`);
      return keys.length;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries for user: ${userId}`);
      return 0;
    }
  }

  /**
   * Prune the cache by removing expired entries
   */
  public async pruneCache(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Pruning cache');
      
      // Delete expired entries from memory cache
      const memoryCount = this.memoryCache.deleteExpired();
      
      // Delete expired entries from persistent cache
      const persistentCount = await this.persistentCache.deleteExpired();
      
      Logger.debug(MODULE_NAME, `Pruned ${memoryCount} memory cache entries and ${persistentCount} persistent cache entries`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to prune cache');
    }
  }

  /**
   * Load frequently accessed entries into memory cache
   */
  private async loadFrequentEntries(limit: number = 20): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Loading ${limit} most frequently accessed cache entries into memory`);
      
      // Get most frequently used entries from persistent cache
      const entries = await this.persistentCache.getMostFrequentlyUsed(limit);
      
      // Load each entry into memory cache
      for (const entry of entries) {
        try {
          const data = JSON.parse(entry.data);
          const ttl = entry.expires_at - Date.now();
          
          // Only load if not expired
          if (ttl > 0) {
            this.memoryCache.set(entry.key, data, ttl);
          }
        } catch (error) {
          Logger.logError(MODULE_NAME, error as Error, `Failed to parse data for key: ${entry.key}`);
        }
      }
      
      Logger.debug(MODULE_NAME, `Loaded ${entries.length} cache entries into memory`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to load frequent cache entries');
    }
  }
} 

================================================================================
File: src/services/ai/cache/index.ts
================================================================================

export { CacheManager } from './CacheManager';
export { MemoryCache } from './MemoryCache';
export { PersistentCache } from './PersistentCache'; 

================================================================================
File: src/services/ai/cache/MemoryCache.ts
================================================================================

import * as Logger from '../utils/logging';
import { CacheEntry, MAX_CACHE_SIZE } from '../types/common';

const MODULE_NAME = 'MemoryCache';

/**
 * In-memory cache implementation
 * Provides fast access to frequently used cache entries
 */
export class MemoryCache {
  private cache: Map<string, CacheEntry<any>> = new Map();
  private maxSize: number;

  constructor(maxSize: number = MAX_CACHE_SIZE) {
    this.maxSize = maxSize;
    Logger.debug(MODULE_NAME, `Initialized with max size: ${maxSize}`);
  }

  /**
   * Set the maximum size of the cache
   */
  public setMaxSize(size: number): void {
    this.maxSize = size;
    Logger.debug(MODULE_NAME, `Max size updated to: ${size}`);
    
    // If the current size exceeds the new max size, prune the cache
    if (this.cache.size > this.maxSize) {
      this.prune();
    }
  }

  /**
   * Get the current size of the cache
   */
  public size(): number {
    return this.cache.size;
  }

  /**
   * Check if the cache contains an entry with the given key
   */
  public has(key: string): boolean {
    return this.cache.has(key);
  }

  /**
   * Get an entry from the cache
   */
  public get<T>(key: string): CacheEntry<T> | undefined {
    const entry = this.cache.get(key) as CacheEntry<T> | undefined;
    
    if (entry) {
      // Update hit count and last accessed time
      entry.hitCount += 1;
      entry.lastAccessed = Date.now();
      Logger.debug(MODULE_NAME, `Cache hit for key: ${key}, hit count: ${entry.hitCount}`);
    } else {
      Logger.debug(MODULE_NAME, `Cache miss for key: ${key}`);
    }
    
    return entry;
  }

  /**
   * Set an entry in the cache
   */
  public set<T>(key: string, data: T, ttl: number): void {
    const now = Date.now();
    const expiresAt = now + ttl;
    
    // Check if we need to make room in the cache
    if (!this.cache.has(key) && this.cache.size >= this.maxSize) {
      this.evictOne();
    }
    
    // Create or update the cache entry
    this.cache.set(key, {
      key,
      data,
      timestamp: now,
      expiresAt,
      ttl,
      hitCount: 0,
      lastAccessed: now
    });
    
    Logger.debug(MODULE_NAME, `Set cache entry for key: ${key}, expires at: ${new Date(expiresAt).toISOString()}`);
  }

  /**
   * Delete an entry from the cache
   */
  public delete(key: string): boolean {
    const result = this.cache.delete(key);
    Logger.debug(MODULE_NAME, `Deleted cache entry for key: ${key}, success: ${result}`);
    return result;
  }

  /**
   * Clear all entries from the cache
   */
  public clear(): void {
    this.cache.clear();
    Logger.debug(MODULE_NAME, 'Cleared all cache entries');
  }

  /**
   * Get all keys in the cache
   */
  public keys(): string[] {
    return Array.from(this.cache.keys());
  }

  /**
   * Get all entries in the cache
   */
  public entries<T>(): Array<[string, CacheEntry<T>]> {
    return Array.from(this.cache.entries()) as Array<[string, CacheEntry<T>]>;
  }

  /**
   * Delete all entries that match a pattern
   */
  public deleteByPattern(pattern: string): number {
    let count = 0;
    const regex = new RegExp(pattern);
    
    // Convert keys iterator to array before iterating
    const keys = Array.from(this.cache.keys());
    for (const key of keys) {
      if (regex.test(key)) {
        this.cache.delete(key);
        count++;
      }
    }
    
    Logger.debug(MODULE_NAME, `Deleted ${count} entries matching pattern: ${pattern}`);
    return count;
  }

  /**
   * Delete all expired entries
   */
  public deleteExpired(): number {
    let count = 0;
    const now = Date.now();
    
    // Convert entries iterator to array before iterating
    const entries = Array.from(this.cache.entries());
    for (const [key, entry] of entries) {
      if (entry.expiresAt <= now) {
        this.cache.delete(key);
        count++;
      }
    }
    
    Logger.debug(MODULE_NAME, `Deleted ${count} expired entries`);
    return count;
  }

  /**
   * Prune the cache to the maximum size
   */
  private prune(): void {
    if (this.cache.size <= this.maxSize) {
      return;
    }
    
    const entriesToRemove = this.cache.size - this.maxSize;
    Logger.debug(MODULE_NAME, `Pruning cache, removing ${entriesToRemove} entries`);
    
    // Sort entries by last accessed time (oldest first)
    const sortedEntries = Array.from(this.cache.entries())
      .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);
    
    // Remove the oldest entries
    for (let i = 0; i < entriesToRemove; i++) {
      this.cache.delete(sortedEntries[i][0]);
    }
  }

  /**
   * Evict one entry from the cache
   * Uses a combination of last accessed time and hit count to determine which entry to evict
   */
  private evictOne(): void {
    if (this.cache.size === 0) {
      return;
    }
    
    Logger.debug(MODULE_NAME, 'Evicting one entry from cache');
    
    // Sort entries by a score that combines last accessed time and hit count
    // Lower score = better candidate for eviction
    const now = Date.now();
    const sortedEntries = Array.from(this.cache.entries())
      .map(([key, entry]) => {
        // Calculate a score based on recency and popularity
        // More recent access and higher hit count = higher score = less likely to be evicted
        const recency = (now - entry.lastAccessed) / 1000; // seconds since last access
        const popularity = Math.log1p(entry.hitCount); // logarithmic scaling of hit count
        const score = popularity / recency; // higher hit count and more recent = higher score
        return { key, score };
      })
      .sort((a, b) => a.score - b.score); // sort by score (ascending)
    
    // Evict the entry with the lowest score
    const keyToEvict = sortedEntries[0].key;
    this.cache.delete(keyToEvict);
    Logger.debug(MODULE_NAME, `Evicted cache entry for key: ${keyToEvict}`);
  }
} 

================================================================================
File: src/services/ai/cache/PersistentCache.ts
================================================================================

import * as Logger from '../utils/logging';
import { CacheRepository } from '../database/repositories/CacheRepository';
import { CacheDbEntry } from '../types/common';
import { DatabaseManager } from '../database/DatabaseManager';

const MODULE_NAME = 'PersistentCache';

/**
 * Persistent cache implementation using SQLite
 * Provides durable storage for cache entries
 */
export class PersistentCache {
  private repository: CacheRepository;
  private initialized: boolean = false;

  constructor() {
    this.repository = new CacheRepository();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Initialize the persistent cache
   */
  private async ensureInitialized(): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      // Make sure the database is initialized
      await DatabaseManager.getInstance().initialize();
      this.initialized = true;
      Logger.debug(MODULE_NAME, 'Database initialized');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database');
      throw new Error('Cache database not initialized');
    }
  }

  /**
   * Store an entry in the persistent cache
   */
  public async set(key: string, data: any, ttl: number): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Storing cache entry with key: ${key}`);
      
      // Validate data before storing
      if (data === null || data === undefined) {
        Logger.error(MODULE_NAME, `Cannot store null or undefined data for key: ${key}`);
        throw new Error('Cannot store null or undefined data in cache');
      }
      
      const now = Date.now();
      const expiresAt = now + ttl;
      
      // Serialize data to JSON string
      let serializedData: string;
      try {
        serializedData = JSON.stringify(data);
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, `Failed to serialize data for key: ${key}`);
        throw new Error(`Failed to serialize data for cache key: ${key}`);
      }
      
      // Store in persistent cache
      await this.repository.storeResponse(key, serializedData, now, expiresAt, ttl);
      
      Logger.debug(MODULE_NAME, `Cache entry stored successfully: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Get an entry from the persistent cache
   */
  public async get<T>(key: string): Promise<T | null> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      const entry = await this.repository.getResponse(key);
      
      if (!entry) {
        Logger.debug(MODULE_NAME, `No cache entry found for key: ${key}`);
        return null;
      }
      
      // Check if the entry is expired
      if (entry.expires_at < Date.now()) {
        Logger.debug(MODULE_NAME, `Cache entry expired for key: ${key}`);
        await this.delete(key);
        return null;
      }
      
      // Update hit count and last accessed time
      await this.repository.updateStats(key, entry.hit_count + 1, Date.now());
      
      // Parse the serialized data
      try {
        const data = JSON.parse(entry.data) as T;
        Logger.debug(MODULE_NAME, `Cache hit for key: ${key}`);
        return data;
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, `Failed to parse data for key: ${key}`);
        await this.delete(key);
        return null;
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      return null;
    }
  }

  /**
   * Delete an entry from the persistent cache
   */
  public async delete(key: string): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      await this.repository.deleteEntry(key);
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Delete entries by pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      const count = await this.repository.deleteByPattern(pattern);
      Logger.debug(MODULE_NAME, `Deleted ${count} cache entries matching pattern: ${pattern}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      throw error;
    }
  }

  /**
   * Clear all entries from the persistent cache
   */
  public async clear(): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      await this.repository.clearAll();
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
      throw error;
    }
  }

  /**
   * Delete expired entries
   */
  public async deleteExpired(): Promise<number> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, 'Deleting expired cache entries');
      const count = await this.repository.deleteExpired();
      Logger.debug(MODULE_NAME, `Deleted ${count} expired cache entries`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to delete expired cache entries');
      throw error;
    }
  }

  /**
   * Get the most frequently used cache entries
   */
  public async getMostFrequentlyUsed(limit: number): Promise<CacheDbEntry[]> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting ${limit} most frequently used cache entries`);
      const entries = await this.repository.getMostFrequentlyUsed(limit);
      Logger.debug(MODULE_NAME, `Found ${entries.length} most frequently used cache entries`);
      return entries;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get most frequently used cache entries');
      throw error;
    }
  }

  /**
   * Get all keys for a specific user
   */
  public async getKeysForUser(userId: string): Promise<string[]> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting cache keys for user: ${userId}`);
      const keyEntries = await this.repository.getKeysForUser(userId);
      const keys = keyEntries.map(entry => entry.key);
      Logger.debug(MODULE_NAME, `Found ${keys.length} cache keys for user: ${userId}`);
      return keys;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache keys for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/database/DatabaseManager.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import * as FileSystem from 'expo-file-system';
import * as Logger from '../utils/logging';

// Import constants
import { 
  AI_USAGE_DB_NAME, 
  RECOMMENDATION_FEEDBACK_DB_NAME, 
  CACHE_DB_NAME 
} from '../types/common';

const MODULE_NAME = 'DatabaseManager';

/**
 * Database Manager class
 * Handles database connections and initialization
 */
export class DatabaseManager {
  private static instance: DatabaseManager;
  private usageDb: SQLiteDatabase | null = null;
  private feedbackDb: SQLiteDatabase | null = null;
  private cacheDb: SQLiteDatabase | null = null;
  private initialized: boolean = false;

  private constructor() {
    // Private constructor to enforce singleton pattern
  }

  /**
   * Get the singleton instance of DatabaseManager
   */
  public static getInstance(): DatabaseManager {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new DatabaseManager();
    }
    return DatabaseManager.instance;
  }

  /**
   * Initialize all databases
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Databases already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing databases...');
      
      // Initialize usage database
      try {
        this.usageDb = await this.openDatabase(AI_USAGE_DB_NAME);
        await this.initializeUsageDb();
        Logger.info(MODULE_NAME, 'Usage database initialized successfully');
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize usage database');
      }
      
      // Initialize feedback database
      try {
        this.feedbackDb = await this.openDatabase(RECOMMENDATION_FEEDBACK_DB_NAME);
        await this.initializeFeedbackDb();
        Logger.info(MODULE_NAME, 'Feedback database initialized successfully');
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback database');
      }
      
      // Initialize cache database
      try {
        this.cacheDb = await this.openDatabase(CACHE_DB_NAME);
        await this.initializeCacheDb();
        Logger.info(MODULE_NAME, 'Cache database initialized successfully');
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize cache database');
      }
      
      // Mark as initialized if at least one database was successfully initialized
      if (this.usageDb || this.feedbackDb || this.cacheDb) {
        this.initialized = true;
        Logger.info(MODULE_NAME, 'Database initialization completed with some databases available');
      } else {
        Logger.error(MODULE_NAME, 'Failed to initialize any databases');
        throw new Error('Failed to initialize any databases');
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize databases');
      throw error;
    }
  }

  /**
   * Get the usage database instance
   */
  public getUsageDb(): SQLiteDatabase {
    if (!this.usageDb) {
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Database not initialized, attempting to initialize now');
        this.initialize().catch(error => {
          Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database on demand');
        });
      }
      throw new Error('Usage database not initialized');
    }
    return this.usageDb;
  }

  /**
   * Get the feedback database instance
   */
  public getFeedbackDb(): SQLiteDatabase {
    if (!this.feedbackDb) {
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Database not initialized, attempting to initialize now');
        this.initialize().catch(error => {
          Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database on demand');
        });
      }
      throw new Error('Feedback database not initialized');
    }
    return this.feedbackDb;
  }

  /**
   * Get the cache database instance
   */
  public getCacheDb(): SQLiteDatabase {
    if (!this.cacheDb) {
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Database not initialized, attempting to initialize now');
        this.initialize().catch(error => {
          Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database on demand');
        });
      }
      throw new Error('Cache database not initialized');
    }
    return this.cacheDb;
  }

  /**
   * Open a database with the given name
   */
  private async openDatabase(dbName: string): Promise<SQLiteDatabase> {
    try {
      Logger.debug(MODULE_NAME, `Opening database: ${dbName}`);
      return await openDatabaseAsync(dbName);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to open database: ${dbName}`);
      throw error;
    }
  }

  /**
   * Initialize the usage database schema
   */
  private async initializeUsageDb(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Initializing usage database schema');
      await this.usageDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS ai_usage (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id TEXT NOT NULL,
          request_type TEXT NOT NULL,
          tokens_used INTEGER NOT NULL,
          timestamp INTEGER NOT NULL
        );
      `);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize usage database schema');
      throw error;
    }
  }

  /**
   * Initialize the feedback database schema
   */
  private async initializeFeedbackDb(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Initializing feedback database schema');
      
      // Create user feedback table
      await this.feedbackDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS user_feedback (
          id TEXT PRIMARY KEY,
          user_id TEXT NOT NULL,
          response_id TEXT NOT NULL,
          response_type TEXT NOT NULL,
          helpful INTEGER NOT NULL,
          accurate INTEGER NOT NULL,
          relevance INTEGER NOT NULL,
          comments TEXT,
          timestamp INTEGER NOT NULL
        );
      `);
      
      // Create response quality scores table
      await this.feedbackDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS response_quality_scores (
          id TEXT PRIMARY KEY,
          response_id TEXT NOT NULL,
          overall_score REAL NOT NULL,
          relevance_score REAL NOT NULL,
          accuracy_score REAL NOT NULL,
          comprehensiveness_score REAL NOT NULL,
          safety_score REAL NOT NULL,
          strengths TEXT NOT NULL,
          weaknesses TEXT NOT NULL,
          improvement_suggestions TEXT NOT NULL,
          timestamp INTEGER NOT NULL
        );
      `);
      
      // Create feedback patterns table
      await this.feedbackDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS feedback_patterns (
          pattern_id TEXT PRIMARY KEY,
          response_type TEXT NOT NULL,
          user_profile_factors TEXT NOT NULL,
          request_factors TEXT NOT NULL,
          positive_outcome_rate REAL NOT NULL,
          sample_size INTEGER NOT NULL,
          last_updated INTEGER NOT NULL
        );
      `);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback database schema');
      throw error;
    }
  }

  /**
   * Initialize the cache database schema
   */
  private async initializeCacheDb(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Initializing cache database schema');
      await this.cacheDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS ai_response_cache (
          key TEXT PRIMARY KEY,
          data TEXT NOT NULL,
          timestamp INTEGER NOT NULL,
          expires_at INTEGER NOT NULL,
          ttl INTEGER NOT NULL,
          hit_count INTEGER NOT NULL DEFAULT 0,
          last_accessed INTEGER NOT NULL
        );
      `);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize cache database schema');
      throw error;
    }
  }

  /**
   * Close all database connections
   */
  public async closeAll(): Promise<void> {
    try {
      Logger.info(MODULE_NAME, 'Closing all database connections');
      
      if (this.usageDb) {
        await this.usageDb.closeAsync();
        this.usageDb = null;
      }
      
      if (this.feedbackDb) {
        await this.feedbackDb.closeAsync();
        this.feedbackDb = null;
      }
      
      if (this.cacheDb) {
        await this.cacheDb.closeAsync();
        this.cacheDb = null;
      }
      
      this.initialized = false;
      Logger.info(MODULE_NAME, 'All database connections closed');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to close database connections');
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/database/repositories/CacheRepository.ts
================================================================================

import { SQLiteDatabase } from "expo-sqlite";
import { DatabaseManager } from "../DatabaseManager";
import * as Logger from '../../utils/logging';
import { CacheDbEntry, KeyEntry, CountResult } from '../../types/common';

const MODULE_NAME = 'CacheRepository';

/**
 * Repository for cache database operations
 */
export class CacheRepository {
  private db: SQLiteDatabase | null = null;

  constructor() {
    try {
      this.db = DatabaseManager.getInstance().getCacheDb();
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get cache database');
    }
  }

  /**
   * Ensure database is available
   */
  private ensureDatabase(): SQLiteDatabase {
    if (!this.db) {
      try {
        this.db = DatabaseManager.getInstance().getCacheDb();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to get cache database');
        throw new Error('Cache database not initialized');
      }
    }
    return this.db;
  }

  /**
   * Store a response in the cache
   */
  public async storeResponse(
    key: string, 
    data: string, 
    timestamp: number, 
    expiresAt: number, 
    ttl: number
  ): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Storing cache entry with key: ${key}`);
      
      // Validate data before storing
      if (!data) {
        Logger.error(MODULE_NAME, `Cannot store null or empty data for key: ${key}`);
        throw new Error('Cannot store null or empty data in cache');
      }
      
      const now = Date.now();
      
      await db.getAllAsync(`
        INSERT OR REPLACE INTO ai_response_cache (
          key, 
          data, 
          timestamp, 
          expires_at, 
          ttl, 
          hit_count, 
          last_accessed
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `, [key, data, timestamp, expiresAt, ttl, 0, now]);
      
      Logger.debug(MODULE_NAME, `Cache entry stored successfully: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Get a response from the cache by key
   */
  public async getResponse(key: string): Promise<CacheDbEntry | null> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      const results = await db.getAllAsync<CacheDbEntry>(`
        SELECT * FROM ai_response_cache WHERE key = ?
      `, [key]);
      
      if (results.length === 0) {
        Logger.debug(MODULE_NAME, `No cache entry found for key: ${key}`);
        return null;
      }
      
      Logger.debug(MODULE_NAME, `Cache entry found for key: ${key}`);
      return results[0];
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Update cache entry statistics
   */
  public async updateStats(key: string, hitCount: number, lastAccessed: number): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Updating stats for cache entry: ${key}`);
      
      await db.getAllAsync(`
        UPDATE ai_response_cache 
        SET hit_count = ?, last_accessed = ? 
        WHERE key = ?
      `, [hitCount, lastAccessed, key]);
      
      Logger.debug(MODULE_NAME, `Stats updated for cache entry: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to update stats for cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Delete a cache entry by key
   */
  public async deleteEntry(key: string): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      
      await db.getAllAsync(`
        DELETE FROM ai_response_cache WHERE key = ?
      `, [key]);
      
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Delete cache entries by pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      
      // First get the keys that match the pattern
      const keys = await db.getAllAsync<KeyEntry>(`
        SELECT key FROM ai_response_cache WHERE key LIKE ?
      `, [`%${pattern}%`]);
      
      if (keys.length === 0) {
        Logger.debug(MODULE_NAME, `No cache entries found matching pattern: ${pattern}`);
        return 0;
      }
      
      // Delete the entries
      await db.getAllAsync(`
        DELETE FROM ai_response_cache WHERE key LIKE ?
      `, [`%${pattern}%`]);
      
      Logger.debug(MODULE_NAME, `Deleted ${keys.length} cache entries matching pattern: ${pattern}`);
      return keys.length;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      throw error;
    }
  }

  /**
   * Clear all cache entries
   */
  public async clearAll(): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      
      await db.getAllAsync(`DELETE FROM ai_response_cache`);
      
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
      throw error;
    }
  }

  /**
   * Get the total number of cache entries
   */
  public async getCount(): Promise<number> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, 'Getting cache entry count');
      
      const result = await db.getAllAsync<CountResult>(`
        SELECT COUNT(*) as count FROM ai_response_cache
      `);
      
      Logger.debug(MODULE_NAME, `Cache entry count: ${result[0].count}`);
      return result[0].count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get cache entry count');
      throw error;
    }
  }

  /**
   * Delete expired cache entries
   */
  public async deleteExpired(): Promise<number> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, 'Deleting expired cache entries');
      
      const now = Date.now();
      
      // First get the keys that are expired
      const keys = await db.getAllAsync<KeyEntry>(`
        SELECT key FROM ai_response_cache WHERE expires_at < ?
      `, [now]);
      
      if (keys.length === 0) {
        Logger.debug(MODULE_NAME, 'No expired cache entries found');
        return 0;
      }
      
      // Delete the expired entries
      await db.getAllAsync(`
        DELETE FROM ai_response_cache WHERE expires_at < ?
      `, [now]);
      
      Logger.debug(MODULE_NAME, `Deleted ${keys.length} expired cache entries`);
      return keys.length;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to delete expired cache entries');
      throw error;
    }
  }

  /**
   * Get the least recently used cache entries
   */
  public async getLeastRecentlyUsed(limit: number): Promise<KeyEntry[]> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Getting ${limit} least recently used cache entries`);
      
      const keys = await db.getAllAsync<KeyEntry>(`
        SELECT key FROM ai_response_cache 
        ORDER BY last_accessed ASC 
        LIMIT ?
      `, [limit]);
      
      Logger.debug(MODULE_NAME, `Found ${keys.length} least recently used cache entries`);
      return keys;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get least recently used cache entries');
      throw error;
    }
  }

  /**
   * Get the most frequently used cache entries
   */
  public async getMostFrequentlyUsed(limit: number): Promise<CacheDbEntry[]> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Getting ${limit} most frequently used cache entries`);
      
      const entries = await db.getAllAsync<CacheDbEntry>(`
        SELECT * FROM ai_response_cache 
        ORDER BY hit_count DESC 
        LIMIT ?
      `, [limit]);
      
      Logger.debug(MODULE_NAME, `Found ${entries.length} most frequently used cache entries`);
      return entries;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get most frequently used cache entries');
      throw error;
    }
  }

  /**
   * Get all keys for a specific user
   */
  public async getKeysForUser(userId: string): Promise<KeyEntry[]> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Getting cache keys for user: ${userId}`);
      
      const keys = await db.getAllAsync<KeyEntry>(`
        SELECT key FROM ai_response_cache 
        WHERE key LIKE ?
      `, [`%user:${userId}%`]);
      
      Logger.debug(MODULE_NAME, `Found ${keys.length} cache keys for user: ${userId}`);
      return keys;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache keys for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/database/repositories/FeedbackRepository.ts
================================================================================

import { SQLiteDatabase } from "expo-sqlite";
import { DatabaseManager } from "../DatabaseManager";
import * as Logger from '../../utils/logging';
import { UserFeedback, QualityScore, FeedbackPattern } from '../../types/feedback';
import { FeedbackStats, PatternEntry, QualityStats } from '../../types/feedback';

const MODULE_NAME = 'FeedbackRepository';

/**
 * Repository for feedback database operations
 */
export class FeedbackRepository {
  private db: SQLiteDatabase | null = null;

  constructor() {
    try {
      this.db = DatabaseManager.getInstance().getFeedbackDb();
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get feedback database');
    }
  }

  /**
   * Ensure database is available
   */
  private ensureDatabase(): SQLiteDatabase {
    if (!this.db) {
      try {
        this.db = DatabaseManager.getInstance().getFeedbackDb();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to get feedback database');
        throw new Error('Feedback database not initialized');
      }
    }
    return this.db;
  }

  /**
   * Store user feedback
   */
  public async storeFeedback(feedback: UserFeedback, feedbackId: string = `fb_${Date.now()}`): Promise<string> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Storing feedback for response: ${feedback.responseId}`);
      
      await db.getAllAsync(`
        INSERT OR REPLACE INTO user_feedback (
          id,
          user_id,
          response_id,
          response_type,
          helpful,
          accurate,
          relevance,
          comments,
          timestamp
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        feedbackId,
        feedback.userId,
        feedback.responseId,
        feedback.responseType,
        feedback.helpful ? 1 : 0,
        feedback.accurate ? 1 : 0,
        feedback.relevance,
        feedback.comments || null,
        feedback.timestamp
      ]);
      
      Logger.debug(MODULE_NAME, `Feedback stored with ID: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store feedback for response: ${feedback.responseId}`);
      throw error;
    }
  }

  /**
   * Store quality score
   */
  public async storeQualityScore(
    evaluationId: string,
    responseId: string,
    qualityScore: QualityScore
  ): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Storing quality score for response: ${responseId}`);
      
      await db.getAllAsync(`
        INSERT OR REPLACE INTO response_quality_scores (
          id,
          response_id,
          overall_score,
          relevance_score,
          accuracy_score,
          comprehensiveness_score,
          safety_score,
          strengths,
          weaknesses,
          improvement_suggestions,
          timestamp
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        evaluationId,
        responseId,
        qualityScore.overallScore,
        qualityScore.relevanceScore,
        qualityScore.accuracyScore,
        qualityScore.comprehensivenessScore,
        qualityScore.safetyScore,
        JSON.stringify(qualityScore.strengths),
        JSON.stringify(qualityScore.weaknesses),
        JSON.stringify(qualityScore.improvementSuggestions),
        Date.now()
      ]);
      
      Logger.debug(MODULE_NAME, `Quality score stored for response: ${responseId}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store quality score for response: ${responseId}`);
      throw error;
    }
  }

  /**
   * Store or update feedback pattern
   */
  public async storePattern(pattern: FeedbackPattern): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Storing feedback pattern: ${pattern.patternId}`);
      
      await this.db.getAllAsync(`
        INSERT OR REPLACE INTO feedback_patterns (
          pattern_id,
          response_type,
          user_profile_factors,
          request_factors,
          positive_outcome_rate,
          sample_size,
          last_updated
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `, [
        pattern.patternId,
        pattern.responseType,
        JSON.stringify(pattern.userProfileFactors),
        JSON.stringify(pattern.requestFactors),
        pattern.positiveOutcomeRate,
        pattern.sampleSize,
        pattern.lastUpdated
      ]);
      
      Logger.debug(MODULE_NAME, `Feedback pattern stored: ${pattern.patternId}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store feedback pattern: ${pattern.patternId}`);
      throw error;
    }
  }

  /**
   * Get feedback pattern by ID
   */
  public async getPattern(patternId: string): Promise<PatternEntry | null> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback pattern: ${patternId}`);
      
      const results = await this.db.getAllAsync<PatternEntry>(`
        SELECT 
          pattern_id,
          user_profile_factors,
          request_factors,
          positive_outcome_rate,
          sample_size
        FROM feedback_patterns 
        WHERE pattern_id = ?
      `, [patternId]);
      
      if (results.length === 0) {
        Logger.debug(MODULE_NAME, `No feedback pattern found for ID: ${patternId}`);
        return null;
      }
      
      Logger.debug(MODULE_NAME, `Feedback pattern found: ${patternId}`);
      return results[0];
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback pattern: ${patternId}`);
      throw error;
    }
  }

  /**
   * Get all feedback for a user
   */
  public async getUserFeedback(userId: string): Promise<UserFeedback[]> {
    try {
      Logger.debug(MODULE_NAME, `Getting all feedback for user: ${userId}`);
      
      // Define the interface for the raw database results
      interface RawFeedbackRow {
        userId: string;
        responseId: string;
        responseType: 'recommendation' | 'chat';
        helpful: number;
        accurate: number;
        relevance: number;
        comments?: string;
        timestamp: number;
      }
      
      const results = await this.db.getAllAsync<RawFeedbackRow>(`
        SELECT 
          user_id as userId,
          response_id as responseId,
          response_type as responseType,
          helpful,
          accurate,
          relevance,
          comments,
          timestamp
        FROM user_feedback 
        WHERE user_id = ?
        ORDER BY timestamp DESC
      `, [userId]);
      
      // Convert boolean fields from SQLite integers
      const feedback: UserFeedback[] = results.map(row => ({
        userId: row.userId,
        responseId: row.responseId,
        responseType: row.responseType,
        helpful: row.helpful === 1,
        accurate: row.accurate === 1,
        relevance: row.relevance,
        comments: row.comments,
        timestamp: row.timestamp
      }));
      
      Logger.debug(MODULE_NAME, `Found ${feedback.length} feedback entries for user: ${userId}`);
      return feedback;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get feedback statistics for a user
   */
  public async getUserFeedbackStats(userId: string): Promise<FeedbackStats> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback stats for user: ${userId}`);
      
      const results = await this.db.getAllAsync<FeedbackStats>(`
        SELECT 
          COUNT(*) as total,
          SUM(CASE WHEN helpful = 1 THEN 1 ELSE 0 END) as positive,
          SUM(relevance) as relevance_sum
        FROM user_feedback 
        WHERE user_id = ?
      `, [userId]);
      
      Logger.debug(MODULE_NAME, `Retrieved feedback stats for user: ${userId}`);
      return results[0];
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback stats for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get quality score statistics
   */
  public async getQualityScoreStats(): Promise<QualityStats> {
    try {
      Logger.debug(MODULE_NAME, 'Getting quality score statistics');
      
      const results = await this.db.getAllAsync<QualityStats>(`
        SELECT 
          AVG(overall_score) as avg_overall,
          AVG(relevance_score) as avg_relevance,
          AVG(safety_score) as avg_safety,
          COUNT(*) as total
        FROM response_quality_scores
      `);
      
      Logger.debug(MODULE_NAME, 'Retrieved quality score statistics');
      return results[0];
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get quality score statistics');
      throw error;
    }
  }

  /**
   * Get all patterns for a response type
   */
  public async getPatternsByType(responseType: string): Promise<PatternEntry[]> {
    try {
      Logger.debug(MODULE_NAME, `Getting patterns for response type: ${responseType}`);
      
      const results = await this.db.getAllAsync<PatternEntry>(`
        SELECT 
          pattern_id,
          user_profile_factors,
          request_factors,
          positive_outcome_rate,
          sample_size
        FROM feedback_patterns 
        WHERE response_type = ?
        ORDER BY positive_outcome_rate DESC
      `, [responseType]);
      
      Logger.debug(MODULE_NAME, `Found ${results.length} patterns for response type: ${responseType}`);
      return results;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get patterns for response type: ${responseType}`);
      throw error;
    }
  }

  /**
   * Delete all feedback for a user
   */
  public async deleteUserFeedback(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting all feedback for user: ${userId}`);
      
      // First count how many entries will be deleted
      const countResult = await this.db.getAllAsync<{ count: number }>(`
        SELECT COUNT(*) as count FROM user_feedback WHERE user_id = ?
      `, [userId]);
      
      const count = countResult[0].count;
      
      // Delete the entries
      await this.db.getAllAsync(`
        DELETE FROM user_feedback WHERE user_id = ?
      `, [userId]);
      
      Logger.debug(MODULE_NAME, `Deleted ${count} feedback entries for user: ${userId}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete feedback for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/feedback/FeedbackService.ts
================================================================================

import * as Logger from '../utils/logging';
import { FeedbackRepository } from '../database/repositories/FeedbackRepository';
import { UserFeedback, QualityScore, FeedbackPattern } from '../types/feedback';
import { AnthropicAPI } from '../api/AnthropicAPI';

const MODULE_NAME = 'FeedbackService';

/**
 * Feedback Service
 * Handles user feedback and response quality evaluation
 */
export class FeedbackService {
  private static instance: FeedbackService;
  private repository: FeedbackRepository;
  private api: AnthropicAPI;
  private initialized: boolean = false;

  private constructor() {
    this.repository = new FeedbackRepository();
    this.api = new AnthropicAPI();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of FeedbackService
   */
  public static getInstance(): FeedbackService {
    if (!FeedbackService.instance) {
      FeedbackService.instance = new FeedbackService();
    }
    return FeedbackService.instance;
  }

  /**
   * Initialize the feedback service
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing feedback service');
      this.initialized = true;
      Logger.info(MODULE_NAME, 'Feedback service initialized successfully');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback service');
      throw error;
    }
  }

  /**
   * Submit user feedback
   */
  public async submitFeedback(feedback: UserFeedback): Promise<string> {
    try {
      Logger.info(MODULE_NAME, `Submitting feedback for response: ${feedback.responseId}`);
      
      // Generate a unique ID for the feedback
      const feedbackId = `fb_${Date.now()}`;
      
      // Store the feedback
      await this.repository.storeFeedback(feedback, feedbackId);
      
      // Evaluate the response quality in the background
      this.evaluateResponseQuality(feedback.responseId, feedback.responseType)
        .catch(error => {
          Logger.logError(MODULE_NAME, error as Error, `Failed to evaluate response quality for: ${feedback.responseId}`);
        });
      
      // Extract feedback patterns in the background
      this.extractFeedbackPatterns(feedback)
        .catch(error => {
          Logger.logError(MODULE_NAME, error as Error, `Failed to extract feedback patterns for: ${feedback.responseId}`);
        });
      
      Logger.info(MODULE_NAME, `Feedback submitted successfully: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit feedback for response: ${feedback.responseId}`);
      throw error;
    }
  }

  /**
   * Evaluate the quality of a response
   */
  public async evaluateResponseQuality(
    responseId: string,
    responseType: 'recommendation' | 'chat',
    responseData?: any
  ): Promise<QualityScore> {
    try {
      Logger.info(MODULE_NAME, `Evaluating quality for response: ${responseId}`);
      
      // Generate a unique ID for the evaluation
      const evaluationId = `eval_${Date.now()}`;
      
      // If we have an API key and want to use the real API
      const useRealApi = false; // Set to true to use the real API
      
      if (useRealApi) {
        // Format the evaluation prompt
        const prompt = `
          You are an expert evaluator of AI responses for a cannabis recommendation app.
          Please evaluate the following ${responseType} response:
          
          ${JSON.stringify(responseData)}
          
          Provide a quality score on a scale of 0-100 for the following aspects:
          - Overall quality
          - Relevance to user needs
          - Accuracy of information
          - Comprehensiveness
          - Safety considerations
          
          Also list:
          - 3 strengths of the response
          - 3 weaknesses of the response
          - 3 suggestions for improvement
          
          Format your response as a JSON object with the following structure:
          {
            "overallScore": number,
            "relevanceScore": number,
            "accuracyScore": number,
            "comprehensivenessScore": number,
            "safetyScore": number,
            "strengths": string[],
            "weaknesses": string[],
            "improvementSuggestions": string[]
          }
        `;
        
        // Call the API
        const response = await this.api.sendMessage([
          { role: 'user', content: prompt }
        ], 2000, 0.3);
        
        // Parse the response
        const qualityScore = JSON.parse(response) as QualityScore;
        
        // Store the quality score
        await this.repository.storeQualityScore(evaluationId, responseId, qualityScore);
        
        Logger.info(MODULE_NAME, `Quality evaluation completed for response: ${responseId}`);
        return qualityScore;
      } else {
        // For testing or when API is not available, generate a mock quality score
        const mockQualityScore: QualityScore = {
          overallScore: 85,
          relevanceScore: 80,
          accuracyScore: 90,
          comprehensivenessScore: 85,
          safetyScore: 95,
          strengths: [
            'Provides detailed information about the recommended strains',
            'Includes safety considerations and dosage guidelines',
            'Explains the reasoning behind the recommendations'
          ],
          weaknesses: [
            'Could provide more context about potential side effects',
            'Limited information about alternative options',
            'Dosage recommendations could be more personalized'
          ],
          improvementSuggestions: [
            'Include more information about potential side effects',
            'Provide alternative recommendations for different scenarios',
            'Enhance personalization of dosage recommendations'
          ]
        };
        
        // Store the mock quality score
        await this.repository.storeQualityScore(evaluationId, responseId, mockQualityScore);
        
        Logger.info(MODULE_NAME, `Mock quality evaluation completed for response: ${responseId}`);
        return mockQualityScore;
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to evaluate quality for response: ${responseId}`);
      
      // Return a default quality score in case of error
      return {
        overallScore: 70,
        relevanceScore: 70,
        accuracyScore: 70,
        comprehensivenessScore: 70,
        safetyScore: 70,
        strengths: ['Not evaluated due to error'],
        weaknesses: ['Not evaluated due to error'],
        improvementSuggestions: ['Not evaluated due to error']
      };
    }
  }

  /**
   * Extract feedback patterns from user feedback
   */
  private async extractFeedbackPatterns(feedback: UserFeedback): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Extracting feedback patterns for response: ${feedback.responseId}`);
      
      // In a real implementation, this would analyze the feedback and extract patterns
      // For now, we'll just create a simple pattern based on the feedback
      
      // Create a pattern ID based on user profile and request factors
      const patternId = `pattern_${feedback.responseType}_${Date.now()}`;
      
      // Check if the pattern already exists
      const existingPattern = await this.repository.getPattern(patternId);
      
      if (existingPattern) {
        // Update the existing pattern
        const updatedPattern: FeedbackPattern = {
          patternId,
          responseType: feedback.responseType,
          userProfileFactors: { userId: feedback.userId },
          requestFactors: { responseId: feedback.responseId },
          positiveOutcomeRate: feedback.helpful ? 1 : 0,
          sampleSize: 1,
          lastUpdated: Date.now()
        };
        
        await this.repository.storePattern(updatedPattern);
      } else {
        // Create a new pattern
        const newPattern: FeedbackPattern = {
          patternId,
          responseType: feedback.responseType,
          userProfileFactors: { userId: feedback.userId },
          requestFactors: { responseId: feedback.responseId },
          positiveOutcomeRate: feedback.helpful ? 1 : 0,
          sampleSize: 1,
          lastUpdated: Date.now()
        };
        
        await this.repository.storePattern(newPattern);
      }
      
      Logger.debug(MODULE_NAME, `Feedback patterns extracted for response: ${feedback.responseId}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to extract feedback patterns for response: ${feedback.responseId}`);
    }
  }

  /**
   * Get all feedback for a user
   */
  public async getUserFeedback(userId: string): Promise<UserFeedback[]> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback for user: ${userId}`);
      const feedback = await this.repository.getUserFeedback(userId);
      Logger.debug(MODULE_NAME, `Found ${feedback.length} feedback entries for user: ${userId}`);
      return feedback;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get feedback statistics for a user
   */
  public async getUserFeedbackStats(userId: string): Promise<any> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback stats for user: ${userId}`);
      const stats = await this.repository.getUserFeedbackStats(userId);
      Logger.debug(MODULE_NAME, `Retrieved feedback stats for user: ${userId}`);
      return stats;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback stats for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get quality score statistics
   */
  public async getQualityScoreStats(): Promise<any> {
    try {
      Logger.debug(MODULE_NAME, 'Getting quality score statistics');
      const stats = await this.repository.getQualityScoreStats();
      Logger.debug(MODULE_NAME, 'Retrieved quality score statistics');
      return stats;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get quality score statistics');
      throw error;
    }
  }

  /**
   * Delete all feedback for a user
   */
  public async deleteUserFeedback(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting feedback for user: ${userId}`);
      const count = await this.repository.deleteUserFeedback(userId);
      Logger.debug(MODULE_NAME, `Deleted ${count} feedback entries for user: ${userId}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete feedback for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/feedback/index.ts
================================================================================

export { FeedbackService } from './FeedbackService'; 

================================================================================
File: src/services/ai/index.ts
================================================================================

export { AIService } from './AIService';

// Export sub-modules
export * from './api';
export * from './cache/index';
export * from './feedback';
export * from './types/common';
export * from './types/errors';
export * from './types/feedback';
export * from './types/requests';
export * from './types/responses'; 

================================================================================
File: src/services/ai/types/common.ts
================================================================================

// Constants
export const AI_USAGE_DB_NAME = "AIUsage";
export const RECOMMENDATION_FEEDBACK_DB_NAME = "RecommendationFeedback";
export const CACHE_DB_NAME = "AIResponseCache";

// Cache configuration
export const DEFAULT_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
export const MAX_CACHE_SIZE = 100; // Maximum number of cached responses

// Anthropic API constants
export const ANTHROPIC_API_URL = "https://api.anthropic.com/v1";
export const ANTHROPIC_API_VERSION = "2023-06-01";
// In a production app, you would use environment variables
// import { ANTHROPIC_API_KEY } from '@env';
// For now, we'll use a placeholder that you'll replace with your actual key
export const ANTHROPIC_API_KEY = "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"; // Replace this with your actual key

// Cache entry interface
export interface CacheEntry<T> {
  key: string;
  data: T;
  timestamp: number;
  expiresAt: number;
  ttl: number;
  hitCount: number;
  lastAccessed: number;
}

// Database entry interfaces
export interface CacheDbEntry {
  key: string;
  data: string;
  timestamp: number;
  expires_at: number;
  ttl: number;
  hit_count: number;
  last_accessed: number;
}

export interface KeyEntry {
  key: string;
}

export interface CountResult {
  count: number;
} 

================================================================================
File: src/services/SafetyService.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import AsyncStorage from '@react-native-async-storage/async-storage';
import { 
  RecommendationRequest, 
  RecommendationResponse, 
  SafetyValidationResult,
  DrugInteractionResult,
  OveruseDetectionResult,
  SafetyRecord,
  JournalEntry,
  UserProfile
} from '../types/ai';

// Constants for safety thresholds
const SAFETY_DB_NAME = "SafetyRecords";
const COOLING_OFF_DAYS = 7; // Default cooling off period in days
const MAX_DAILY_SESSIONS = 5; // Threshold for potential overuse warning
const HIGH_THC_THRESHOLD = 25; // THC percentage considered high potency
const MINIMUM_AGE_REQUIREMENT = 21; // Minimum age for recommendations

export class SafetyService {
  private static instance: SafetyService;
  private db: SQLiteDatabase | null = null;
  private initialized: boolean = false;
  
  private constructor() {}
  
  static getInstance(): SafetyService {
    if (!SafetyService.instance) {
      SafetyService.instance = new SafetyService();
    }
    return SafetyService.instance;
  }
  
  // Initialize database and safety features
  async initialize(): Promise<void> {
    if (this.initialized) return;
    
    try {
      console.log('[SafetyService] Initializing safety database...');
      
      this.db = await openDatabaseAsync(SAFETY_DB_NAME);
      
      // Create tables for safety records
      await this.db.execAsync(`
        PRAGMA journal_mode = WAL;
        
        CREATE TABLE IF NOT EXISTS ${SAFETY_DB_NAME} (
          id TEXT PRIMARY KEY NOT NULL,
          user_id TEXT NOT NULL,
          concern_type TEXT NOT NULL,
          concern_details TEXT NOT NULL,
          resolution_suggestions TEXT,
          cooling_off_until INTEGER,
          created_at INTEGER NOT NULL
        );
        
        CREATE INDEX IF NOT EXISTS idx_user_id 
        ON ${SAFETY_DB_NAME}(user_id);
        
        CREATE INDEX IF NOT EXISTS idx_created_at 
        ON ${SAFETY_DB_NAME}(created_at);
      `);
      
      // Initialize educational content if not already done
      const hasInitialized = await AsyncStorage.getItem('safety_initialized');
      if (!hasInitialized) {
        await this.initializeEducationalContent();
        await AsyncStorage.setItem('safety_initialized', 'true');
      }
      
      this.initialized = true;
      console.log('[SafetyService] Safety service initialized');
      
    } catch (error) {
      console.error('[SafetyService] Error initializing safety database:', error);
      throw error;
    }
  }
  
  // Core validation method for recommendation requests
  async validateRecommendationRequest(request: RecommendationRequest): Promise<SafetyValidationResult> {
    try {
      await this.ensureInitialized();
      
      const { userProfile, desiredEffects, medicalNeeds, context } = request;
      const safetyFlags: string[] = [];
      let isValid = true;
      let reason = '';
      let modifications: Partial<RecommendationRequest> = {};
      let warningLevel: 'info' | 'warning' | 'critical' = 'info';
      
      // Check for required fields
      if (!userProfile) {
        return {
          valid: false,
          reason: 'User profile is required for personalized recommendations',
          warningLevel: 'critical'
        };
      }

      // Verify age restrictions (if age is provided)
      if (userProfile.experience_level === 'beginner') {
        // For beginners, add a safety flag
        safetyFlags.push('Recommendations tailored for beginners. Start with lower doses.');
      }
      
      // Check for cooling off period
      const coolingOffStatus = await this.checkCoolingOffStatus(userProfile.id);
      if (coolingOffStatus.inCoolingOff) {
        return {
          valid: false,
          reason: `Cooling off period in effect until ${new Date(coolingOffStatus.endTime!).toLocaleDateString()}`,
          warningLevel: 'critical'
        };
      }
      
      // Check for overdose concerns based on user profile
      const overuseCheck = await this.detectOverusePatterns(userProfile.id);
      if (overuseCheck.detected) {
        if (overuseCheck.level === 'severe') {
          return {
            valid: false,
            reason: overuseCheck.details || 'Usage patterns indicate potential health concerns',
            warningLevel: 'critical'
          };
        } else {
          safetyFlags.push(overuseCheck.details || 'Frequent use detected. Consider moderating consumption.');
          warningLevel = overuseCheck.level === 'moderate' ? 'warning' : 'info';
        }
      }
      
      // Check for medication interactions if applicable
      if (userProfile.medications && userProfile.medications.length > 0) {
        const interactionCheck = await this.checkMedicationInteractions(
          userProfile.medications
        );
        
        if (interactionCheck.hasInteractions) {
          if (interactionCheck.severity === 'severe') {
            return {
              valid: false,
              reason: 'Potential serious interaction with medications detected',
              safetyFlags: interactionCheck.details,
              warningLevel: 'critical'
            };
          } else {
            safetyFlags.push(...(interactionCheck.details || []));
            warningLevel = interactionCheck.severity === 'moderate' ? 'warning' : 'info';
          }
        }
      }
      
      // Adjust recommendations for beginners
      if (userProfile.experience_level === 'beginner') {
        // Modify the request to prioritize lower THC content for beginners
        modifications = {
          ...modifications,
          context: 'wellness', // Override context for beginners
          desiredEffects: [...(request.desiredEffects || []), 'mild', 'gentle']
        };
        
        safetyFlags.push('Recommendations adjusted for beginner experience level.');
      }
      
      // Handle medical context with extra care
      if (context === 'medical' && medicalNeeds && medicalNeeds.length > 0) {
        safetyFlags.push('Medical disclaimer: Consult with a healthcare professional before use.');
        
        // Check if any medical needs require special attention
        const sensitiveConditions = ['anxiety', 'heart', 'psychiatric', 'pregnancy'];
        const hasSensitiveCondition = medicalNeeds.some(need => 
          sensitiveConditions.some(condition => need.toLowerCase().includes(condition))
        );
        
        if (hasSensitiveCondition) {
          safetyFlags.push('Some conditions may require extra caution. Medical supervision is strongly advised.');
          warningLevel = 'warning';
        }
      }
      
      // Return validation result
      return {
        valid: isValid,
        reason: reason,
        modifications: Object.keys(modifications).length > 0 ? modifications : undefined,
        safetyFlags: safetyFlags.length > 0 ? safetyFlags : undefined,
        warningLevel
      };
      
    } catch (error) {
      console.error('[SafetyService] Error validating recommendation request:', error);
      return {
        valid: false,
        reason: 'Internal safety check error. Please try again later.',
        warningLevel: 'critical'
      };
    }
  }
  
  // Process recommendation response to add appropriate safety information
  async processRecommendationResponse(
    response: RecommendationResponse, 
    userProfile: UserProfile,
    recentEntries: JournalEntry[]
  ): Promise<RecommendationResponse> {
    try {
      await this.ensureInitialized();
      
      let additionalDisclaimers: string[] = [];
      let enhancedSafetyNotes = [...(response.safetyNotes || [])];
      let recommendations = [...response.recommendations];
      
      // Ensure we always have basic disclaimers
      if (!response.disclaimers || response.disclaimers.length === 0) {
        additionalDisclaimers.push(
          "Cannabis affects individuals differently. Start with a low dose.",
          "Do not drive or operate machinery while using cannabis.",
          "Keep cannabis products away from children and pets."
        );
      }
      
      // Add experience level specific notes
      if (userProfile.experience_level === 'beginner') {
        additionalDisclaimers.push(
          "As a beginner, start with a very small amount and wait at least 2 hours before considering more.",
          "Effects may be stronger than expected for new users."
        );
      }
      
      // Check journal entries for negative patterns
      if (recentEntries.length > 0) {
        // Look for commonly reported negative effects
        const negativeEffectsMap = new Map<string, number>();
        recentEntries.forEach(entry => {
          if (entry.negative_effects) {
            entry.negative_effects.forEach(effect => {
              negativeEffectsMap.set(effect, (negativeEffectsMap.get(effect) || 0) + 1);
            });
          }
        });
        
        // Find frequent negative effects
        const frequentNegativeEffects = Array.from(negativeEffectsMap.entries())
          .filter(([_, count]) => count >= 2)
          .map(([effect]) => effect);
        
        if (frequentNegativeEffects.length > 0) {
          enhancedSafetyNotes.push(
            `Based on your journal, watch for these effects you've reported: ${frequentNegativeEffects.join(', ')}.`
          );
        }
        
        // Look for high dosage patterns
        const highDosageEntries = recentEntries.filter(entry => 
          entry.dosage > (userProfile.experience_level === 'beginner' ? 10 : 25)
        );
        
        if (highDosageEntries.length > 2) {
          enhancedSafetyNotes.push(
            "Your journal shows higher dosages than typically recommended. Consider a tolerance break or gradual reduction."
          );
          
          // Flag user for potential follow-up if overuse is detected
          await this.logSafetyConcern({
            userId: userProfile.id,
            concernType: 'overuse',
            concernDetails: 'High dosage pattern detected in journal entries',
            timestamp: Date.now(),
            resolutionSuggestions: [
              'Consider a 48-hour tolerance break',
              'Try microdosing techniques',
              'Explore lower THC varieties'
            ]
          });
        }
      }
      
      // Filter out potentially inappropriate recommendations
      if (userProfile.avoid_effects && userProfile.avoid_effects.length > 0) {
        // In a real app, this would check against a database of strain profiles
        // For this demo, we'll just add a safety note
        enhancedSafetyNotes.push(
          `Note: You've indicated you want to avoid ${userProfile.avoid_effects.join(', ')}. Adjust dosage accordingly.`
        );
      }
      
      // Include any contextual medical warnings
      if (userProfile.medical_needs && userProfile.medical_needs.length > 0) {
        additionalDisclaimers.push(
          "These recommendations are not a replacement for professional medical advice."
        );
      }
      
      // Return enhanced response
      return {
        ...response,
        disclaimers: [...(response.disclaimers || []), ...additionalDisclaimers],
        safetyNotes: enhancedSafetyNotes,
        recommendations
      };
      
    } catch (error) {
      console.error('[SafetyService] Error processing recommendation response:', error);
      // Return original response if processing fails
      return response;
    }
  }
  
  /**
   * Detects potential overuse patterns in user's consumption history
   * Uses more sophisticated pattern recognition to identify concerning usage trends
   */
  async detectOverusePatterns(userId: string): Promise<OveruseDetectionResult> {
    try {
      await this.ensureInitialized();
      
      // Get recent journal entries
      const recentEntries = await this.getRecentJournalEntries(userId, 90); // Last 90 days
      
      if (recentEntries.length < 5) {
        return { detected: false };
      }
      
      // Extract features for pattern analysis
      const features = this.extractUsageFeatures(recentEntries);
      
      // Check for increasing frequency pattern
      const weeklyUsageCounts = this.getWeeklyUsageCounts(recentEntries);
      const increasingFrequency = this.detectIncreasingTrend(weeklyUsageCounts);
      
      // Check for increasing dosage pattern
      const weeklyAvgDosages = this.getWeeklyAverageDosages(recentEntries);
      const increasingDosage = this.detectIncreasingTrend(weeklyAvgDosages);
      
      // Check for tolerance development (same dosage, decreasing effectiveness)
      const effectivenessRatios = this.getEffectivenessRatios(recentEntries);
      const decreasingEffectiveness = this.detectDecreasingTrend(effectivenessRatios);
      
      // Check for withdrawal symptoms
      const withdrawalSymptoms = this.detectWithdrawalSymptoms(recentEntries);
      
      // Determine overall risk level
      let level: 'mild' | 'moderate' | 'severe' | undefined;
      let details = '';
      let recommendedAction = '';
      let coolingOffPeriod: number | undefined;
      
      const riskFactors = [
        increasingFrequency && 'increasing usage frequency',
        increasingDosage && 'increasing dosage',
        decreasingEffectiveness && 'developing tolerance',
        withdrawalSymptoms && 'potential withdrawal symptoms'
      ].filter(Boolean);
      
      if (riskFactors.length >= 3) {
        level = 'severe';
        details = `Multiple concerning patterns detected: ${riskFactors.join(', ')}.`;
        recommendedAction = 'Consider a 7-day tolerance break and consult with a healthcare provider.';
        coolingOffPeriod = 7;
      } else if (riskFactors.length >= 2) {
        level = 'moderate';
        details = `Some concerning patterns detected: ${riskFactors.join(', ')}.`;
        recommendedAction = 'Consider scheduling regular cannabis-free days each week.';
      } else if (riskFactors.length >= 1) {
        level = 'mild';
        details = `Early warning signs detected: ${riskFactors.join(', ')}.`;
        recommendedAction = 'Consider mindful consumption practices and occasional breaks.';
      } else {
        return { detected: false };
      }
      
      // Log safety concern if moderate or severe
      if (level === 'moderate' || level === 'severe') {
        await this.logSafetyConcern({
          userId,
          concernType: 'overuse',
          concernDetails: details,
          timestamp: Date.now(),
          resolutionSuggestions: [recommendedAction],
          coolingOffUntil: level === 'severe' ? Date.now() + (coolingOffPeriod! * 24 * 60 * 60 * 1000) : undefined
        });
      }
      
      return {
        detected: true,
        level,
        details,
        recommendedAction,
        coolingOffPeriod
      };
    } catch (error) {
      console.error('[SafetyService] Error detecting overuse patterns:', error);
      return { detected: false };
    }
  }
  
  // Helper methods for pattern detection
  
  /**
   * Get recent journal entries for a user
   */
  private async getRecentJournalEntries(userId: string, days: number): Promise<JournalEntry[]> {
    // In a real implementation, this would query the journal database
    // For now, return mock data
    return [
      {
        id: "j1",
        user_id: userId,
        strain_id: 1,
        strain_name: "Blue Dream",
        consumption_method: "vaporize",
        dosage: 15,
        dosage_unit: "mg",
        effects_felt: ["Relaxed", "Happy", "Creative"],
        rating: 4,
        effectiveness: 4,
        notes: "Good for evening relaxation, helped with creativity",
        mood_before: "Stressed",
        mood_after: "Calm",
        medical_symptoms_relieved: ["Anxiety"],
        negative_effects: ["Dry mouth"],
        duration_minutes: 180,
        created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
      },
      {
        id: "j2",
        user_id: userId,
        strain_id: 2,
        strain_name: "OG Kush",
        consumption_method: "edible",
        dosage: 10,
        dosage_unit: "mg",
        effects_felt: ["Sleepy", "Relaxed", "Hungry"],
        rating: 3,
        effectiveness: 4,
        notes: "Helped with sleep, but made me too hungry",
        mood_before: "Tired",
        mood_after: "Sleepy",
        medical_symptoms_relieved: ["Insomnia"],
        negative_effects: ["Groggy morning"],
        duration_minutes: 240,
        created_at: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
      }
    ];
  }
  
  /**
   * Extract features for pattern analysis
   */
  private extractUsageFeatures(entries: JournalEntry[]): any {
    // Extract features for ML analysis
    // In a real implementation, this would extract meaningful features
    return {
      totalEntries: entries.length,
      averageDosage: entries.reduce((sum, entry) => sum + entry.dosage, 0) / entries.length,
      averageEffectiveness: entries.reduce((sum, entry) => sum + entry.effectiveness, 0) / entries.length,
      uniqueStrains: new Set(entries.map(entry => entry.strain_id)).size,
      negativeEffectsRate: entries.filter(entry => entry.negative_effects && entry.negative_effects.length > 0).length / entries.length
    };
  }
  
  /**
   * Group entries by week and count
   */
  private getWeeklyUsageCounts(entries: JournalEntry[]): number[] {
    // Group entries by week and count
    const weeklyCounts: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 12 weeks
    
    entries.forEach(entry => {
      const entryDate = new Date(entry.created_at);
      const now = new Date();
      const diffTime = Math.abs(now.getTime() - entryDate.getTime());
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      const weekIndex = Math.floor(diffDays / 7);
      
      if (weekIndex < weeklyCounts.length) {
        weeklyCounts[weekIndex]++;
      }
    });
    
    return weeklyCounts.reverse(); // Most recent first
  }
  
  /**
   * Get weekly average dosages
   */
  private getWeeklyAverageDosages(entries: JournalEntry[]): number[] {
    // Group entries by week and calculate average dosage
    const weeklyDosages: { sum: number, count: number }[] = Array(12).fill(0).map(() => ({ sum: 0, count: 0 }));
    
    entries.forEach(entry => {
      const entryDate = new Date(entry.created_at);
      const now = new Date();
      const diffTime = Math.abs(now.getTime() - entryDate.getTime());
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      const weekIndex = Math.floor(diffDays / 7);
      
      if (weekIndex < weeklyDosages.length) {
        weeklyDosages[weekIndex].sum += entry.dosage;
        weeklyDosages[weekIndex].count++;
      }
    });
    
    return weeklyDosages.map(week => week.count > 0 ? week.sum / week.count : 0).reverse();
  }
  
  /**
   * Calculate effectiveness ratios (effectiveness / dosage)
   */
  private getEffectivenessRatios(entries: JournalEntry[]): number[] {
    // Calculate effectiveness to dosage ratios over time
    const sortedEntries = [...entries].sort((a, b) => 
      new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
    );
    
    return sortedEntries.map(entry => entry.effectiveness / entry.dosage);
  }
  
  /**
   * Detect increasing trend in a series of values
   */
  private detectIncreasingTrend(values: number[]): boolean {
    if (values.length < 3) return false;
    
    // Simple linear regression
    const n = values.length;
    const indices = Array.from({ length: n }, (_, i) => i);
    
    const sumX = indices.reduce((sum, x) => sum + x, 0);
    const sumY = values.reduce((sum, y) => sum + y, 0);
    const sumXY = indices.reduce((sum, x, i) => sum + x * values[i], 0);
    const sumXX = indices.reduce((sum, x) => sum + x * x, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    
    // Check if the slope is positive and significant
    return slope > 0.1;
  }
  
  /**
   * Detect decreasing trend in a series of values
   */
  private detectDecreasingTrend(values: number[]): boolean {
    if (values.length < 3) return false;
    
    // Simple linear regression
    const n = values.length;
    const indices = Array.from({ length: n }, (_, i) => i);
    
    const sumX = indices.reduce((sum, x) => sum + x, 0);
    const sumY = values.reduce((sum, y) => sum + y, 0);
    const sumXY = indices.reduce((sum, x, i) => sum + x * values[i], 0);
    const sumXX = indices.reduce((sum, x) => sum + x * x, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    
    // Check if the slope is negative and significant
    return slope < -0.1;
  }
  
  /**
   * Detect potential withdrawal symptoms
   */
  private detectWithdrawalSymptoms(entries: JournalEntry[]): boolean {
    // Look for patterns indicating withdrawal
    // This is a simplified implementation
    
    // Check for mood deterioration after periods without use
    const sortedEntries = [...entries].sort((a, b) => 
      new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
    );
    
    // Look for gaps between entries
    for (let i = 1; i < sortedEntries.length; i++) {
      const prevEntry = sortedEntries[i - 1];
      const currEntry = sortedEntries[i];
      
      const prevDate = new Date(prevEntry.created_at);
      const currDate = new Date(currEntry.created_at);
      
      const diffHours = (currDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60);
      
      // If there's a gap of more than 48 hours and mood deteriorated
      if (diffHours > 48 && 
          currEntry.mood_before === "Irritable" || 
          currEntry.mood_before === "Anxious" ||
          currEntry.mood_before === "Restless") {
        return true;
      }
    }
    
    return false;
  }
  
  // Check for medication interactions with cannabis
  async checkMedicationInteractions(
    medications: string[]
  ): Promise<DrugInteractionResult> {
    try {
      await this.ensureInitialized();
      
      // In a real app, this would check against a medical database
      // For this demo, we'll use a simplified mock implementation
      
      // Known high-risk interactions
      const highRiskMeds = [
        'warfarin', 'clopidogrel', 'rivaroxaban', 'dabigatran', // Blood thinners
        'tacrolimus', 'cyclosporine', // Immunosuppressants
        'lithium', 'clozapine', // Psychiatric medications
        'theophylline', // Respiratory
        'amiodarone', 'digoxin' // Cardiac
      ];
      
      // Moderate risk interactions
      const moderateRiskMeds = [
        'fluoxetine', 'sertraline', 'paroxetine', 'citalopram', // SSRIs
        'zolpidem', 'eszopiclone', // Sleep medications
        'alprazolam', 'lorazepam', 'diazepam', // Benzodiazepines
        'amlodipine', 'diltiazem', // Blood pressure
        'metformin', 'glyburide', // Diabetes
        'oxycodone', 'hydrocodone', 'tramadol' // Pain medications
      ];
      
      // Check for matches
      const highRiskMatches = medications.filter(med => 
        highRiskMeds.some(risk => med.toLowerCase().includes(risk.toLowerCase()))
      );
      
      const moderateRiskMatches = medications.filter(med => 
        moderateRiskMeds.some(risk => med.toLowerCase().includes(risk.toLowerCase()))
      );
      
      if (highRiskMatches.length > 0) {
        return {
          hasInteractions: true,
          details: highRiskMatches.map(med => 
            `Potential serious interaction between cannabis and ${med}. Consult a healthcare provider before use.`
          ),
          severity: 'severe',
          recommendations: [
            'Consult with your healthcare provider before using cannabis',
            'Monitor for unexpected side effects if using both substances',
            'Consider CBD-only products which may have fewer interactions'
          ]
        };
      } else if (moderateRiskMatches.length > 0) {
        return {
          hasInteractions: true,
          details: moderateRiskMatches.map(med => 
            `Potential interaction between cannabis and ${med}. Use with caution.`
          ),
          severity: 'moderate',
          recommendations: [
            'Start with very low doses and monitor effects carefully',
            'Space out timing between medication and cannabis use',
            'Keep a detailed journal of any side effects'
          ]
        };
      }
      
      return {
        hasInteractions: false
      };
      
    } catch (error) {
      console.error('[SafetyService] Error checking drug interactions:', error);
      return {
        hasInteractions: false
      };
    }
  }
  
  // Log a safety concern for a user
  async logSafetyConcern(data: {
    userId: string;
    concernType: 'overuse' | 'negative_effects' | 'interactions';
    concernDetails: string;
    timestamp: number;
    resolutionSuggestions?: string[];
    coolingOffUntil?: number;
  }): Promise<void> {
    try {
      await this.ensureInitialized();
      
      if (!this.db) {
        throw new Error('Safety database not initialized');
      }
      
      const id = `concern_${Date.now()}`;
      
      await this.db.execAsync(`
        INSERT INTO ${SAFETY_DB_NAME} (
          id,
          user_id,
          concern_type,
          concern_details,
          resolution_suggestions,
          cooling_off_until,
          created_at
        ) VALUES (
          '${id}',
          '${data.userId}',
          '${data.concernType}',
          '${data.concernDetails}',
          ${data.resolutionSuggestions ? `'${JSON.stringify(data.resolutionSuggestions)}'` : 'NULL'},
          ${data.coolingOffUntil ? data.coolingOffUntil : 'NULL'},
          ${data.timestamp}
        )
      `);
      
      console.log('[SafetyService] Safety concern logged for user', data.userId);
      
    } catch (error) {
      console.error('[SafetyService] Error logging safety concern:', error);
      throw error;
    }
  }
  
  // Get safety history for a user
  async getSafetyHistory(userId: string): Promise<SafetyRecord[]> {
    try {
      await this.ensureInitialized();
      
      if (!this.db) {
        return [];
      }
      
      const result = await this.db.getAllAsync<any>(`
        SELECT * FROM ${SAFETY_DB_NAME}
        WHERE user_id = '${userId}'
        ORDER BY created_at DESC
      `);
      
      return result.map((row: any) => ({
        id: row.id,
        user_id: row.user_id,
        concern_type: row.concern_type as 'overuse' | 'negative_effects' | 'interactions',
        concern_details: row.concern_details,
        resolution_suggestions: row.resolution_suggestions 
          ? JSON.parse(row.resolution_suggestions) 
          : [],
        cooling_off_until: row.cooling_off_until,
        created_at: new Date(row.created_at).toISOString()
      }));
      
    } catch (error) {
      console.error('[SafetyService] Error getting safety history:', error);
      return [];
    }
  }
  
  // Check if a user is in a cooling off period
  async checkCoolingOffStatus(userId: string): Promise<{
    inCoolingOff: boolean;
    endTime?: number;
    reason?: string;
  }> {
    try {
      await this.ensureInitialized();
      
      if (!this.db) {
        return { inCoolingOff: false };
      }
      
      const now = Date.now();
      
      const [result] = await this.db.getAllAsync<any>(`
        SELECT * FROM ${SAFETY_DB_NAME}
        WHERE user_id = '${userId}' AND cooling_off_until > ${now}
        ORDER BY cooling_off_until DESC
        LIMIT 1
      `);
      
      if (!result) {
        return { inCoolingOff: false };
      }
      
      return {
        inCoolingOff: true,
        endTime: result.cooling_off_until,
        reason: result.concern_details
      };
      
    } catch (error) {
      console.error('[SafetyService] Error checking cooling off status:', error);
      return { inCoolingOff: false };
    }
  }
  
  // Private helper methods
  
  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }
  
  private async initializeEducationalContent(): Promise<void> {
    // Set up initial educational content in storage
    const educationalContent = {
      harm_reduction: [
        {
          title: "Start Low, Go Slow",
          content: "Begin with a low dose (2.5-5mg THC) and wait at least 2 hours before considering more."
        },
        {
          title: "Know Your Source",
          content: "Only purchase cannabis from legal, regulated sources to ensure quality and safety."
        },
        {
          title: "Mind Your Method",
          content: "Different consumption methods have different onset times and potency levels. Edibles take longer to feel but last longer."
        },
        {
          title: "Set and Setting",
          content: "Use in a comfortable, safe environment with trusted people, especially when trying a new product."
        },
        {
          title: "Stay Hydrated",
          content: "Drink plenty of water before, during, and after cannabis use to minimize dry mouth and dehydration."
        }
      ],
      warning_signs: [
        {
          title: "Increasing Tolerance",
          content: "Needing more cannabis to achieve the same effects is a sign of developing tolerance."
        },
        {
          title: "Preoccupation",
          content: "Thinking about cannabis frequently or planning life around cannabis use."
        },
        {
          title: "Interference",
          content: "Cannabis use affecting responsibilities, relationships, or activities you once enjoyed."
        },
        {
          title: "Withdrawal",
          content: "Experiencing irritability, sleep problems, decreased appetite, or mood changes when not using."
        }
      ],
      responsible_use: [
        {
          title: "Schedule Cannabis-Free Days",
          content: "Regular breaks help prevent tolerance and dependence. Aim for at least 2-3 cannabis-free days per week."
        },
        {
          title: "Keep a Journal",
          content: "Track your usage, effects, and how you feel the next day to identify patterns and optimal dosing."
        },
        {
          title: "Never Drive",
          content: "Cannabis impairs coordination and reaction time. Never drive or operate heavy machinery after use."
        },
        {
          title: "Secure Storage",
          content: "Store cannabis products securely and out of reach of children and pets."
        }
      ]
    };
    
    await AsyncStorage.setItem('educational_content', JSON.stringify(educationalContent));
  }
  
  // Cleanup resources
  async cleanup(): Promise<void> {
    if (this.db) {
      try {
        // Check if the database is already closed
        const isClosed = await this.isDbClosed();
        if (!isClosed) {
          await this.db.closeAsync();
        }
        this.db = null;
        this.initialized = false;
      } catch (error) {
        console.error('[SafetyService] Error during cleanup:', error);
      }
    }
  }

  // Helper method to check if the database is closed
  private async isDbClosed(): Promise<boolean> {
    try {
      // Try a simple query - if it fails with a "database is closed" error, the DB is closed
      await this.db?.execAsync('SELECT 1');
      return false; // Query succeeded, database is open
    } catch (error) {
      // If the error message contains "closed", the database is already closed
      const errorMessage = String(error);
      return errorMessage.includes('closed') || errorMessage.includes('not open');
    }
  }
}

export default SafetyService.getInstance(); 

================================================================================
File: src/services/StrainService.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import { STRAINS_DATABASE_NAME, SAMPLE_STRAINS } from "../constants";
import { Strain } from "../dbManager";

export interface StrainSearchFilters {
  geneticType?: string;
  effects?: string[];
  minTHC?: number;
  maxTHC?: number;
  sort?: 'rating' | 'name' | 'thc';
}

export interface PaginationParams {
  page: number;
  limit: number;
}

export interface StrainSearchResult {
  success: boolean;
  data: Strain[];
  error?: string;
  total: number;
  currentPage: number;
  totalPages: number;
  hasMore: boolean;
}

export class StrainService {
  private static instance: StrainService;
  private db: SQLiteDatabase | null = null;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {}

  static getInstance(): StrainService {
    if (!StrainService.instance) {
      StrainService.instance = new StrainService();
    }
    return StrainService.instance;
  }

  private async initialize(): Promise<void> {
    try {
      console.log('[StrainService] Initializing database...');
      this.db = await openDatabaseAsync(STRAINS_DATABASE_NAME);

      // Drop existing table to ensure clean state
      await this.db.execAsync(`DROP TABLE IF EXISTS ${STRAINS_DATABASE_NAME};`);

      // Create table and indexes
      await this.db.execAsync(`
        PRAGMA journal_mode = WAL;
        
        CREATE TABLE IF NOT EXISTS ${STRAINS_DATABASE_NAME} (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          overview TEXT,
          genetic_type TEXT,
          lineage TEXT,
          thc_range TEXT,
          cbd_level TEXT,
          dominant_terpenes TEXT,
          qualitative_insights TEXT,
          effects TEXT,
          negatives TEXT,
          uses TEXT,
          thc_rating REAL,
          user_rating REAL,
          combined_rating REAL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        
        CREATE INDEX IF NOT EXISTS idx_strain_name 
        ON ${STRAINS_DATABASE_NAME}(name);
        
        CREATE INDEX IF NOT EXISTS idx_strain_genetic_type 
        ON ${STRAINS_DATABASE_NAME}(genetic_type);
        
        CREATE INDEX IF NOT EXISTS idx_strain_effects 
        ON ${STRAINS_DATABASE_NAME}(effects);
        
        CREATE INDEX IF NOT EXISTS idx_strain_rating 
        ON ${STRAINS_DATABASE_NAME}(combined_rating DESC);
      `);

      // Insert all sample strains
      console.log('[StrainService] Inserting', SAMPLE_STRAINS.length, 'sample strains...');
      
      for (const strain of SAMPLE_STRAINS) {
        try {
          await this.db.runAsync(
            `INSERT INTO ${STRAINS_DATABASE_NAME} (
              name, overview, genetic_type, lineage, thc_range,
              cbd_level, dominant_terpenes, qualitative_insights,
              effects, negatives, uses, thc_rating,
              user_rating, combined_rating
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`,
            [
              strain.name,
              strain.overview,
              strain.genetic_type,
              strain.lineage,
              strain.thc_range,
              strain.cbd_level,
              strain.dominant_terpenes,
              strain.qualitative_insights,
              strain.effects,
              strain.negatives,
              strain.uses,
              strain.thc_rating,
              strain.user_rating,
              strain.combined_rating
            ]
          );
        } catch (insertError) {
          console.error(`[StrainService] Failed to insert strain ${strain.name}:`, insertError);
          // Continue with next strain instead of failing completely
        }
      }

      // Verify the data
      const [finalCount] = await this.db.getAllAsync<{ count: number }>(
        `SELECT COUNT(*) as count FROM ${STRAINS_DATABASE_NAME}`
      );
      console.log('[StrainService] Database initialized with', finalCount?.count || 0, 'strains');

    } catch (error) {
      console.error('[StrainService] Failed to initialize database:', error);
      this.db = null;
      throw error;
    }
  }

  private async getDatabase(): Promise<SQLiteDatabase> {
    if (!this.db) {
      if (!this.initializationPromise) {
        this.initializationPromise = this.initialize();
      }
      await this.initializationPromise;
      this.initializationPromise = null;
    }

    if (!this.db) {
      throw new Error('Database initialization failed');
    }

    return this.db;
  }

  private parseTHCRange(thcRange: string): { min: number; max: number } {
    const matches = thcRange.match(/(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)/);
    if (matches) {
      return {
        min: parseFloat(matches[1]),
        max: parseFloat(matches[2])
      };
    }
    return { min: 0, max: 0 };
  }

  async searchStrains(
    query: string = '',
    filters: StrainSearchFilters = {},
    pagination: PaginationParams = { page: 1, limit: 20 }
  ): Promise<StrainSearchResult> {
    try {
      const db = await this.getDatabase();
      const { page, limit } = pagination;
      const offset = (page - 1) * limit;
      
      let whereConditions: string[] = [];
      let params: any[] = [];

      // Add search query conditions
      if (query.trim()) {
        const searchTerms = query.trim().split(/\s+/);
        searchTerms.forEach(term => {
          whereConditions.push('(name LIKE ? OR effects LIKE ? OR genetic_type LIKE ? OR uses LIKE ?)');
          const searchTerm = `%${term}%`;
          params.push(searchTerm, searchTerm, searchTerm, searchTerm);
        });
      }

      // Add filter conditions
      if (filters.geneticType) {
        whereConditions.push('genetic_type = ?');
        params.push(filters.geneticType);
      }

      if (filters.effects?.length) {
        filters.effects.forEach(effect => {
          whereConditions.push('effects LIKE ?');
          params.push(`%${effect}%`);
        });
      }

      if (filters.minTHC !== undefined) {
        whereConditions.push('CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) >= ?');
        params.push(filters.minTHC);
      }

      if (filters.maxTHC !== undefined) {
        whereConditions.push('CAST(SUBSTR(thc_range, INSTR(thc_range, "-")+1) AS FLOAT) <= ?');
        params.push(filters.maxTHC);
      }

      const whereClause = whereConditions.length 
        ? `WHERE ${whereConditions.join(' AND ')}` 
        : '';

      // Get total count
      const [countResult] = await db.getAllAsync<{ total: number }>(
        `SELECT COUNT(*) as total FROM ${STRAINS_DATABASE_NAME} ${whereClause}`,
        params
      );

      // Get filtered results
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} 
         ${whereClause} 
         ORDER BY ${this.getSortOrder(filters.sort)}
         LIMIT ? OFFSET ?`,
        [...params, limit, offset]
      );

      const total = countResult?.total || 0;
      const totalPages = Math.ceil(total / limit);

      return {
        success: true,
        data: results,
        total,
        currentPage: page,
        totalPages,
        hasMore: (page * limit) < total
      };

    } catch (error) {
      console.error('[StrainService] Search error:', error);
      return {
        success: false,
        data: [],
        error: error instanceof Error ? error.message : 'Search failed',
        total: 0,
        currentPage: 1,
        totalPages: 1,
        hasMore: false
      };
    }
  }

  private getSortOrder(sort?: StrainSearchFilters['sort']): string {
    switch (sort) {
      case 'name':
        return 'name ASC';
      case 'thc':
        return 'CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) DESC';
      case 'rating':
      default:
        return 'combined_rating DESC';
    }
  }

  async getStrainById(id: number): Promise<Strain | null> {
    try {
      const db = await this.getDatabase();
      const [strain] = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} WHERE id = ? LIMIT 1`,
        [id]
      );
      return strain || null;
    } catch (error) {
      console.error('[StrainService] Error getting strain by id:', error);
      return null;
    }
  }

  async getPopularStrains(limit: number = 10): Promise<Strain[]> {
    try {
      const db = await this.getDatabase();
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} ORDER BY combined_rating DESC LIMIT ?`,
        [limit]
      );
      return results || [];
    } catch (error) {
      console.error('[StrainService] Error getting popular strains:', error);
      return [];
    }
  }

  async getRelatedStrains(strain: Strain): Promise<Strain[]> {
    try {
      const db = await this.getDatabase();
      // Get strains with similar genetic type and effects
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME}
         WHERE id != ? 
         AND (
           genetic_type = ? 
           OR effects LIKE ?
         )
         ORDER BY combined_rating DESC
         LIMIT 5`,
        [strain.id!, strain.genetic_type, `%${strain.effects.split(',')[0]}%`]
      );
      return results || [];
    } catch (error) {
      console.error('[StrainService] Error getting related strains:', error);
      return [];
    }
  }

  async getStrainCategories(): Promise<{ [key: string]: number }> {
    try {
      const db = await this.getDatabase();
      const results = await db.getAllAsync<{ genetic_type: string; count: number }>(
        `SELECT genetic_type, COUNT(*) as count
         FROM ${STRAINS_DATABASE_NAME}
         GROUP BY genetic_type`
      );
      
      return results.reduce((acc, { genetic_type, count }) => {
        if (genetic_type) {
          acc[genetic_type] = count;
        }
        return acc;
      }, {} as { [key: string]: number });
    } catch (error) {
      console.error('[StrainService] Error getting strain categories:', error);
      return {};
    }
  }

  async cleanup(): Promise<void> {
    if (this.db) {
      try {
        await this.db.closeAsync();
        this.db = null;
        this.initializationPromise = null;
      } catch (error) {
        console.error('[StrainService] Error during cleanup:', error);
        throw error;
      }
    }
  }
}

// Export a default instance
export default StrainService.getInstance(); 

================================================================================
File: src/services/utils/hash.ts
================================================================================

/**
 * A simple SHA-256 hash implementation for string inputs
 * This is a basic implementation for caching purposes
 * In a production environment, use a proper crypto library
 */
export function SHA256(input: string): string {
  // Simple hash function for demo purposes
  // In a real app, use a proper crypto library
  let hash = 0;
  
  if (input.length === 0) {
    return hash.toString(16);
  }
  
  // Generate a simple hash
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Convert to hex string and ensure it's 64 characters long (SHA-256 length)
  const hexHash = Math.abs(hash).toString(16).padStart(8, '0');
  
  // Repeat the hash to make it look like a SHA-256 hash (64 chars)
  return (hexHash.repeat(8)).substring(0, 64);
} 

================================================================================
File: src/types.ts
================================================================================

// Core data types
export interface BongHit {
    id?: number;
    timestamp: string;
    duration_ms: number;
    intensity?: number;
    notes?: string;
}

export interface BongHitStats {
    averageDuration: number;
    longestHit: number;
    totalHits?: number;
}

export interface DailyStats {
    date: string;
    hitCount: number;
    averageDuration: number;
}

export interface AverageHourCount {
    count: number;
    hourOfDay: string;
}

export interface Datapoint {
    x: string | number;
    y: number;
}

// Chart-specific types
export interface ChartDataPoint {
    label: string;
    value: number;
}

export interface ChartDataset {
    data: number[];
    color: (opacity?: number) => string;
    strokeWidth: number;
}

export interface ChartData {
    labels: string[];
    datasets: ChartDataset[];
    legend?: string[];
}

// Database types
export interface DatabaseRow {
    timestamp?: string;
    duration_ms?: number;
    day?: string;
    month?: string;
    hour?: string;
    hit_count?: number;
    count?: number;
    avg_duration?: number;
    max_duration?: number;
    total_hits?: number;
    avg_hits_per_day?: number;
    avg_duration_per_day?: number;
    daily_hits?: number;
    days_with_data?: number;
    weekday_avg?: number;
    weekday_total?: number;
    weekend_avg?: number;
    weekend_total?: number;
    peak_day_hits?: number;
    lowest_day_hits?: number;
    most_active_hour?: number;
    least_active_hour?: number;
    total_duration?: number;
    avg_hits_per_hour?: number;
    hits_std_dev?: number;
    // Fields from time distribution query
    morning?: number;
    afternoon?: number;
    evening?: number;
    night?: number;
    // Fields from usage stats query
    average_hits_per_day?: number;
    shortest_hit?: number;
    longest_hit?: number;
    consistency?: number;
}

export interface UsageStats {
    // Hit counts
    averageHitsPerDay: number;
    totalHits: number;
    peakDayHits: number;
    lowestDayHits: number;
    
    // Duration stats
    averageDuration: number;  // in ms
    longestHit: number;      // in ms
    shortestHit: number;     // in ms
    
    // Time patterns
    mostActiveHour: number;  // 0-23
    leastActiveHour: number; // 0-23
    
    // Derived metrics
    totalDuration: number;   // total time in ms
    averageHitsPerHour: number;
    consistency: number;     // standard deviation of daily hits

    // Weekday vs Weekend stats
    weekdayStats: WeekdayStats;
}

// Add new interfaces for time distribution
export interface TimeDistribution {
    morning: number;
    afternoon: number;
    evening: number;
    night: number;
}

export interface WeekdayStats {
    weekday: { avg: number; total: number; };
    weekend: { avg: number; total: number; };
}

// Component Props interfaces
export interface WeeklyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface MonthlyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface NotificationProps {
    averageHits: number;
    percentageChange: number;
    onDismiss: () => void;
}

export interface DailyAverageCardProps {
    data: ChartDataPoint[];
    averageHits: number;
    onPress?: () => void;
}

export interface WeeklyUsageBannerProps {
    weeklyData: ChartDataPoint[];
    average: number;
    percentageChange: number;
    onPress?: () => void;
}

// API Response types
export interface DatabaseResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}

export interface UsageAnalytics {
    dailyAverage: number;
    weeklyAverage: number;
    percentageChange: number;
    lastUpdated: string;
}

export interface SavedDevice {
    id: string;
    name: string;
}

// State management types
export interface DataState {
    weeklyData: ChartDataPoint[];
    monthlyData: ChartDataPoint[];
    usageStats: UsageStats;
    timeDistribution: TimeDistribution;
    isLoading: boolean;
    error: string | null;
}

================================================================================
File: src/types/ai.ts
================================================================================

// AI recommendation system types
export interface UserProfile {
  id: string;
  experience_level: 'beginner' | 'intermediate' | 'experienced';
  preferred_effects: string[];
  medical_needs?: string[];
  avoid_effects?: string[];
  preferred_consumption_method?: string;
  thc_tolerance?: number; // Scale 1-10
  medications?: string[];
  created_at: string;
  updated_at: string;
}

export interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: string;
}

export interface JournalEntry {
  id: string;
  user_id: string;
  strain_id: number;
  strain_name: string;
  consumption_method: string;
  dosage: number;
  dosage_unit: string;
  effects_felt: string[];
  rating: number;
  effectiveness: number;
  notes?: string;
  mood_before?: string;
  mood_after?: string;
  medical_symptoms_relieved?: string[];
  negative_effects?: string[];
  duration_minutes?: number;
  created_at: string;
}

export interface RecommendationRequest {
  userProfile: UserProfile;
  journalEntries?: JournalEntry[];
  desiredEffects: string[];
  medicalNeeds?: string[];
  context?: 'recreational' | 'medical' | 'wellness';
  locationCode?: string; // For regulations
}

export interface StrainRecommendation {
  strainId: number;
  strainName: string;
  matchScore: number; // 0-100
  reasoningFactors: {
    factor: string;
    weight: number;
  }[];
  alternativeStrains?: {
    strainId: number;
    strainName: string;
    reason: string;
  }[];
}

export interface DosageSuggestion {
  minDosage: number;
  maxDosage: number;
  unit: string;
  gradualApproach: boolean;
  notes: string;
}

export interface RecommendationResponse {
  recommendations: StrainRecommendation[];
  reasoning: string;
  confidenceScore: number;
  disclaimers: string[];
  dosageSuggestion?: DosageSuggestion;
  safetyNotes?: string[];
  error?: {
    message: string;
    type: string;
    recoverable: boolean;
  };
}

export interface ChatRequest {
  message: string;
  userProfile: UserProfile;
  locationCode?: string;
  previousMessages?: {
    role: 'user' | 'assistant';
    content: string;
  }[];
}

export interface ChatResponse {
  response: string;
  educationalLinks?: string[];
  disclaimers?: string[];
  regulatoryNotes?: string[];
  followUpSuggestions?: string[];
}

export interface JournalAnalysisResult {
  patterns: string[];
  insights: string[];
  recommendations: string[];
  safetyFlags?: string[];
}

export interface SafetyValidationResult {
  valid: boolean;
  reason?: string;
  modifications?: Partial<RecommendationRequest>;
  safetyFlags?: string[];
  warningLevel?: 'info' | 'warning' | 'critical';
}

export interface DrugInteractionResult {
  hasInteractions: boolean;
  details?: string[];
  severity?: 'mild' | 'moderate' | 'severe';
  recommendations?: string[];
}

export interface OveruseDetectionResult {
  detected: boolean;
  level?: 'mild' | 'moderate' | 'severe';
  details?: string;
  recommendedAction?: string;
  coolingOffPeriod?: number; // in days
}

export interface SafetyRecord {
  id: string;
  user_id: string;
  concern_type: 'overuse' | 'negative_effects' | 'interactions';
  concern_details: string;
  resolution_suggestions: string[];
  cooling_off_until: number | null;
  created_at: string;
} 

=