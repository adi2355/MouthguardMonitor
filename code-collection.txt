

================================================================================
File: app.json
================================================================================

{
  "expo": {
    "name": "CanovaReactNativeApp",
    "slug": "CanovaReactNativeApp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/canovafavicon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.anonymous.CanovaReactNativeApp",
      "infoPlist": {
        "NSBluetoothAlwaysUsageDescription": "This app requires Bluetooth access to connect to devices.",
        "NSBluetoothPeripheralUsageDescription": "This app requires Bluetooth access to communicate with nearby devices."
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/canovafavicon.png",
        "backgroundColor": "#ffffff"
      },
      "permissions": [
        "android.permission.BLUETOOTH",
        "android.permission.BLUETOOTH_ADMIN",
        "android.permission.BLUETOOTH_CONNECT",
        "android.permission.BLUETOOTH",
        "android.permission.BLUETOOTH_ADMIN",
        "android.permission.BLUETOOTH_CONNECT"
      ],
      "package": "com.anonymous.CanovaReactNativeApp"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/canovafavicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ],
      "expo-sqlite",
      [
        "react-native-ble-plx",
        {
          "isBackgroundEnabled": true,
          "modes": [
            "peripheral",
            "central"
          ],
          "bluetoothAlwaysPermission": "Allow $(PRODUCT_NAME) to connect to bluetooth devices"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}


================================================================================
File: app/_layout.tsx
================================================================================

import { Stack } from "expo-router";
import { useState, useEffect } from "react";
import { BluetoothContext, BluetoothHandler } from "@/src/contexts/BluetoothContext";
import { useColorScheme } from 'react-native';

export default function RootLayout() {
  const colorScheme = useColorScheme();

  const [bluetoothHandler] = useState<BluetoothHandler>(new BluetoothHandler());

  return (
    <BluetoothContext.Provider value={bluetoothHandler}>
      <Stack>
        <Stack.Screen 
          name="(tabs)" 
          options={{ headerShown: false }} 
        />
        <Stack.Screen 
          name="dataOverviews/strains/strainDetails" 
          options={{ 
            headerShown: false,
            presentation: 'modal',
            animation: 'slide_from_bottom',
          }} 
        />
        <Stack.Screen name="+not-found" />
      </Stack>  
    </BluetoothContext.Provider>
  );
}


================================================================================
File: app/(tabs)/_layout.tsx
================================================================================

import { Tabs } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarStyle: {
          backgroundColor: COLORS.background,
          borderTopColor: 'rgba(255, 255, 255, 0.1)',
        },
        tabBarActiveTintColor: COLORS.primary,
        tabBarInactiveTintColor: 'rgba(255, 255, 255, 0.5)',
        headerShown: false,
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          href: null,
        }}
      />
      <Tabs.Screen
        name="mydata"
        options={{
          title: 'My Data',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="chart-box" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="devices"
        options={{
          title: 'Devices',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="devices" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="journal"
        options={{
          title: 'Journal',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="notebook" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="trending"
        options={{
          title: 'Trending',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="trending-up" size={24} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

================================================================================
File: app/(tabs)/devices.tsx
================================================================================

import { BluetoothContext } from '@/src/contexts/BluetoothContext';
import AntDesign from '@expo/vector-icons/AntDesign';
import React, { useState, useEffect, useRef, useContext } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Alert
} from 'react-native';
import base64 from 'react-native-base64';
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';

export default function Devices() {

  const [savedDevices, setSavedDevice] = useState<Device[]>([]);
  const [devices, setDevices] = useState<Device[]>([]);
  const [scanning, setScanning] = useState<boolean>(false);

  //Track devices to avoid duplicate keys when scanning
  const undiscoveredDeviceSet = useRef(new Set<string>());

  const bluetoothHandler = useContext(BluetoothContext)!;

  useEffect(() => {
    setSavedDevice(bluetoothHandler.getSavedDevices());
  }, []);

  // THIS WILL decode BONG HIT DATA
  function onDataUpdate(error: BleError | null, characteristic: Characteristic | null) {
    if (error) {
      console.log(error);
      return -1;
    } else if (!characteristic?.value) {
      console.log("No Data was recieved");
      return -1;
    }
    const rawData = base64.decode(characteristic.value);
    Alert.alert(`Raw Data: ${rawData}`);
  }

  function scanDevices(): void {
    const manager: BleManager = bluetoothHandler.getBLEManager();
    setScanning(true);
    setDevices([]);

    manager.startDeviceScan(null, null, (error, device) => {
      if (error) {
        console.error('Error scanning devices:', error.message);
        setScanning(false);
        return;
      }

      if (device && device.name && !undiscoveredDeviceSet.current.has(device.id)) {
        undiscoveredDeviceSet.current.add(device.id); // Add device ID to the Set
        setDevices((prevDevices) => [...prevDevices, device]);
      }
    });

    // Stop scanning after 10 seconds
    setTimeout(() => {
      manager.stopDeviceScan();
      setScanning(false);
    }, 10000);
  };

  // Renders device
  const renderDevice = ({ item }: { item: Device }): JSX.Element => (
    <TouchableOpacity style={styles.deviceItem} onPress={() => bluetoothHandler.connectToDevice(item)}>
      <AntDesign name="hdd" size={24} color="black" />
      <View style={styles.deviceInfo}>
        <Text style={styles.deviceName}>{item.name}</Text>
      </View>
      {item.id === bluetoothHandler.getConnectedDevice()?.id ? <Text>Connected</Text> : <Text>Not Connected</Text>}
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      <View style={styles.devicesFlatMapContainer}>
        <View style={styles.header}>
          <Text style={styles.headerText}>My Devices</Text>
        </View>
        <FlatList
          data={savedDevices}
          keyExtractor={(item) => item.id}
          renderItem={renderDevice}
          contentContainerStyle={styles.list}
        />
      </View>
      <View style={styles.devicesFlatMapContainer}>
        <View style={styles.header}>
          <Text style={styles.headerText}>Other Devices</Text>
        </View>
        <TouchableOpacity style={styles.scanButton} onPress={scanDevices} disabled={scanning}>
          <Text style={styles.scanButtonText}>
            {scanning ? 'Scanning...' : 'Scan for Devices'}
          </Text>
        </TouchableOpacity>
        {scanning && <ActivityIndicator style={styles.loader} size="large" color="#007AFF" />}
        <FlatList
          data={devices}
          keyExtractor={(item) => item.id}
          renderItem={renderDevice}
          contentContainerStyle={styles.list}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  devicesFlatMapContainer: {
    marginBottom: 20
  },
  header: {
    backgroundColor: '#ffffff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e6e6e6'
  },
  headerText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#000',
  },
  scanButton: {
    backgroundColor: '#12a35f',
    padding: 12,
    margin: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  scanButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loader: {
    marginTop: 10,
  },
  list: {
    padding: 16,
  },
  deviceItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e6e6e6',
    borderRadius: 6,
    marginVertical: 4,
  },
  deviceInfo: {
    marginLeft: 12,
    flex: 1,
  },
  deviceName: {
    fontSize: 16,
    fontWeight: '500',
  },
  deviceId: {
    color: '#8e8e93',
    fontSize: 12,
  },
});


================================================================================
File: app/(tabs)/index.tsx
================================================================================

import { Redirect } from 'expo-router';

export default function Index() {
  return <Redirect href="/mydata" />;
}

================================================================================
File: app/(tabs)/journal.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, Modal, TextInput, Button, StyleSheet } from 'react-native';
import { Calendar } from 'react-native-calendars';

export default function JournalCalendar() {
  const [selectedDate, setSelectedDate] = useState('');
  const [modalVisible, setModalVisible] = useState(false);
  const [entries, setEntries] = useState({});
  const [currentEntry, setCurrentEntry] = useState('');

  const handleDayPress = (day) => {
    const date = day.dateString;
    setSelectedDate(date);
    setCurrentEntry(entries[date] || '');
    setModalVisible(true);
  };

  const saveEntry = () => {
    setEntries({ ...entries, [selectedDate]: currentEntry });
    setModalVisible(false);
  };

  return (
    <View style={styles.container}>
      {/* Calendar */}
      <Calendar
        onDayPress={handleDayPress}
        markedDates={{
          ...Object.keys(entries).reduce((acc, date) => {
            acc[date] = { marked: true };
            return acc;
          }, {}),
          [selectedDate]: { selected: true, selectedColor: '#12a35f' },
        }}
      />

      {/* Modal for journal entry */}
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              Journal Entry for {selectedDate}
            </Text>
            <TextInput
              style={styles.input}
              multiline
              placeholder="Write your journal entry here..."
              value={currentEntry}
              onChangeText={setCurrentEntry}
            />
            <View style={styles.modalButtons}>
              <Button title="Save" onPress={saveEntry} />
              <Button title="Cancel" onPress={() => setModalVisible(false)} />
            </View>
          </View>
        </View>
      </Modal>

      {/* Display Saved Entries */}
      <View style={styles.entriesContainer}>
        <Text style={styles.entriesTitle}>Saved Journal Entries:</Text>
        {Object.keys(entries).length > 0 ? (
          Object.entries(entries).map(([date, entry]) => (
            <View key={date} style={styles.entry}>
              <Text style={styles.entryDate}>{date}</Text>
              <Text style={styles.entryText}>{entry}</Text>
            </View>
          ))
        ) : (
          <Text>No journal entries yet.</Text>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '80%',
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 20,
    alignItems: 'center',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  input: {
    width: '100%',
    height: 100,
    borderColor: '#ddd',
    borderWidth: 1,
    borderRadius: 5,
    padding: 10,
    textAlignVertical: 'top',
    marginBottom: 20,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  entriesContainer: {
    marginTop: 20,
  },
  entriesTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  entry: {
    marginBottom: 10,
  },
  entryDate: {
    fontWeight: 'bold',
  },
  entryText: {
    fontSize: 14,
  },
});


================================================================================
File: app/(tabs)/mydata.tsx
================================================================================

import React, { memo, useCallback, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { COLORS } from '@/src/constants';
import { useDataService } from '@/src/hooks/useDataService';
import Animated, { FadeIn } from 'react-native-reanimated';

// Import components from their new structure
import LoadingView from '@/app/components/shared/LoadingView';
import ErrorView from '@/app/components/shared/ErrorView';
import Header from '@/app/components/mydata/Header';
import Section from '@/app/components/mydata/Section';
import NotificationBanner from '@/app/components/mydata/NotificationBanner';
import MedicalCard from '@/app/components/mydata/MedicalCard';
import DailyAverageCard from '@/app/components/mydata/DailyAverageCard';
import WeeklyUsageBanner from '@/app/components/mydata/WeeklyUsageBanner';
import WeeklyOverviewChart from '@/app/components/mydata/charts/WeeklyOverviewChart';
import MonthlyOverviewChart from '@/app/components/mydata/charts/MonthlyOverviewChart';
import StatsOverviewCard from '@/app/components/mydata/StatsOverviewCard';
import TimeDistributionCard from '@/app/components/mydata/TimeDistributionCard';

const ROUTES = {
  DAILY_AVERAGE: "/mydata/daily-average",
  WEEKLY_AVERAGE: "/mydata/weekly-average",
  WEEKLY_OVERVIEW: "/mydata/weekly-overview",
  MONTHLY_OVERVIEW: "/mydata/monthly-overview",
} as const;

export default memo(function MyData() {
  const router = useRouter();
  const [showNotification, setShowNotification] = useState(true);
  const { 
    weeklyData, 
    monthlyData, 
    usageStats, 
    timeDistribution,
    isLoading, 
    error 
  } = useDataService();

  const handleNavigation = useCallback((route: keyof typeof ROUTES) => {
    router.push(ROUTES[route] as any);
  }, [router]);

  if (isLoading) return <LoadingView />;
  if (error) return <ErrorView error={error} />;

  const weekdayAvg = usageStats.weekdayStats?.weekday.avg || 0;
  const weekendAvg = usageStats.weekdayStats?.weekend.avg || 0;
  const percentageChange = weekdayAvg > 0 ? ((weekendAvg - weekdayAvg) / weekdayAvg) * 100 : 0;

  return (
    <SafeAreaProvider>
      <Animated.ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
        entering={FadeIn.duration(200)}
        scrollEventThrottle={16}
        removeClippedSubviews={true}
      >
        <Header />

        <View style={styles.mainContent}>
          <Section title="Notifications & Medical">
            {showNotification && (
              <NotificationBanner
                averageHits={usageStats.averageHitsPerDay}
                percentageChange={percentageChange}
                onDismiss={() => setShowNotification(false)}
              />
            )}
            <MedicalCard />
          </Section>

          <Section title="Usage Overview">
            <DailyAverageCard
              data={weeklyData}
              averageHits={usageStats.averageHitsPerDay}
              onPress={() => handleNavigation("DAILY_AVERAGE")}
            />
            <WeeklyUsageBanner
              weeklyData={weeklyData}
              average={usageStats.averageHitsPerDay}
              onPress={() => handleNavigation("WEEKLY_AVERAGE")}
            />
          </Section>

          <Section title="Usage Analytics">
            <WeeklyOverviewChart 
              data={weeklyData}
              onPress={() => handleNavigation("WEEKLY_OVERVIEW")}
            />
            <MonthlyOverviewChart 
              data={monthlyData}
              onPress={() => handleNavigation("MONTHLY_OVERVIEW")}
            />
          </Section>

          <Section title="Detailed Statistics">
            <StatsOverviewCard stats={usageStats} />
            <TimeDistributionCard timeData={timeDistribution} />
          </Section>
        </View>
      </Animated.ScrollView>
    </SafeAreaProvider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  mainContent: {
    paddingHorizontal: 20,
  },
});

================================================================================
File: app/(tabs)/trending.tsx
================================================================================

// app/(tabs)/trending.tsx
import React, { useState, useCallback, useEffect, memo, useMemo } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useStrains } from '@/src/hooks/useStrains';
import { COLORS } from '@/src/constants';
import { StrainSearchFilters } from '@/src/services/StrainService';
import { Strain } from '@/src/dbManager';
import { hasActiveFilters } from '@/src/utils/filters';

// Import components from their new structure
import LoadingView from '@/app/components/shared/LoadingView';
import Header from '@/app/components/trending/Header';
import StrainsList from '@/app/components/trending/StrainsList';
import CompareBar from '@/app/components/trending/CompareBar';
import SearchFilters from '@/app/components/trending/SearchFilters';

const TrendingScreen = memo(() => {
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState('');
  const [showFilters, setShowFilters] = useState(false);
  const [compareList, setCompareList] = useState<Strain[]>([]);
  const [filters, setFilters] = useState<StrainSearchFilters>({
    geneticType: undefined,
    effects: [],
    sort: 'rating'
  });

  const { 
    strains,
    popularStrains,
    categories,
    isLoading,
    error,
    searchStrains,
    clearSearch,
    loadMore,
    toggleFavorite,
    isFavorite,
    pagination
  } = useStrains();

  useEffect(() => {
    const delaySearch = setTimeout(() => {
      if (searchQuery.trim() || hasActiveFilters(filters)) {
        searchStrains(searchQuery, filters);
      } else {
        clearSearch();
      }
    }, 300);

    return () => clearTimeout(delaySearch);
  }, [searchQuery, filters, searchStrains, clearSearch]);

  const handleFilterChange = useCallback((newFilters: StrainSearchFilters) => {
    setFilters(newFilters);
  }, []);

  const handleApplyFilters = useCallback(() => {
    setShowFilters(false);
  }, []);

  const handleClearSearch = useCallback(() => {
    setSearchQuery('');
    setFilters({
      geneticType: undefined,
      effects: [],
      sort: 'rating'
    });
    clearSearch();
  }, [clearSearch]);

  const handleCompareToggle = useCallback((strain: Strain) => {
    setCompareList(prev => {
      if (prev.some(s => s.id === strain.id)) {
        return prev.filter(s => s.id !== strain.id);
      }
      if (prev.length >= 3) return prev;
      return [...prev, strain];
    });
  }, []);

  const handleCompare = useCallback(() => {
    if (compareList.length >= 2) {
      router.push({
        pathname: "/strains/compare",
        params: { ids: compareList.map(s => s.id).join(',') }
      } as any);
    }
  }, [compareList, router]);

  // Memoize the displayed strains to prevent unnecessary re-renders
  const displayedStrains = useMemo(() => 
    searchQuery.trim() || hasActiveFilters(filters) ? strains : popularStrains,
    [searchQuery, filters, strains, popularStrains]
  );

  // Memoize the section title
  const sectionTitle = useMemo(() => 
    searchQuery.trim() || hasActiveFilters(filters) 
      ? `Search Results (${pagination.total})`
      : "Popular Strains",
    [searchQuery, filters, pagination.total]
  );

  if (isLoading && !strains.length && !popularStrains.length) {
    return <LoadingView />;
  }

  return (
    <SafeAreaProvider>
      <View style={styles.container}>
        <Header 
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          showFilters={showFilters}
          setShowFilters={setShowFilters}
          filters={filters}
          handleClearSearch={handleClearSearch}
        />

        {showFilters && (
          <View style={styles.filtersContainer}>
            <SearchFilters
              filters={filters}
              onFilterChange={handleFilterChange}
              onApplyFilters={handleApplyFilters}
              categories={categories}
            />
          </View>
        )}

        <View style={styles.listContainer}>
          <Text style={styles.sectionTitle}>{sectionTitle}</Text>
          <StrainsList
            strains={displayedStrains}
            onCompareToggle={handleCompareToggle}
            onFavoriteToggle={toggleFavorite}
            compareList={compareList}
            isFavorite={isFavorite}
            isLoading={isLoading}
            onEndReached={loadMore}
          />
        </View>

        {compareList.length > 0 && (
          <CompareBar
            compareList={compareList}
            onCompareToggle={handleCompareToggle}
            onCompare={handleCompare}
          />
        )}
      </View>
    </SafeAreaProvider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  filtersContainer: {
    paddingHorizontal: 20,
    paddingBottom: 12,
  },
  listContainer: {
    flex: 1,
    paddingHorizontal: 20,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
    marginBottom: 12,
  },
});

export default TrendingScreen;

================================================================================
File: app/components/charts/BarChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '@/src/constants';

interface BarChartProps {
  data: number[];
  labels: string[];
  maxValue?: number;
  barColor?: string;
}

const BarChart: React.FC<BarChartProps> = ({ 
  data, 
  labels, 
  maxValue: propMaxValue, 
  barColor = COLORS.primary
}) => {
  // Calculate maxValue if not provided
  const maxValue = propMaxValue || Math.max(...data) * 1.2; // Add 20% padding
  const chartHeight = 220;
  const divisions = 5; // Number of horizontal lines

  // Generate y-axis labels
  const yAxisLabels = Array.from({ length: divisions + 1 }, (_, i) => {
    const value = (maxValue / divisions) * (divisions - i);
    return Math.round(value).toString();
  });

  return (
    <View style={styles.container}>
      {/* Y-axis labels */}
      <View style={styles.yAxis}>
        {yAxisLabels.map((label, index) => (
          <Text key={index} style={styles.yAxisLabel}>
            {label}
          </Text>
        ))}
      </View>

      {/* Chart area */}
      <View style={styles.chartArea}>
        {/* Horizontal grid lines */}
        {yAxisLabels.map((_, index) => (
          <View 
            key={index} 
            style={[
              styles.gridLine,
              { top: (chartHeight / divisions) * index }
            ]} 
          />
        ))}

        {/* Bars */}
        <View style={styles.barsContainer}>
          {data.map((value, index) => {
            const barHeight = (value / maxValue) * chartHeight;
            
            return (
              <View key={index} style={styles.barWrapper}>
                <View style={styles.barLabelContainer}>
                  <Text style={styles.barValue}>{value}</Text>
                </View>
                <View style={[styles.barBackground, { height: barHeight }]}>
                  <LinearGradient
                    colors={[
                      `${barColor}CC`, // 80% opacity
                      `${barColor}66`, // 40% opacity
                    ]}
                    style={[styles.bar, { height: '100%' }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 0, y: 1 }}
                  />
                </View>
                <Text style={styles.xAxisLabel}>{labels[index]}</Text>
              </View>
            );
          })}
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    height: 280, // Include space for labels
    paddingRight: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 12,
    padding: 16,
  },
  yAxis: {
    width: 50,
    justifyContent: 'space-between',
    marginRight: 10,
  },
  yAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    textAlign: 'right',
  },
  chartArea: {
    flex: 1,
    height: 220,
    position: 'relative',
  },
  gridLine: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  barsContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    height: '100%',
  },
  barWrapper: {
    flex: 1,
    alignItems: 'center',
    height: '100%',
    justifyContent: 'flex-end',
  },
  barLabelContainer: {
    position: 'absolute',
    top: -20,
    width: '100%',
    alignItems: 'center',
  },
  barValue: {
    color: COLORS.text.primary,
    fontSize: 12,
    fontWeight: '600',
  },
  barBackground: {
    width: '60%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
    overflow: 'hidden',
  },
  bar: {
    width: '100%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
  },
  xAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    marginTop: 8,
  },
});

export default BarChart; 

================================================================================
File: app/components/charts/ChartStyles.ts
================================================================================

import { StyleSheet } from 'react-native';
import { COLORS } from '@/src/constants';

const chartStyles = StyleSheet.create({
  card: {
    backgroundColor: COLORS.cardBackground,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 20,
    padding: 20,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 15,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.08)',
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12,
  },
  headerIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: 0.38,
  },
  description: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 20,
    letterSpacing: -0.24,
    lineHeight: 20,
  },
  chartWrapper: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
  },
  chartContainer: {
    borderRadius: 16,
    overflow: 'hidden',
  },
});

export default chartStyles; 

================================================================================
File: app/components/charts/MonthlyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '@/src/types';

interface MonthlyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const MonthlyOverviewChart: React.FC<MonthlyOverviewChartProps> = ({ data, onPress }) => {
  const chartData = {
    labels: data.map(item => item.label),
    datasets: [{
      data: data.map(item => item.value)
    }]
  };

  // Calculate monthly stats
  const totalHits = data.reduce((sum, month) => sum + month.value, 0);
  const avgHits = totalHits / data.length;
  const maxHits = Math.max(...data.map(month => month.value));
  const maxMonth = data.find(month => month.value === maxHits)?.label || '';
  const monthlyGrowth = data.length > 1 
    ? ((data[data.length - 1].value - data[0].value) / data[0].value * 100).toFixed(1)
    : '0';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Monthly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/month average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-areaspline" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Month</Text>
              <Text style={styles.statValue}>{maxMonth}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Growth</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={Number(monthlyGrowth) >= 0 ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(Number(monthlyGrowth))}%
                </Text>
              </View>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Monthly Analysis</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 18,
    fontWeight: '600',
    marginLeft: 4,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default MonthlyOverviewChart; 

================================================================================
File: app/components/charts/WeeklyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '@/src/types';

interface WeeklyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const WeeklyOverviewChart: React.FC<WeeklyOverviewChartProps> = ({ data, onPress }) => {
  const chartData = {
    labels: data.map(item => item.label),
    datasets: [{
      data: data.map(item => item.value)
    }]
  };

  // Calculate weekly stats
  const totalHits = data.reduce((sum, day) => sum + day.value, 0);
  const avgHits = totalHits / 7;
  const maxHits = Math.max(...data.map(day => day.value));
  const maxDay = data.find(day => day.value === maxHits)?.label || '';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Weekly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/day average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-line-variant" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Day</Text>
              <Text style={styles.statValue}>{maxDay}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Max Hits</Text>
              <Text style={styles.statValue}>{maxHits}</Text>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Details</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default WeeklyOverviewChart; 

================================================================================
File: app/components/Header.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { COLORS } from '@/src/constants';

interface HeaderProps {
  title: string;
}

export default function Header({ title }: HeaderProps) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: COLORS.background,
  },
  title: {
    fontSize: 28,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
}); 

================================================================================
File: app/components/mydata/DailyAverageCard.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { ChartDataPoint } from '@/src/types';

interface DailyAverageCardProps {
  data: ChartDataPoint[];
  averageHits: number;
  onPress: () => void;
}

const DailyAverageCard: React.FC<DailyAverageCardProps> = ({ data, averageHits, onPress }) => {
  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Daily Average</Text>
              <Text style={styles.subtitle}>
                {averageHits.toFixed(1)} hits per day
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-bell-curve" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Details</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
    minHeight: 120,
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 20,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  buttonContainer: {
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default DailyAverageCard;

================================================================================
File: app/components/mydata/Header.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';

// Gradient configurations
const gradients = {
  header: ['rgba(0,230,118,0.15)', 'rgba(0,230,118,0.05)', 'transparent'] as const,
};

const Header = memo(() => (
  <View style={styles.headerSection}>
    <LinearGradient
      colors={gradients.header}
      style={styles.headerGradient}
      start={{ x: 0, y: 0 }}
      end={{ x: 0, y: 1 }}
    />
    <View style={styles.headerContent}>
      <Text style={styles.headerTitle}>Summary</Text>
      <View style={styles.profileContainer}>
        <MaterialCommunityIcons 
          name="account" 
          size={24} 
          color={COLORS.primary}
        />
      </View>
    </View>
  </View>
));

const styles = StyleSheet.create({
  headerSection: {
    height: 120,
    position: 'relative',
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    marginBottom: 24,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  profileContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0,230,118,0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.2)',
  },
});

export default Header;

================================================================================
File: app/components/mydata/MedicalCard.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from "expo-linear-gradient";
import { COLORS } from "@/src/constants";

export default function MedicalCard() {
  return (
    <View style={styles.medicalCard}>
      <LinearGradient
        colors={[
          'rgba(0,230,118,0.15)',
          'rgba(0,230,118,0.05)',
          'transparent'
        ]}
        style={styles.cardGradient}
      />
      
      <View style={styles.cardHeader}>
        <MaterialCommunityIcons 
          name="medical-bag" 
          size={24} 
          color={COLORS.primary}
        />
        <Text style={styles.cardHeaderText}>Medical Info</Text>
      </View>

      <View style={styles.medicalStats}>
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>Strain Type</Text>
          <Text style={styles.statValue}>Hybrid</Text>
        </View>
        <View style={styles.statDivider} />
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>THC Content</Text>
          <Text style={styles.statValue}>18-24%</Text>
        </View>
        <View style={styles.statDivider} />
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>CBD Content</Text>
          <Text style={styles.statValue}>0.1%</Text>
        </View>
      </View>

      <TouchableOpacity style={styles.moreDetailsButton}>
        <Text style={styles.moreDetailsText}>View Medical Details</Text>
        <MaterialCommunityIcons 
          name="chevron-right" 
          size={20} 
          color={COLORS.primary}
        />
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  medicalCard: {
    backgroundColor: COLORS.cardBackground,
    width: '100%',
    marginHorizontal: 2,
    marginVertical: 8,
    borderRadius: 16,
    padding: 16,
    overflow: 'hidden',
    position: 'relative',
    
  },
  cardGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  cardHeaderText: {
    fontSize: 17,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 8,
  },
  medicalStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statLabel: {
    fontSize: 13,
    color: COLORS.text.secondary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 17,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  statDivider: {
    width: 1,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginHorizontal: 8,
  },
  moreDetailsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  moreDetailsText: {
    fontSize: 15,
    color: COLORS.primary,
  },
});

================================================================================
File: app/components/mydata/NotificationBanner.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from "@/src/constants";
import Animated, { 
  FadeIn, 
  FadeInDown, 
  FadeOutUp,
  withTiming,
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  Layout
} from 'react-native-reanimated';

interface NotificationProps {
  averageHits: number;
  percentageChange: number;
  onDismiss: () => void;
}

const NotificationBanner: React.FC<NotificationProps> = ({ 
  averageHits, 
  percentageChange, 
  onDismiss 
}) => {
  const isIncrease = percentageChange > 0;
  const statusColor = isIncrease ? '#FF5252' : COLORS.primary;

  // Format percentage to 1 decimal place and handle edge cases
  const formattedPercentage = Math.abs(Number(percentageChange.toFixed(1)));

  // Enhanced gradient combinations with type assertions
  const gradientBase = isIncrease 
    ? ['rgba(255,82,82,0.2)', 'rgba(255,82,82,0.08)', 'transparent'] as const
    : ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.08)', 'transparent'] as const;

  const accentGradient = isIncrease
    ? ['rgba(255,82,82,0.3)', 'rgba(255,82,82,0.15)'] as const
    : ['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.15)'] as const;

  return (
    <Animated.View 
      entering={FadeInDown.springify()}
      exiting={FadeOutUp.springify()}
      layout={Layout.springify()}
      style={styles.container}
    >
      {/* Enhanced Background Gradient */}
      <LinearGradient
        colors={gradientBase}
        style={styles.backgroundGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      {/* Shimmer Effect Layer */}
      <LinearGradient
        colors={['transparent', 'rgba(255,255,255,0.05)', 'transparent'] as const}
        style={styles.shimmerEffect}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      <View style={styles.content}>
        {/* Enhanced Header */}
        <View style={styles.header}>
          <View style={styles.titleRow}>
            <LinearGradient
              colors={accentGradient}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="bell-outline" 
                size={22} 
                color={statusColor}
              />
            </LinearGradient>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Daily Summary</Text>
              <Text style={styles.subtitle}>Last 24 hours</Text>
            </View>
          </View>
          
          <TouchableOpacity 
            onPress={onDismiss}
            style={styles.dismissButton}
          >
            <LinearGradient
              colors={['rgba(255,255,255,0.1)', 'rgba(255,255,255,0.05)'] as const}
              style={styles.dismissGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="close" 
                size={18} 
                color={COLORS.text.secondary}
              />
            </LinearGradient>
          </TouchableOpacity>
        </View>

        {/* Enhanced Stats Container */}
        <View style={styles.statsContainer}>
          <LinearGradient
            colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
            style={styles.statsGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Daily Average</Text>
              <Text style={styles.statValue}>{averageHits.toFixed(1)}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Change</Text>
              <Text style={[styles.statValue, { color: statusColor }]}>
                {isIncrease ? '+' : '-'}{formattedPercentage}%
              </Text>
            </View>
          </LinearGradient>
        </View>

        {/* Status Message */}
        <View style={styles.messageContainer}>
          <LinearGradient
            colors={accentGradient}
            style={styles.statusIcon}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons
              name={isIncrease ? "trending-up" : "trending-down"}
              size={24}
              color={statusColor}
            />
          </LinearGradient>

          <Text style={styles.messageText}>
            {isIncrease 
              ? 'Your daily average has increased compared to last week'
              : 'Your daily average has decreased compared to last week'
            }
          </Text>
        </View>

        {/* Action Button */}
        <TouchableOpacity style={styles.actionButton}>
          <LinearGradient
            colors={[statusColor, `${statusColor}CC`] as const}
            style={styles.actionGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
          >
            <Text style={styles.actionText}>View Details</Text>
            <MaterialCommunityIcons 
              name="chevron-right" 
              size={18} 
              color="#FFF"
            />
          </LinearGradient>
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: COLORS.cardBackground,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    marginBottom: 16,
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 12,
      },
      android: {
        elevation: 8,
      },
    }),
  },
  backgroundGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  shimmerEffect: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.4,
  },
  content: {
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  titleContainer: {
    marginLeft: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 13,
    color: COLORS.text.secondary,
  },
  dismissButton: {
    borderRadius: 15,
    overflow: 'hidden',
  },
  dismissGradient: {
    width: 30,
    height: 30,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 15,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  statsContainer: {
    borderRadius: 16,
    overflow: 'hidden',
    marginBottom: 20,
  },
  statsGradient: {
    flexDirection: 'row',
    padding: 16,
    alignItems: 'center',
    justifyContent: 'space-around',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statLabel: {
    fontSize: 13,
    color: COLORS.text.secondary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  statDivider: {
    width: 1,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginHorizontal: 16,
  },
  messageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.03)',
    padding: 12,
    borderRadius: 12,
  },
  statusIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  messageText: {
    flex: 1,
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
  },
  actionButton: {
    borderRadius: 20,
    overflow: 'hidden',
  },
  actionGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 20,
  },
  actionText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#FFF',
    marginRight: 4,
  },
});

export default NotificationBanner;

================================================================================
File: app/components/mydata/Section.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '@/src/constants';

// Gradient configurations
const gradients = {
  section: ['rgba(0,230,118,0.1)', 'rgba(0,230,118,0.02)', 'transparent'] as const,
  divider: ['rgba(0,230,118,0.1)', 'transparent'] as const,
};

interface SectionProps {
  title: string;
  children: React.ReactNode;
}

const Section = memo(({ title, children }: SectionProps) => (
  <View style={styles.sectionWrapper}>
    <LinearGradient
      colors={gradients.divider}
      style={styles.sectionDivider}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 0 }}
    />
    <View style={styles.section}>
      <LinearGradient
        colors={gradients.section}
        style={styles.sectionGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionTitle}>{title}</Text>
      </View>
      <View style={styles.sectionContent}>
        {children}
      </View>
    </View>
  </View>
));

const styles = StyleSheet.create({
  sectionWrapper: {
    marginBottom: 32,
    position: 'relative',
  },
  sectionDivider: {
    height: 1,
    width: '100%',
    marginBottom: 16,
  },
  section: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(26, 26, 26, 0.85)',
  },
  sectionGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  sectionHeader: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 230, 118, 0.1)',
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  sectionContent: {
    padding: 12,
    gap: 12,
  },
});

export default Section;

================================================================================
File: app/components/mydata/WeeklyUsageBanner.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { ChartDataPoint } from '@/src/types';

interface WeeklyUsageBannerProps {
  weeklyData: ChartDataPoint[];
  average: number;
  onPress: () => void;
}

const WeeklyUsageBanner: React.FC<WeeklyUsageBannerProps> = ({ weeklyData, average, onPress }) => {
  // Calculate the percentage change from last week
  const currentWeekTotal = weeklyData.reduce((sum, day) => sum + day.value, 0);
  const weeklyAverage = currentWeekTotal / 7;
  const percentageChange = ((weeklyAverage - average) / average) * 100;
  
  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Weekly Usage</Text>
              <Text style={styles.subtitle}>
                {weeklyAverage.toFixed(1)} average hits per day
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-timeline-variant" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{currentWeekTotal}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>vs Last Week</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={percentageChange >= 0 ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={percentageChange >= 0 ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: percentageChange >= 0 ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(percentageChange).toFixed(1)}%
                </Text>
              </View>
            </View>
          </View>

          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Weekly Analysis</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
    minHeight: 160,
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 20,
    paddingTop: 8,
  },
  statItem: {
    flex: 1,
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 20,
    fontWeight: '600',
    marginLeft: 4,
  },
  buttonContainer: {
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default WeeklyUsageBanner;

================================================================================
File: app/components/shared/Card.tsx
================================================================================

import React, { forwardRef } from "react";
import { View, StyleSheet, StyleProp, ViewStyle } from "react-native";
import { COLORS } from '@/src/constants';

interface CardProps {
    children: React.ReactNode;
    style?: StyleProp<ViewStyle>;
}

export const Card = forwardRef<View, CardProps>(({ children, style }, ref) => {
    return <View ref={ref} style={[styles.card, style]}>{children}</View>;
});

const styles = StyleSheet.create({
    card: {
        backgroundColor: COLORS.cardBackground,
        borderRadius: 16,
        elevation: 6,
        shadowColor: COLORS.primary,
        shadowOffset: {
            width: 0,
            height: 2,
        },
        shadowOpacity: 0.15,
        shadowRadius: 8,
        padding: 16,
        borderWidth: 1,
        borderColor: 'rgba(0, 230, 118, 0.1)',
    }
});

================================================================================
File: app/components/shared/ErrorView.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '@/src/constants';

interface ErrorViewProps {
  error: string;
}

export default function ErrorView({ error }: ErrorViewProps) {
  return (
    <View style={styles.container}>
      <MaterialCommunityIcons 
        name="alert-circle-outline" 
        size={48} 
        color={COLORS.error} 
      />
      <Text style={styles.title}>Error</Text>
      <Text style={styles.message}>{error}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    marginTop: 16,
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  message: {
    marginTop: 8,
    fontSize: 16,
    color: COLORS.text.secondary,
    textAlign: 'center',
  },
});

================================================================================
File: app/components/shared/LoadingView.tsx
================================================================================

import React, { useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '@/src/constants';
import Animated, { 
  withRepeat, 
  withTiming,
  useAnimatedStyle, 
  useSharedValue,
  FadeIn
} from 'react-native-reanimated';
import { TIMING_CONFIG } from '@/src/utils/animations';

export default function LoadingView() {
  const rotation = useSharedValue(0);

  useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        ...TIMING_CONFIG,
        duration: 1500 // Slightly slower for smoother rotation
      }),
      -1
    );
  }, []);

  const spinStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }]
  }));

  return (
    <View style={styles.container}>
      <Animated.View 
        entering={FadeIn.duration(300)}
        style={styles.content}
      >
        <Animated.View style={spinStyle}>
          <MaterialCommunityIcons 
            name="cannabis" 
            size={32} 
            color={COLORS.primary} 
          />
        </Animated.View>
        <Text style={styles.text}>Loading...</Text>
      </Animated.View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    alignItems: 'center',
    gap: 12,
  },
  text: {
    fontSize: 16,
    color: COLORS.text.secondary,
  },
});

================================================================================
File: app/components/StatsOverviewCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { Card } from "@/components/Card";
import { COLORS } from "@/src/constants";
import { UsageStats } from "@/src/types";
import Animated, { FadeIn } from 'react-native-reanimated';

interface StatsOverviewCardProps {
  stats: UsageStats;
}

function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

const StatsOverviewCard: React.FC<StatsOverviewCardProps> = ({ stats }) => {
  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <LinearGradient
        colors={[
          'rgba(0,230,118,0.15)',
          'rgba(0,230,118,0.05)',
          'transparent'
        ]}
        style={StyleSheet.absoluteFill}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      
      <View style={styles.content}>
        {/* Header */}
        <View style={styles.headerRow}>
          <View style={styles.titleContainer}>
            <Text style={styles.title}>Usage Statistics</Text>
            <Text style={styles.subtitle}>
              Detailed overview of your usage patterns
            </Text>
          </View>
          
          <LinearGradient
            colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
            style={styles.iconContainer}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons 
              name="chart-box-outline" 
              size={24} 
              color={COLORS.primary}
            />
          </LinearGradient>
        </View>

        {/* Hit Counts Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Hit Counts</Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Daily Average</Text>
              <Text style={styles.statValue}>{stats.averageHitsPerDay.toFixed(1)}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Day</Text>
              <Text style={styles.statValue}>{stats.peakDayHits}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{stats.totalHits}</Text>
            </View>
          </View>
        </View>

        {/* Duration Stats Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Duration</Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Average</Text>
              <Text style={styles.statValue}>{formatDuration(stats.averageDuration)}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Longest</Text>
              <Text style={styles.statValue}>{formatDuration(stats.longestHit)}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Shortest</Text>
              <Text style={styles.statValue}>{formatDuration(stats.shortestHit)}</Text>
            </View>
          </View>
        </View>

        {/* Time Patterns Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Activity Patterns</Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Hours</Text>
              <Text style={styles.statValue}>{stats.mostActiveHour}:00</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Quiet Hours</Text>
              <Text style={styles.statValue}>{stats.leastActiveHour}:00</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Consistency</Text>
              <Text style={styles.statValue}>{stats.consistency.toFixed(1)}</Text>
            </View>
          </View>
        </View>

        {/* Weekday vs Weekend */}
        <View style={[styles.section, styles.lastSection]}>
          <Text style={styles.sectionTitle}>Weekly Distribution</Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Weekday Avg</Text>
              <Text style={styles.statValue}>
                {stats.weekdayStats.weekday.avg.toFixed(1)}
              </Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Weekend Avg</Text>
              <Text style={styles.statValue}>
                {stats.weekdayStats.weekend.avg.toFixed(1)}
              </Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Difference</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={stats.weekdayStats.weekend.avg >= stats.weekdayStats.weekday.avg ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={stats.weekdayStats.weekend.avg >= stats.weekdayStats.weekday.avg ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: stats.weekdayStats.weekend.avg >= stats.weekdayStats.weekday.avg ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(((stats.weekdayStats.weekend.avg - stats.weekdayStats.weekday.avg) / stats.weekdayStats.weekday.avg) * 100).toFixed(1)}%
                </Text>
              </View>
            </View>
          </View>
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 24,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  section: {
    marginBottom: 24,
  },
  lastSection: {
    marginBottom: 0,
  },
  sectionTitle: {
    fontSize: 17,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 16,
    letterSpacing: -0.41,
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    flex: 1,
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 18,
    fontWeight: '600',
    marginLeft: 4,
  },
});

export default StatsOverviewCard; 

================================================================================
File: app/components/TimeDistributionCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from "@/src/constants";
import { TimeDistribution } from "@/src/types";
import Animated, { FadeIn } from 'react-native-reanimated';

interface TimeDistributionCardProps {
  timeData: TimeDistribution;
}

type TimeSlot = 'morning' | 'afternoon' | 'evening' | 'night';

const COLORS_MAP: Record<TimeSlot, string> = {
  morning: '#FFB74D',
  afternoon: '#4FC3F7',
  evening: '#7986CB',
  night: '#9575CD',
};

const ICONS_MAP: Record<TimeSlot, keyof typeof MaterialCommunityIcons.glyphMap> = {
  morning: 'weather-sunny',
  afternoon: 'weather-partly-cloudy',
  evening: 'weather-sunset',
  night: 'weather-night',
};

const TimeDistributionCard = ({ timeData }: TimeDistributionCardProps) => {
  const total = Object.values(timeData).reduce((sum, val) => sum + val, 0);

  const TimeSlotComponent = ({ type, value }: { type: TimeSlot; value: number }) => {
    const percentage = total === 0 ? 0 : (value / total) * 100;
    const barWidth = Math.max(0, Math.min(100, percentage));

    return (
      <Animated.View 
        entering={FadeIn.delay(type === 'morning' ? 200 : type === 'afternoon' ? 400 : type === 'evening' ? 600 : 800)}
        style={styles.timeSlot}
      >
        <View style={styles.timeSlotContent}>
          <View style={styles.timeSlotHeader}>
            <LinearGradient
              colors={[`${COLORS_MAP[type]}40`, `${COLORS_MAP[type]}20`]}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name={ICONS_MAP[type]} 
                size={18} 
                color={COLORS_MAP[type]} 
              />
            </LinearGradient>
            <Text style={styles.timeSlotText}>
              {type.charAt(0).toUpperCase() + type.slice(1)}
            </Text>
            <Text style={styles.percentageText}>
              {percentage.toFixed(0)}%
            </Text>
          </View>
          <View style={styles.barContainer}>
            <LinearGradient
              colors={[`${COLORS_MAP[type]}`, `${COLORS_MAP[type]}80`]}
              style={[styles.bar, { width: `${barWidth}%` }]}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
          </View>
        </View>
      </Animated.View>
    );
  };

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <LinearGradient
        colors={[
          'rgba(0,230,118,0.15)',
          'rgba(0,230,118,0.05)',
          'transparent'
        ]}
        style={StyleSheet.absoluteFill}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      
      <View style={styles.content}>
        <View style={styles.headerRow}>
          <View style={styles.titleContainer}>
            <Text style={styles.title}>Time Distribution</Text>
            <Text style={styles.subtitle}>
              Activity patterns throughout the day
            </Text>
          </View>
          
          <LinearGradient
            colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
            style={styles.headerIconContainer}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons 
              name="clock-outline" 
              size={24} 
              color={COLORS.primary}
            />
          </LinearGradient>
        </View>

        <View style={styles.distributionContent}>
          <TimeSlotComponent type="morning" value={timeData.morning} />
          <TimeSlotComponent type="afternoon" value={timeData.afternoon} />
          <TimeSlotComponent type="evening" value={timeData.evening} />
          <TimeSlotComponent type="night" value={timeData.night} />
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 24,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  headerIconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  distributionContent: {
    gap: 16,
  },
  timeSlot: {
    marginBottom: 4,
  },
  timeSlotContent: {
    gap: 8,
  },
  timeSlotHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  timeSlotText: {
    flex: 1,
    fontSize: 15,
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: -0.24,
  },
  percentageText: {
    fontSize: 15,
    fontWeight: '600',
    color: COLORS.text.primary,
    width: 40,
    textAlign: 'right',
    letterSpacing: -0.24,
  },
  barContainer: {
    height: 6,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 3,
    overflow: 'hidden',
    marginTop: 4,
  },
  bar: {
    height: '100%',
    borderRadius: 3,
  },
});

export default TimeDistributionCard; 

================================================================================
File: app/components/trending/CompareBar.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, FlatList } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import { Strain } from '@/src/dbManager';
import Animated, { FadeIn } from 'react-native-reanimated';

interface CompareBarProps {
  compareList: Strain[];
  onCompareToggle: (strain: Strain) => void;
  onCompare: () => void;
}

const CompareBar = memo(({
  compareList,
  onCompareToggle,
  onCompare
}: CompareBarProps) => (
  <Animated.View 
    entering={FadeIn}
    style={styles.compareBar}
  >
    <FlatList
      horizontal
      data={compareList}
      keyExtractor={item => item.id!.toString()}
      renderItem={({ item }) => (
        <View style={styles.compareItem}>
          <Text style={styles.compareItemText}>{item.name}</Text>
          <TouchableOpacity 
            onPress={() => onCompareToggle(item)}
            style={styles.compareItemRemove}
          >
            <MaterialCommunityIcons 
              name="close" 
              size={20} 
              color={COLORS.text.secondary} 
            />
          </TouchableOpacity>
        </View>
      )}
    />
    <TouchableOpacity 
      style={[
        styles.compareButton,
        compareList.length < 2 && styles.compareButtonDisabled
      ]}
      onPress={onCompare}
      disabled={compareList.length < 2}
    >
      <Text style={styles.compareButtonText}>
        Compare ({compareList.length})
      </Text>
    </TouchableOpacity>
  </Animated.View>
));

const styles = StyleSheet.create({
  compareBar: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'rgba(26, 26, 26, 0.95)',
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 230, 118, 0.1)',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    gap: 12,
  },
  compareItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderRadius: 8,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    gap: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  compareItemText: {
    color: COLORS.text.primary,
    fontSize: 14,
    maxWidth: 120,
    letterSpacing: 0.2,
  },
  compareItemRemove: {
    padding: 2,
  },
  compareButton: {
    backgroundColor: COLORS.primary,
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
    opacity: 1,
  },
  compareButtonDisabled: {
    opacity: 0.5,
  },
  compareButtonText: {
    color: COLORS.background,
    fontWeight: '600',
    fontSize: 14,
    letterSpacing: 0.2,
  },
});

export default CompareBar; 

================================================================================
File: app/components/trending/Header.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '@/src/constants';
import SearchBar from './SearchBar';
import { StrainSearchFilters } from '@/src/services/StrainService';

interface HeaderProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  filters: StrainSearchFilters;
  handleClearSearch: () => void;
}

const Header = memo(({ 
  searchQuery, 
  setSearchQuery,
  showFilters,
  setShowFilters,
  filters,
  handleClearSearch 
}: HeaderProps) => (
  <View style={styles.headerSection}>
    <LinearGradient
      colors={['rgba(0,230,118,0.15)', 'rgba(0,230,118,0.05)', 'transparent']}
      style={styles.headerGradient}
      start={{ x: 0, y: 0 }}
      end={{ x: 0, y: 1 }}
    />
    <View style={styles.headerContent}>
      <View>
        <Text style={styles.headerTitle}>Trending</Text>
        <Text style={styles.headerSubtitle}>Discover popular strains</Text>
      </View>
      <SearchBar
        searchQuery={searchQuery}
        setSearchQuery={setSearchQuery}
        showFilters={showFilters}
        setShowFilters={setShowFilters}
        filters={filters}
        onClear={handleClearSearch}
      />
    </View>
  </View>
));

const styles = StyleSheet.create({
  headerSection: {
    height: 120,
    position: 'relative',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.85)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    marginBottom: 24,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  headerSubtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    marginTop: 4,
  },
});

export default Header; 

================================================================================
File: app/components/trending/SearchBar.tsx
================================================================================

import React, { memo } from 'react';
import { View, TextInput, TouchableOpacity, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import { StrainSearchFilters } from '@/src/services/StrainService';
import { hasActiveFilters } from '@/src/utils/filters';

interface SearchBarProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  filters: StrainSearchFilters;
  onClear: () => void;
}

const SearchBar = memo(({
  searchQuery,
  setSearchQuery,
  showFilters,
  setShowFilters,
  filters,
  onClear
}: SearchBarProps) => (
  <View style={styles.searchContainer}>
    <View style={styles.searchBar}>
      <MaterialCommunityIcons 
        name="magnify" 
        size={24} 
        color={COLORS.text.secondary} 
      />
      <TextInput
        style={styles.searchInput}
        placeholder="Search strains..."
        placeholderTextColor={COLORS.text.secondary}
        value={searchQuery}
        onChangeText={setSearchQuery}
        returnKeyType="search"
      />
      {(searchQuery.trim() || hasActiveFilters(filters)) && (
        <TouchableOpacity onPress={onClear}>
          <MaterialCommunityIcons 
            name="close-circle" 
            size={20} 
            color={COLORS.text.secondary} 
          />
        </TouchableOpacity>
      )}
    </View>

    <TouchableOpacity 
      style={[
        styles.filterButton, 
        showFilters && styles.filterButtonActive,
        hasActiveFilters(filters) && styles.filterButtonHasFilters
      ]} 
      onPress={() => setShowFilters(!showFilters)}
    >
      <MaterialCommunityIcons 
        name="filter-variant" 
        size={24} 
        color={
          showFilters || hasActiveFilters(filters)
            ? COLORS.primary 
            : COLORS.text.secondary
        } 
      />
    </TouchableOpacity>
  </View>
));

const styles = StyleSheet.create({
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
    marginTop: 16,
  },
  searchBar: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderRadius: 12,
    paddingHorizontal: 12,
    height: 44,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  searchInput: {
    flex: 1,
    color: COLORS.text.primary,
    fontSize: 16,
    marginLeft: 8,
    padding: 0,
  },
  filterButton: {
    width: 44,
    height: 44,
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  filterButtonActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  filterButtonHasFilters: {
    borderColor: COLORS.primary,
  },
});

export default SearchBar; 

================================================================================
File: app/components/trending/SearchFilters.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import { StrainSearchFilters } from '@/src/services/StrainService';
import { LinearGradient } from 'expo-linear-gradient';

interface SearchFiltersProps {
  filters: StrainSearchFilters;
  onFilterChange: (filters: StrainSearchFilters) => void;
  onApplyFilters: () => void;
  categories: { [key: string]: number };
}

const SORT_OPTIONS = [
  { key: 'rating', label: 'Rating', icon: 'star' },
  { key: 'name', label: 'Name', icon: 'sort-alphabetical-ascending' },
  { key: 'thc', label: 'THC', icon: 'percent' },
] as const;

const COMMON_EFFECTS = [
  'Relaxed',
  'Energetic',
  'Creative',
  'Focused',
  'Euphoric',
  'Sleepy',
  'Happy',
  'Uplifted'
];

export default function SearchFilters({ 
  filters, 
  onFilterChange, 
  onApplyFilters,
  categories 
}: SearchFiltersProps) {
  const [localFilters, setLocalFilters] = useState<StrainSearchFilters>(filters);

  const handleSortChange = (sort: StrainSearchFilters['sort']) => {
    setLocalFilters(prev => ({ ...prev, sort }));
  };

  const handleEffectToggle = (effect: string) => {
    const currentEffects = localFilters.effects || [];
    const newEffects = currentEffects.includes(effect)
      ? currentEffects.filter(e => e !== effect)
      : [...currentEffects, effect];
    setLocalFilters(prev => ({ ...prev, effects: newEffects }));
  };

  const handleGeneticTypeChange = (geneticType: string | undefined) => {
    setLocalFilters(prev => ({ ...prev, geneticType }));
  };

  const handleApply = () => {
    onFilterChange(localFilters);
    onApplyFilters();
  };

  return (
    <View style={styles.container}>
      {/* Sort Options */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Sort By</Text>
        <View style={styles.sortOptions}>
          {SORT_OPTIONS.map(({ key, label, icon }) => (
            <TouchableOpacity
              key={key}
              style={[
                styles.sortOption,
                localFilters.sort === key && styles.sortOptionActive
              ]}
              onPress={() => handleSortChange(key)}
            >
              <MaterialCommunityIcons
                name={icon}
                size={18}
                color={localFilters.sort === key ? COLORS.primary : COLORS.text.secondary}
              />
              <Text style={[
                styles.sortOptionText,
                localFilters.sort === key && styles.sortOptionTextActive
              ]}>
                {label}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Genetic Types */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Genetic Type</Text>
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          style={styles.geneticTypes}
        >
          <TouchableOpacity
            style={[
              styles.typeChip,
              !localFilters.geneticType && styles.typeChipActive
            ]}
            onPress={() => handleGeneticTypeChange(undefined)}
          >
            <Text style={[
              styles.typeChipText,
              !localFilters.geneticType && styles.typeChipTextActive
            ]}>
              All
            </Text>
          </TouchableOpacity>
          {Object.entries(categories).map(([type, count]) => (
            <TouchableOpacity
              key={type}
              style={[
                styles.typeChip,
                localFilters.geneticType === type && styles.typeChipActive
              ]}
              onPress={() => handleGeneticTypeChange(type)}
            >
              <Text style={[
                styles.typeChipText,
                localFilters.geneticType === type && styles.typeChipTextActive
              ]}>
                {type} ({count})
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>

      {/* Effects */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Effects</Text>
        <View style={styles.effectsGrid}>
          {COMMON_EFFECTS.map(effect => (
            <TouchableOpacity
              key={effect}
              style={[
                styles.effectChip,
                (localFilters.effects || []).includes(effect) && styles.effectChipActive
              ]}
              onPress={() => handleEffectToggle(effect)}
            >
              <Text style={[
                styles.effectChipText,
                (localFilters.effects || []).includes(effect) && styles.effectChipTextActive
              ]}>
                {effect}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Apply Button */}
      <TouchableOpacity 
        style={styles.applyButton}
        onPress={handleApply}
      >
        <LinearGradient
          colors={[COLORS.primary, COLORS.primaryDark]}
          style={styles.applyButtonGradient}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          <Text style={styles.applyButtonText}>Apply Filters</Text>
          <MaterialCommunityIcons 
            name="check" 
            size={20} 
            color="#FFF" 
          />
        </LinearGradient>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 12,
    padding: 16,
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  sortOptions: {
    flexDirection: 'row',
    gap: 12,
  },
  sortOption: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    gap: 6,
  },
  sortOptionActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  sortOptionText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  sortOptionTextActive: {
    color: COLORS.primary,
  },
  geneticTypes: {
    flexDirection: 'row',
  },
  typeChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    marginRight: 8,
  },
  typeChipActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  typeChipText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  typeChipTextActive: {
    color: COLORS.primary,
  },
  effectsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  effectChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  effectChipActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  effectChipText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  effectChipTextActive: {
    color: COLORS.primary,
  },
  applyButton: {
    marginTop: 20,
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  applyButtonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 8,
    width: '100%',
  },
  applyButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFF',
    marginRight: 8,
  },
});

================================================================================
File: app/components/trending/Section.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '@/src/constants';

interface SectionProps {
  title: string;
  children: React.ReactNode;
}

const Section = memo(({ title, children }: SectionProps) => (
  <View style={styles.sectionWrapper}>
    <LinearGradient
      colors={['rgba(0,230,118,0.1)', 'transparent']}
      style={styles.sectionDivider}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 0 }}
    />
    <View style={styles.section}>
      <LinearGradient
        colors={['rgba(0,230,118,0.1)', 'rgba(0,230,118,0.02)', 'transparent']}
        style={styles.sectionGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionTitle}>{title}</Text>
      </View>
      <View style={styles.sectionContent}>
        {children}
      </View>
    </View>
  </View>
));

const styles = StyleSheet.create({
  sectionWrapper: {
    marginBottom: 32,
    position: 'relative',
  },
  sectionDivider: {
    height: 1,
    width: '100%',
    marginBottom: 16,
  },
  section: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.75)',
      android: 'rgba(26, 26, 26, 0.9)',
    }),
  },
  sectionGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  sectionHeader: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 230, 118, 0.1)',
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  sectionContent: {
    padding: 12,
    gap: 12,
  },
});

export default Section; 

================================================================================
File: app/components/trending/StrainsList.tsx
================================================================================

import React, { memo, useCallback, useRef } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, FlatList, Platform } from 'react-native';
import { useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '@/src/constants';
import { Strain } from '@/src/dbManager';
import Animated, { FadeIn } from 'react-native-reanimated';
import LoadingView from '@/app/components/shared/LoadingView';

interface StrainsListProps {
  strains: Strain[];
  onCompareToggle: (strain: Strain) => void;
  onFavoriteToggle: (strainId: number) => void;
  compareList: Strain[];
  isFavorite: (strainId: number) => boolean;
  isLoading: boolean;
  onEndReached: () => void;
}

// Approximate height for optimization
const ITEM_HEIGHT = 180;

export const StrainsList = memo(({
  strains,
  onCompareToggle,
  onFavoriteToggle,
  compareList,
  isFavorite,
  isLoading,
  onEndReached,
}: StrainsListProps) => {
  const router = useRouter();

  // Optimize with useCallback and useRef
  const renderStrainItem = useCallback(({ item: strain }: { item: Strain }) => (
    <Animated.View 
      entering={FadeIn.duration(300)}
      style={styles.strainItem}
    >
      <TouchableOpacity
        onPress={() => router.push({
          pathname: "/strains/details",
          params: { id: strain.id }
        } as any)}
      >
        <LinearGradient
          colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.05)', 'rgba(0,230,118,0)']}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
          style={StyleSheet.absoluteFill}
        />
        
        <View style={styles.strainContent}>
          <View style={styles.strainHeader}>
            <Text style={styles.strainName}>{strain.name}</Text>
            <Text style={styles.rating}>{strain.combined_rating.toFixed(1)}</Text>
          </View>

          <Text style={styles.strainType}>{strain.genetic_type}</Text>
          <Text numberOfLines={2} style={styles.strainDescription}>
            {strain.overview}
          </Text>

          <View style={styles.actionButtons}>
            <TouchableOpacity 
              onPress={() => onFavoriteToggle(strain.id!)}
              style={styles.actionButton}
            >
              <MaterialCommunityIcons 
                name={isFavorite(strain.id!) ? "heart" : "heart-outline"} 
                size={24} 
                color={isFavorite(strain.id!) ? COLORS.primary : COLORS.text.secondary} 
              />
            </TouchableOpacity>
            
            <TouchableOpacity 
              onPress={() => onCompareToggle(strain)}
              style={styles.actionButton}
              disabled={compareList.length >= 3 && !compareList.some(s => s.id === strain.id)}
            >
              <MaterialCommunityIcons 
                name={compareList.some(s => s.id === strain.id) ? "compare" : "compare-horizontal"} 
                size={24} 
                color={compareList.some(s => s.id === strain.id) ? COLORS.primary : COLORS.text.secondary} 
              />
            </TouchableOpacity>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  ), [onCompareToggle, onFavoriteToggle, compareList, isFavorite, router]);

  const keyExtractor = useCallback((item: Strain) => 
    item.id!.toString()
  , []);

  // Optional performance optimizations
  const getItemLayout = useRef((data: any, index: number) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index + (index * 12), // account for gap
    index,
  })).current;

  if (!strains.length && !isLoading) {
    return (
      <View style={styles.emptyContainer}>
        <MaterialCommunityIcons 
          name="cannabis" 
          size={48} 
          color={COLORS.text.secondary} 
        />
        <Text style={styles.emptyText}>
          No strains found matching your criteria
        </Text>
      </View>
    );
  }

  return (
    <FlatList
      data={strains}
      renderItem={renderStrainItem}
      keyExtractor={keyExtractor}
      contentContainerStyle={styles.content}
      onEndReached={onEndReached}
      onEndReachedThreshold={0.5}
      ListFooterComponent={
        isLoading ? <LoadingView /> : null
      }
      // Performance optimizations
      initialNumToRender={8}
      maxToRenderPerBatch={5}
      windowSize={5}
      removeClippedSubviews={Platform.OS === 'android'}
      getItemLayout={getItemLayout}
      updateCellsBatchingPeriod={50}
    />
  );
});

const styles = StyleSheet.create({
  content: {
    gap: 12,
  },
  strainItem: {
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderRadius: 12,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  strainContent: {
    padding: 16,
  },
  strainHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  strainName: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.3,
  },
  rating: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.primary,
  },
  strainType: {
    fontSize: 14,
    color: COLORS.text.secondary,
    marginBottom: 4,
  },
  strainDescription: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    lineHeight: 20,
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 12,
    marginTop: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 230, 118, 0.1)',
    paddingTop: 12,
  },
  actionButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 20,
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  emptyContainer: {
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
    gap: 16,
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  emptyText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    textAlign: 'center',
    letterSpacing: 0.2,
  },
});

export default StrainsList;

================================================================================
File: app/mydata/_layout.tsx
================================================================================

import { Stack } from 'expo-router';

export default function MyDataLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="daily-average" 
        options={{ 
          title: "Daily Average",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="weekly-average" 
        options={{ 
          title: "Weekly Average",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="weekly-overview" 
        options={{ 
          title: "Weekly Overview",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="monthly-overview" 
        options={{ 
          title: "Monthly Overview",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
    </Stack>
  );
}

================================================================================
File: app/mydata/daily-average.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { COLORS } from '@/src/constants';

export default function DailyAverageOverview() {
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Daily Average Overview
      </Text>
    </View>
  );
}

================================================================================
File: app/mydata/monthly-overview.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { COLORS } from '@/src/constants';

export default function MonthlyOverview() {
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Monthly Overview
      </Text>
    </View>
  );
}

================================================================================
File: app/mydata/weekly-average.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { COLORS } from '@/src/constants';

export default function WeeklyAverage() {
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Weekly Average
      </Text>
    </View>
  );
}

================================================================================
File: app/mydata/weekly-overview.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { COLORS } from '@/src/constants';

export default function WeeklyOverview() {
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Weekly Overview
      </Text>
    </View>
  );
}

================================================================================
File: app/strains/_layout.tsx
================================================================================

import { Stack } from 'expo-router';

export default function StrainsLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="popular" 
        options={{ 
          title: "Popular Strains",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="details" 
        options={{ 
          title: "Strain Details",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="compare" 
        options={{ 
          title: "Compare Strains",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
    </Stack>
  );
}

================================================================================
File: app/strains/compare.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
import { COLORS } from '@/src/constants';

export default function CompareStrains() {
  const { ids } = useLocalSearchParams();
  const strainIds = typeof ids === 'string' ? ids.split(',') : [];
  
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Compare Strains
      </Text>
      <Text style={{ color: COLORS.text.secondary, marginTop: 8 }}>
        Comparing IDs: {strainIds.join(', ')}
      </Text>
    </View>
  );
}

================================================================================
File: app/strains/details.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
import { COLORS } from '@/src/constants';

export default function StrainDetails() {
  const { id } = useLocalSearchParams();
  
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Strain Details for ID: {id}
      </Text>
    </View>
  );
}

================================================================================
File: app/strains/popular.tsx
================================================================================

import React from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList,
  TouchableOpacity,
  Platform 
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';

// Define strain type
interface Strain {
  id: string;
  name: string;
  description: string;
  thcContent?: string;
  type: 'sativa' | 'indica' | 'hybrid';
}

// Sample data
const strains: Strain[] = [
  { 
    id: '1', 
    name: 'Blue Dream', 
    description: 'Hybrid strain with sweet berry aroma',
    thcContent: '18-24%',
    type: 'hybrid'
  },
  { 
    id: '2', 
    name: 'OG Kush', 
    description: 'Classic strain with earthy pine scent',
    thcContent: '20-25%',
    type: 'hybrid'
  },
  { 
    id: '3', 
    name: 'Gorilla Glue', 
    description: 'Powerful hybrid with diesel notes',
    thcContent: '25-28%',
    type: 'hybrid'
  },
  { 
    id: '4', 
    name: 'Gelato', 
    description: 'Sweet and creamy hybrid strain',
    thcContent: '17-22%',
    type: 'hybrid'
  },
  { 
    id: '5', 
    name: 'Sour Diesel', 
    description: 'Energetic sativa with diesel aroma',
    thcContent: '19-25%',
    type: 'sativa'
  }
];

const PopularStrains = () => {
  const router = useRouter();

  const renderItem = ({ item }: { item: Strain }) => (
    <TouchableOpacity 
      style={styles.strainItem}
      onPress={() => router.push(`/strains/${item.id}`)}
    >
      <View style={styles.iconContainer}>
        <MaterialCommunityIcons name="cannabis" size={24} color="#fff" />
      </View>
      <View style={styles.textContainer}>
        <Text style={styles.strainName}>{item.name}</Text>
        <Text style={styles.strainDescription}>{item.description}</Text>
        {item.thcContent && (
          <Text style={styles.thcContent}>THC: {item.thcContent}</Text>
        )}
      </View>
      <MaterialCommunityIcons 
        name="chevron-right" 
        size={24} 
        color={colors.label.secondary} 
      />
    </TouchableOpacity>
  );

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <MaterialCommunityIcons 
            name="chevron-left" 
            size={28} 
            color={colors.label.primary} 
          />
        </TouchableOpacity>
        <Text style={styles.headerText}>Popular Strains</Text>
      </View>
      <FlatList
        data={strains}
        renderItem={renderItem}
        keyExtractor={item => item.id}
        contentContainerStyle={styles.listContainer}
        showsVerticalScrollIndicator={false}
      />
    </SafeAreaView>
  );
};

const colors = {
  label: {
    primary: "#FFFFFF",
    secondary: "#8E8E93",
    tertiary: "#636366",
  },
  background: {
    primary: "#000000",
    secondary: "#1C1C1E",
    tertiary: "#2C2C2E",
  }
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background.primary,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    paddingTop: 8,
    borderBottomWidth: 1,
    borderBottomColor: colors.background.secondary,
  },
  backButton: {
    marginRight: 8,
    padding: 4,
  },
  headerText: {
    fontSize: 24,
    fontWeight: Platform.select({ ios: '600', android: 'bold' }),
    color: colors.label.primary,
  },
  listContainer: {
    padding: 16,
  },
  strainItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    backgroundColor: colors.background.secondary,
    borderRadius: 12,
    marginBottom: 12,
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: colors.background.tertiary,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  textContainer: {
    flex: 1,
  },
  strainName: {
    fontSize: 17,
    fontWeight: Platform.select({ ios: '600', android: 'bold' }),
    color: colors.label.primary,
    marginBottom: 4,
  },
  strainDescription: {
    fontSize: 14,
    color: colors.label.secondary,
    marginBottom: 4,
  },
  thcContent: {
    fontSize: 12,
    color: colors.label.tertiary,
    fontWeight: '500',
  },
});

export default PopularStrains; 

================================================================================
File: components/charts/WeeklyOverviewChart.tsx
================================================================================

import { Card } from "@/components/Card";
import { StyleSheet, View, Text, Dimensions } from "react-native";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { BarChart } from "react-native-chart-kit";
import { LinearGradient } from "expo-linear-gradient";
import { Datapoint } from "@/src/types";
import { useMemo } from "react";

// Keep COLORS here for now, we'll move it to constants later
const COLORS = {
  background: '#000000',
  cardBackground: '#1A1A1A',
  primary: '#00E676',       // Neon green 
  primaryLight: '#69F0AE',  // Light neon green
  primaryDark: '#00C853',   // Darker green
  text: {
    primary: '#FFFFFF',
    secondary: '#FFFFFFCC',  // 80% white
    tertiary: '#FFFFFF99',   // 60% white
  },
  chart: {
    primary: '#00E676',
    secondary: '#69F0AE',
    background: '#1A1A1A',
  },
  gradientColors: {
    start: 'rgba(0,230,118,0.4)',
    middle: 'rgba(105,240,174,0.2)',
    end: 'rgba(0,0,0,0)',
  }
};

const windowWidth = Dimensions.get("window").width;

interface WeeklyOverviewChartProps {
  data: Datapoint[];
  onPress?: () => void;
}

export function WeeklyOverviewChart({ data }: WeeklyOverviewChartProps) {
  // Memoize the chart width calculation
  const chartWidth = useMemo(() => Math.max(windowWidth - 64, 200), [windowWidth]);

  // Base chart config with optimizations
  const baseChartConfig = useMemo(() => ({
    backgroundColor: COLORS.chart.background,
    backgroundGradientFrom: COLORS.chart.background,
    backgroundGradientTo: COLORS.chart.background,
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
    labelColor: (opacity = 0.8) => `rgba(255, 255, 255, ${opacity})`,
    barPercentage: 0.7,
    useShadowColorFromDataset: false,
    withInnerLines: false,
    withVerticalLabels: true,
    withHorizontalLabels: true,
    withVerticalLines: false,
    withHorizontalLines: true,
    propsForBackgroundLines: {
      stroke: COLORS.text.tertiary,
      strokeWidth: 1,
    },
    propsForDots: {
      r: "4",
      strokeWidth: "2",
      stroke: COLORS.primaryLight,
    },
    style: {
      borderRadius: 16,
    },
    formatYLabel: (value: string) => Math.round(Number(value)).toString(),
    formatXLabel: (label: string) => label.substring(0, 3),
    segments: 4,
  }), []);

  // Memoize the data transformation
  const chartData = useMemo(() => ({
    labels: data.map((d) => d.label),
    datasets: [{ 
      data: data.map((d) => d.value),
      color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
      strokeWidth: 2,
    }]
  }), [data]);

  if (!data?.length) {
    return (
      <Card style={styles.card}>
        <View style={styles.cardHeader}>
          <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
          <Text style={styles.cardTitle}>Weekly Overview</Text>
        </View>
        <View style={styles.chartContainer}>
          <Text style={styles.noDataText}>No data available</Text>
        </View>
      </Card>
    );
  }

  return (
    <Card style={styles.card}>
      <View style={styles.cardHeader}>
        <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
        <Text style={styles.cardTitle}>Weekly Overview</Text>
      </View>
      <Text style={styles.cardDescription}>Compare your usage across different days</Text>
      <View style={styles.chartContainer}>
        <LinearGradient
          colors={[
            COLORS.gradientColors.start,
            COLORS.gradientColors.middle,
            COLORS.gradientColors.end
          ]}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
          style={styles.chartGradient}
        />
        <BarChart
          data={chartData}
          width={chartWidth}
          height={180}
          chartConfig={baseChartConfig}
          style={styles.chart}
          showValuesOnTopOfBars
          fromZero
          segments={4}
          flatColor={true}
          withCustomBarColorFromData={true}
        />
      </View>
    </Card>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#1A1A1A',
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 16,
    padding: 16,
    shadowColor: '#00E676',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  cardTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 10,
  },
  cardDescription: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 16,
    lineHeight: 20,
  },
  chartContainer: {
    marginTop: 16,
    alignItems: "center",
    paddingHorizontal: 8,
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 4,
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
    backgroundColor: COLORS.cardBackground,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 6,
  },
  chartGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 16,
  },
  noDataText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    padding: 20,
  }
}); 

================================================================================
File: components/Leaderboard.tsx
================================================================================

import React from 'react';
import { View, Text, FlatList, StyleSheet } from 'react-native';

interface LeaderboardEntry {
  id: string;
  name: string;
  score: number;
}

interface LeaderboardProps {
  data: LeaderboardEntry[];
  title: string;
}

const Leaderboard: React.FC<LeaderboardProps> = ({ title, data }) => {
  const renderItem = ({ item, index }: { item: LeaderboardEntry; index: number }) => (
    <View style={[styles.row, index === 0 ? styles.topRank : {}]}>
      <Text style={styles.rank}>{index + 1}</Text>
      <Text style={styles.name}>{item.name}</Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
      <FlatList
        data={data.sort((a, b) => b.score - a.score)} // Sort by score in descending order
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        ListEmptyComponent={<Text style={styles.empty}>No entries yet!</Text>}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 16,
    color: '#333',
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    marginVertical: 4,
    backgroundColor: '#fff',
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  topRank: {
    backgroundColor: '#ffd700', // Gold for top rank
  },
  rank: {
    fontSize: 18,
    fontWeight: 'bold',
    width: 40,
    textAlign: 'center',
  },
  name: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginLeft: 8,
  },
  score: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#12a35f',
  },
  empty: {
    textAlign: 'center',
    fontSize: 16,
    color: '#aaa',
    marginTop: 20,
  },
});

export default Leaderboard;

================================================================================
File: package.json
================================================================================

{
  "name": "canovareactnativeapp",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "expo": "~52.0.23",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.3",
    "expo-dev-client": "~5.0.8",
    "expo-device": "^7.0.2",
    "expo-font": "~13.0.2",
    "expo-haptics": "~14.0.0",
    "expo-linear-gradient": "~14.0.2",
    "expo-linking": "~7.0.3",
    "expo-router": "~4.0.15",
    "expo-splash-screen": "~0.29.18",
    "expo-sqlite": "~15.1.2",
    "expo-status-bar": "~2.0.0",
    "expo-symbols": "~0.2.0",
    "expo-system-ui": "~4.0.6",
    "expo-web-browser": "~14.0.1",
    "lucide-react": "^0.475.0",
    "papaparse": "^5.5.2",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.5",
    "react-native-base64": "^0.2.1",
    "react-native-ble-plx": "^3.4.0",
    "react-native-calendars": "^1.1308.0",
    "react-native-chart-kit": "^6.12.0",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "^15.10.1",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@react-native-community/cli": "latest",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-native-base64": "^0.2.2",
    "@types/react-test-renderer": "^18.3.0",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.2",
    "react-test-renderer": "18.3.1",
    "typescript": "^5.3.3"
  },
  "private": true
}


================================================================================
File: src/constants.ts
================================================================================

export const BONG_HITS_DATABASE_NAME: string = "BongHits";
export const SAVED_DEVICES_DATABASE_NAME: string = "SavedDevices";
export const STRAINS_DATABASE_NAME: string = "Strains";

export const dayLookUpTable = new Map<number, string>()
dayLookUpTable.set(0, "Sun");
dayLookUpTable.set(1, "Mon");
dayLookUpTable.set(2, "Tue");
dayLookUpTable.set(3, "Wed");
dayLookUpTable.set(4, "Thu");
dayLookUpTable.set(5, "Fri");
dayLookUpTable.set(6, "Sat");

// Function to generate strain insert statements
export function getStrainInsertStatements(): string {
  return '';  // Empty implementation for now
}

export const COLORS = {
  background: '#000000',
  cardBackground: '#1A1A1A',
  primary: '#00E676',       // Neon green 
  primaryLight: '#69F0AE',  // Light neon green
  primaryDark: '#00C853',   // Darker green
  text: {
    primary: '#FFFFFF',
    secondary: '#FFFFFFCC',  // 80% white
    tertiary: '#FFFFFF99',   // 60% white
  },
  chart: {
    primary: '#00E676',
    secondary: '#69F0AE',
    background: '#1A1A1A',
  },
  gradientColors: {
    start: 'rgba(0,230,118,0.4)',
    middle: 'rgba(105,240,174,0.2)',
    end: 'rgba(0,0,0,0)',
  }
};

/**
 * Stupid goofy hardcoded function for testing
 * https://www.mockaroo.com/
 * @returns 
 */
export function getInsertStatements(): string {
    return(`
insert into BongHits (timestamp, duration_ms) values ('2024-12-26 18:28:33', 27050);
insert into BongHits (timestamp, duration_ms) values ('2025-01-03 03:31:57', 12228);
insert into BongHits (timestamp, duration_ms) values ('2024-12-30 23:51:43', 13319);
insert into BongHits (timestamp, duration_ms) values ('2024-12-28 17:23:17', 18857);
insert into BongHits (timestamp, duration_ms) values ('2024-12-30 11:04:59', 10164);
insert into BongHits (timestamp, duration_ms) values ('2025-01-05 12:15:16', 17533);
insert into BongHits (timestamp, duration_ms) values ('2024-12-24 14:02:16', 6253);
insert into BongHits (timestamp, duration_ms) values ('2024-12-29 08:19:24', 16822);
insert into BongHits (timestamp, duration_ms) values ('2024-12-26 08:59:23', 22545);
insert into BongHits (timestamp, duration_ms) values ('2025-01-03 00:18:00', 8259);
insert into BongHits (timestamp, duration_ms) values ('2024-12-24 04:04:13', 2611);
insert into BongHits (timestamp, duration_ms) values ('2025-01-03 07:48:33', 22620);
insert into BongHits (timestamp, duration_ms) values ('2024-12-24 21:38:17', 15988);
insert into BongHits (timestamp, duration_ms) values ('2024-12-25 14:01:32', 22414);
insert into BongHits (timestamp, duration_ms) values ('2024-12-31 01:11:03', 15364);
insert into BongHits (timestamp, duration_ms) values ('2024-12-30 15:27:55', 4427);
insert into BongHits (timestamp, duration_ms) values ('2024-12-31 20:31:00', 4238);
insert into BongHits (timestamp, duration_ms) values ('2024-12-29 06:22:38', 15957);
insert into BongHits (timestamp, duration_ms) values ('2024-12-31 14:39:58', 26633);
insert into BongHits (timestamp, duration_ms) values ('2024-12-26 08:48:03', 13728);
insert into BongHits (timestamp, duration_ms) values ('2024-12-26 08:49:51', 15266);
insert into BongHits (timestamp, duration_ms) values ('2024-12-25 20:12:41', 28871);
insert into BongHits (timestamp, duration_ms) values ('2024-12-24 10:54:11', 21137);
insert into BongHits (timestamp, duration_ms) values ('2025-01-01 19:39:11', 15547);
insert into BongHits (timestamp, duration_ms) values ('2024-12-31 23:10:19', 26405);
insert into BongHits (timestamp, duration_ms) values ('2025-01-04 23:16:18', 26609);
insert into BongHits (timestamp, duration_ms) values ('2025-01-05 00:47:56', 14683);
insert into BongHits (timestamp, duration_ms) values ('2025-01-01 12:40:53', 8349);
insert into BongHits (timestamp, duration_ms) values ('2025-01-05 13:22:24', 2529);
insert into BongHits (timestamp, duration_ms) values ('2025-01-02 05:51:30', 27163);
insert into BongHits (timestamp, duration_ms) values ('2025-01-03 18:13:22', 2017);
insert into BongHits (timestamp, duration_ms) values ('2024-12-27 14:04:39', 16879);
insert into BongHits (timestamp, duration_ms) values ('2024-12-30 19:32:07', 21005);
insert into BongHits (timestamp, duration_ms) values ('2025-01-05 14:58:39', 11376);
insert into BongHits (timestamp, duration_ms) values ('2024-12-31 12:38:21', 10324);
insert into BongHits (timestamp, duration_ms) values ('2024-12-26 11:38:52', 12010);
insert into BongHits (timestamp, duration_ms) values ('2025-01-04 22:09:03', 25025);

insert into BongHits (timestamp, duration_ms) values ('2024-12-28 15:13:36', 10003);
`)
}

export function getStrainsCSV(): string {
  return `"Strain Name","Overview","Genetic Type","Lineage","THC Range","CBD Level","Dominant Terpenes","Qualitative Insights","Effects","Negatives","Uses","THC-Based Potency Rating (1-10)","User Rating (1-10)","Combined Potency / User Rating (1-10)"
"Chernobyl","Hybrid strain with an earthy, pungent aroma and a balanced mix of cerebral and body effects.","Hybrid","Unknown (landrace blend)","16-20%","Low","Myrcene, Caryophyllene","Earthy, spicy aroma; compact, dense buds","Balanced, Euphoric, Relaxed","dry mouth, dry eyes","Ideal for daytime use and mild pain relief","6.5","6.25","6.38"
"sia Lemon","Sativa-dominant hybrid blending citrus and earthy flavors for an energizing, creative high.","Sativa-dominant Hybrid","Amnesia x Lemon Skunk","18-24%","Low","Limonene, Terpinolene","Bright lemon aroma with earthy undertones; light, airy buds","Energized, Uplifted, Creative","dry mouth, anxiety","Great for daytime creativity and mood boost","8","8","8.00"
"Forbidden Jack","Hybrid strain merging tropical fruit notes with a potent, balanced high for a unique experience.","Hybrid","Forbidden Fruit x Jack Herer","19-25%","Low","Limonene, Caryophyllene","Tropical, fruity aroma with spicy hints; resinous buds","Euphoric, Relaxed, Creative","dry mouth, drowsiness","Ideal for creative sessions and stress relief","8.5","8.25","8.38"
`;
}


export const SAMPLE_STRAINS = [
  
  
  {
    name: "Forbidden Jack",
    overview: "Hybrid strain merging tropical fruit notes with a potent, balanced high for a unique experience.",
    genetic_type: "Hybrid",
    lineage: "Forbidden Fruit x Jack Herer",
    thc_range: "19-25%",
    cbd_level: "Low",
    dominant_terpenes: "Limonene, Caryophyllene",
    qualitative_insights: "Tropical, fruity aroma with spicy hints; resinous buds",
    effects: "Euphoric, Relaxed, Creative",
    negatives: "dry mouth, drowsiness",
    uses: "Ideal for creative sessions and stress relief",
    thc_rating: 8.5,
    user_rating: 8.25,
    combined_rating: 8.38
  }
];

================================================================================
File: src/contexts/BluetoothContext.ts
================================================================================

import { createContext, useContext } from "react";
import { PermissionsAndroid, Platform } from "react-native";
import * as ExpoDevice from "expo-device";
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';

type ConnectedDevice = {
    device: Device;
    serviceUUID: string;
    characteristicUUID: string
}

export class BluetoothHandler {
    private manager: BleManager;
    private connectedDevice: ConnectedDevice | null;

    constructor() {
        this.manager = new BleManager();
        this.connectedDevice = null;
    }

    public async connectToDevice(device: Device) {
        if (this.connectedDevice !== null) {
            // TODO: decide how to handle new connection when device is already connected
            return;
        }
        try {
            const deviceConnection: Device = await this.manager.connectToDevice(device.id);
            await deviceConnection.discoverAllServicesAndCharacteristics();
            const services = await deviceConnection.services();
            if (services.length !== 1) {
                throw Error("Bad number of services");
            }

            const service = services[0];
            const characteristics = await service.characteristics();
            if (characteristics.length !== 1) {
                throw Error("Bad number of characteristics");
            }
            const characteristic = characteristics[0];
            this.connectedDevice = {
                device: deviceConnection,
                serviceUUID: service.uuid,
                characteristicUUID: characteristic.uuid
            }

        } catch (error) {
            console.error('Error discovering services/characteristics:', error);
        } finally {
            this.manager.stopDeviceScan();
        }
    }

    public disconnectFromDevice(connectedDevice: Device) {
        if (connectedDevice) {
            this.manager.cancelDeviceConnection(connectedDevice.id);
          }
    }

    public streamOnConnectedDevice(streamListener: (error: BleError | null, characteristic: Characteristic | null) => void) {
        if (this.connectedDevice === null) {
            throw Error("Tried to stream with no device connected");
        } 
        this.connectedDevice.device.monitorCharacteristicForService(
            this.connectedDevice.serviceUUID,
            this.connectedDevice.characteristicUUID,
            streamListener
          );
    }

    public getBLEManager(): BleManager {
        return this.manager;
    }

    public getConnectedDevice(): Device | undefined {
        return this.connectedDevice?.device;
    }

    public getSavedDevices(): Device[] {
        // TODO query database
        return [];
    }

    /*
     * Requests bluetooth permissions, accounting for platform differences
     */
    private async requestPermissions() {
        if (Platform.OS === "android") {
            if ((ExpoDevice.platformApiLevel ?? -1) < 31) {
                // Android version below 31
                const granted = await PermissionsAndroid.request(
                    PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
                    {
                        title: "Location Permission",
                        message: "Bluetooth Low Energy requires Location",
                        buttonPositive: "OK",
                    }
                );
                return granted === PermissionsAndroid.RESULTS.GRANTED;
            } else {
                // Android version above 31
                const isAndroid31PermissionsGranted = await this.requestAndroid31Permissions();

                return isAndroid31PermissionsGranted;
            }
        } else {
            //ios
            return true;
        }
    }

    private async requestAndroid31Permissions() {
        const bluetoothScanPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_SCAN,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );
        const bluetoothConnectPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_CONNECT,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );
        const fineLocationPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );

        return (
            bluetoothScanPermission === "granted" &&
            bluetoothConnectPermission === "granted" &&
            fineLocationPermission === "granted"
        );
    }
}

export const BluetoothContext = createContext<BluetoothHandler | undefined>(undefined);


================================================================================
File: src/dbManager.ts
================================================================================

// File: src/dbManager.ts

import AsyncStorage from "@react-native-async-storage/async-storage";
import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import {
  BONG_HITS_DATABASE_NAME,
  SAVED_DEVICES_DATABASE_NAME,
  STRAINS_DATABASE_NAME,
  getInsertStatements,
  getStrainInsertStatements,
  SAMPLE_STRAINS
} from "./constants";
import { BongHitStats, Datapoint, AverageHourCount } from "./types";

const FIRST_LAUNCH_KEY = "hasLaunched";

export interface Strain {
  id?: number;
  name: string;
  overview: string;
  genetic_type: string;
  lineage: string;
  thc_range: string;
  cbd_level: string;
  dominant_terpenes: string;
  qualitative_insights: string;
  effects: string;
  negatives: string;
  uses: string;
  thc_rating: number;
  user_rating: number;
  combined_rating: number;
  created_at?: string;
}

/**
 * Checks if the application is launching for the first time.
 */
export async function isFirstLaunch(): Promise<boolean> {
  try {
    return (await AsyncStorage.getItem(FIRST_LAUNCH_KEY)) === null;
  } catch (error) {
    console.error('[dbManager] Error checking first launch:', error);
    return false;
  }
}

/**
 * Called on first launch to run any initial setup (e.g. DB creation).
 */
export async function initializeAppOnFirstLaunch() {
  try {
    await AsyncStorage.setItem(FIRST_LAUNCH_KEY, "true");
    await initializeDatabase();
  } catch (error) {
    console.error('[dbManager] Error initializing app:', error);
    throw error;
  }
}

/**
 * Initializes all databases and tables with initial data.
 */
async function initializeDatabase(): Promise<void> {
  try {
    console.log('[dbManager] Starting database initialization...');

    // Initialize BongHits database
    const bongHitsDb = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    await bongHitsDb.execAsync(
      'PRAGMA journal_mode = WAL;' +
      `CREATE TABLE IF NOT EXISTS ${BONG_HITS_DATABASE_NAME} (
        timestamp TIMESTAMP PRIMARY KEY NOT NULL,
        duration_ms INTEGER NOT NULL
      );` +
      `CREATE INDEX IF NOT EXISTS idx_timestamp 
      ON ${BONG_HITS_DATABASE_NAME}(timestamp);` +
      getInsertStatements()
    );
    console.log('[dbManager] BongHits database initialized');

    // Initialize SavedDevices database
    const savedDevicesDb = await openDatabaseAsync(SAVED_DEVICES_DATABASE_NAME);
    await savedDevicesDb.execAsync(
      'PRAGMA journal_mode = WAL;' +
      `CREATE TABLE IF NOT EXISTS ${SAVED_DEVICES_DATABASE_NAME} (
        uuid TEXT PRIMARY KEY NOT NULL,
        name TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );` +
      `CREATE INDEX IF NOT EXISTS idx_device_name 
      ON ${SAVED_DEVICES_DATABASE_NAME}(name);`
    );
    console.log('[dbManager] SavedDevices database initialized');

    // Initialize Strains database
    const strainsDb = await openDatabaseAsync(STRAINS_DATABASE_NAME);
    await strainsDb.execAsync(
      'PRAGMA journal_mode = WAL;' +
      `CREATE TABLE IF NOT EXISTS ${STRAINS_DATABASE_NAME} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        overview TEXT,
        genetic_type TEXT,
        lineage TEXT,
        thc_range TEXT,
        cbd_level TEXT,
        dominant_terpenes TEXT,
        qualitative_insights TEXT,
        effects TEXT,
        negatives TEXT,
        uses TEXT,
        thc_rating REAL,
        user_rating REAL,
        combined_rating REAL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );` +
      `CREATE INDEX IF NOT EXISTS idx_strain_name 
      ON ${STRAINS_DATABASE_NAME}(name);` +
      `CREATE INDEX IF NOT EXISTS idx_strain_genetic_type 
      ON ${STRAINS_DATABASE_NAME}(genetic_type);` +
      `CREATE INDEX IF NOT EXISTS idx_strain_effects 
      ON ${STRAINS_DATABASE_NAME}(effects);` +
      `CREATE INDEX IF NOT EXISTS idx_strain_rating 
      ON ${STRAINS_DATABASE_NAME}(combined_rating DESC);`
    );

    // Insert sample strain data
    await insertStrainData(strainsDb);
    console.log('[dbManager] Strains database initialized');

    console.log('[dbManager] All databases initialized successfully');
  } catch (error) {
    console.error('[dbManager] Error initializing databases:', error);
    throw error;
  }
}

/**
 * Inserts sample strain data into the database
 */
async function insertStrainData(db: SQLiteDatabase): Promise<void> {
  try {
    console.log('[dbManager] Starting strain data insertion...');
    
    // Insert strains in batches for better performance
    const batchSize = 50;
    for (let i = 0; i < SAMPLE_STRAINS.length; i += batchSize) {
      const batch = SAMPLE_STRAINS.slice(i, i + batchSize);
      
      const placeholders = batch.map(() => 
        '(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
      ).join(',');

      const values = batch.flatMap((strain: Strain) => [
        strain.name,
        strain.overview,
        strain.genetic_type,
        strain.lineage,
        strain.thc_range,
        strain.cbd_level,
        strain.dominant_terpenes,
        strain.qualitative_insights,
        strain.effects,
        strain.negatives,
        strain.uses,
        strain.thc_rating,
        strain.user_rating,
        strain.combined_rating
      ]);

      await db.execAsync(
        `INSERT OR IGNORE INTO ${STRAINS_DATABASE_NAME} (
          name, overview, genetic_type, lineage, thc_range,
          cbd_level, dominant_terpenes, qualitative_insights,
          effects, negatives, uses, thc_rating,
          user_rating, combined_rating
        ) VALUES ${placeholders}`,
        values
      );
    }

    console.log('[dbManager] Strain data insertion completed');
  } catch (error) {
    console.error('[dbManager] Error inserting strain data:', error);
    throw error;
  }
}

/* ------------------------------------------------------------------
   Helpers to validate results before returning them
 ------------------------------------------------------------------ */

const validateBongHitStats = (stats: BongHitStats): BongHitStats => ({
  averageDuration: Math.max(0, Number(stats.averageDuration) || 0),
  longestHit: Math.max(0, Number(stats.longestHit) || 0),
});

const validateDatapoint = (point: Datapoint): Datapoint => ({
  label: String(point.label || ""),
  value: Math.max(0, Number(point.value) || 0),
});

const validateAverageHourCount = (count: AverageHourCount): AverageHourCount => ({
  hourOfDay: String(count.hourOfDay || "00"),
  count: Math.max(0, Number(count.count) || 0),
});

/* ------------------------------------------------------------------
   Data-Fetching / Query Functions
   (Now using execAsync, parse the result sets)
 ------------------------------------------------------------------ */

/**
 * Retrieves average and max duration over the past 7 days.
 */
export async function getBongHitStatsFromPastWeek(): Promise<BongHitStats> {
  try {
    const db: SQLiteDatabase = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    const results = await db.execAsync(`
      SELECT
        AVG(duration_ms) AS avg_duration,
        MAX(duration_ms) AS max_duration
      FROM ${BONG_HITS_DATABASE_NAME}
      WHERE timestamp >= DATETIME('now', '-7 days')
    `);

    // execAsync returns an array of result sets; we only have one query
    const row = results[0]?.rows?._array[0];
    if (!row) {
      // Fallback if no data
      return validateBongHitStats({ averageDuration: 0, longestHit: 0 });
    }

    return validateBongHitStats({
      averageDuration: row.avg_duration,
      longestHit: row.max_duration,
    });
  } catch (error) {
    console.error("Error in getBongHitStatsFromPastWeek:", error);
    throw error;
  }
}

/**
 * Counts hits per day over the past week (filling day indices 0..6).
 */
export async function queryNumberOfHitsFromPastWeek(): Promise<Datapoint[]> {
  try {
    const db: SQLiteDatabase = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    const results = await db.execAsync(`
      SELECT 
        strftime('%w', timestamp) AS day,
        COUNT(*) AS hit_count
      FROM ${BONG_HITS_DATABASE_NAME}
      WHERE timestamp >= '2024-12-24'
      GROUP BY day
      ORDER BY day;
    `);

    const rows = results[0]?.rows?._array || [];
    console.log("Weekly query results:", rows);

    // Prepare an array for Sunday..Saturday
    const weekData: Datapoint[] = Array.from({ length: 7 }, (_, i) => ({
      label: dayLookUpTable.get(i) || "",
      value: 0,
    }));

    rows.forEach((row: any) => {
      const dayIndex = parseInt(row.day, 10);
      if (dayIndex >= 0 && dayIndex < 7) {
        weekData[dayIndex] = validateDatapoint({
          label: dayLookUpTable.get(dayIndex) || "",
          value: row.hit_count,
        });
      }
    });

    return weekData;
  } catch (error) {
    console.error("Error in queryNumberOfHitsFromPastWeek:", error);
    throw error;
  }
}

/**
 * Returns a list of (hourOfDay -> # of hits) since 2024-12-24,
 * filling missing hours with 0.
 */
export async function getDailyAverageDatapoints(): Promise<AverageHourCount[]> {
  try {
    const db: SQLiteDatabase = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    const results = await db.execAsync(`
      SELECT 
        strftime('%H', timestamp) AS hourOfDay,
        COUNT(*) AS count
      FROM ${BONG_HITS_DATABASE_NAME}
      WHERE timestamp >= '2024-12-24'
      GROUP BY hourOfDay
      ORDER BY hourOfDay
    `);

    const rows = results[0]?.rows?._array || [];
    // Hours "00" through "23"
    const allHours = Array.from({ length: 24 }, (_, i) => i.toString().padStart(2, "0"));
    const dataMap = new Map<string, number>(
      rows.map((item: any) => [item.hourOfDay, item.count])
    );

    return allHours.map((hour) =>
      validateAverageHourCount({
        hourOfDay: hour,
        count: dataMap.get(hour) || 0,
      })
    );
  } catch (error) {
    console.error("Error in getDailyAverageDatapoints:", error);
    throw error;
  }
}

/**
 * Generic function to get data based on a time range (D=Day, W=Week, M=Month).
 * Returns both chartData and some aggregated stats.
 */
export async function getDailyStats(timeRange: string) {
  let query = "";

  switch (timeRange) {
    case "D":
      query = `
        SELECT strftime('%H', timestamp) as label,
               COUNT(*) as value,
               AVG(duration_ms) as avg_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE date(timestamp) = date('now')
        GROUP BY label
        ORDER BY label
      `;
      break;
    case "W":
      query = `
        SELECT strftime('%w', timestamp) as label,
               COUNT(*) as value,
               AVG(duration_ms) as avg_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= date('now', '-7 days')
        GROUP BY label
        ORDER BY label
      `;
      break;
    case "M":
      query = `
        SELECT strftime('%d', timestamp) as label,
               COUNT(*) as value,
               AVG(duration_ms) as avg_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= date('now', '-30 days')
        GROUP BY label
        ORDER BY label
      `;
      break;
    default:
      // fallback same as 'D'
      query = `
        SELECT strftime('%H', timestamp) as label,
               COUNT(*) as value,
               AVG(duration_ms) as avg_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE date(timestamp) = date('now')
        GROUP BY label
        ORDER BY label
      `;
  }

  try {
    const db: SQLiteDatabase = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    const results = await db.execAsync(query);
    const rows = results[0]?.rows?._array || [];

    // Build chart data
    const chartData = {
      labels: rows.map((r: any) => `${r.label}h`),
      datasets: [
        {
          data: rows.map((r: any) => r.value),
          color: (opacity = 1) => `rgba(0, 122, 255, ${opacity})`,
          strokeWidth: 2,
        },
      ],
      legend: ["Hits"],
    };

    // Build aggregated stats
    // If no rows, handle safely
    if (!rows.length) {
      return {
        chartData,
        stats: {
          avgDuration: 0,
          totalHits: 0,
          peakHour: null,
        },
      };
    }

    const avgDuration =
      rows.reduce((acc: number, curr: any) => acc + curr.avg_duration, 0) /
      rows.length;
    const totalHits = rows.reduce((acc: number, curr: any) => acc + curr.value, 0);
    const peak = rows.reduce((a: any, b: any) => (a.value > b.value ? a : b));
    const peakHour = peak.label;

    return {
      chartData,
      stats: {
        avgDuration,
        totalHits,
        peakHour,
      },
    };
  } catch (error) {
    console.error("Error in getDailyStats:", error);
    throw error;
  }
}

// Export query functions


================================================================================
File: src/hooks/useDataService.ts
================================================================================

import { useState, useEffect } from 'react';
import { DataService } from '@/src/services/DataService';
import { DataState, ChartDataPoint, UsageStats, WeekdayStats } from '@/src/types';

const DEFAULT_STATE: DataState = {
  weeklyData: [],
  monthlyData: [],
  usageStats: {
    averageHitsPerDay: 0,
    totalHits: 0,
    peakDayHits: 0,
    lowestDayHits: 0,
    averageDuration: 0,
    longestHit: 0,
    shortestHit: 0,
    mostActiveHour: 0,
    leastActiveHour: 0,
    totalDuration: 0,
    averageHitsPerHour: 0,
    consistency: 0,
    weekdayStats: {
      weekday: { avg: 0, total: 0 },
      weekend: { avg: 0, total: 0 }
    }
  },
  timeDistribution: {
    morning: 0,
    afternoon: 0,
    evening: 0,
    night: 0
  },
  isLoading: true,
  error: null
};

export function useDataService() {
  const [state, setState] = useState<DataState>(DEFAULT_STATE);

  useEffect(() => {
    let isMounted = true;
    const service = DataService.getInstance();

    const loadData = async () => {
      try {
        // Log for debugging
        console.log('[useDataService] Starting data fetch...');

        // Set initial loading state
        if (!isMounted) return;
        setState(prev => ({ ...prev, isLoading: true, error: null }));

        // Fetch data sequentially to avoid race conditions
        console.log('[useDataService] Fetching weekly stats...');
        const weeklyStats = await service.getWeeklyStats();
        if (!isMounted) return;
        console.log('[useDataService] Weekly stats:', weeklyStats);

        console.log('[useDataService] Fetching monthly stats...');
        const monthlyStats = await service.getMonthlyStats();
        if (!isMounted) return;
        console.log('[useDataService] Monthly stats:', monthlyStats);

        console.log('[useDataService] Fetching usage stats...');
        const usageStats = await service.getUsageStats();
        if (!isMounted) return;
        console.log('[useDataService] Usage stats:', usageStats);

        console.log('[useDataService] Fetching time distribution...');
        const timeDistribution = await service.getTimeDistribution();
        if (!isMounted) return;
        console.log('[useDataService] Time distribution:', timeDistribution);

        // Collect any errors from the responses
        const errors: string[] = [];
        if (!weeklyStats.success) errors.push(`Weekly stats: ${weeklyStats.error}`);
        if (!monthlyStats.success) errors.push(`Monthly stats: ${monthlyStats.error}`);
        if (!usageStats.success) errors.push(`Usage stats: ${usageStats.error}`);
        if (!timeDistribution.success) errors.push(`Time distribution: ${timeDistribution.error}`);

        if (errors.length > 0) {
          const errorMessage = errors.join('; ');
          console.error('[useDataService] Data fetch errors:', errorMessage);
          if (isMounted) {
            setState(prev => ({
              ...prev,
              isLoading: false,
              error: errorMessage
            }));
          }
          return;
        }

        // Update state only if all requests succeeded and component is mounted
        console.log('[useDataService] All data fetched successfully, updating state...');
        if (isMounted) {
          setState({
            ...DEFAULT_STATE,
            weeklyData: weeklyStats.data!,
            monthlyData: monthlyStats.data!,
            usageStats: {
              ...DEFAULT_STATE.usageStats,
              ...usageStats.data!
            },
            timeDistribution: timeDistribution.data!,
            isLoading: false,
            error: null
          });
        }
      } catch (error) {
        console.error('[useDataService] Unexpected error in loadData:', error);
        if (isMounted) {
          setState(prev => ({
            ...prev,
            isLoading: false,
            error: error instanceof Error ? error.message : 'An unexpected error occurred while fetching data'
          }));
        }
      }
    };

    loadData();

    return () => {
      console.log('[useDataService] Cleaning up...');
      isMounted = false;
      service.cleanup().catch(error => {
        console.error('[useDataService] Error during cleanup:', error);
      });
    };
  }, []); // Empty dependency array as we only want to run this once

  return state;
} 

================================================================================
File: src/hooks/useStrains.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import StrainService, { StrainSearchFilters } from '../services/StrainService';
import { Strain } from '../dbManager';

export interface UseStrainState {
  strains: Strain[];
  popularStrains: Strain[];
  categories: { [key: string]: number };
  isLoading: boolean;
  error: string | null;
  pagination: {
    total: number;
    currentPage: number;
    totalPages: number;
    hasMore: boolean;
  };
}

export interface UseStrainActions {
  searchStrains: (query: string, filters: StrainSearchFilters) => Promise<void>;
  loadMore: () => void;
  toggleFavorite: (strainId: number) => Promise<void>;
  isFavorite: (strainId: number) => boolean;
  clearSearch: () => void;
  getStrainDetails: (id: number) => Promise<Strain | null>;
  getRelatedStrains: (strain: Strain) => Promise<Strain[]>;
}

const INITIAL_STATE: UseStrainState = {
  strains: [],
  popularStrains: [],
  categories: {},
  isLoading: false,
  error: null,
  pagination: {
    total: 0,
    currentPage: 1,
    totalPages: 1,
    hasMore: false
  }
};

export function useStrains(): UseStrainState & UseStrainActions {
  const [state, setState] = useState<UseStrainState>(INITIAL_STATE);
  const [filters, setFilters] = useState<StrainSearchFilters>({});
  const [favoriteStrains, setFavoriteStrains] = useState<number[]>([]);

  // Load initial data
  useEffect(() => {
    loadInitialData();
  }, []);

  const loadInitialData = async () => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      
      const [popularStrains, categories] = await Promise.all([
        StrainService.getPopularStrains(),
        StrainService.getStrainCategories()
      ]);

      setState(prev => ({
        ...prev,
        popularStrains,
        categories,
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Failed to load initial data',
        isLoading: false
      }));
    }
  };

  const searchStrains = useCallback(async (
    query: string,
    newFilters: StrainSearchFilters = {},
    page: number = 1
  ) => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      setFilters(newFilters);

      const result = await StrainService.searchStrains(query, newFilters, { page, limit: 10 });

      setState(prev => ({
        ...prev,
        strains: page === 1 ? result.data : [...prev.strains, ...result.data],
        pagination: {
          total: result.total,
          currentPage: result.currentPage,
          totalPages: result.totalPages,
          hasMore: result.hasMore
        },
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Search failed',
        isLoading: false
      }));
    }
  }, []);

  const loadMore = useCallback(() => {
    if (state.pagination.hasMore && !state.isLoading) {
      const nextPage = state.pagination.currentPage + 1;
      searchStrains('', filters, nextPage);
    }
  }, [state.pagination, state.isLoading, filters, searchStrains]);

  const toggleFavorite = useCallback(async (strainId: number) => {
    setFavoriteStrains(prev => {
      const isFavorited = prev.includes(strainId);
      return isFavorited 
        ? prev.filter(id => id !== strainId)
        : [...prev, strainId];
    });
  }, []);

  const isFavorite = useCallback((strainId: number) => {
    return favoriteStrains.includes(strainId);
  }, [favoriteStrains]);

  const clearSearch = useCallback(() => {
    setState(prev => ({
      ...prev,
      strains: [],
      pagination: {
        total: 0,
        currentPage: 1,
        totalPages: 1,
        hasMore: false
      }
    }));
  }, []);

  const getStrainDetails = useCallback(async (id: number): Promise<Strain | null> => {
    try {
      return await StrainService.getStrainById(id);
    } catch (error) {
      console.error('[useStrains] Error getting strain details:', error);
      return null;
    }
  }, []);

  const getRelatedStrains = useCallback(async (strain: Strain): Promise<Strain[]> => {
    try {
      return await StrainService.getRelatedStrains(strain);
    } catch (error) {
      console.error('[useStrains] Error getting related strains:', error);
      return [];
    }
  }, []);

  return {
    ...state,
    searchStrains,
    loadMore,
    toggleFavorite,
    isFavorite,
    clearSearch,
    getStrainDetails,
    getRelatedStrains
  };
} 

================================================================================
File: src/services/DataService.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import { 
  BongHit, 
  ChartDataPoint, 
  DatabaseResponse, 
  UsageStats,
  TimeDistribution,
  DatabaseRow 
} from "@/src/types";
import { BONG_HITS_DATABASE_NAME, dayLookUpTable, getInsertStatements } from "@/src/constants";

interface CountResult {
  count: number;
}

export class DataService {
  private static instance: DataService;
  private db: SQLiteDatabase | null = null;
  private initializationPromise: Promise<void> | null = null;
  
  private constructor() {}

  static getInstance(): DataService {
    if (!DataService.instance) {
      DataService.instance = new DataService();
    }
    return DataService.instance;
  }

  private async initialize(): Promise<void> {
    try {
      console.log('[DataService] Initializing database...');
      this.db = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);

      // Set up database with proper schema and mock data
      await this.db.execAsync(`
        PRAGMA journal_mode = WAL;
        
        DROP TABLE IF EXISTS ${BONG_HITS_DATABASE_NAME};
        
        CREATE TABLE IF NOT EXISTS ${BONG_HITS_DATABASE_NAME} (
          timestamp TIMESTAMP PRIMARY KEY NOT NULL,
          duration_ms INTEGER NOT NULL
        );
        
        CREATE INDEX IF NOT EXISTS idx_timestamp 
        ON ${BONG_HITS_DATABASE_NAME}(timestamp);
      `.concat(getInsertStatements()));

      // Verify data was inserted
      const [countResult] = await this.db.getAllAsync<CountResult>('SELECT COUNT(*) as count FROM ' + BONG_HITS_DATABASE_NAME);
      console.log('[DataService] Initialized database with', countResult.count, 'records');

    } catch (error) {
      console.error('[DataService] Failed to initialize database:', error);
      this.db = null;
      throw error;
    }
  }

  private async getDatabase(): Promise<SQLiteDatabase> {
    if (!this.db) {
      if (!this.initializationPromise) {
        this.initializationPromise = this.initialize();
      }
      await this.initializationPromise;
      this.initializationPromise = null;
    }

    if (!this.db) {
      throw new Error('Database initialization failed');
    }

    // Verify database has data
    const [countResult] = await this.db.getAllAsync<CountResult>(`
      SELECT COUNT(*) as count FROM ${BONG_HITS_DATABASE_NAME}
    `);
    console.log('[DataService] Current database record count:', countResult.count);

    return this.db;
  }

  private handleError<T>(error: unknown, operation: string): DatabaseResponse<T> {
    const errorMessage = error instanceof Error ? error.message : `Failed to ${operation}`;
    console.error(`[DataService] Error in ${operation}:`, error);
    return {
      success: false,
      error: errorMessage
    };
  }

  private validateWeeklyData(data: DatabaseRow[]): ChartDataPoint[] {
    console.log('[DataService] Validating weekly data:', data);
    const weekData = Array.from({ length: 7 }, (_, i) => ({
      label: dayLookUpTable.get(i) || "",
      value: 0
    }));
    
    data.forEach(row => {
      const dayIndex = Number(row.day);
      if (dayIndex >= 0 && dayIndex < 7) {
        weekData[dayIndex].value = Number(row.hit_count || 0);
      }
    });
    
    console.log('[DataService] Validated weekly data:', weekData);
    return weekData;
  }

  private validateMonthlyData(data: DatabaseRow[]): ChartDataPoint[] {
    console.log('[DataService] Validating monthly data:', data);
    const monthlyData = data.map(row => ({
      label: new Date(2024, Number(row.month) - 1).toLocaleString('default', { month: 'short' }),
      value: Number(row.hit_count || 0)
    }));
    console.log('[DataService] Validated monthly data:', monthlyData);
    return monthlyData;
  }

  async getWeeklyStats(): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      console.log('[DataService] Fetching weekly stats...');
      const db = await this.getDatabase();
      const results = await db.getAllAsync<DatabaseRow>(`
        SELECT 
          strftime('%w', timestamp) as day,
          COUNT(*) as hit_count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY day
        ORDER BY day
      `);

      console.log('[DataService] Raw weekly results:', results);

      if (!results?.length) {
        console.log('[DataService] No weekly data found, returning empty dataset');
        return {
          success: true,
          data: Array.from({ length: 7 }, (_, i) => ({
            label: dayLookUpTable.get(i) || "",
            value: 0
          }))
        };
      }

      const validatedData = this.validateWeeklyData(results);
      return {
        success: true,
        data: validatedData
      };

    } catch (error) {
      return this.handleError(error, 'getWeeklyStats');
    }
  }

  async getMonthlyStats(): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      console.log('[DataService] Fetching monthly stats...');
      const db = await this.getDatabase();
      const results = await db.getAllAsync<DatabaseRow>(`
        SELECT 
          strftime('%m', timestamp) as month,
          COUNT(*) as hit_count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY month
        ORDER BY month
      `);

      console.log('[DataService] Raw monthly results:', results);

      if (!results?.length) {
        console.log('[DataService] No monthly data found, returning empty dataset');
        return {
          success: true,
          data: Array.from({ length: 12 }, (_, i) => ({
            label: new Date(2024, i).toLocaleString('default', { month: 'short' }),
            value: 0
          }))
        };
      }

      const validatedData = this.validateMonthlyData(results);
      return {
        success: true,
        data: validatedData
      };

    } catch (error) {
      return this.handleError(error, 'getMonthlyStats');
    }
  }

  async getUsageStats(): Promise<DatabaseResponse<UsageStats>> {
    try {
      console.log('[DataService] Fetching usage stats...');
      const db = await this.getDatabase();
      
      // First get daily hits to calculate variance
      const dailyHitsQuery = `
        SELECT COUNT(*) as daily_hits
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY strftime('%Y-%m-%d', timestamp)
      `;

      const dailyHits = await db.getAllAsync<{ daily_hits: number }>(dailyHitsQuery);
      const dailyHitsArray = dailyHits.map(row => Number(row.daily_hits));
      const mean = dailyHitsArray.reduce((sum, val) => sum + val, 0) / dailyHitsArray.length;
      const variance = dailyHitsArray.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / dailyHitsArray.length;
      const consistency = Math.sqrt(variance);
      
      const query = `
        WITH DailyStats AS (
          SELECT 
            strftime('%Y-%m-%d', timestamp) as day,
            strftime('%w', timestamp) as weekday,
            COUNT(*) as daily_hits,
            AVG(duration_ms) as avg_duration_per_day,
            MIN(duration_ms) as min_duration,
            MAX(duration_ms) as max_duration,
            SUM(duration_ms) as total_duration_per_day
          FROM ${BONG_HITS_DATABASE_NAME}
          WHERE timestamp >= '2024-12-24'
          GROUP BY day
        ),
        WeekdayStats AS (
          SELECT
            CASE WHEN weekday IN ('0', '6') THEN 'weekend' ELSE 'weekday' END as day_type,
            AVG(daily_hits) as avg_hits,
            SUM(daily_hits) as total_hits
          FROM DailyStats
          GROUP BY day_type
        ),
        HourlyStats AS (
          SELECT 
            strftime('%H', timestamp) as hour,
            COUNT(*) as hits
          FROM ${BONG_HITS_DATABASE_NAME}
          WHERE timestamp >= '2024-12-24'
          GROUP BY hour
          ORDER BY hits DESC
        )
        SELECT 
          ROUND(AVG(d.daily_hits), 2) as average_hits_per_day,
          MAX(d.daily_hits) as peak_day_hits,
          MIN(d.daily_hits) as lowest_day_hits,
          SUM(d.daily_hits) as total_hits,
          ROUND(AVG(d.avg_duration_per_day), 2) as avg_duration,
          MIN(d.min_duration) as shortest_hit,
          MAX(d.max_duration) as longest_hit,
          SUM(d.total_duration_per_day) as total_duration,
          (SELECT hour FROM HourlyStats LIMIT 1) as most_active_hour,
          (SELECT hour FROM HourlyStats ORDER BY hits ASC LIMIT 1) as least_active_hour,
          ROUND((SELECT AVG(hits) FROM HourlyStats), 2) as avg_hits_per_hour,
          (SELECT avg_hits FROM WeekdayStats WHERE day_type = 'weekday') as weekday_avg,
          (SELECT total_hits FROM WeekdayStats WHERE day_type = 'weekday') as weekday_total,
          (SELECT avg_hits FROM WeekdayStats WHERE day_type = 'weekend') as weekend_avg,
          (SELECT total_hits FROM WeekdayStats WHERE day_type = 'weekend') as weekend_total
        FROM DailyStats d
      `;

      const [result] = await db.getAllAsync<DatabaseRow>(query);
      console.log('[DataService] Raw usage stats:', result);

      if (!result) {
        return {
          success: true,
          data: {
            averageHitsPerDay: 0,
            totalHits: 0,
            peakDayHits: 0,
            lowestDayHits: 0,
            averageDuration: 0,
            longestHit: 0,
            shortestHit: 0,
            mostActiveHour: 0,
            leastActiveHour: 0,
            totalDuration: 0,
            averageHitsPerHour: 0,
            consistency: 0,
            weekdayStats: {
              weekday: { avg: 0, total: 0 },
              weekend: { avg: 0, total: 0 }
            }
          }
        };
      }

      const stats: UsageStats = {
        averageHitsPerDay: Number(result.average_hits_per_day || 0),
        totalHits: Number(result.total_hits || 0),
        peakDayHits: Number(result.peak_day_hits || 0),
        lowestDayHits: Number(result.lowest_day_hits || 0),
        averageDuration: Number(result.avg_duration || 0),
        longestHit: Number(result.longest_hit || 0),
        shortestHit: Number(result.shortest_hit || 0),
        mostActiveHour: Number(result.most_active_hour || 0),
        leastActiveHour: Number(result.least_active_hour || 0),
        totalDuration: Number(result.total_duration || 0),
        averageHitsPerHour: Number(result.avg_hits_per_hour || 0),
        consistency: Math.round(consistency * 100) / 100,
        weekdayStats: {
          weekday: {
            avg: Number(result.weekday_avg || 0),
            total: Number(result.weekday_total || 0)
          },
          weekend: {
            avg: Number(result.weekend_avg || 0),
            total: Number(result.weekend_total || 0)
          }
        }
      };

      console.log('[DataService] Processed usage stats:', stats);
      return { success: true, data: stats };
    } catch (error) {
      return this.handleError(error, 'getUsageStats');
    }
  }

  async getTimeDistribution(): Promise<DatabaseResponse<TimeDistribution>> {
    try {
      const db = await this.getDatabase();
      const query = `
        WITH HourlyHits AS (
          SELECT 
            CAST(strftime('%H', timestamp) AS INTEGER) as hour,
            COUNT(*) as hits
          FROM ${BONG_HITS_DATABASE_NAME}
          WHERE timestamp >= '2024-12-24'
          GROUP BY hour
        )
        SELECT 
          SUM(CASE WHEN hour BETWEEN 6 AND 11 THEN hits ELSE 0 END) as morning,
          SUM(CASE WHEN hour BETWEEN 12 AND 17 THEN hits ELSE 0 END) as afternoon,
          SUM(CASE WHEN hour BETWEEN 18 AND 23 THEN hits ELSE 0 END) as evening,
          SUM(CASE WHEN hour < 6 OR hour = 0 THEN hits ELSE 0 END) as night
        FROM HourlyHits
      `;

      const [result] = await db.getAllAsync<DatabaseRow>(query);

      return {
        success: true,
        data: {
          morning: Number(result?.morning || 0),
          afternoon: Number(result?.afternoon || 0),
          evening: Number(result?.evening || 0),
          night: Number(result?.night || 0)
        }
      };
    } catch (error) {
      return this.handleError(error, 'getTimeDistribution');
    }
  }

  async getDailyAverageDatapoints(): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      console.log('[DataService] Fetching daily average datapoints...');
      const db = await this.getDatabase();
      const results = await db.getAllAsync<DatabaseRow>(`
        SELECT 
          strftime('%H', timestamp) as hour,
          COUNT(*) as count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY hour
        ORDER BY hour
      `);

      console.log('[DataService] Raw daily average results:', results);

      const processedData = Array.from({ length: 24 }, (_, i) => ({
        label: i.toString().padStart(2, '0'),
        value: 0
      }));

      results.forEach(row => {
        const hourIndex = Number(row.hour);
        if (hourIndex >= 0 && hourIndex < 24) {
          processedData[hourIndex].value = Number(row.count || 0);
        }
      });

      console.log('[DataService] Processed daily average data:', processedData);
      return {
        success: true,
        data: processedData
      };

    } catch (error) {
      return this.handleError(error, 'getDailyAverageDatapoints');
    }
  }

  async cleanup() {
    console.log('[DataService] Starting cleanup...');
    if (this.db) {
      try {
        await this.db.closeAsync();
        this.db = null;
        this.initializationPromise = null;
        console.log('[DataService] Cleanup completed successfully');
      } catch (error) {
        console.error('[DataService] Error during cleanup:', error);
        throw error;
      }
    }
  }
} 

================================================================================
File: src/services/StrainService.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import { STRAINS_DATABASE_NAME, SAMPLE_STRAINS } from "../constants";
import { Strain } from "../dbManager";

export interface StrainSearchFilters {
  geneticType?: string;
  effects?: string[];
  minTHC?: number;
  maxTHC?: number;
  sort?: 'rating' | 'name' | 'thc';
}

export interface PaginationParams {
  page: number;
  limit: number;
}

export interface StrainSearchResult {
  success: boolean;
  data: Strain[];
  error?: string;
  total: number;
  currentPage: number;
  totalPages: number;
  hasMore: boolean;
}

export class StrainService {
  private static instance: StrainService;
  private db: SQLiteDatabase | null = null;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {}

  static getInstance(): StrainService {
    if (!StrainService.instance) {
      StrainService.instance = new StrainService();
    }
    return StrainService.instance;
  }

  private async initialize(): Promise<void> {
    try {
      console.log('[StrainService] Initializing database...');
      this.db = await openDatabaseAsync(STRAINS_DATABASE_NAME);

      // Drop existing table to ensure clean state
      await this.db.execAsync(`DROP TABLE IF EXISTS ${STRAINS_DATABASE_NAME};`);

      // Create table and indexes
      await this.db.execAsync(`
        PRAGMA journal_mode = WAL;
        
        CREATE TABLE IF NOT EXISTS ${STRAINS_DATABASE_NAME} (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          overview TEXT,
          genetic_type TEXT,
          lineage TEXT,
          thc_range TEXT,
          cbd_level TEXT,
          dominant_terpenes TEXT,
          qualitative_insights TEXT,
          effects TEXT,
          negatives TEXT,
          uses TEXT,
          thc_rating REAL,
          user_rating REAL,
          combined_rating REAL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        
        CREATE INDEX IF NOT EXISTS idx_strain_name 
        ON ${STRAINS_DATABASE_NAME}(name);
        
        CREATE INDEX IF NOT EXISTS idx_strain_genetic_type 
        ON ${STRAINS_DATABASE_NAME}(genetic_type);
        
        CREATE INDEX IF NOT EXISTS idx_strain_effects 
        ON ${STRAINS_DATABASE_NAME}(effects);
        
        CREATE INDEX IF NOT EXISTS idx_strain_rating 
        ON ${STRAINS_DATABASE_NAME}(combined_rating DESC);
      `);

      // Insert all sample strains
      console.log('[StrainService] Inserting', SAMPLE_STRAINS.length, 'sample strains...');
      
      for (const strain of SAMPLE_STRAINS) {
        try {
          await this.db.runAsync(
            `INSERT INTO ${STRAINS_DATABASE_NAME} (
              name, overview, genetic_type, lineage, thc_range,
              cbd_level, dominant_terpenes, qualitative_insights,
              effects, negatives, uses, thc_rating,
              user_rating, combined_rating
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`,
            [
              strain.name,
              strain.overview,
              strain.genetic_type,
              strain.lineage,
              strain.thc_range,
              strain.cbd_level,
              strain.dominant_terpenes,
              strain.qualitative_insights,
              strain.effects,
              strain.negatives,
              strain.uses,
              strain.thc_rating,
              strain.user_rating,
              strain.combined_rating
            ]
          );
        } catch (insertError) {
          console.error(`[StrainService] Failed to insert strain ${strain.name}:`, insertError);
          // Continue with next strain instead of failing completely
        }
      }

      // Verify the data
      const [finalCount] = await this.db.getAllAsync<{ count: number }>(
        `SELECT COUNT(*) as count FROM ${STRAINS_DATABASE_NAME}`
      );
      console.log('[StrainService] Database initialized with', finalCount?.count || 0, 'strains');

    } catch (error) {
      console.error('[StrainService] Failed to initialize database:', error);
      this.db = null;
      throw error;
    }
  }

  private async getDatabase(): Promise<SQLiteDatabase> {
    if (!this.db) {
      if (!this.initializationPromise) {
        this.initializationPromise = this.initialize();
      }
      await this.initializationPromise;
      this.initializationPromise = null;
    }

    if (!this.db) {
      throw new Error('Database initialization failed');
    }

    return this.db;
  }

  private parseTHCRange(thcRange: string): { min: number; max: number } {
    const matches = thcRange.match(/(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)/);
    if (matches) {
      return {
        min: parseFloat(matches[1]),
        max: parseFloat(matches[2])
      };
    }
    return { min: 0, max: 0 };
  }

  async searchStrains(
    query: string = '',
    filters: StrainSearchFilters = {},
    pagination: PaginationParams = { page: 1, limit: 20 }
  ): Promise<StrainSearchResult> {
    try {
      const db = await this.getDatabase();
      const { page, limit } = pagination;
      const offset = (page - 1) * limit;
      
      let whereConditions: string[] = [];
      let params: any[] = [];

      // Add search query conditions
      if (query.trim()) {
        const searchTerms = query.trim().split(/\s+/);
        searchTerms.forEach(term => {
          whereConditions.push('(name LIKE ? OR effects LIKE ? OR genetic_type LIKE ? OR uses LIKE ?)');
          const searchTerm = `%${term}%`;
          params.push(searchTerm, searchTerm, searchTerm, searchTerm);
        });
      }

      // Add filter conditions
      if (filters.geneticType) {
        whereConditions.push('genetic_type = ?');
        params.push(filters.geneticType);
      }

      if (filters.effects?.length) {
        filters.effects.forEach(effect => {
          whereConditions.push('effects LIKE ?');
          params.push(`%${effect}%`);
        });
      }

      if (filters.minTHC !== undefined) {
        whereConditions.push('CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) >= ?');
        params.push(filters.minTHC);
      }

      if (filters.maxTHC !== undefined) {
        whereConditions.push('CAST(SUBSTR(thc_range, INSTR(thc_range, "-")+1) AS FLOAT) <= ?');
        params.push(filters.maxTHC);
      }

      const whereClause = whereConditions.length 
        ? `WHERE ${whereConditions.join(' AND ')}` 
        : '';

      // Get total count
      const [countResult] = await db.getAllAsync<{ total: number }>(
        `SELECT COUNT(*) as total FROM ${STRAINS_DATABASE_NAME} ${whereClause}`,
        params
      );

      // Get filtered results
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} 
         ${whereClause} 
         ORDER BY ${this.getSortOrder(filters.sort)}
         LIMIT ? OFFSET ?`,
        [...params, limit, offset]
      );

      const total = countResult?.total || 0;
      const totalPages = Math.ceil(total / limit);

      return {
        success: true,
        data: results,
        total,
        currentPage: page,
        totalPages,
        hasMore: (page * limit) < total
      };

    } catch (error) {
      console.error('[StrainService] Search error:', error);
      return {
        success: false,
        data: [],
        error: error instanceof Error ? error.message : 'Search failed',
        total: 0,
        currentPage: 1,
        totalPages: 1,
        hasMore: false
      };
    }
  }

  private getSortOrder(sort?: StrainSearchFilters['sort']): string {
    switch (sort) {
      case 'name':
        return 'name ASC';
      case 'thc':
        return 'CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) DESC';
      case 'rating':
      default:
        return 'combined_rating DESC';
    }
  }

  async getStrainById(id: number): Promise<Strain | null> {
    try {
      const db = await this.getDatabase();
      const [strain] = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} WHERE id = ? LIMIT 1`,
        [id]
      );
      return strain || null;
    } catch (error) {
      console.error('[StrainService] Error getting strain by id:', error);
      return null;
    }
  }

  async getPopularStrains(limit: number = 10): Promise<Strain[]> {
    try {
      const db = await this.getDatabase();
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} ORDER BY combined_rating DESC LIMIT ?`,
        [limit]
      );
      return results || [];
    } catch (error) {
      console.error('[StrainService] Error getting popular strains:', error);
      return [];
    }
  }

  async getRelatedStrains(strain: Strain): Promise<Strain[]> {
    try {
      const db = await this.getDatabase();
      // Get strains with similar genetic type and effects
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME}
         WHERE id != ? 
         AND (
           genetic_type = ? 
           OR effects LIKE ?
         )
         ORDER BY combined_rating DESC
         LIMIT 5`,
        [strain.id!, strain.genetic_type, `%${strain.effects.split(',')[0]}%`]
      );
      return results || [];
    } catch (error) {
      console.error('[StrainService] Error getting related strains:', error);
      return [];
    }
  }

  async getStrainCategories(): Promise<{ [key: string]: number }> {
    try {
      const db = await this.getDatabase();
      const results = await db.getAllAsync<{ genetic_type: string; count: number }>(
        `SELECT genetic_type, COUNT(*) as count
         FROM ${STRAINS_DATABASE_NAME}
         GROUP BY genetic_type`
      );
      
      return results.reduce((acc, { genetic_type, count }) => {
        if (genetic_type) {
          acc[genetic_type] = count;
        }
        return acc;
      }, {} as { [key: string]: number });
    } catch (error) {
      console.error('[StrainService] Error getting strain categories:', error);
      return {};
    }
  }

  async cleanup(): Promise<void> {
    if (this.db) {
      try {
        await this.db.closeAsync();
        this.db = null;
        this.initializationPromise = null;
      } catch (error) {
        console.error('[StrainService] Error during cleanup:', error);
        throw error;
      }
    }
  }
}

// Export a default instance
export default StrainService.getInstance(); 

================================================================================
File: src/types.ts
================================================================================

// Core data types
export interface BongHit {
    id?: number;
    timestamp: string;
    duration_ms: number;
    intensity?: number;
    notes?: string;
}

export interface BongHitStats {
    averageDuration: number;
    longestHit: number;
    totalHits?: number;
}

export interface DailyStats {
    date: string;
    hitCount: number;
    averageDuration: number;
}

export interface AverageHourCount {
    count: number;
    hourOfDay: string;
}

// Chart-specific types
export interface ChartDataPoint {
    label: string;
    value: number;
}

export interface ChartDataset {
    data: number[];
    color: (opacity?: number) => string;
    strokeWidth: number;
}

export interface ChartData {
    labels: string[];
    datasets: ChartDataset[];
    legend?: string[];
}

// Database types
export interface DatabaseRow {
    timestamp?: string;
    duration_ms?: number;
    day?: string;
    month?: string;
    hour?: string;
    hit_count?: number;
    count?: number;
    avg_duration?: number;
    max_duration?: number;
    total_hits?: number;
    avg_hits_per_day?: number;
    avg_duration_per_day?: number;
    daily_hits?: number;
    days_with_data?: number;
    weekday_avg?: number;
    weekday_total?: number;
    weekend_avg?: number;
    weekend_total?: number;
    peak_day_hits?: number;
    lowest_day_hits?: number;
    most_active_hour?: number;
    least_active_hour?: number;
    total_duration?: number;
    avg_hits_per_hour?: number;
    hits_std_dev?: number;
    // Fields from time distribution query
    morning?: number;
    afternoon?: number;
    evening?: number;
    night?: number;
    // Fields from usage stats query
    average_hits_per_day?: number;
    shortest_hit?: number;
    longest_hit?: number;
    consistency?: number;
}

export interface UsageStats {
    // Hit counts
    averageHitsPerDay: number;
    totalHits: number;
    peakDayHits: number;
    lowestDayHits: number;
    
    // Duration stats
    averageDuration: number;  // in ms
    longestHit: number;      // in ms
    shortestHit: number;     // in ms
    
    // Time patterns
    mostActiveHour: number;  // 0-23
    leastActiveHour: number; // 0-23
    
    // Derived metrics
    totalDuration: number;   // total time in ms
    averageHitsPerHour: number;
    consistency: number;     // standard deviation of daily hits

    // Weekday vs Weekend stats
    weekdayStats: WeekdayStats;
}

// Add new interfaces for time distribution
export interface TimeDistribution {
    morning: number;
    afternoon: number;
    evening: number;
    night: number;
}

export interface WeekdayStats {
    weekday: { avg: number; total: number; };
    weekend: { avg: number; total: number; };
}

// Component Props interfaces
export interface WeeklyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface MonthlyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface NotificationProps {
    averageHits: number;
    percentageChange: number;
    onDismiss: () => void;
}

export interface DailyAverageCardProps {
    data: ChartDataPoint[];
    averageHits: number;
    onPress?: () => void;
}

export interface WeeklyUsageBannerProps {
    weeklyData: ChartDataPoint[];
    average: number;
    percentageChange: number;
    onPress?: () => void;
}

// API Response types
export interface DatabaseResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}

export interface UsageAnalytics {
    dailyAverage: number;
    weeklyAverage: number;
    percentageChange: number;
    lastUpdated: string;
}

// State management types
export interface DataState {
    weeklyData: ChartDataPoint[];
    monthlyData: ChartDataPoint[];
    usageStats: UsageStats;
    timeDistribution: TimeDistribution;
    isLoading: boolean;
    error: string | null;
}

================================================================================
File: src/utils/animations.ts
================================================================================

import { useCallback } from 'react';
import { Platform } from 'react-native';
import {
  FadeIn,
  FadeInDown,
  FadeInUp,
  withSpring,
  withTiming,
  WithTimingConfig,
  Easing,
  useSharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

// Optimized spring configuration
export const SPRING_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100,
  restDisplacementThreshold: 0.01,
  restSpeedThreshold: 0.01,
} as const;

// Optimized timing configuration
export const TIMING_CONFIG: WithTimingConfig = {
  duration: 300,
  easing: Easing.bezier(0.25, 0.1, 0.25, 1),
} as const;

// Shared animation factory
export const createSharedAnimation = (delay: number = 0) => {
  return Platform.select({
    ios: FadeInDown.duration(300)
      .springify()
      .delay(delay)
      .damping(SPRING_CONFIG.damping)
      .mass(SPRING_CONFIG.mass),
    android: FadeIn.duration(250)
      .delay(delay)
  });
};

// Optimized press animation hook
export const useAnimatedPress = (scale: number = 0.98) => {
  const pressed = useSharedValue(false);
  
  const animatedStyle = useAnimatedStyle(() => {
    'worklet';
    return {
      transform: [{
        scale: withSpring(
          pressed.value ? scale : 1, 
          SPRING_CONFIG
        )
      }]
    };
  });

  return {
    animatedStyle,
    pressHandlers: {
      onPressIn: useCallback(() => {
        pressed.value = true;
      }, []),
      onPressOut: useCallback(() => {
        pressed.value = false;
      }, [])
    }
  };
};

// Gradient optimization utilities
export const GRADIENT_PROPS = Platform.select({
  ios: {
    shouldRasterizeIOS: true,
  },
  android: {
    renderToHardwareTextureAndroid: true,
  },
});

// Chart animation configuration
export const CHART_ANIMATION_CONFIG = {
  animationEnabled: true,
  animationDuration: 300,
  animationEasing: Easing.ease,
  propsForLabels: {
    fontSize: 10,
    fontWeight: '400'
  }
} as const;

// Optimized layout animation configuration
export const LAYOUT_ANIMATION_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100
} as const; 

================================================================================
File: src/utils/filters.ts
================================================================================

import { StrainSearchFilters } from '../services/StrainService';

export const hasActiveFilters = (filters: StrainSearchFilters): boolean => {
  return !!(
    filters.geneticType ||
    (filters.effects && filters.effects.length > 0) ||
    filters.minTHC ||
    filters.maxTHC ||
    (filters.sort && filters.sort !== 'rating')
  );
}; 

================================================================================
File: tsconfig.json
================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}