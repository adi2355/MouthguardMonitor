

================================================================================
File: app.json
================================================================================

{
  "expo": {
    "name": "CanovaReactNativeApp",
    "slug": "CanovaReactNativeApp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/canovafavicon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.anonymous.CanovaReactNativeApp",
      "infoPlist": {
        "NSBluetoothAlwaysUsageDescription": "This app requires Bluetooth access to connect to devices.",
        "NSBluetoothPeripheralUsageDescription": "This app requires Bluetooth access to communicate with nearby devices."
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/canovafavicon.png",
        "backgroundColor": "#ffffff"
      },
      "permissions": [
        "android.permission.BLUETOOTH",
        "android.permission.BLUETOOTH_ADMIN",
        "android.permission.BLUETOOTH_SCAN",
        "android.permission.BLUETOOTH_CONNECT",
        "android.permission.ACCESS_FINE_LOCATION"
      ],
      "package": "com.anonymous.CanovaReactNativeApp"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/canovafavicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ],
      "expo-sqlite",
      [
        "react-native-ble-plx",
        {
          "isBackgroundEnabled": true,
          "modes": [
            "peripheral",
            "central"
          ],
          "bluetoothAlwaysPermission": "Allow $(PRODUCT_NAME) to connect to bluetooth devices"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}


================================================================================
File: app/_layout.tsx
================================================================================

import { Stack } from "expo-router";
import { useState, useEffect } from "react";
import { BluetoothHandler, BluetoothContext } from "@/src/contexts/BluetoothContext";
import { useColorScheme, AppState, AppStateStatus } from 'react-native';
import * as SplashScreen from 'expo-splash-screen';
import { useFonts } from 'expo-font';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { AchievementProvider } from './context/AchievementContext';
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { AppProvider } from '@/src/providers/AppProvider';

export {
  // Catch any errors thrown by the Layout component.
  ErrorBoundary,
} from 'expo-router';

export const unstable_settings = {
  // Ensure that reloading on `/modal` keeps a back button present.
  initialRouteName: '(tabs)',
};

// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const [loaded, error] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
    ...FontAwesome.font,
  });

  // Expo Router uses Error Boundaries to catch errors in the navigation tree.
  useEffect(() => {
    if (error) throw error;
  }, [error]);

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return <RootLayoutNav />;
}

function RootLayoutNav() {
  const colorScheme = useColorScheme();
  // Create the Bluetooth handler to pass to the AppProvider
  const [bluetoothHandler] = useState<BluetoothHandler>(new BluetoothHandler());

  return (
    <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
      <BluetoothContext.Provider value={bluetoothHandler}>
        <AppProvider bluetoothHandler={bluetoothHandler}>
          <AchievementProvider>
            <Stack>
              <Stack.Screen 
                name="(tabs)" 
                options={{ headerShown: false }} 
              />
              <Stack.Screen 
                name="dataOverviews/strains/strainDetails" 
                options={{ 
                  headerShown: false,
                  presentation: 'modal',
                  animation: 'slide_from_bottom',
                }} 
              />
              <Stack.Screen name="dataOverviews/bongHitLogs" options={{ title: 'Bong Hit Logs' }} />
              <Stack.Screen name="dataOverviews/dailyAverageOverview" options={{ title: 'Daily Average' }} />
              <Stack.Screen name="dataOverviews/weeklyAverage" options={{ title: 'Weekly Average' }} />
              <Stack.Screen name="dataOverviews/weeklyOverview" options={{ title: 'Weekly Overview' }} />
              <Stack.Screen name="dataOverviews/monthlyOverview" options={{ title: 'Monthly Overview' }} />
              <Stack.Screen name="dataOverviews/strainUsage" options={{ title: 'Strain Usage' }} />
              <Stack.Screen name="screens/AchievementsScreen" options={{ title: 'Achievements' }} />
              <Stack.Screen name="+not-found" />
            </Stack>
          </AchievementProvider>
        </AppProvider>
      </BluetoothContext.Provider>
    </ThemeProvider>
  );
}


================================================================================
File: app/(tabs)/_layout.tsx
================================================================================

import { Tabs } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarStyle: {
          backgroundColor: COLORS.background,
          borderTopColor: 'rgba(255, 255, 255, 0.1)',
        },
        tabBarActiveTintColor: COLORS.primary,
        tabBarInactiveTintColor: 'rgba(255, 255, 255, 0.5)',
        headerShown: false,
      }}
      initialRouteName="index"
    >
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="home" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="mydata"
        options={{
          title: 'My Data',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="chart-box" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="devices"
        options={{
          title: 'Devices',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="devices" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="journal"
        options={{
          title: 'Journal',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="notebook" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="trending"
        options={{
          title: 'Trending',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="trending-up" size={24} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

================================================================================
File: app/(tabs)/devices.tsx
================================================================================

import { BluetoothContext, BluetoothHandler } from '@/src/contexts/BluetoothContext';
import { databaseManager } from '@/src/DatabaseManager';
import { SavedDevice } from '@/src/types';
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Alert,
  ScrollView
} from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import base64 from 'react-native-base64';
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import { LinearGradient } from 'expo-linear-gradient';
import { useBluetoothService } from '@/src/providers/AppProvider';

export default function Devices() {
  const [savedDevices, setSavedDevices] = useState<SavedDevice[]>([]);
  const [scannedDevices, setScannedDevices] = useState<Device[]>([]);
  const [scanning, setScanning] = useState<boolean>(false);
  const [deviceConnectedId, setDeviceConnectedId] = useState<string|null >(null);
  const [connectionError, setConnectionError] = useState<string|null>(null);

  //Track devices to avoid duplicate keys when scanning
  const undiscoveredDeviceSet: React.MutableRefObject<Set<string>> = useRef(new Set<string>());
  
  // Use BluetoothService instead of BluetoothContext
  const bluetoothService = useBluetoothService();

  useEffect(() => {
    updateSavedDevices();
    
    // Check if there's already a connected device
    const connectedDevice = bluetoothService.getConnectedDevice();
    if (connectedDevice) {
      setDeviceConnectedId(connectedDevice.id);
    }
  }, []);

  useEffect(() => {
    // This effect will run whenever savedDevices or deviceConnectedId changes
    console.log(`Connected device ID: ${deviceConnectedId}`);
  }, [savedDevices, deviceConnectedId]);

 
  function connectAndListenToDevice(deviceId: string, device?: Device): void {
    if (deviceConnectedId === deviceId) {
      return;
    }
    
    setConnectionError(null);

    bluetoothService.connectToDevice(deviceId)
      .then(() => {
        // The connection and streaming is handled by the service
        setDeviceConnectedId(deviceId);
      })
      .catch(error => {
        console.error("Connection error:", error);
        setConnectionError("Failed to connect to device");
      });
  }
  
  function updateSavedDevices() {
    bluetoothService.getSavedDevices()
      .then(devices => {
        console.log("Saved devices:", devices);
        // The service directly returns the devices array without the response wrapper
        setSavedDevices(devices);
       
        // Prevent saved devices from showing during scanning
        devices.forEach((device: SavedDevice) => {
          undiscoveredDeviceSet.current.add(device.id);
        });
      })
      .catch(error => {
        console.error("Error getting saved devices:", error);
        // Initialize with empty array if there's an error
        setSavedDevices([]);
      });
  }

  function scanDevices(): void {
    setScanning(true);
    setScannedDevices([]);
    
    // Only clear the set for new devices, keep saved devices in the set
    const savedIds = new Set(savedDevices.map(device => device.id));
    undiscoveredDeviceSet.current = savedIds;

    bluetoothService.scanForDevices(
      (device) => {
        if (device && device.name && !undiscoveredDeviceSet.current.has(device.id)) {
          undiscoveredDeviceSet.current.add(device.id); // Add device ID to the Set
          setScannedDevices((prevDevices) => [...prevDevices, device]);
        }
      },
      10000 // 10 second timeout
    ).then(() => {
      setScanning(false);
    }).catch(error => {
      console.error('Error scanning devices:', error);
      setScanning(false);
    });
  }

  // Renders device
  const renderDevice = ({ item }: { item: Device | SavedDevice }): JSX.Element => (
    <TouchableOpacity 
      style={styles.deviceItem} 
      onPress={() => { (item instanceof Device) ? connectAndListenToDevice(item.id, item) : connectAndListenToDevice(item.id) }}
    >
      <View style={styles.deviceIconContainer}>
        <MaterialCommunityIcons name="bluetooth" size={22} color={COLORS.primary} />
      </View>
      <View style={styles.deviceInfo}>
        <Text style={styles.deviceName}>{item.name}</Text>
        <Text style={styles.deviceStatus}>
          {item.id === deviceConnectedId ? "Connected" : "Not Connected"}
        </Text>
      </View>
      <MaterialCommunityIcons 
        name="chevron-right" 
        size={24} 
        color={COLORS.text.secondary} 
      />
    </TouchableOpacity>
  );

  return (
    <SafeAreaProvider>
      <ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Devices</Text>
        </View>

        {/* My Devices Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>My Devices</Text>
          <View style={styles.sectionCard}>
            {savedDevices.length > 0 ? (
              <FlatList
                data={savedDevices}
                keyExtractor={(item) => item.id}
                renderItem={renderDevice}
                scrollEnabled={false}
                ItemSeparatorComponent={() => <View style={styles.deviceSeparator} />}
              />
            ) : (
              <View style={styles.emptyStateContainer}>
                <MaterialCommunityIcons name="devices" size={40} color={COLORS.text.tertiary} />
                <Text style={styles.emptyStateText}>No paired devices</Text>
              </View>
            )}
          </View>
        </View>

        {/* Available Devices Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Available Devices</Text>
          
          <TouchableOpacity 
            style={styles.scanButton} 
            onPress={scanDevices} 
            disabled={scanning}
          >
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark || '#00C853']}
              style={styles.scanButtonGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="bluetooth-settings" 
                size={20} 
                color="#000" 
              />
              <Text style={styles.scanButtonText}>
                {scanning ? 'Scanning...' : 'Scan for Devices'}
              </Text>
            </LinearGradient>
          </TouchableOpacity>
          
          {scanning && (
            <View style={styles.scanningIndicator}>
              <ActivityIndicator size="small" color={COLORS.primary} />
              <Text style={styles.scanningText}>Searching for devices...</Text>
            </View>
          )}
          
          {scannedDevices.length > 0 && (
            <View style={styles.sectionCard}>
              <FlatList
                data={scannedDevices}
                keyExtractor={(item) => item.id}
                renderItem={renderDevice}
                scrollEnabled={false}
                ItemSeparatorComponent={() => <View style={styles.deviceSeparator} />}
              />
            </View>
          )}
          
          {!scanning && scannedDevices.length === 0 && (
            <View style={styles.sectionCard}>
              <View style={styles.emptyStateContainer}>
                <MaterialCommunityIcons name="bluetooth-off" size={40} color={COLORS.text.tertiary} />
                <Text style={styles.emptyStateText}>No devices found</Text>
                <Text style={styles.emptyStateSubtext}>Tap the scan button to search for devices</Text>
              </View>
            </View>
          )}
        </View>
        
        {/* Connection Info Card */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Connection Info</Text>
          <View style={styles.infoCard}>
            <View style={styles.infoRow}>
              <Text style={styles.infoLabel}>Status:</Text>
              <Text style={[
                styles.infoValue, 
                deviceConnectedId ? styles.connectedText : styles.disconnectedText
              ]}>
                {deviceConnectedId ? 'Connected' : 'Disconnected'}
              </Text>
            </View>
            {deviceConnectedId && (
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Device ID:</Text>
                <Text style={styles.infoValue}>{deviceConnectedId}</Text>
              </View>
            )}
            {connectionError && (
              <View style={styles.errorContainer}>
                <MaterialCommunityIcons name="alert-circle" size={18} color="#FF5252" />
                <Text style={styles.errorText}>{connectionError}</Text>
              </View>
            )}
          </View>
        </View>
      </ScrollView>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 8,
    marginTop: 30
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.35,
  },
  section: {
    marginBottom: 24,
    paddingHorizontal: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  sectionCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
    overflow: 'hidden',
  },
  deviceItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
  },
  deviceSeparator: {
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginLeft: 56,
  },
  deviceIconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  deviceInfo: {
    flex: 1,
  },
  deviceName: {
    fontSize: 16,
    fontWeight: '500',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  deviceStatus: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  scanButton: {
    marginBottom: 16,
    borderRadius: 12,
    overflow: 'hidden',
  },
  scanButtonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    paddingHorizontal: 24,
  },
  scanButtonText: {
    color: '#000',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  scanningIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  scanningText: {
    marginLeft: 8,
    color: COLORS.text.secondary,
    fontSize: 14,
  },
  emptyStateContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 24,
  },
  emptyStateText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    marginTop: 12,
  },
  emptyStateSubtext: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginTop: 4,
    textAlign: 'center',
  },
  infoCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    padding: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
  },
  infoRow: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  infoLabel: {
    width: 100,
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  infoValue: {
    flex: 1,
    fontSize: 14,
    color: COLORS.text.primary,
  },
  connectedText: {
    color: COLORS.primary,
    fontWeight: '500',
  },
  disconnectedText: {
    color: '#FF5252',
    fontWeight: '500',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 82, 82, 0.1)',
    padding: 12,
    borderRadius: 8,
    marginTop: 8,
  },
  errorText: {
    color: '#FF5252',
    fontSize: 14,
    marginLeft: 8,
  }
});

================================================================================
File: app/(tabs)/index.tsx
================================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  TouchableOpacity, 
  ActivityIndicator,
  ScrollView,
  Alert,
  RefreshControl
} from 'react-native';
import { useBongHitsRepository } from '@/src/providers/AppProvider';
import { BongHitStats, Datapoint } from '@/src/types';
import { Ionicons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import { useRouter } from 'expo-router';

// Add missing color constants
const EXTENDED_COLORS = {
  ...COLORS,
  inactive: '#555555', // Gray color for inactive bars
  error: '#FF3B30'    // Red color for the recording button when active
};

export default function HomeScreen() {
  const router = useRouter();
  const bongHitsRepository = useBongHitsRepository();
  
  const [isRecording, setIsRecording] = useState(false);
  const [recordingStartTime, setRecordingStartTime] = useState<Date | null>(null);
  const [elapsedTime, setElapsedTime] = useState(0);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [stats, setStats] = useState<BongHitStats | null>(null);
  const [weeklyData, setWeeklyData] = useState<Datapoint[] | null>(null);
  const [currentWeekAverage, setCurrentWeekAverage] = useState<number>(0);
  
  // Timer interval for recording
  useEffect(() => {
    let timerInterval: NodeJS.Timeout | null = null;
    
    if (isRecording && recordingStartTime) {
      timerInterval = setInterval(() => {
        const now = new Date();
        const elapsed = now.getTime() - recordingStartTime.getTime();
        setElapsedTime(elapsed);
      }, 100);
    }
    
    return () => {
      if (timerInterval) {
        clearInterval(timerInterval);
      }
    };
  }, [isRecording, recordingStartTime]);
  
  // Load data function
  const loadData = useCallback(async () => {
    try {
      console.log("[HomeScreen] Loading data...");
      setLoading(true);
      
      // Get stats from the past 7 days
      const stats = await bongHitsRepository.getBongHitStats(7);
      setStats(stats);
      
      // Get hits per day for the past week
      const hitsPerDayResponse = await bongHitsRepository.getHitsPerDay(7);
      if (hitsPerDayResponse.success) {
        setWeeklyData(hitsPerDayResponse.data ?? null);
      }
      
      // Fetch average hits for the current calendar week
      const currentWeekAvgResponse = await bongHitsRepository.getAverageHitsForCurrentWeek();
      if (currentWeekAvgResponse.success) {
        setCurrentWeekAverage(currentWeekAvgResponse.data ?? 0);
      }
      
      console.log("[HomeScreen] Data loaded successfully");
    } catch (error) {
      console.error('Error loading data:', error);
      Alert.alert('Error', 'Failed to load bong hit data');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, [bongHitsRepository]);
  
  // Load initial data
  useEffect(() => {
    loadData();
  }, [loadData]);
  
  // Handle refresh
  const onRefresh = useCallback(() => {
    console.log("[HomeScreen] Refresh triggered");
    setRefreshing(true);
    loadData();
  }, [loadData]);
  
  const handleStartRecording = () => {
    setIsRecording(true);
    setRecordingStartTime(new Date());
    setElapsedTime(0);
  };
  
  const handleStopRecording = async () => {
    if (!isRecording || !recordingStartTime) return;
    
    const endTime = new Date();
    const duration = endTime.getTime() - recordingStartTime.getTime();
    setIsRecording(false);
    
    try {
      // Record the bong hit
      await bongHitsRepository.recordBongHit(
        recordingStartTime.toISOString(),
        duration
      );
      
      // Refresh data
      await loadData();
      
      Alert.alert(
        'Bong Hit Recorded',
        `Duration: ${formatDuration(duration)}`,
        [{ text: 'OK' }]
      );
    } catch (error) {
      console.error('Error recording bong hit:', error);
      Alert.alert('Error', 'Failed to record bong hit');
    }
  };
  
  const formatDuration = (ms: number): string => {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const milliseconds = ms % 1000;
    
    // Format: mm:ss.ms (e.g., 01:23.4)
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${Math.floor(milliseconds / 100)}`;
  };
  
  const renderWeeklyData = () => {
    if (!weeklyData) return null;
    
    const maxValue = Math.max(...weeklyData.map(item => item.y), 1); // Ensure non-zero denominator
    const barHeight = 100; // Max height for bars in pixels
    
    return (
      <View style={styles.chartContainer}>
        <Text style={styles.chartTitle}>Hits - Last 7 Days</Text>
        <View style={styles.chartContent}>
          {weeklyData.map((item, index) => (
            <View key={index} style={styles.barContainer}>
              <Text style={styles.barValue}>{item.y}</Text>
              <View 
                style={[
                  styles.bar, 
                  { 
                    height: (item.y / maxValue) * barHeight,
                    backgroundColor: item.y > 0 ? EXTENDED_COLORS.primary : EXTENDED_COLORS.inactive
                  }
                ]} 
              />
              <Text style={styles.barLabel}>{item.x}</Text>
            </View>
          ))}
        </View>
        <TouchableOpacity 
          style={styles.viewMoreButton}
          onPress={() => router.push('/dataOverviews/weeklyOverview')}
        >
          <Text style={styles.viewMoreText}>View Details</Text>
          <Ionicons name="chevron-forward" size={16} color={EXTENDED_COLORS.primary} />
        </TouchableOpacity>
      </View>
    );
  };
  
  return (
    <View style={styles.container}>
      <ScrollView 
        style={styles.scrollContainer}
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={[EXTENDED_COLORS.primary]}
            tintColor={EXTENDED_COLORS.primary}
          />
        }
      >
        <View style={styles.header}>
          <Text style={styles.title}>Canova</Text>
        </View>
        
        <View style={styles.recordContainer}>
          <View style={styles.timerContainer}>
            {isRecording ? (
              <Text style={styles.timerText}>
                {formatDuration(elapsedTime)}
              </Text>
            ) : (
              <Text style={styles.recordPrompt}>
                Record Your Bong Hit
              </Text>
            )}
          </View>
          
          <TouchableOpacity
            style={[
              styles.recordButton,
              isRecording ? styles.recordingButton : {}
            ]}
            onPress={isRecording ? handleStopRecording : handleStartRecording}
          >
            <Ionicons
              name={isRecording ? "stop" : "flame"}
              size={40}
              color="white"
            />
          </TouchableOpacity>
        </View>
        
        {loading && !refreshing ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={EXTENDED_COLORS.primary} />
            <Text style={styles.loadingText}>Loading data...</Text>
          </View>
        ) : (
          <>
            {/* Current Week Average Card */}
            <View style={styles.statCardLarge}>
              <Text style={styles.statLabelLarge}>Avg Hits/Day (This Week)</Text>
              <Text style={styles.statValueLarge}>{Math.round(currentWeekAverage)}</Text>
            </View>
            
            {stats && (
              <View style={styles.statsContainer}>
                <View style={styles.statCard}>
                  <Text style={styles.statLabel}>Avg Duration (Last 7d)</Text>
                  <Text style={styles.statValue}>
                    {formatDuration(stats.averageDuration)}
                  </Text>
                </View>
                <View style={styles.statCard}>
                  <Text style={styles.statLabel}>Longest Hit (Last 7d)</Text>
                  <Text style={styles.statValue}>
                    {formatDuration(stats.longestHit)}
                  </Text>
                </View>
              </View>
            )}
            
            {renderWeeklyData()}
            
            <View style={styles.actionsContainer}>
              <TouchableOpacity 
                style={styles.actionButton}
                onPress={() => router.push('/dataOverviews/bongHitLogs')}
              >
                <Ionicons name="list" size={24} color={EXTENDED_COLORS.text.primary} />
                <Text style={styles.actionButtonText}>View Logs</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.actionButton}
                onPress={() => router.push('/dataOverviews/dailyAverageOverview')}
              >
                <Ionicons name="stats-chart" size={24} color={EXTENDED_COLORS.text.primary} />
                <Text style={styles.actionButtonText}>Analytics</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[styles.actionButton, { backgroundColor: '#2196F3' }]}
                onPress={() => router.push('/screens/TestDataScreen')}
              >
                <Ionicons name="bug" size={24} color={EXTENDED_COLORS.text.primary} />
                <Text style={styles.actionButtonText}>Test Data</Text>
              </TouchableOpacity>
            </View>
          </>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: EXTENDED_COLORS.background,
  },
  scrollContainer: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 40, // Ensure space at the bottom
  },
  header: {
    marginBottom: 24,
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: EXTENDED_COLORS.text.primary,
  },
  recordContainer: {
    alignItems: 'center',
    marginBottom: 32,
  },
  timerContainer: {
    alignItems: 'center',
    marginBottom: 20,
    minHeight: 60, // Ensure space for text
    justifyContent: 'center',
  },
  timerText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: EXTENDED_COLORS.text.primary,
  },
  recordPrompt: {
    fontSize: 20,
    color: EXTENDED_COLORS.text.secondary,
    marginBottom: 8,
  },
  recordButton: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: EXTENDED_COLORS.primary,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: EXTENDED_COLORS.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  recordingButton: {
    backgroundColor: EXTENDED_COLORS.error,
    shadowColor: EXTENDED_COLORS.error,
  },
  loadingContainer: {
    padding: 20,
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    color: EXTENDED_COLORS.text.secondary,
  },
  statCardLarge: {
    backgroundColor: EXTENDED_COLORS.cardBackground,
    borderRadius: 12,
    padding: 20,
    marginBottom: 24,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.05)',
  },
  statLabelLarge: {
    fontSize: 16,
    color: EXTENDED_COLORS.text.secondary,
    marginBottom: 8,
  },
  statValueLarge: {
    fontSize: 36,
    fontWeight: 'bold',
    color: EXTENDED_COLORS.primary,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 24,
    gap: 12,
  },
  statCard: {
    flex: 1,
    backgroundColor: EXTENDED_COLORS.cardBackground,
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 2,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.05)',
  },
  statLabel: {
    fontSize: 14,
    color: EXTENDED_COLORS.text.secondary,
    marginBottom: 8,
    textAlign: 'center',
  },
  statValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: EXTENDED_COLORS.text.primary,
  },
  chartContainer: {
    backgroundColor: EXTENDED_COLORS.cardBackground,
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.05)',
  },
  chartTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: EXTENDED_COLORS.text.primary,
    marginBottom: 16,
  },
  chartContent: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-end',
    height: 140,
    marginBottom: 8,
  },
  barContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  bar: {
    width: '60%',
    borderRadius: 4,
    marginBottom: 8,
    minHeight: 2, // Ensure even 0-value bars are visible
  },
  barLabel: {
    fontSize: 12,
    color: EXTENDED_COLORS.text.secondary,
  },
  barValue: {
    fontSize: 12,
    color: EXTENDED_COLORS.text.secondary,
    marginBottom: 4,
  },
  viewMoreButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 8,
    padding: 8,
  },
  viewMoreText: {
    fontSize: 14,
    color: EXTENDED_COLORS.primary,
    marginRight: 4,
    fontWeight: '600',
  },
  actionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
  },
  actionButton: {
    flex: 1,
    backgroundColor: EXTENDED_COLORS.cardBackground,
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 2,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.05)',
  },
  actionButtonText: {
    marginTop: 8,
    fontSize: 14,
    color: EXTENDED_COLORS.text.primary,
    textAlign: 'center',
  }
});

================================================================================
File: app/(tabs)/journal.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, Modal, TextInput, Button, StyleSheet } from 'react-native';
import { Calendar } from 'react-native-calendars';

export default function JournalCalendar() {
  const [selectedDate, setSelectedDate] = useState('');
  const [modalVisible, setModalVisible] = useState(false);
  const [entries, setEntries] = useState({});
  const [currentEntry, setCurrentEntry] = useState('');

  const handleDayPress = (day) => {
    const date = day.dateString;
    setSelectedDate(date);
    setCurrentEntry(entries[date] || '');
    setModalVisible(true);
  };

  const saveEntry = () => {
    setEntries({ ...entries, [selectedDate]: currentEntry });
    setModalVisible(false);
  };

  return (
    <View style={styles.container}>
      {/* Calendar */}
      <Calendar
        onDayPress={handleDayPress}
        markedDates={{
          ...Object.keys(entries).reduce((acc, date) => {
            acc[date] = { marked: true };
            return acc;
          }, {}),
          [selectedDate]: { selected: true, selectedColor: '#12a35f' },
        }}
      />

      {/* Modal for journal entry */}
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              Journal Entry for {selectedDate}
            </Text>
            <TextInput
              style={styles.input}
              multiline
              placeholder="Write your journal entry here..."
              value={currentEntry}
              onChangeText={setCurrentEntry}
            />
            <View style={styles.modalButtons}>
              <Button title="Save" onPress={saveEntry} />
              <Button title="Cancel" onPress={() => setModalVisible(false)} />
            </View>
          </View>
        </View>
      </Modal>

      {/* Display Saved Entries */}
      <View style={styles.entriesContainer}>
        <Text style={styles.entriesTitle}>Saved Journal Entries:</Text>
        {Object.keys(entries).length > 0 ? (
          Object.entries(entries).map(([date, entry]) => (
            <View key={date} style={styles.entry}>
              <Text style={styles.entryDate}>{date}</Text>
              <Text style={styles.entryText}>{entry}</Text>
            </View>
          ))
        ) : (
          <Text>No journal entries yet.</Text>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '80%',
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 20,
    alignItems: 'center',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  input: {
    width: '100%',
    height: 100,
    borderColor: '#ddd',
    borderWidth: 1,
    borderRadius: 5,
    padding: 10,
    textAlignVertical: 'top',
    marginBottom: 20,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  entriesContainer: {
    marginTop: 20,
  },
  entriesTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  entry: {
    marginBottom: 10,
  },
  entryDate: {
    fontWeight: 'bold',
  },
  entryText: {
    fontSize: 14,
  },
});


================================================================================
File: app/(tabs)/mydata.tsx
================================================================================

import React, { memo, useCallback, useState, useEffect } from 'react';
import { View, StyleSheet, TouchableOpacity, Alert, ScrollView, RefreshControl, ActivityIndicator } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { COLORS } from '../../src/constants';
import { useDataService } from '../../src/hooks/useDataService';
import { useDailyData } from '../../src/hooks/useDailyData';
import { useCurrentWeekData } from '../../src/hooks/useCurrentWeekData';
import { useBongHitsRepository } from '../../src/providers/AppProvider';
import { databaseManager } from "../../src/DatabaseManager";
import { BongHit, ChartDataPoint } from '../../src/types';
import { LinearGradient } from 'expo-linear-gradient';
import { Text } from 'react-native';
import MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';
import { dataChangeEmitter, dbEvents } from '../../src/utils/EventEmitter';

// Import components from their new structure
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';
import Header from '../components/mydata/Header';
import Section from '../components/mydata/Section';
import NotificationBanner from '../components/mydata/NotificationBanner';
import MedicalCard from '../components/mydata/MedicalCard';
import DailyAverageCard from '../components/mydata/DailyAverageCard';
import WeeklyUsageBanner from '../components/mydata/WeeklyUsageBanner';
import WeeklyOverviewChart from '../components/charts/WeeklyOverviewChart';
import MonthlyOverviewChart from '../components/charts/MonthlyOverviewChart';
import StatsOverviewCard from '../components/StatsOverviewCard';
import TimeDistributionCard from '../components/TimeDistributionCard';

// Import new components
import GoalTrackingCard from '../components/mydata/GoalTrackingCard';
import SetGoalModal from '../components/mydata/SetGoalModal';
import StrainUsageCard from '../components/mydata/StrainUsageCard';
import AIRecommendationCard from '../components/mydata/AIRecommendationCard';
import { BongHitLogsCard } from '../components/mydata/BongHitLogsCard';
import SubscriptionButton from '../components/mydata/SubscriptionButton';
import SubscriptionModal from '../components/mydata/SubscriptionModal';
import { AchievementsButton } from '../components/mydata/AchievementsButton';
import { useAchievements } from '../context/AchievementContext';
import { AchievementUnlockedNotification } from '../components/achievements/AchievementUnlockedNotification';

const ROUTES = {
  DAILY_AVERAGE: "/dataOverviews/dailyAverageOverview",
  WEEKLY_AVERAGE: "/dataOverviews/weeklyAverage",
  WEEKLY_OVERVIEW: "/dataOverviews/weeklyOverview",
  MONTHLY_OVERVIEW: "/dataOverviews/monthlyOverview",
  STRAIN_USAGE: "/dataOverviews/strainUsage",
  BONG_HIT_LOGS: "/dataOverviews/bongHitLogs",
} as const;

// Define a type for the average display logic
interface AverageDisplayInfo {
  value: number;
  label: string;
  chartData: ChartDataPoint[];
}

export default memo(function MyData() {
  const router = useRouter();
  const bongHitsRepository = useBongHitsRepository();
  const [showNotification, setShowNotification] = useState(true);
  const [goalModalVisible, setGoalModalVisible] = useState(false);
  const [dailyGoal, setDailyGoal] = useState(10); // Default goal
  const [bongHitSummary, setBongHitSummary] = useState({
    totalHits: 0,
    averageDuration: 0,
    recentTimestamp: new Date().toISOString()
  });
  const [subscriptionModalVisible, setSubscriptionModalVisible] = useState(false);
  const { stats: achievementStats, newlyUnlocked, clearNewlyUnlocked } = useAchievements();
  const [refreshKey, setRefreshKey] = useState(0); // Add refreshKey state
  
  // Note: In a real implementation, this would be based on user selection
  const [currentTimeRange, setCurrentTimeRange] = useState<'D' | 'W' | 'M' | 'Y'>('D'); // Default to daily view
  
  // Use our new hooks
  const { hitsToday, isLoading: dailyLoading, error: dailyError, refresh: refreshDaily } = useDailyData();
  const { currentWeekAverage, isLoading: weeklyLoading, error: weeklyError, refresh: refreshWeekly } = useCurrentWeekData();
  
  // Keep useDataService for holistic data
  const { 
    weeklyData, 
    monthlyData, 
    usageStats, 
    timeDistribution,
    isLoading: dataServiceLoading, 
    error: dataServiceError,
    isRefreshing: dataServiceRefreshing,
    refreshData: refreshDataService
  } = useDataService();

  // Combined loading & error states
  const isLoading = dailyLoading || weeklyLoading || (dataServiceLoading && !dataServiceRefreshing);
  const error = dailyError || weeklyError || dataServiceError;

  useEffect(() => {
    const fetchBongHitData = async () => {
      try {
        const bongHitLogsResponse = await databaseManager.getAllBongHitLogs();
        
        if (bongHitLogsResponse.success && bongHitLogsResponse.data && bongHitLogsResponse.data.length > 0) {
          const logs = bongHitLogsResponse.data as BongHit[];
          const totalDuration = logs.reduce((sum: number, log: BongHit) => sum + log.duration_ms, 0);
          
          setBongHitSummary({
            totalHits: logs.length,
            averageDuration: totalDuration / (logs.length * 1000), // convert to seconds
            recentTimestamp: logs[0].timestamp
          });
        }
      } catch (error) {
        console.error('Failed to fetch bong hit data:', error);
      }
    };
    
    fetchBongHitData();
  }, [dataServiceRefreshing]); // Re-fetch when refreshing

  // Listen specifically for data changes to force a re-render if needed
  useEffect(() => {
    const handleDataChange = () => {
      console.log('[MyData] Received data change event, forcing re-render key update.');
      // We still rely on useDataService to fetch the data via its own listener,
      // but we increment this key to ensure MyData re-renders.
      setRefreshKey(prevKey => prevKey + 1);
    };

    dataChangeEmitter.on(dbEvents.DATA_CHANGED, handleDataChange);

    return () => {
      dataChangeEmitter.off(dbEvents.DATA_CHANGED, handleDataChange);
    };
  }, []); // Empty dependency array means this effect runs once on mount

  const handleNavigation = useCallback((route: keyof typeof ROUTES) => {
    router.push(ROUTES[route] as any);
  }, [router]);

  const handleNavigateToAI = () => {
    router.push('/ai/recommendations' as any);
  };
  
  const handleSubscribe = (planId: string) => {
    setSubscriptionModalVisible(false);
    // In a real app, this would process payment and update subscription status
    Alert.alert('Subscription', `Successfully subscribed to plan: ${planId}`);
  };

  const handleAchievementsPress = () => {
    router.push('/screens/AchievementsScreen' as any);
  };
  
  const handleAchievementNotificationPress = () => {
    clearNewlyUnlocked();
    router.push('/screens/AchievementsScreen' as any);
  };

  // Combined refresh handler
  const handleRefresh = useCallback(async () => {
    console.log('[MyData] Manual refresh triggered');
    // Refresh all data sources
    await Promise.all([
      refreshDaily(),
      refreshWeekly(),
      refreshDataService()
    ]);
  }, [refreshDaily, refreshWeekly, refreshDataService]);

  // Calculate which average to display based on the time range
  const getAverageDisplayInfo = (): AverageDisplayInfo => {
    switch (currentTimeRange) {
      case 'D':
        // For 'Day' view, show today's actual hit count from useDailyData
        return { value: hitsToday, label: "Today's Hits", chartData: [] };
      case 'W':
        // For 'Week' view, use the current week average from useCurrentWeekData
        return { value: currentWeekAverage, label: "Daily Avg (This Week)", chartData: weeklyData };
      case 'M':
        // For 'Month' view, use the monthly average
        return { value: usageStats.averageHitsPerDay, label: "Daily Avg (Month)", chartData: [] };
      case 'Y':
        // For 'Year' view, use the yearly average
        return { value: usageStats.averageHitsPerDay, label: "Daily Avg (Year)", chartData: monthlyData };
      default:
        // Default to today's hits
        return { value: hitsToday, label: "Today's Hits", chartData: [] };
    }
  };

  const averageDisplayInfo = getAverageDisplayInfo();

  // Sample strain data - in a real app, this would come from your database
  const mockStrainData = [
    {
      strainId: 1,
      strainName: "Blue Dream",
      strainType: "Hybrid",
      usageCount: 42,
      percentageOfTotal: 35.6
    },
    {
      strainId: 2,
      strainName: "OG Kush",
      strainType: "Indica",
      usageCount: 28,
      percentageOfTotal: 23.7
    },
    {
      strainId: 3,
      strainName: "Sour Diesel",
      strainType: "Sativa",
      usageCount: 18,
      percentageOfTotal: 15.3
    }
  ];

  // Only show loading view on initial load, not during refresh
  if (isLoading && !dataServiceRefreshing) return <LoadingView />;
  if (error && !isLoading) return <ErrorView error={error} />;

  const weekdayAvg = usageStats.weekdayStats?.weekday.avg || 0;
  const weekendAvg = usageStats.weekdayStats?.weekend.avg || 0;
  const percentageChange = weekdayAvg > 0 ? ((weekendAvg - weekdayAvg) / weekdayAvg) * 100 : 0;

  return (
    <SafeAreaProvider>
      <ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={dataServiceRefreshing} // Use dataServiceRefreshing for refresh indicator
            onRefresh={handleRefresh}
            tintColor={COLORS.primary}
            colors={[COLORS.primary]}
            progressBackgroundColor={COLORS.cardBackground}
          />
        }
      >
        <Header />

        <View style={styles.mainContent}>
          {/* Goals Section */}
          <Section title="Goals & Tracking">
            <GoalTrackingCard
              currentUsage={hitsToday} // Use today's hits from useDailyData
              goalUsage={dailyGoal}
              onEditGoal={() => setGoalModalVisible(true)}
            />
          </Section>

          <Section title="Consumption Data">
            {dailyLoading ? (
              <ActivityIndicator color={COLORS.primary} />
            ) : dailyError ? (
              <Text style={styles.errorText}>{dailyError}</Text>
            ) : (
              <DailyAverageCard
                data={averageDisplayInfo.chartData}
                averageHits={hitsToday} // Use today's hits from useDailyData
                averageLabel="Today's Hits"
                onPress={() => handleNavigation("DAILY_AVERAGE")}
              />
            )}
            
            {weeklyLoading ? (
              <ActivityIndicator color={COLORS.primary} />
            ) : weeklyError ? (
              <Text style={styles.errorText}>{weeklyError}</Text>
            ) : (
              <WeeklyUsageBanner
                weeklyData={weeklyData}
                average={Math.round(currentWeekAverage)}
                percentageChange={percentageChange}
                averageLabel="Avg Hits/Day (This Week)"
                onPress={() => handleNavigation("WEEKLY_AVERAGE")}
              />
            )}
            
            <BongHitLogsCard
              totalHits={bongHitSummary.totalHits}
              averageDuration={bongHitSummary.averageDuration}
              recentTimestamp={bongHitSummary.recentTimestamp}
              onPress={() => handleNavigation("BONG_HIT_LOGS")}
            />
          </Section>

          <Section title="Usage Overview">
            <StrainUsageCard
              strainData={mockStrainData}
              totalHits={usageStats.totalHits}
              onViewAll={() => handleNavigation("STRAIN_USAGE")}
            />
          </Section>

          <Section title="Detailed Statistics">
            <StatsOverviewCard stats={{
              ...usageStats,
              averageHitsPerDay: Math.round(usageStats.averageHitsPerDay),
              weekdayStats: {
                weekday: { ...usageStats.weekdayStats.weekday, avg: Math.round(usageStats.weekdayStats.weekday.avg) },
                weekend: { ...usageStats.weekdayStats.weekend, avg: Math.round(usageStats.weekdayStats.weekend.avg) }
              }
            }} />
            <TimeDistributionCard timeData={timeDistribution} />
          </Section>

          <AIRecommendationCard onPress={handleNavigateToAI} />
          
          <AchievementsButton
            onPress={handleAchievementsPress}
            unlocked={achievementStats.unlocked}
            total={achievementStats.total}
          />
        </View>
      </ScrollView>

      <SetGoalModal
        visible={goalModalVisible}
        currentGoal={dailyGoal}
        onSave={(goal) => {
          setDailyGoal(goal);
          setGoalModalVisible(false);
        }}
        onClose={() => setGoalModalVisible(false)}
      />

      <SubscriptionModal
        visible={subscriptionModalVisible}
        onClose={() => setSubscriptionModalVisible(false)}
        onSubscribe={handleSubscribe}
      />

      {newlyUnlocked && (
        <AchievementUnlockedNotification
          achievement={newlyUnlocked}
          onPress={handleAchievementNotificationPress}
          onDismiss={clearNewlyUnlocked}
        />
      )}
    </SafeAreaProvider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  contentContainer: {
    paddingBottom: 40,
  },
  mainContent: {
    paddingHorizontal: 16,
  },
  errorText: {
    color: '#FF5252',
    textAlign: 'center',
    margin: 10,
  }
});

================================================================================
File: app/(tabs)/trending.tsx
================================================================================

// app/(tabs)/trending.tsx
import React, { useState, useCallback, useEffect, memo, useMemo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { useRouter } from 'expo-router';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useStrains } from '../../src/hooks/useStrains';
import { COLORS } from '../../src/constants';
import { StrainSearchFilters } from '../../src/DatabaseManager';
import { Strain } from "@/src/types";
import { LinearGradient } from 'expo-linear-gradient';
import LoadingView from '../components/shared/LoadingView';
import Header from '../components/trending/Header';
import StrainsList from '../components/trending/StrainsList';
import CompareBar from '../components/trending/CompareBar';
import SearchFilters from '../components/trending/SearchFilters';
import { hasActiveFilters } from '../../src/utils/filters';
import Animated, { FadeIn } from 'react-native-reanimated';

const TrendingScreen = memo(() => {
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState('');
  const [showFilters, setShowFilters] = useState(false);
  const [compareList, setCompareList] = useState<Strain[]>([]);
  const [filters, setFilters] = useState<StrainSearchFilters>({
    geneticType: undefined,
    effects: [],
    sort: 'rating'
  });

  const { 
    strains,
    popularStrains,
    categories,
    isLoading,
    error,
    searchStrains,
    clearSearch,
    loadMore,
    toggleFavorite,
    isFavorite,
    pagination
  } = useStrains();

  useEffect(() => {
    const delaySearch = setTimeout(() => {
      if (searchQuery.trim() || hasActiveFilters(filters)) {
        searchStrains(searchQuery, filters);
      } else {
        clearSearch();
      }
    }, 300);

    return () => clearTimeout(delaySearch);
  }, [searchQuery, filters, searchStrains, clearSearch]);

  const handleFilterChange = useCallback((newFilters: StrainSearchFilters) => {
    setFilters(newFilters);
  }, []);

  const handleApplyFilters = useCallback(() => {
    setShowFilters(false);
  }, []);

  const handleClearSearch = useCallback(() => {
    setSearchQuery('');
    setFilters({
      geneticType: undefined,
      effects: [],
      sort: 'rating'
    });
    clearSearch();
  }, [clearSearch]);

  const handleCompareToggle = useCallback((strain: Strain) => {
    setCompareList(prev => {
      if (prev.some(s => s.id === strain.id)) {
        return prev.filter(s => s.id !== strain.id);
      }
      if (prev.length >= 3) return prev;
      return [...prev, strain];
    });
  }, []);

  const handleCompare = useCallback(() => {
    if (compareList.length >= 2) {
      router.push({
        pathname: "/dataOverviews/compare",
        params: { ids: compareList.map(s => s.id).join(',') }
      } as any);
    }
  }, [compareList, router]);

  // Memoize the displayed strains to prevent unnecessary re-renders
  const displayedStrains = useMemo(() => 
    searchQuery.trim() || hasActiveFilters(filters) ? strains : popularStrains,
    [searchQuery, filters, strains, popularStrains]
  );

  // Memoize the section title
  const sectionTitle = useMemo(() => 
    searchQuery.trim() || hasActiveFilters(filters) 
      ? `Search Results (${pagination.total})`
      : "Popular Strains",
    [searchQuery, filters, pagination.total]
  );

  if (isLoading && !strains.length && !popularStrains.length) {
    return <LoadingView />;
  }

  return (
    <SafeAreaProvider>
      <View style={styles.container}>
        {/* Black background */}
        <View style={StyleSheet.absoluteFillObject} />
        
        {/* Header with glow effect */}
        <LinearGradient
          colors={['rgba(0, 230, 118, 0.15)', 'transparent']}
          style={styles.headerGradient}
          start={{ x: 0.5, y: 0 }}
          end={{ x: 0.5, y: 0.3 }}
        />
        
        <Header 
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          showFilters={showFilters}
          setShowFilters={setShowFilters}
          filters={filters}
          handleClearSearch={handleClearSearch}
        />

        {showFilters && (
          <Animated.View 
            entering={FadeIn.duration(300)}
            style={styles.filtersContainer}
          >
            <SearchFilters
              filters={filters}
              onFilterChange={handleFilterChange}
              onApplyFilters={handleApplyFilters}
              categories={categories}
            />
          </Animated.View>
        )}

        <View style={styles.mainContent}>
          <View style={styles.sectionHeaderContainer}>
            <LinearGradient
              colors={['rgba(0, 230, 118, 0.12)', 'transparent']}
              style={styles.sectionHeaderGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
            <Text style={styles.sectionTitle}>{sectionTitle}</Text>
          </View>
          
          {/* Don't wrap this in a ScrollView since StrainsList is already virtualized */}
          <View style={styles.listWrapper}>
            <StrainsList
              strains={displayedStrains}
              onCompareToggle={handleCompareToggle}
              onFavoriteToggle={toggleFavorite}
              compareList={compareList}
              isFavorite={isFavorite}
              isLoading={isLoading}
              onEndReached={loadMore}
            />
          </View>
        </View>

        {compareList.length > 0 && (
          <CompareBar
            compareList={compareList}
            onCompareToggle={handleCompareToggle}
            onCompare={handleCompare}
          />
        )}
      </View>
    </SafeAreaProvider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000000', // Jet black background
  },
  headerGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 150,
    zIndex: 0,
  },
  filtersContainer: {
    paddingHorizontal: 20,
    paddingBottom: 16,
    marginTop: 8,
    zIndex: 1,
  },
  mainContent: {
    flex: 1,
    paddingHorizontal: 20,
  },
  sectionHeaderContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    paddingVertical: 10,
    position: 'relative',
  },
  sectionHeaderGradient: {
    position: 'absolute',
    left: -20,
    right: -20,
    top: 0,
    bottom: 0,
    height: '100%',
    borderRadius: 8,
  },
  sectionTitle: {
    fontSize: 22,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
    textShadowColor: 'rgba(0, 230, 118, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  listWrapper: {
    flex: 1,
  }
});

export default TrendingScreen;

================================================================================
File: app/ai/_layout.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { Tabs, useRouter, usePathname } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { View, ActivityIndicator, Text, StyleSheet } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../src/constants';

export default function AILayout() {
  const router = useRouter();
  const pathname = usePathname();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    // Check if the user has completed onboarding
    const checkOnboardingStatus = async () => {
      try {
        // Add a small delay to prevent UI jittering
        await new Promise(resolve => setTimeout(resolve, 300));
        
        const hasCompletedOnboarding = await AsyncStorage.getItem('ai_onboarding_completed');
        
        if (hasCompletedOnboarding !== 'true') {
          // Only redirect if we're not already on the onboarding screen
          if (!pathname.includes('/ai/onboarding')) {
            router.replace('/ai/onboarding');
          }
        }
      } catch (error) {
        console.error('Error checking onboarding status:', error);
        setError('Failed to check onboarding status');
      } finally {
        setIsLoading(false);
      }
    };
    
    checkOnboardingStatus();
  }, [router, pathname]);
  
  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <LinearGradient
          colors={['rgba(0,230,118,0.1)', 'transparent']}
          style={styles.loadingGradient}
          start={{ x: 0.5, y: 0 }}
          end={{ x: 0.5, y: 1 }}
        />
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>Loading...</Text>
      </View>
    );
  }
  
  if (error) {
    return (
      <View style={styles.errorContainer}>
        <LinearGradient
          colors={['rgba(255,107,107,0.1)', 'transparent']}
          style={styles.errorGradient}
          start={{ x: 0.5, y: 0 }}
          end={{ x: 0.5, y: 1 }}
        />
        <View style={styles.errorContent}>
          <MaterialCommunityIcons 
            name="alert-circle-outline" 
            size={48} 
            color="#ff6b6b" 
          />
          <Text style={styles.errorTitle}>Something went wrong</Text>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorSubtext}>
            Please restart the app or try again later.
          </Text>
        </View>
      </View>
    );
  }
  
  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: COLORS.primary,
        tabBarInactiveTintColor: COLORS.text.tertiary,
        tabBarStyle: {
          backgroundColor: COLORS.background,
          borderTopColor: 'rgba(255, 255, 255, 0.1)',
          borderTopWidth: 1,
          elevation: 0,
          shadowOpacity: 0,
        },
        tabBarLabelStyle: {
          fontSize: 12,
          fontWeight: '500',
        },
        headerStyle: {
          backgroundColor: COLORS.background,
          elevation: 0,
          shadowOpacity: 0,
          borderBottomWidth: 1,
          borderBottomColor: 'rgba(255, 255, 255, 0.1)',
        },
        headerTintColor: COLORS.text.primary,
        headerTitleStyle: {
          fontWeight: '600',
        }
      }}
    >
      <Tabs.Screen
        name="recommendations"
        options={{
          title: 'Recommendations',
          tabBarLabel: 'Recommendations',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="leaf" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="chat"
        options={{
          title: 'AI Assistant',
          tabBarLabel: 'Chat',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="chat-processing" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="journal-insights"
        options={{
          title: 'Journal Insights',
          tabBarLabel: 'Insights',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="chart-line" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="onboarding"
        options={{
          href: null, // Hide from tab bar
          headerShown: false,
        }}
      />
    </Tabs>
  );
}

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
    position: 'relative',
  },
  loadingGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: COLORS.text.secondary,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
    padding: 24,
    position: 'relative',
  },
  errorGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  errorContent: {
    alignItems: 'center',
    backgroundColor: COLORS.cardBackground,
    padding: 24,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 107, 107, 0.2)',
    width: '90%',
    maxWidth: 400,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginTop: 16,
    marginBottom: 8,
  },
  errorText: {
    fontSize: 16,
    color: '#ff6b6b',
    textAlign: 'center',
    marginBottom: 16,
  },
  errorSubtext: {
    fontSize: 14,
    color: COLORS.text.secondary,
    textAlign: 'center',
  }
});

================================================================================
File: app/ai/chat.tsx
================================================================================

import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity, 
  FlatList,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator
} from 'react-native';
import { Stack } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { ChatMessage, UserProfile } from '../../src/types';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

// Initial welcome message
const WELCOME_MESSAGE: ChatMessage = {
  id: 'welcome',
  content: "Hi there! I'm your cannabis assistant. I can help you find strains, answer questions about cannabis, or provide guidance on usage. What would you like to know?",
  role: 'assistant',
  timestamp: new Date().toISOString()
};

export default function ChatScreen() {
  const { loading, error, chatHistory, getChatResponse, clearChatHistory } = useAIRecommendations();
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<ChatMessage[]>([WELCOME_MESSAGE]);
  const flatListRef = useRef<FlatList>(null);
  
  // Initialize chat history
  useEffect(() => {
    if (chatHistory.length > 0) {
      setMessages([WELCOME_MESSAGE, ...chatHistory]);
    }
  }, [chatHistory]);
  
  // Scroll to bottom when messages change
  useEffect(() => {
    if (flatListRef.current && messages.length > 0) {
      setTimeout(() => {
        flatListRef.current?.scrollToEnd({ animated: true });
      }, 100);
    }
  }, [messages]);
  
  // Handle sending a message
  const handleSendMessage = async () => {
    if (!message.trim()) return;
    
    const userMessage = message.trim();
    setMessage('');
    
    // Add user message to local state immediately for better UX
    const newUserMessage: ChatMessage = {
      id: `user_${Date.now()}`,
      content: userMessage,
      role: 'user',
      timestamp: new Date().toISOString()
    };
    
    setMessages(prev => [...prev, newUserMessage]);
    
    // Get AI response
    const response = await getChatResponse(userMessage, mockUserProfile);
    
    if (response) {
      setMessages(prev => [...prev, response]);
    } else if (error) {
      // Add error message if request failed
      const errorMessage: ChatMessage = {
        id: `error_${Date.now()}`,
        content: "Sorry, I'm having trouble responding right now. Please try again later.",
        role: 'assistant',
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, errorMessage]);
    }
  };
  
  // Clear chat history
  const handleClearChat = () => {
    clearChatHistory();
    setMessages([WELCOME_MESSAGE]);
  };
  
  // Render a chat message
  const renderMessage = ({ item }: { item: ChatMessage }) => {
    const isUser = item.role === 'user';
    
    return (
      <View style={[
        styles.messageContainer,
        isUser ? styles.userMessageContainer : styles.assistantMessageContainer
      ]}>
        {!isUser && (
          <View style={styles.avatarContainer}>
            <MaterialCommunityIcons name="robot" size={24} color="#fff" />
          </View>
        )}
        
        <View style={[
          styles.messageBubble,
          isUser ? styles.userMessageBubble : styles.assistantMessageBubble
        ]}>
          <Text style={styles.messageText}>{item.content}</Text>
        </View>
        
        {isUser && (
          <View style={styles.avatarContainer}>
            <MaterialCommunityIcons name="account" size={24} color="#fff" />
          </View>
        )}
      </View>
    );
  };
  
  if (loading && messages.length === 1) {
    return <LoadingView />;
  }
  
  if (error && messages.length === 1) {
    return <ErrorView error={error} />;
  }
  
  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
    >
      <Stack.Screen 
        options={{
          title: 'AI Assistant',
          headerRight: () => (
            <TouchableOpacity onPress={handleClearChat} style={styles.clearButton}>
              <MaterialCommunityIcons name="delete-outline" size={24} color={COLORS.text.primary} />
            </TouchableOpacity>
          ),
        }} 
      />
      
      <FlatList
        ref={flatListRef}
        data={messages}
        renderItem={renderMessage}
        keyExtractor={item => item.id}
        contentContainerStyle={styles.messagesContainer}
      />
      
      {error && messages.length > 1 && (
        <View style={styles.errorContainer}>
          <MaterialCommunityIcons name="alert-circle" size={20} color="#ff6b6b" />
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}
      
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.input}
          placeholder="Type a message..."
          placeholderTextColor={COLORS.text.tertiary}
          value={message}
          onChangeText={setMessage}
          multiline
          maxLength={500}
          onSubmitEditing={handleSendMessage}
        />
        
        <TouchableOpacity 
          style={[
            styles.sendButton,
            (!message.trim() || loading) && styles.disabledSendButton
          ]}
          onPress={handleSendMessage}
          disabled={!message.trim() || loading}
        >
          {loading ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <MaterialCommunityIcons name="send" size={24} color="#fff" />
          )}
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  messagesContainer: {
    padding: 16,
    paddingBottom: 24,
  },
  messageContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    alignItems: 'flex-end',
  },
  userMessageContainer: {
    justifyContent: 'flex-end',
  },
  assistantMessageContainer: {
    justifyContent: 'flex-start',
  },
  avatarContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginHorizontal: 8,
  },
  messageBubble: {
    maxWidth: '70%',
    padding: 12,
    borderRadius: 16,
  },
  userMessageBubble: {
    backgroundColor: COLORS.primary,
    borderBottomRightRadius: 4,
  },
  assistantMessageBubble: {
    backgroundColor: COLORS.cardBackground,
    borderBottomLeftRadius: 4,
  },
  messageText: {
    color: COLORS.text.primary,
    fontSize: 16,
    lineHeight: 22,
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
    backgroundColor: COLORS.cardBackground,
    alignItems: 'center',
  },
  input: {
    flex: 1,
    backgroundColor: COLORS.background,
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 10,
    color: COLORS.text.primary,
    fontSize: 16,
    maxHeight: 120,
  },
  sendButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: COLORS.primary,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 12,
  },
  disabledSendButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.3)',
  },
  clearButton: {
    padding: 8,
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    padding: 12,
    borderRadius: 8,
    margin: 12,
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
});

================================================================================
File: app/ai/index.tsx
================================================================================

import { useEffect } from 'react';
import { Redirect } from 'expo-router';

export default function AIIndex() {
  // Redirect to the recommendations screen by default
  return <Redirect href={'/ai/recommendations' as any} />;
} 

================================================================================
File: app/ai/journal-insights.tsx
================================================================================

import React, { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity,
  ActivityIndicator
} from 'react-native';
import { Stack } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { UserProfile } from '../../src/types';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Mock journal entries for demo purposes
const mockJournalEntries = [
  {
    id: "j1",
    user_id: "user123",
    strain_id: 1,
    strain_name: "Blue Dream",
    consumption_method: "vaporize",
    dosage: 15,
    dosage_unit: "mg",
    effects_felt: ["Relaxed", "Happy", "Creative"],
    rating: 4,
    effectiveness: 4,
    notes: "Good for evening relaxation, helped with creativity",
    mood_before: "Stressed",
    mood_after: "Calm",
    medical_symptoms_relieved: ["Anxiety"],
    negative_effects: ["Dry mouth"],
    duration_minutes: 180,
    created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
  },
  {
    id: "j2",
    user_id: "user123",
    strain_id: 2,
    strain_name: "OG Kush",
    consumption_method: "edible",
    dosage: 10,
    dosage_unit: "mg",
    effects_felt: ["Sleepy", "Relaxed", "Hungry"],
    rating: 3,
    effectiveness: 4,
    notes: "Helped with sleep, but made me too hungry",
    mood_before: "Tired",
    mood_after: "Sleepy",
    medical_symptoms_relieved: ["Insomnia"],
    negative_effects: ["Groggy morning"],
    duration_minutes: 240,
    created_at: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
  },
  {
    id: "j3",
    user_id: "user123",
    strain_id: 3,
    strain_name: "Sour Diesel",
    consumption_method: "flower",
    dosage: 0.5,
    dosage_unit: "g",
    effects_felt: ["Energetic", "Focused", "Creative"],
    rating: 5,
    effectiveness: 5,
    notes: "Perfect for morning use, helped with productivity",
    mood_before: "Groggy",
    mood_after: "Energized",
    medical_symptoms_relieved: ["Fatigue"],
    negative_effects: [],
    duration_minutes: 150,
    created_at: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()
  }
];

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

export default function JournalInsightsScreen() {
  const { loading, error, analyzeJournalPatterns } = useAIRecommendations();
  const [insights, setInsights] = useState<any>(null);
  
  // Handle analyzing journal entries
  const handleAnalyzeJournal = async () => {
    const analysis = await analyzeJournalPatterns(mockJournalEntries, mockUserProfile);
    if (analysis) {
      setInsights(analysis);
    }
  };
  
  if (loading && !insights) {
    return <LoadingView />;
  }
  
  if (error && !insights) {
    return <ErrorView error={error} />;
  }
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          title: 'Journal Insights',
        }} 
      />
      
      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        <View style={styles.headerContainer}>
          <Text style={styles.headerTitle}>AI Journal Analysis</Text>
          <Text style={styles.headerSubtitle}>
            Get personalized insights based on your journal entries
          </Text>
        </View>
        
        <View style={styles.journalSummaryContainer}>
          <Text style={styles.sectionTitle}>Journal Summary</Text>
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{mockJournalEntries.length}</Text>
              <Text style={styles.statLabel}>Entries</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>
                {(mockJournalEntries.reduce((sum, entry) => sum + entry.rating, 0) / mockJournalEntries.length).toFixed(1)}
              </Text>
              <Text style={styles.statLabel}>Avg Rating</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>
                {[...new Set(mockJournalEntries.map(entry => entry.strain_name))].length}
              </Text>
              <Text style={styles.statLabel}>Strains</Text>
            </View>
          </View>
        </View>
        
        <TouchableOpacity 
          style={styles.analyzeButton}
          onPress={handleAnalyzeJournal}
          disabled={loading}
        >
          <Text style={styles.analyzeButtonText}>
            {loading ? 'Analyzing...' : 'Analyze My Journal'}
          </Text>
          {loading && (
            <ActivityIndicator 
              size="small" 
              color="#fff" 
              style={styles.loadingIndicator} 
            />
          )}
        </TouchableOpacity>
        
        {error && insights && (
          <View style={styles.errorContainer}>
            <MaterialCommunityIcons name="alert-circle" size={24} color="#ff6b6b" />
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}
        
        {insights && (
          <View style={styles.insightsContainer}>
            <Text style={styles.insightsTitle}>Your Personalized Insights</Text>
            
            {/* Pattern Insights */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="chart-line" size={24} color={COLORS.primary} />
                <Text style={styles.insightHeaderText}>Usage Patterns</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.patterns?.summary || "You tend to use cannabis in the evening for relaxation. Your highest rated strains are typically Sativa dominant."}
              </Text>
            </View>
            
            {/* Effectiveness Insights */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="check-circle" size={24} color={COLORS.primary} />
                <Text style={styles.insightHeaderText}>Effectiveness</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.effectiveness?.summary || "Based on your ratings, strains with high myrcene content seem to be most effective for your needs."}
              </Text>
              <View style={styles.effectiveStrains}>
                {(insights.effectiveness?.topStrains || ["Sour Diesel", "Blue Dream"]).map((strain: string, index: number) => (
                  <View key={`strain-${index}`} style={styles.effectiveStrain}>
                    <Text style={styles.effectiveStrainText}>{strain}</Text>
                  </View>
                ))}
              </View>
            </View>
            
            {/* Recommendations */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="lightbulb" size={24} color={COLORS.primary} />
                <Text style={styles.insightHeaderText}>Recommendations</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.recommendations?.summary || "Consider trying lower doses in the evening to improve sleep quality without morning grogginess."}
              </Text>
              <View style={styles.recommendationsList}>
                {(insights.recommendations?.tips || [
                  "Try vaporizing at a lower temperature",
                  "Consider CBD-rich strains for anxiety",
                  "Journal more consistently for better insights"
                ]).map((tip: string, index: number) => (
                  <View key={`tip-${index}`} style={styles.recommendationItem}>
                    <MaterialCommunityIcons name="arrow-right" size={16} color={COLORS.primary} />
                    <Text style={styles.recommendationText}>{tip}</Text>
                  </View>
                ))}
              </View>
            </View>
          </View>
        )}
        
        {!insights && !loading && (
          <View style={styles.placeholderContainer}>
            <MaterialCommunityIcons name="book-open-page-variant" size={64} color={COLORS.text.tertiary} />
            <Text style={styles.placeholderText}>
              Tap "Analyze My Journal" to get personalized insights based on your usage patterns
            </Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  headerContainer: {
    marginBottom: 24,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 8,
  },
  headerSubtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    lineHeight: 22,
  },
  journalSummaryContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: COLORS.primary,
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  analyzeButton: {
    backgroundColor: COLORS.primary,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    marginBottom: 24,
    flexDirection: 'row',
    justifyContent: 'center',
  },
  analyzeButtonText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  loadingIndicator: {
    marginLeft: 10,
  },
  errorContainer: {
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
    flexDirection: 'row',
    alignItems: 'center',
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
  insightsContainer: {
    marginBottom: 24,
  },
  insightsTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 16,
  },
  insightCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  insightHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  insightHeaderText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginLeft: 8,
  },
  insightText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    lineHeight: 22,
    marginBottom: 16,
  },
  effectiveStrains: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  effectiveStrain: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    borderRadius: 16,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  effectiveStrainText: {
    color: COLORS.primary,
    fontWeight: '500',
  },
  recommendationsList: {
    marginTop: 8,
  },
  recommendationItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  recommendationText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    marginLeft: 8,
    flex: 1,
  },
  placeholderContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
    marginTop: 24,
  },
  placeholderText: {
    fontSize: 16,
    color: COLORS.text.tertiary,
    textAlign: 'center',
    marginTop: 16,
    lineHeight: 24,
  },
});

================================================================================
File: app/ai/onboarding.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ActivityIndicator } from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { LinearGradient } from 'expo-linear-gradient';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Define the step type with proper icon names
type OnboardingStep = {
  title: string;
  description: string;
  icon: React.ComponentProps<typeof MaterialCommunityIcons>['name'];
  color: string;
};

const ONBOARDING_STEPS: OnboardingStep[] = [
  {
    title: "Personalized Recommendations",
    description: "Our AI analyzes your preferences and usage patterns to suggest strains tailored to your needs.",
    icon: "leaf",
    color: COLORS.primary
  },
  {
    title: "Smart Safety Checks",
    description: "We automatically check for potential interactions and usage patterns to keep you informed and safe.",
    icon: "shield-check",
    color: COLORS.primary
  },
  {
    title: "Journal Insights",
    description: "Get personalized insights from your journal entries to better understand what works for you.",
    icon: "notebook",
    color: COLORS.primary
  },
  {
    title: "AI Assistant",
    description: "Chat with our AI assistant to get answers about cannabis, effects, dosing, and more.",
    icon: "robot",
    color: COLORS.primary
  }
];

export default function AIOnboarding() {
  const router = useRouter();
  const [currentStep, setCurrentStep] = useState(0);
  const [isCompleting, setIsCompleting] = useState(false);
  const [hasChecked, setHasChecked] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Check if onboarding is already completed
  useEffect(() => {
    const checkOnboardingStatus = async () => {
      try {
        const hasCompletedOnboarding = await AsyncStorage.getItem('ai_onboarding_completed');
        if (hasCompletedOnboarding === 'true') {
          router.replace('/ai/recommendations');
        }
      } catch (error) {
        console.error('Error checking onboarding status:', error);
        setError('Failed to check onboarding status');
      } finally {
        setHasChecked(true);
      }
    };
    
    checkOnboardingStatus();
  }, [router]);
  
  const handleNext = () => {
    if (currentStep < ONBOARDING_STEPS.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      completeOnboarding();
    }
  };
  
  const completeOnboarding = async () => {
    try {
      setIsCompleting(true);
      await AsyncStorage.setItem('ai_onboarding_completed', 'true');
      
      // Add a small delay to ensure the AsyncStorage value is set
      await new Promise(resolve => setTimeout(resolve, 300));
      
      router.replace('/ai/recommendations');
    } catch (error) {
      console.error('Error saving onboarding status:', error);
      setIsCompleting(false);
      setError('Failed to complete onboarding');
    }
  };
  
  // Show loading screen while checking onboarding status
  if (!hasChecked) {
    return <LoadingView />;
  }
  
  if (error) {
    return <ErrorView error={error} />;
  }
  
  const step = ONBOARDING_STEPS[currentStep];
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          headerShown: false
        }} 
      />
      
      <LinearGradient
        colors={[COLORS.background, COLORS.background]}
        style={StyleSheet.absoluteFill}
      />
      
      <View style={styles.content}>
        <View style={styles.stepIndicators}>
          {ONBOARDING_STEPS.map((_, index) => (
            <View 
              key={index} 
              style={[
                styles.stepDot,
                currentStep === index && styles.activeStepDot
              ]} 
            />
          ))}
        </View>
        
        <View style={styles.iconContainer}>
          <LinearGradient
            colors={[step.color, `${step.color}80`]}
            style={styles.iconGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons 
              name={step.icon} 
              size={60} 
              color="#FFFFFF" 
            />
          </LinearGradient>
        </View>
        
        <Text style={styles.title}>{step.title}</Text>
        <Text style={styles.description}>{step.description}</Text>
        
        <View style={styles.buttonContainer}>
          <TouchableOpacity 
            style={styles.skipButton}
            onPress={completeOnboarding}
            disabled={isCompleting}
          >
            <Text style={styles.skipButtonText}>Skip</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={styles.nextButton}
            onPress={handleNext}
            disabled={isCompleting}
          >
            {isCompleting ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <>
                <Text style={styles.nextButtonText}>
                  {currentStep < ONBOARDING_STEPS.length - 1 ? 'Next' : 'Get Started'}
                </Text>
                <MaterialCommunityIcons 
                  name="arrow-right" 
                  size={20} 
                  color="#FFFFFF" 
                />
              </>
            )}
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  stepIndicators: {
    flexDirection: 'row',
    marginBottom: 60,
  },
  stepDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    marginHorizontal: 6,
  },
  activeStepDot: {
    backgroundColor: COLORS.primary,
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  iconContainer: {
    marginBottom: 40,
  },
  iconGradient: {
    width: 120,
    height: 120,
    borderRadius: 60,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 16,
    textAlign: 'center',
  },
  description: {
    fontSize: 16,
    color: COLORS.text.secondary,
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 60,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  skipButton: {
    padding: 16,
  },
  skipButtonText: {
    color: COLORS.text.tertiary,
    fontSize: 16,
  },
  nextButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 30,
    flexDirection: 'row',
    alignItems: 'center',
    minWidth: 120,
    justifyContent: 'center',
  },
  nextButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginRight: 8,
  },
});

================================================================================
File: app/ai/recommendations.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity, 
  Alert,
  TextInput
} from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { RecommendationRequest, StrainRecommendation, UserProfile } from '../../src/types';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Extended StrainRecommendation for UI purposes
interface UIStrainRecommendation extends StrainRecommendation {
  name: string;
  type: string;
  effects: string[];
  reason: string;
}

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

export default function RecommendationsScreen() {
  const router = useRouter();
  const { 
    loading, 
    error, 
    recommendations, 
    safetyValidation,
    getRecommendations 
  } = useAIRecommendations();
  
  const [desiredEffects, setDesiredEffects] = useState<string[]>(['relaxed', 'creative']);
  const [context, setContext] = useState<'recreational' | 'medical'>('recreational');
  const [customEffect, setCustomEffect] = useState('');
  
  // Fetch recommendations on initial load
  useEffect(() => {
    fetchRecommendations();
  }, []);
  
  // Handle fetching recommendations
  const fetchRecommendations = async () => {
    const request: RecommendationRequest = {
      userProfile: mockUserProfile,
      desiredEffects,
      context,
      medicalNeeds: context === 'medical' ? mockUserProfile.medical_needs : []
    };
    
    await getRecommendations(request);
  };
  
  // Add custom effect
  const handleAddEffect = () => {
    if (customEffect.trim() && !desiredEffects.includes(customEffect.trim().toLowerCase())) {
      setDesiredEffects([...desiredEffects, customEffect.trim().toLowerCase()]);
      setCustomEffect('');
    }
  };
  
  // Remove effect
  const handleRemoveEffect = (effect: string) => {
    setDesiredEffects(desiredEffects.filter(e => e !== effect));
  };
  
  // Transform StrainRecommendation to UIStrainRecommendation
  const enhanceRecommendation = (recommendation: StrainRecommendation): UIStrainRecommendation => {
    // Extract genetic type from the reasoning factors if available
    let type = 'hybrid'; // Default to hybrid
    
    if (recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors)) {
      // Look for the genetic type in the reasoning factors
      const typeFactors = recommendation.reasoningFactors.filter(factor => 
        factor.factor.includes('Indica') || 
        factor.factor.includes('Sativa') || 
        factor.factor.includes('Hybrid')
      );
      
      if (typeFactors.length > 0) {
        const typeFactor = typeFactors[0].factor.toLowerCase();
        
        if (typeFactor.includes('indica')) {
          type = 'indica';
        } else if (typeFactor.includes('sativa')) {
          type = 'sativa';
        } else if (typeFactor.includes('hybrid')) {
          type = 'hybrid';
        }
      }
    }
    
    // Extract effects from the reasoning factors
    let effects = ['Relaxed', 'Happy']; // Default effects
    
    if (recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors)) {
      const effectsFactor = recommendation.reasoningFactors.find(factor => 
        factor.factor.includes('Matches') && factor.factor.includes('effects')
      );
      
      if (effectsFactor) {
        // Try to extract the effects from the factor text
        effects = effectsFactor.factor
          .replace('Matches', '')
          .replace('of your desired effects', '')
          .trim()
          .split(',')
          .map(e => e.trim())
          .filter(e => e.length > 0);
        
        // If we couldn't extract effects, use the desired effects from the request
        if (effects.length === 0 || (effects.length === 1 && !isNaN(parseInt(effects[0])))) {
          effects = desiredEffects.map(e => e.charAt(0).toUpperCase() + e.slice(1));
        }
      }
    }
    
    return {
      ...recommendation,
      name: recommendation.strainName,
      type: type,
      effects: effects,
      reason: recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors) 
        ? recommendation.reasoningFactors.map(f => f.factor).join('. ')
        : 'Recommended based on your preferences'
    };
  };
  
  // Render recommendation card
  const renderRecommendationCard = (recommendation: StrainRecommendation, index: number) => {
    const enhancedRecommendation = enhanceRecommendation(recommendation);
    
    return (
      <TouchableOpacity 
        key={`recommendation-${index}`}
        style={styles.recommendationCard}
        onPress={() => Alert.alert('Strain Details', `View detailed information about ${enhancedRecommendation.name}`)}
      >
        <View style={[
          styles.strainTypeIndicator,
          { backgroundColor: getStrainTypeColor(enhancedRecommendation.type) }
        ]} />
        <View style={styles.recommendationContent}>
          <Text style={styles.strainName}>{enhancedRecommendation.name}</Text>
          <Text style={styles.strainType}>{enhancedRecommendation.type}</Text>
          <Text style={styles.matchScore}>
            {enhancedRecommendation.matchScore}% Match
          </Text>
          <Text style={styles.reasonText}>{enhancedRecommendation.reason}</Text>
          
          <View style={styles.effectsContainer}>
            {enhancedRecommendation.effects.slice(0, 3).map((effect, i) => (
              <View key={`effect-${i}`} style={styles.effectTag}>
                <Text style={styles.effectText}>{effect}</Text>
              </View>
            ))}
          </View>
        </View>
      </TouchableOpacity>
    );
  };
  
  // Get color based on strain type
  const getStrainTypeColor = (type: string): string => {
    switch(type.toLowerCase()) {
      case 'indica':
        return '#3949ab'; // Indigo color
      case 'sativa':
        return COLORS.primary; // Primary green color
      case 'hybrid':
        return '#7b1fa2'; // Purple color
      default:
        return '#757575'; // Gray color
    }
  };
  
  // Render safety warnings if any
  const renderSafetyWarnings = () => {
    if (!safetyValidation || !safetyValidation.safetyFlags) return null;
    
    return (
      <View style={styles.safetyWarningsContainer}>
        <View style={styles.safetyHeader}>
          <MaterialCommunityIcons 
            name="alert-circle-outline" 
            size={20} 
            color={safetyValidation.warningLevel === 'warning' ? '#ffb300' : '#2196f3'} 
          />
          <Text style={styles.safetyHeaderText}>Safety Information</Text>
        </View>
        
        {safetyValidation.safetyFlags.map((flag, index) => (
          <Text key={`flag-${index}`} style={styles.safetyFlag}>
             {flag}
          </Text>
        ))}
      </View>
    );
  };
  
  if (loading) {
    return <LoadingView />;
  }
  
  if (error && !recommendations) {
    return <ErrorView error={error} />;
  }
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          title: 'AI Strain Recommendations'
        }} 
      />
      
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.contentContainer} showsVerticalScrollIndicator={false}>
        {/* Context Selector */}
        <View style={styles.contextSelector}>
          <Text style={styles.sectionTitle}>Purpose</Text>
          <View style={styles.timeRangeButtons}>
            <TouchableOpacity
              style={[
                styles.timeRangeButton,
                context === 'recreational' && styles.timeRangeButtonActive
              ]}
              onPress={() => setContext('recreational')}
            >
              <Text style={[
                styles.timeRangeButtonText,
                context === 'recreational' && styles.timeRangeButtonTextActive
              ]}>
                Recreational
              </Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={[
                styles.timeRangeButton,
                context === 'medical' && styles.timeRangeButtonActive
              ]}
              onPress={() => setContext('medical')}
            >
              <Text style={[
                styles.timeRangeButtonText,
                context === 'medical' && styles.timeRangeButtonTextActive
              ]}>
                Medical
              </Text>
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Desired Effects */}
        <View style={styles.effectsSection}>
          <Text style={styles.sectionTitle}>Desired Effects</Text>
          
          <View style={styles.selectedEffectsContainer}>
            {desiredEffects.map((effect, index) => (
              <View key={`selected-${index}`} style={styles.selectedEffect}>
                <Text style={styles.selectedEffectText}>{effect}</Text>
                <TouchableOpacity onPress={() => handleRemoveEffect(effect)}>
                  <MaterialCommunityIcons name="close-circle" size={16} color={COLORS.text.primary} />
                </TouchableOpacity>
              </View>
            ))}
          </View>
          
          <View style={styles.addEffectContainer}>
            <TextInput
              style={styles.effectInput}
              placeholder="Add desired effect..."
              placeholderTextColor={COLORS.text.tertiary}
              value={customEffect}
              onChangeText={setCustomEffect}
              onSubmitEditing={handleAddEffect}
            />
            <TouchableOpacity 
              style={styles.addEffectButton}
              onPress={handleAddEffect}
            >
              <MaterialCommunityIcons name="plus" size={20} color={COLORS.text.primary} />
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Get Recommendations Button */}
        <TouchableOpacity 
          style={styles.getRecommendationsButton}
          onPress={fetchRecommendations}
        >
          <Text style={styles.getRecommendationsText}>
            Get Recommendations
          </Text>
        </TouchableOpacity>
        
        {/* Safety Warnings */}
        {renderSafetyWarnings()}
        
        {/* Error Message */}
        {error && recommendations && (
          <View style={styles.errorContainer}>
            <MaterialCommunityIcons name="alert-circle" size={24} color="#ff6b6b" />
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}
        
        {/* Recommendations */}
        {recommendations && recommendations.recommendations && Array.isArray(recommendations.recommendations) && recommendations.recommendations.length > 0 ? (
          <View style={styles.recommendationsContainer}>
            <Text style={styles.sectionTitle}>
              Your Personalized Recommendations
            </Text>
            
            {recommendations.recommendations.map((recommendation, index) => 
              renderRecommendationCard(recommendation, index)
            )}
            
            {/* Disclaimers */}
            {recommendations.disclaimers && Array.isArray(recommendations.disclaimers) && recommendations.disclaimers.length > 0 && (
              <View style={styles.disclaimersContainer}>
                <Text style={styles.insightTitle}>Important Information</Text>
                {recommendations.disclaimers.map((disclaimer, index) => (
                  <Text key={`disclaimer-${index}`} style={styles.disclaimerText}>
                     {disclaimer}
                  </Text>
                ))}
              </View>
            )}
          </View>
        ) : (
          <View style={styles.noRecommendationsContainer}>
            <Text style={styles.noRecommendationsText}>
              No recommendations available. Try adjusting your preferences or try again later.
            </Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    paddingHorizontal: 16,
    paddingBottom: 32,
  },
  contextSelector: {
    marginTop: 16,
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  timeRangeButtons: {
    flexDirection: 'row',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 12,
    padding: 4,
  },
  timeRangeButton: {
    flex: 1,
    paddingVertical: 10,
    alignItems: 'center',
    borderRadius: 8,
  },
  timeRangeButtonActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
  },
  timeRangeButtonText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  timeRangeButtonTextActive: {
    color: COLORS.primary,
    fontWeight: '600',
  },
  effectsSection: {
    marginBottom: 20,
  },
  selectedEffectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
  },
  selectedEffect: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
    borderRadius: 16,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  selectedEffectText: {
    color: COLORS.primary,
    marginRight: 6,
    fontWeight: '500',
  },
  addEffectContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  effectInput: {
    flex: 1,
    backgroundColor: COLORS.cardBackground,
    borderRadius: 8,
    padding: 12,
    color: COLORS.text.primary,
    marginRight: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  addEffectButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
    borderRadius: 8,
    padding: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  getRecommendationsButton: {
    backgroundColor: COLORS.primary,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    marginBottom: 20,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  getRecommendationsText: {
    color: '#fff',
    fontWeight: '700',
    fontSize: 16,
  },
  loadingIndicator: {
    marginLeft: 10,
  },
  safetyWarningsContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 2,
  },
  safetyHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  safetyHeaderText: {
    color: COLORS.text.primary,
    fontWeight: '600',
    marginLeft: 8,
    fontSize: 16,
  },
  safetyFlag: {
    color: COLORS.text.secondary,
    marginBottom: 4,
    lineHeight: 20,
  },
  errorContainer: {
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    borderRadius: 16,
    padding: 16,
    marginBottom: 20,
    flexDirection: 'row',
    alignItems: 'center',
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
  recommendationsContainer: {
    marginBottom: 20,
  },
  recommendationCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    marginBottom: 16,
    overflow: 'hidden',
    flexDirection: 'row',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
  },
  strainTypeIndicator: {
    width: 8,
    height: '100%',
  },
  recommendationContent: {
    padding: 16,
    flex: 1,
  },
  strainName: {
    fontSize: 18,
    fontWeight: '700',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  strainType: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 8,
    textTransform: 'capitalize'
  },
  matchScore: {
    fontSize: 16,
    fontWeight: '700',
    color: COLORS.primary,
    marginBottom: 8,
  },
  reasonText: {
    fontSize: 14,
    color: COLORS.text.secondary,
    marginBottom: 12,
    lineHeight: 20,
  },
  effectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  effectTag: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    borderRadius: 16,
    paddingVertical: 4,
    paddingHorizontal: 10,
    marginRight: 8,
    marginBottom: 4,
  },
  effectText: {
    color: COLORS.primary,
    fontSize: 12,
    fontWeight: '500',
  },
  disclaimersContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  insightTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
  },
  disclaimerText: {
    color: COLORS.text.secondary,
    marginBottom: 4,
    lineHeight: 20,
  },
  noRecommendationsContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginTop: 20,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  noRecommendationsText: {
    color: COLORS.text.secondary,
    fontSize: 16,
    textAlign: 'center',
    lineHeight: 22,
  },
});

================================================================================
File: app/components/achievements/AchievementCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Dimensions } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { UserAchievementWithDetails } from '../../../src/types';

interface AchievementCardProps {
  achievement: UserAchievementWithDetails;
  onPress: (achievement: UserAchievementWithDetails) => void;
}

export const AchievementCard: React.FC<AchievementCardProps> = ({ achievement, onPress }) => {
  const { name, category, progress, isUnlocked, icon } = achievement;
  
  // Define styles based on locked/unlocked state
  const cardOpacity = isUnlocked ? 1 : 0.6;
  const iconColor = isUnlocked ? '#00C853' : '#757575';
  const gradientColors = isUnlocked 
    ? ['#43A047', '#2E7D32'] as readonly [string, string]
    : ['#616161', '#424242'] as readonly [string, string];
  
  const renderProgressBar = () => {
    // Limit progress to 100%
    const limitedProgress = Math.min(100, progress);
    
    return (
      <View style={styles.progressContainer}>
        <View style={styles.progressBar}>
          <View style={[styles.progressFill, { flex: limitedProgress }]} />
          <View style={{ flex: 100 - limitedProgress }} />
        </View>
        <Text style={styles.progressText}>{Math.round(progress)}%</Text>
      </View>
    );
  };
  
  return (
    <TouchableOpacity 
      style={[styles.container, { opacity: cardOpacity }]} 
      onPress={() => onPress(achievement)}
      activeOpacity={0.8}
    >
      <LinearGradient
        colors={gradientColors}
        style={styles.gradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      >
        <View style={styles.content}>
          <View style={styles.iconContainer}>
            <MaterialCommunityIcons 
              name={icon as any || 'trophy'} 
              size={28} 
              color={iconColor} 
            />
          </View>
          
          <View style={styles.textContainer}>
            <Text style={styles.title}>{name}</Text>
            <Text style={styles.category}>{category}</Text>
            
            {!isUnlocked && renderProgressBar()}
          </View>
          
          {isUnlocked && (
            <View style={styles.completedBadge}>
              <MaterialCommunityIcons name="check-circle" size={18} color="#FFFFFF" />
            </View>
          )}
        </View>
      </LinearGradient>
    </TouchableOpacity>
  );
};

// Export default for expo-router
export default AchievementCard;

const styles = StyleSheet.create({
  container: {
    height: 80,
    borderRadius: 12,
    marginVertical: 6,
    overflow: 'hidden',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  gradient: {
    flex: 1,
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
  },
  iconContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#1E1E1E',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  textContainer: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 2,
  },
  category: {
    fontSize: 12,
    color: '#E0E0E0',
    marginBottom: 4,
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  progressBar: {
    height: 4,
    backgroundColor: '#424242',
    borderRadius: 2,
    flex: 1,
    marginRight: 8,
    overflow: 'hidden',
    flexDirection: 'row',
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#4CAF50',
    borderRadius: 2,
  },
  progressText: {
    fontSize: 12,
    color: '#E0E0E0',
    minWidth: 32,
  },
  completedBadge: {
    backgroundColor: '#4CAF50',
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
}); 

================================================================================
File: app/components/achievements/AchievementDetailModal.tsx
================================================================================

import React from 'react';
import { Modal, View, Text, StyleSheet, TouchableOpacity, ScrollView, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { UserAchievementWithDetails } from '../../../src/types';
import { COLORS } from '../../../src/constants';

interface AchievementDetailModalProps {
  visible: boolean;
  achievement: UserAchievementWithDetails | null;
  onClose: () => void;
}

export const AchievementDetailModal: React.FC<AchievementDetailModalProps> = ({ 
  visible, 
  achievement, 
  onClose 
}) => {
  if (!achievement) return null;
  
  const { name, category, unlockCondition, notes, progress, isUnlocked, dateUnlocked, icon, complexity } = achievement;
  
  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'Not yet unlocked';
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric'
    });
  };
  
  const renderComplexityStars = (level: number) => {
    return Array(3).fill(0).map((_, index) => (
      <MaterialCommunityIcons 
        key={index} 
        name="star" 
        size={16} 
        color={index < Math.min(level, 3) ? COLORS.primary : 'rgba(255, 255, 255, 0.2)'} 
        style={{ marginRight: 2 }}
      />
    ));
  };
  
  const renderProgressBar = () => {
    // Limit progress to 100%
    const limitedProgress = Math.min(100, progress);
    
    return (
      <View style={styles.progressContainer}>
        <View style={styles.progressBar}>
          <View style={[styles.progressFill, { flex: limitedProgress }]} />
          <View style={{ flex: 100 - limitedProgress }} />
        </View>
        <Text style={styles.progressText}>{Math.round(progress)}%</Text>
      </View>
    );
  };
  
  return (
    <Modal
      visible={visible}
      transparent={true}
      animationType="fade"
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.header}>
            <LinearGradient
              colors={[
                'rgba(0,230,118,0.2)',
                'rgba(0,230,118,0.05)',
                'transparent'
              ]}
              style={StyleSheet.absoluteFill}
              start={{ x: 0, y: 0 }}
              end={{ x: 0, y: 1 }}
            />
            
            <View style={styles.iconContainer}>
              <LinearGradient
                colors={['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.2)']}
                style={styles.iconGradient}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 1 }}
              >
                <MaterialCommunityIcons 
                  name={icon as any || 'trophy'} 
                  size={40} 
                  color={isUnlocked ? COLORS.primary : COLORS.text.secondary} 
                />
              </LinearGradient>
            </View>
            
            <TouchableOpacity style={styles.closeButton} onPress={onClose}>
              <MaterialCommunityIcons name="close" size={24} color={COLORS.text.secondary} />
            </TouchableOpacity>
          </View>
          
          <ScrollView style={styles.content}>
            <Text style={styles.title}>{name}</Text>
            
            <View style={styles.categoryRow}>
              <Text style={styles.categoryLabel}>{category}</Text>
              <View style={styles.complexityContainer}>
                {renderComplexityStars(complexity)}
              </View>
            </View>
            
            {!isUnlocked && (
              <View style={styles.progressSection}>
                {renderProgressBar()}
              </View>
            )}
            
            <View style={styles.detailSection}>
              <Text style={styles.sectionTitle}>How to unlock</Text>
              <Text style={styles.detailText}>{unlockCondition}</Text>
            </View>
            
            {notes && (
              <View style={styles.detailSection}>
                <Text style={styles.sectionTitle}>Details</Text>
                <Text style={styles.detailText}>{notes}</Text>
              </View>
            )}
            
            <View style={styles.detailSection}>
              <Text style={styles.sectionTitle}>Status</Text>
              <View style={styles.statusRow}>
                <MaterialCommunityIcons 
                  name={isUnlocked ? "check-circle" : "clock-outline"} 
                  size={18} 
                  color={isUnlocked ? COLORS.primary : COLORS.text.secondary} 
                  style={styles.statusIcon}
                />
                <Text style={styles.statusText}>
                  {isUnlocked 
                    ? `Unlocked on ${formatDate(dateUnlocked)}` 
                    : 'Not yet unlocked'}
                </Text>
              </View>
            </View>
          </ScrollView>
        </View>
      </View>
    </Modal>
  );
};

// Add default export for expo-router
export default AchievementDetailModal;

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    width: '100%',
    maxWidth: 500,
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.95)',
      android: 'rgba(26, 26, 26, 0.98)',
    }),
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 12,
      },
      android: {
        elevation: 8,
      },
    }),
  },
  header: {
    height: 120,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  iconContainer: {
    marginBottom: 8,
  },
  iconGradient: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.2)',
  },
  closeButton: {
    position: 'absolute',
    top: 12,
    right: 12,
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    padding: 20,
    maxHeight: 400,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: COLORS.text.primary,
    textAlign: 'center',
    marginBottom: 12,
    letterSpacing: 0.35,
  },
  categoryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  categoryLabel: {
    fontSize: 14,
    color: COLORS.text.secondary,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  complexityContainer: {
    flexDirection: 'row',
  },
  progressSection: {
    marginBottom: 20,
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  progressBar: {
    height: 8,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 4,
    flex: 1,
    marginRight: 8,
    overflow: 'hidden',
    flexDirection: 'row',
  },
  progressFill: {
    height: '100%',
    backgroundColor: COLORS.primary,
    borderRadius: 4,
  },
  progressText: {
    fontSize: 14,
    color: COLORS.text.secondary,
    minWidth: 40,
    textAlign: 'right',
  },
  detailSection: {
    marginBottom: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    padding: 16,
    borderRadius: 12,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.25,
  },
  detailText: {
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
    letterSpacing: 0.25,
  },
  statusRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusIcon: {
    marginRight: 8,
  },
  statusText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
});

================================================================================
File: app/components/achievements/AchievementUnlockedNotification.tsx
================================================================================

import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated, TouchableOpacity, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { UserAchievementWithDetails } from '../../../src/types';
import { COLORS } from '../../../src/constants';

interface AchievementUnlockedNotificationProps {
  achievement: UserAchievementWithDetails;
  onPress: (achievement: UserAchievementWithDetails) => void;
  onDismiss: () => void;
}

export const AchievementUnlockedNotification: React.FC<AchievementUnlockedNotificationProps> = ({
  achievement,
  onPress,
  onDismiss
}) => {
  const slideAnim = useRef(new Animated.Value(-200)).current;
  const opacityAnim = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    // Slide in
    Animated.parallel([
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 500,
        useNativeDriver: true,
      }),
      Animated.timing(opacityAnim, {
        toValue: 1,
        duration: 400,
        useNativeDriver: true,
      })
    ]).start();
    
    // Auto dismiss after 5 seconds
    const timeout = setTimeout(() => {
      dismiss();
    }, 5000);
    
    return () => clearTimeout(timeout);
  }, []);
  
  const dismiss = () => {
    Animated.parallel([
      Animated.timing(slideAnim, {
        toValue: -200,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(opacityAnim, {
        toValue: 0,
        duration: 250,
        useNativeDriver: true,
      })
    ]).start(() => {
      onDismiss();
    });
  };
  
  return (
    <Animated.View
      style={[
        styles.container,
        {
          transform: [{ translateY: slideAnim }],
          opacity: opacityAnim,
        }
      ]}
    >
      <TouchableOpacity
        style={styles.touchable}
        onPress={() => {
          dismiss();
          onPress(achievement);
        }}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          <View style={styles.iconContainer}>
            <LinearGradient
              colors={['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.2)']}
              style={styles.iconGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons
                name={achievement.icon as any || 'trophy'}
                size={24}
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>
          
          <View style={styles.textContainer}>
            <Text style={styles.achievementUnlocked}>Achievement Unlocked!</Text>
            <Text style={styles.title}>{achievement.name}</Text>
          </View>
          
          <TouchableOpacity style={styles.closeButton} onPress={dismiss}>
            <MaterialCommunityIcons name="close" size={16} color={COLORS.text.secondary} />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

// Add default export for expo-router
export default AchievementUnlockedNotification;

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 60,
    left: 20,
    right: 20,
    zIndex: 1000,
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  touchable: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
  },
  iconContainer: {
    marginRight: 12,
  },
  iconGradient: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  textContainer: {
    flex: 1,
  },
  achievementUnlocked: {
    fontSize: 12,
    color: COLORS.text.secondary,
    textTransform: 'uppercase',
    fontWeight: '600',
    letterSpacing: 0.5,
    marginBottom: 4,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.35,
  },
  closeButton: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================================================================================
File: app/components/ai/RecommendationFeedback.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, TextInput, ActivityIndicator } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { AIService } from '../../../src/services/ai';

interface RecommendationFeedbackProps {
  userId: string;
  recommendationId: string;
  onClose: () => void;
}

export default function RecommendationFeedback({ 
  userId, 
  recommendationId, 
  onClose 
}: RecommendationFeedbackProps) {
  const [helpful, setHelpful] = useState<boolean | null>(null);
  const [accurateEffects, setAccurateEffects] = useState<boolean | null>(null);
  const [wouldTryAgain, setWouldTryAgain] = useState<boolean | null>(null);
  const [comments, setComments] = useState('');
  const [submitting, setSubmitting] = useState(false);
  
  // Get AIService instance
  const aiService = AIService.getInstance();
  
  const handleSubmit = async () => {
    if (helpful === null) return;
    
    setSubmitting(true);
    
    try {
      // Calculate relevance score (1-5) based on user feedback
      const relevance = calculateRelevanceScore(helpful, accurateEffects, wouldTryAgain);
      
      await aiService.submitRecommendationFeedback(
        userId,
        recommendationId,
        helpful,
        accurateEffects || false,
        relevance,
        comments
      );
      
      onClose();
    } catch (error) {
      console.error('Error submitting feedback:', error);
    } finally {
      setSubmitting(false);
    }
  };
  
  // Calculate a relevance score (1-5) based on user feedback
  const calculateRelevanceScore = (
    helpful: boolean, 
    accurateEffects: boolean | null, 
    wouldTryAgain: boolean | null
  ): number => {
    if (!helpful) return 1; // Not helpful at all
    
    // Base score for helpful
    let score = 3;
    
    // Add points for accurate effects
    if (accurateEffects) score += 1;
    
    // Add points for would try again
    if (wouldTryAgain) score += 1;
    
    return Math.min(score, 5); // Cap at 5
  };
  
  return (
    <View style={styles.container}>
      <Text style={styles.title}>How was this recommendation?</Text>
      
      <View style={styles.questionContainer}>
        <Text style={styles.questionText}>Was this recommendation helpful?</Text>
        <View style={styles.buttonGroup}>
          <TouchableOpacity 
            style={[
              styles.optionButton,
              helpful === true && styles.selectedButton
            ]}
            onPress={() => setHelpful(true)}
          >
            <MaterialCommunityIcons 
              name="thumb-up" 
              size={20} 
              color={helpful === true ? '#FFFFFF' : '#AAAAAA'} 
            />
            <Text style={[
              styles.optionText,
              helpful === true && styles.selectedOptionText
            ]}>Yes</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[
              styles.optionButton,
              helpful === false && styles.selectedButton
            ]}
            onPress={() => setHelpful(false)}
          >
            <MaterialCommunityIcons 
              name="thumb-down" 
              size={20} 
              color={helpful === false ? '#FFFFFF' : '#AAAAAA'} 
            />
            <Text style={[
              styles.optionText,
              helpful === false && styles.selectedOptionText
            ]}>No</Text>
          </TouchableOpacity>
        </View>
      </View>
      
      {helpful !== null && (
        <>
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>Were the effects as described?</Text>
            <View style={styles.buttonGroup}>
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  accurateEffects === true && styles.selectedButton
                ]}
                onPress={() => setAccurateEffects(true)}
              >
                <Text style={[
                  styles.optionText,
                  accurateEffects === true && styles.selectedOptionText
                ]}>Yes</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  accurateEffects === false && styles.selectedButton
                ]}
                onPress={() => setAccurateEffects(false)}
              >
                <Text style={[
                  styles.optionText,
                  accurateEffects === false && styles.selectedOptionText
                ]}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>Would you try this strain again?</Text>
            <View style={styles.buttonGroup}>
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  wouldTryAgain === true && styles.selectedButton
                ]}
                onPress={() => setWouldTryAgain(true)}
              >
                <Text style={[
                  styles.optionText,
                  wouldTryAgain === true && styles.selectedOptionText
                ]}>Yes</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  wouldTryAgain === false && styles.selectedButton
                ]}
                onPress={() => setWouldTryAgain(false)}
              >
                <Text style={[
                  styles.optionText,
                  wouldTryAgain === false && styles.selectedOptionText
                ]}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          <View style={styles.commentsContainer}>
            <Text style={styles.questionText}>Additional comments (optional)</Text>
            <TextInput
              style={styles.commentsInput}
              placeholder="Share your experience..."
              placeholderTextColor="#888888"
              value={comments}
              onChangeText={setComments}
              multiline
              maxLength={500}
            />
          </View>
          
          <TouchableOpacity 
            style={styles.submitButton}
            onPress={handleSubmit}
            disabled={submitting}
          >
            {submitting ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <Text style={styles.submitButtonText}>Submit Feedback</Text>
            )}
          </TouchableOpacity>
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#1A1A1A',
    borderRadius: 16,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 20,
    textAlign: 'center',
  },
  questionContainer: {
    marginBottom: 20,
  },
  questionText: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 12,
  },
  buttonGroup: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  optionButton: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginHorizontal: 6,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  selectedButton: {
    backgroundColor: '#4CAF50',
  },
  optionText: {
    color: '#AAAAAA',
    fontSize: 16,
    marginLeft: 8,
  },
  selectedOptionText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  commentsContainer: {
    marginBottom: 20,
  },
  commentsInput: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 8,
    padding: 12,
    color: '#FFFFFF',
    height: 100,
    textAlignVertical: 'top',
  },
  submitButton: {
    backgroundColor: '#4CAF50',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
  },
  submitButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
}); 

================================================================================
File: app/components/charts/BarChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';

interface BarChartProps {
  data: number[];
  labels: string[];
  maxValue?: number;
  barColor?: string;
}

const BarChart: React.FC<BarChartProps> = ({ 
  data, 
  labels, 
  maxValue: propMaxValue, 
  barColor = COLORS.primary
}) => {
  // Calculate maxValue if not provided
  const maxValue = propMaxValue || Math.max(...data) * 1.2; // Add 20% padding
  const chartHeight = 220;
  const divisions = 5; // Number of horizontal lines

  // Generate y-axis labels
  const yAxisLabels = Array.from({ length: divisions + 1 }, (_, i) => {
    const value = (maxValue / divisions) * (divisions - i);
    return Math.round(value).toString();
  });

  return (
    <View style={styles.container}>
      {/* Y-axis labels */}
      <View style={styles.yAxis}>
        {yAxisLabels.map((label, index) => (
          <Text key={index} style={styles.yAxisLabel}>
            {label}
          </Text>
        ))}
      </View>

      {/* Chart area */}
      <View style={styles.chartArea}>
        {/* Horizontal grid lines */}
        {yAxisLabels.map((_, index) => (
          <View 
            key={index} 
            style={[
              styles.gridLine,
              { top: (chartHeight / divisions) * index }
            ]} 
          />
        ))}

        {/* Bars */}
        <View style={styles.barsContainer}>
          {data.map((value, index) => {
            const barHeight = (value / maxValue) * chartHeight;
            
            return (
              <View key={index} style={styles.barWrapper}>
                <View style={styles.barLabelContainer}>
                  <Text style={styles.barValue}>{value}</Text>
                </View>
                <View style={[styles.barBackground, { height: barHeight }]}>
                  <LinearGradient
                    colors={[
                      `${barColor}CC`, // 80% opacity
                      `${barColor}66`, // 40% opacity
                    ]}
                    style={[styles.bar, { height: '100%' }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 0, y: 1 }}
                  />
                </View>
                <Text style={styles.xAxisLabel}>{labels[index]}</Text>
              </View>
            );
          })}
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    height: 280, // Include space for labels
    paddingRight: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 12,
    padding: 16,
  },
  yAxis: {
    width: 50,
    justifyContent: 'space-between',
    marginRight: 10,
  },
  yAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    textAlign: 'right',
  },
  chartArea: {
    flex: 1,
    height: 220,
    position: 'relative',
  },
  gridLine: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  barsContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    height: '100%',
  },
  barWrapper: {
    flex: 1,
    alignItems: 'center',
    height: '100%',
    justifyContent: 'flex-end',
  },
  barLabelContainer: {
    position: 'absolute',
    top: -20,
    width: '100%',
    alignItems: 'center',
  },
  barValue: {
    color: COLORS.text.primary,
    fontSize: 12,
    fontWeight: '600',
  },
  barBackground: {
    width: '60%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
    overflow: 'hidden',
  },
  bar: {
    width: '100%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
  },
  xAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    marginTop: 8,
  },
});

export default BarChart; 

================================================================================
File: app/components/charts/ChartStyles.ts
================================================================================

import { StyleSheet } from 'react-native';
import { COLORS } from '../../../src/constants';

const chartStyles = StyleSheet.create({
  card: {
    backgroundColor: COLORS.cardBackground,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 20,
    padding: 20,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 15,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.08)',
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12,
  },
  headerIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: 0.38,
  },
  description: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 20,
    letterSpacing: -0.24,
    lineHeight: 20,
  },
  chartWrapper: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
  },
  chartContainer: {
    borderRadius: 16,
    overflow: 'hidden',
  },
});

export default chartStyles; 

================================================================================
File: app/components/charts/LineChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { LineChart as RNLineChart } from 'react-native-chart-kit';
import { COLORS } from '../../../src/constants';

interface LineChartProps {
  data: number[];
  labels: string[];
  color?: string;
  width?: number;
  height?: number;
  alwaysShowZero?: boolean;
}

const screenWidth = Dimensions.get('window').width;

const LineChart: React.FC<LineChartProps> = ({
  data,
  labels,
  color = COLORS.primary,
  width = screenWidth - 64,
  height = 220,
  alwaysShowZero = true
}) => {
  // Check if we have data to display (any data points)
  const hasAnyData = data && data.length > 0;
  
  // Check if we have any non-zero values
  const hasNonZeroData = hasAnyData && data.some(val => val > 0);
  
  // If no data at all, display "No data available" message
  if (!hasAnyData) {
    return (
      <View style={[styles.container, { height, width, justifyContent: 'center', alignItems: 'center' }]}>
        <Text style={styles.noDataText}>No data available</Text>
      </View>
    );
  }
  
  // If all values are zero and we don't want to show zero charts
  if (!hasNonZeroData && !alwaysShowZero) {
    return (
      <View style={[styles.container, { height, width, justifyContent: 'center', alignItems: 'center' }]}>
        <Text style={styles.noDataText}>No data available for this time period</Text>
      </View>
    );
  }
  
  // Validate data to prevent NaN values
  const validatedData = data.map(val => (isNaN(val) ? 0 : val));
  
  const chartConfig = {
    backgroundColor: 'transparent',
    backgroundGradientFrom: 'transparent',
    backgroundGradientTo: 'transparent',
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
    labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity * 0.7})`,
    style: {
      borderRadius: 16
    },
    propsForDots: {
      r: '5',
      strokeWidth: '2',
      stroke: color
    },
    propsForBackgroundLines: {
      strokeDasharray: '5, 5',
      stroke: 'rgba(255, 255, 255, 0.1)',
      strokeWidth: 1
    },
    propsForLabels: {
      fontSize: 10
    }
  };

  return (
    <View style={styles.container}>
      <RNLineChart
        data={{
          labels,
          datasets: [
            {
              data: validatedData,
              color: (opacity = 1) => color ? `${color}${Math.round(opacity * 255).toString(16).padStart(2, '0')}` : `rgba(0, 230, 118, ${opacity})`,
              strokeWidth: 2
            }
          ]
        }}
        width={width}
        height={height}
        chartConfig={chartConfig}
        bezier
        style={styles.chart}
        withInnerLines={true}
        withOuterLines={false}
        withHorizontalLabels={true}
        withVerticalLabels={true}
        withDots={true}
        segments={5}
        fromZero={true}
      />
      
      {/* Show an overlay message when all values are zero but we're still showing the chart */}
      {!hasNonZeroData && alwaysShowZero && (
        <View style={styles.zeroDataOverlay}>
          <Text style={styles.zeroDataText}>No activity recorded</Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 16,
    overflow: 'hidden',
    position: 'relative',
  },
  chart: {
    borderRadius: 16,
  },
  noDataText: {
    color: COLORS.text.secondary,
    fontSize: 16,
    textAlign: 'center',
  },
  zeroDataOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    borderRadius: 16,
  },
  zeroDataText: {
    color: COLORS.text.secondary,
    fontSize: 14,
    textAlign: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
  }
});

export default LineChart; 

================================================================================
File: app/components/charts/MonthlyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '../../../src/types';

interface MonthlyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const MonthlyOverviewChart: React.FC<MonthlyOverviewChartProps> = ({ data, onPress }) => {
  // Validate data to prevent NaN values
  const validatedData = data.map(item => ({
    ...item,
    value: isNaN(item.value) ? 0 : item.value
  }));
  
  const chartData = {
    labels: validatedData.map(item => item.label),
    datasets: [{
      data: validatedData.map(item => item.value)
    }]
  };

  // Calculate monthly stats with validated data
  const totalHits = validatedData.reduce((sum, month) => sum + month.value, 0);
  const avgHits = totalHits / validatedData.length;
  const maxHits = Math.max(...validatedData.map(month => month.value));
  const maxMonth = validatedData.find(month => month.value === maxHits)?.label || '';
  
  // Prevent division by zero and handle potential NaN values
  const monthlyGrowth = validatedData.length > 1 && validatedData[0].value !== 0
    ? ((validatedData[validatedData.length - 1].value - validatedData[0].value) / validatedData[0].value * 100).toFixed(1)
    : '0';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Monthly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/month average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-areaspline" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Month</Text>
              <Text style={styles.statValue}>{maxMonth}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Growth</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={Number(monthlyGrowth) >= 0 ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(Number(monthlyGrowth))}%
                </Text>
              </View>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Monthly Analysis</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 18,
    fontWeight: '600',
    marginLeft: 4,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default MonthlyOverviewChart; 

================================================================================
File: app/components/charts/WeeklyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '../../../src/types';

interface WeeklyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const WeeklyOverviewChart: React.FC<WeeklyOverviewChartProps> = ({ data, onPress }) => {
  // Validate data to prevent NaN values
  const validatedData = data.map(item => ({
    ...item,
    value: isNaN(item.value) ? 0 : item.value
  }));
  
  const chartData = {
    labels: validatedData.map(item => item.label),
    datasets: [{
      data: validatedData.map(item => item.value)
    }]
  };

  // Calculate weekly stats using validated data
  const totalHits = validatedData.reduce((sum, day) => sum + day.value, 0);
  const avgHits = totalHits / 7;
  const maxHits = Math.max(...validatedData.map(day => day.value));
  const maxDay = validatedData.find(day => day.value === maxHits)?.label || '';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Weekly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/day average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-line-variant" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Day</Text>
              <Text style={styles.statValue}>{maxDay}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Max Hits</Text>
              <Text style={styles.statValue}>{maxHits}</Text>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Details</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default WeeklyOverviewChart; 

================================================================================
File: app/components/Header.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { COLORS } from '@/src/constants';

interface HeaderProps {
  title: string;
}

export default function Header({ title }: HeaderProps) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: COLORS.background,
  },
  title: {
    fontSize: 28,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
}); 

================================================================================
File: app/components/shared/Card.tsx
================================================================================

import React, { forwardRef } from "react";
import { View, StyleSheet, StyleProp, ViewStyle } from "react-native";
import { COLORS } from '../../../src/constants';

interface CardProps {
    children: React.ReactNode;
    style?: StyleProp<ViewStyle>;
}

export const Card = forwardRef<View, CardProps>(({ children, style }, ref) => {
    return <View ref={ref} style={[styles.card, style]}>{children}</View>;
});

const styles = StyleSheet.create({
    card: {
        backgroundColor: COLORS.cardBackground,
        borderRadius: 16,
        elevation: 6,
        shadowColor: COLORS.primary,
        shadowOffset: {
            width: 0,
            height: 2,
        },
        shadowOpacity: 0.15,
        shadowRadius: 8,
        padding: 16,
        borderWidth: 1,
        borderColor: 'rgba(0, 230, 118, 0.1)',
    }
});

// Add default export for expo-router
export default Card;

================================================================================
File: app/components/shared/ErrorView.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '@/src/constants';

interface ErrorViewProps {
  error: string;
}

export default function ErrorView({ error }: ErrorViewProps) {
  return (
    <View style={styles.container}>
      <MaterialCommunityIcons 
        name="alert-circle-outline" 
        size={48} 
        color={COLORS.error} 
      />
      <Text style={styles.title}>Error</Text>
      <Text style={styles.message}>{error}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    marginTop: 16,
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  message: {
    marginTop: 8,
    fontSize: 16,
    color: COLORS.text.secondary,
    textAlign: 'center',
  },
});

================================================================================
File: app/components/shared/LoadingView.tsx
================================================================================

import React, { useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '../../../src/constants';
import Animated, { 
  withRepeat, 
  withTiming,
  useAnimatedStyle, 
  useSharedValue,
  FadeIn
} from 'react-native-reanimated';
import { TIMING_CONFIG } from '@/src/utils/animations';

export default function LoadingView() {
  const rotation = useSharedValue(0);

  useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        ...TIMING_CONFIG,
        duration: 1500 // Slightly slower for smoother rotation
      }),
      -1
    );
  }, []);

  const spinStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }]
  }));

  return (
    <View style={styles.container}>
      <Animated.View 
        entering={FadeIn.duration(300)}
        style={styles.content}
      >
        <Animated.View style={spinStyle}>
          <MaterialCommunityIcons 
            name="cannabis" 
            size={32} 
            color={COLORS.primary} 
          />
        </Animated.View>
        <Text style={styles.text}>Loading...</Text>
      </Animated.View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    alignItems: 'center',
    gap: 12,
  },
  text: {
    fontSize: 16,
    color: COLORS.text.secondary,
  },
});

================================================================================
File: app/components/StatsOverviewCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { Card } from "./shared/Card";
import { COLORS } from "../../src/constants";
import { UsageStats } from "../../src/types";
import Animated, { FadeInDown, Layout } from 'react-native-reanimated';

interface StatsOverviewCardProps {
  stats: UsageStats;
}

function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

const StatsOverviewCard: React.FC<StatsOverviewCardProps> = ({ stats }) => {
  // Enhanced gradient combinations with type assertions
  const gradientBase = ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.08)', 'transparent'] as const;
  const accentGradient = ['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.15)'] as const;
  
  // Weekly difference calculation for message
  const weekendVsWeekday = ((stats.weekdayStats.weekend.avg - stats.weekdayStats.weekday.avg) / stats.weekdayStats.weekday.avg) * 100;
  const isWeekendHigher = weekendVsWeekday > 0;

  return (
    <Animated.View 
      entering={FadeInDown.springify()}
      layout={Layout.springify()}
      style={styles.container}
    >
      {/* Enhanced Background Gradient */}
      <LinearGradient
        colors={gradientBase}
        style={styles.backgroundGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      {/* Shimmer Effect Layer */}
      <LinearGradient
        colors={['transparent', 'rgba(255,255,255,0.05)', 'transparent'] as const}
        style={styles.shimmerEffect}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />
      
      <View style={styles.content}>
        {/* Enhanced Header */}
        <View style={styles.header}>
          <View style={styles.titleRow}>
            <LinearGradient
              colors={accentGradient}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-box-outline" 
                size={22} 
                color={COLORS.primary}
              />
            </LinearGradient>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Usage Statistics</Text>
              <Text style={styles.subtitle}>
                Detailed overview of your usage patterns
              </Text>
            </View>
          </View>
        </View>

        {/* Hit Counts Section */}
        <View style={styles.statsSection}>
          <Text style={styles.sectionTitle}>Hit Counts</Text>
          <View style={styles.statsContainer}>
            <LinearGradient
              colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
              style={styles.statsGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.statRow}>
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Daily Average</Text>
                  <Text style={styles.statValue}>{stats.averageHitsPerDay}</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Peak Day</Text>
                  <Text style={styles.statValue}>{stats.peakDayHits}</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Total Hits</Text>
                  <Text style={styles.statValue}>{stats.totalHits ?? 0}</Text>
                </View>
              </View>
            </LinearGradient>
          </View>
        </View>

        {/* Duration Stats Section */}
        <View style={styles.statsSection}>
          <Text style={styles.sectionTitle}>Duration</Text>
          <View style={styles.statsContainer}>
            <LinearGradient
              colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
              style={styles.statsGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.statRow}>
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Average</Text>
                  <Text style={styles.statValue}>{formatDuration(stats.averageDuration)}</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Longest</Text>
                  <Text style={styles.statValue}>{formatDuration(stats.longestHit)}</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Shortest</Text>
                  <Text style={styles.statValue}>{formatDuration(stats.shortestHit)}</Text>
                </View>
              </View>
            </LinearGradient>
          </View>
        </View>

        {/* Time Patterns Section */}
        <View style={styles.statsSection}>
          <Text style={styles.sectionTitle}>Activity Patterns</Text>
          <View style={styles.statsContainer}>
            <LinearGradient
              colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
              style={styles.statsGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.statRow}>
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Peak Hours</Text>
                  <Text style={styles.statValue}>{stats.mostActiveHour}:00</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Quiet Hours</Text>
                  <Text style={styles.statValue}>{stats.leastActiveHour}:00</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Consistency</Text>
                  <Text style={styles.statValue}>{stats.consistency.toFixed(1)}</Text>
                </View>
              </View>
            </LinearGradient>
          </View>
        </View>

        {/* Weekday vs Weekend */}
        <View style={[styles.statsSection, styles.lastSection]}>
          <Text style={styles.sectionTitle}>Weekly Distribution</Text>
          <View style={styles.statsContainer}>
            <LinearGradient
              colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
              style={styles.statsGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.statRow}>
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Weekday Avg</Text>
                  <Text style={styles.statValue}>
                    {stats.weekdayStats.weekday.avg}
                  </Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Weekend Avg</Text>
                  <Text style={styles.statValue}>
                    {stats.weekdayStats.weekend.avg}
                  </Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Difference</Text>
                  <View style={styles.changeContainer}>
                    <MaterialCommunityIcons 
                      name={isWeekendHigher ? "trending-up" : "trending-down"} 
                      size={16} 
                      color={isWeekendHigher ? COLORS.primary : '#FF5252'} 
                    />
                    <Text style={[
                      styles.changeText,
                      { color: isWeekendHigher ? COLORS.primary : '#FF5252' }
                    ]}>
                      {Math.abs(weekendVsWeekday).toFixed(1)}%
                    </Text>
                  </View>
                </View>
              </View>
            </LinearGradient>
          </View>
        </View>

        {/* Message Box */}
        <View style={styles.messageContainer}>
          <LinearGradient
            colors={accentGradient}
            style={styles.statusIcon}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons
              name="information-outline"
              size={24}
              color={COLORS.primary}
            />
          </LinearGradient>

          <Text style={styles.messageText}>
            Your most active times are at {stats.mostActiveHour}:00 with an average session duration of {formatDuration(stats.averageDuration)}. Your usage is {Math.abs(weekendVsWeekday).toFixed(1)}% {isWeekendHigher ? "higher" : "lower"} on weekends compared to weekdays.
          </Text>
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: COLORS.cardBackground,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    marginBottom: 16,
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 12,
      },
      android: {
        elevation: 8,
      },
    }),
  },
  backgroundGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  shimmerEffect: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.4,
  },
  content: {
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  titleContainer: {
    marginLeft: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 13,
    color: COLORS.text.secondary,
  },
  statsSection: {
    marginBottom: 20,
  },
  lastSection: {
    marginBottom: 20, // Changed from 0 to accommodate message box
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 10,
    letterSpacing: -0.24,
  },
  statsContainer: {
    borderRadius: 16,
    overflow: 'hidden',
  },
  statsGradient: {
    padding: 16,
  },
  statRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-around',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statLabel: {
    fontSize: 13,
    color: COLORS.text.secondary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  statDivider: {
    width: 1,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginHorizontal: 8,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 4,
  },
  messageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.03)',
    padding: 12,
    borderRadius: 12,
  },
  statusIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  messageText: {
    flex: 1,
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
  },
});

export default StatsOverviewCard;

================================================================================
File: app/components/TimeDistributionCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from "../../src/constants";
import { TimeDistribution } from "../../src/types";
import Animated, { FadeInDown, Layout } from 'react-native-reanimated';

interface TimeDistributionCardProps {
  timeData: TimeDistribution;
}

type TimeSlot = 'morning' | 'afternoon' | 'evening' | 'night';

const COLORS_MAP: Record<TimeSlot, string> = {
  morning: '#FFB74D',
  afternoon: '#4FC3F7',
  evening: '#7986CB',
  night: '#9575CD',
};

const ICONS_MAP: Record<TimeSlot, keyof typeof MaterialCommunityIcons.glyphMap> = {
  morning: 'weather-sunny',
  afternoon: 'weather-partly-cloudy',
  evening: 'weather-sunset',
  night: 'weather-night',
};

const TimeDistributionCard = ({ timeData }: TimeDistributionCardProps) => {
  const total = Object.values(timeData).reduce((sum, val) => sum + val, 0);
  
  // Enhanced gradient combinations with type assertions
  const gradientBase = ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.08)', 'transparent'] as const;
  const accentGradient = ['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.15)'] as const;

  const TimeSlotComponent = ({ type, value }: { type: TimeSlot; value: number }) => {
    const percentage = total === 0 ? 0 : (value / total) * 100;
    const barWidth = Math.max(0, Math.min(100, percentage));

    return (
      <Animated.View 
        entering={FadeInDown.delay(type === 'morning' ? 200 : type === 'afternoon' ? 400 : type === 'evening' ? 600 : 800).springify()}
        style={styles.timeSlot}
      >
        <View style={styles.timeSlotContent}>
          <View style={styles.timeSlotHeader}>
            <LinearGradient
              colors={[`${COLORS_MAP[type]}40`, `${COLORS_MAP[type]}20`]}
              style={styles.timeSlotIconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name={ICONS_MAP[type]} 
                size={18} 
                color={COLORS_MAP[type]} 
              />
            </LinearGradient>
            <Text style={styles.timeSlotText}>
              {type.charAt(0).toUpperCase() + type.slice(1)}
            </Text>
            <Text style={styles.percentageText}>
              {percentage.toFixed(0)}%
            </Text>
          </View>
          <View style={styles.barContainer}>
            <LinearGradient
              colors={[`${COLORS_MAP[type]}`, `${COLORS_MAP[type]}80`]}
              style={[styles.bar, { width: `${barWidth}%` }]}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
          </View>
        </View>
      </Animated.View>
    );
  };

  return (
    <Animated.View 
      entering={FadeInDown.springify()}
      layout={Layout.springify()}
      style={styles.container}
    >
      {/* Enhanced Background Gradient */}
      <LinearGradient
        colors={gradientBase}
        style={styles.backgroundGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      {/* Shimmer Effect Layer */}
      <LinearGradient
        colors={['transparent', 'rgba(255,255,255,0.05)', 'transparent'] as const}
        style={styles.shimmerEffect}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />
      
      <View style={styles.content}>
        {/* Enhanced Header */}
        <View style={styles.header}>
          <View style={styles.titleRow}>
            <LinearGradient
              colors={accentGradient}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="clock-outline" 
                size={22} 
                color={COLORS.primary}
              />
            </LinearGradient>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Time Distribution</Text>
              <Text style={styles.subtitle}>
                Activity patterns throughout the day
              </Text>
            </View>
          </View>
        </View>
        
        {/* Stats Container - Using same styled container but with custom content */}
        <View style={styles.statsContainer}>
          <LinearGradient
            colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
            style={styles.statsGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <View style={styles.distributionContent}>
              <TimeSlotComponent type="morning" value={timeData.morning} />
              <TimeSlotComponent type="afternoon" value={timeData.afternoon} />
              <TimeSlotComponent type="evening" value={timeData.evening} />
              <TimeSlotComponent type="night" value={timeData.night} />
            </View>
          </LinearGradient>
        </View>
        
        {/* Message Box */}
        <View style={styles.messageContainer}>
          <LinearGradient
            colors={accentGradient}
            style={styles.statusIcon}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons
              name="chart-timeline-variant"
              size={24}
              color={COLORS.primary}
            />
          </LinearGradient>

          <Text style={styles.messageText}>
            Your usage is primarily during the {
              Object.entries(timeData)
                .sort((a, b) => b[1] - a[1])[0][0]
            } hours, making up {
              Math.floor((Math.max(...Object.values(timeData)) / total) * 100)
            }% of your total consumption
          </Text>
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: COLORS.cardBackground,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    marginBottom: 16,
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 12,
      },
      android: {
        elevation: 8,
      },
    }),
  },
  backgroundGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  shimmerEffect: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.4,
  },
  content: {
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  titleContainer: {
    marginLeft: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 13,
    color: COLORS.text.secondary,
  },
  statsContainer: {
    borderRadius: 16,
    overflow: 'hidden',
    marginBottom: 20,
  },
  statsGradient: {
    padding: 16,
  },
  distributionContent: {
    gap: 16,
  },
  timeSlot: {
    marginBottom: 4,
  },
  timeSlotContent: {
    gap: 8,
  },
  timeSlotHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  timeSlotIconContainer: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  timeSlotText: {
    flex: 1,
    fontSize: 15,
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: -0.24,
  },
  percentageText: {
    fontSize: 15,
    fontWeight: '600',
    color: COLORS.text.primary,
    width: 40,
    textAlign: 'right',
    letterSpacing: -0.24,
  },
  barContainer: {
    height: 6,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 3,
    overflow: 'hidden',
    marginTop: 4,
  },
  bar: {
    height: '100%',
    borderRadius: 3,
  },
  messageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 0,
    backgroundColor: 'rgba(255, 255, 255, 0.03)',
    padding: 12,
    borderRadius: 12,
  },
  statusIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  messageText: {
    flex: 1,
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
  },
});

export default TimeDistributionCard;

================================================================================
File: app/components/trending/CompareBar.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, FlatList } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import { Strain } from "@/src/types";
import Animated, { FadeIn } from 'react-native-reanimated';

interface CompareBarProps {
  compareList: Strain[];
  onCompareToggle: (strain: Strain) => void;
  onCompare: () => void;
}

const CompareBar = memo(({
  compareList,
  onCompareToggle,
  onCompare
}: CompareBarProps) => (
  <Animated.View 
    entering={FadeIn}
    style={styles.compareBar}
  >
    <FlatList
      horizontal
      data={compareList}
      keyExtractor={item => item.id!.toString()}
      renderItem={({ item }) => (
        <View style={styles.compareItem}>
          <Text style={styles.compareItemText}>{item.name}</Text>
          <TouchableOpacity 
            onPress={() => onCompareToggle(item)}
            style={styles.compareItemRemove}
          >
            <MaterialCommunityIcons 
              name="close" 
              size={20} 
              color={COLORS.text.secondary} 
            />
          </TouchableOpacity>
        </View>
      )}
    />
    <TouchableOpacity 
      style={[
        styles.compareButton,
        compareList.length < 2 && styles.compareButtonDisabled
      ]}
      onPress={onCompare}
      disabled={compareList.length < 2}
    >
      <Text style={styles.compareButtonText}>
        Compare ({compareList.length})
      </Text>
    </TouchableOpacity>
  </Animated.View>
));

const styles = StyleSheet.create({
  compareBar: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'rgba(26, 26, 26, 0.95)',
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 230, 118, 0.1)',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    gap: 12,
  },
  compareItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderRadius: 8,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    gap: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  compareItemText: {
    color: COLORS.text.primary,
    fontSize: 14,
    maxWidth: 120,
    letterSpacing: 0.2,
  },
  compareItemRemove: {
    padding: 2,
  },
  compareButton: {
    backgroundColor: COLORS.primary,
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
    opacity: 1,
  },
  compareButtonDisabled: {
    opacity: 0.5,
  },
  compareButtonText: {
    color: COLORS.background,
    fontWeight: '600',
    fontSize: 14,
    letterSpacing: 0.2,
  },
});

export default CompareBar; 

================================================================================
File: app/components/trending/Header.tsx
================================================================================

// components/trending/Header.tsx
import React, { useState, memo } from 'react';
import { View, Text, StyleSheet, TextInput, TouchableOpacity } from 'react-native';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';
import { StrainSearchFilters } from '../../../src/DatabaseManager';
import { hasActiveFilters } from '../../../src/utils/filters';
import Animated, { FadeIn } from 'react-native-reanimated';
import SearchBar from './SearchBar';

interface HeaderProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  filters: StrainSearchFilters;
  handleClearSearch: () => void;
}

const Header = ({ 
  searchQuery, 
  setSearchQuery, 
  showFilters, 
  setShowFilters,
  filters,
  handleClearSearch
}: HeaderProps) => {
  const insets = useSafeAreaInsets();
  const hasFilters = hasActiveFilters(filters);
  const hasSearchOrFilters = searchQuery.trim() || hasFilters;

  return (
    <View style={[styles.container, { paddingTop: insets.top + 10 }]}>
      <LinearGradient
        colors={['rgba(0, 230, 118, 0.15)', 'transparent']}
        style={[styles.headerGradient, { top: 0 }]}
        start={{ x: 0.5, y: 0 }}
        end={{ x: 0.5, y: 1 }}
      />
      
      <Text style={styles.title}>Trending</Text>
      
      <View style={styles.searchContainer}>
        <View style={styles.searchInputContainer}>
          <Ionicons name="search" size={20} color={COLORS.text.secondary} style={styles.searchIcon} />
          <TextInput
            style={styles.searchInput}
            placeholder="Search strains..."
            placeholderTextColor={COLORS.text.placeholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            returnKeyType="search"
          />
          {searchQuery.length > 0 && (
            <TouchableOpacity onPress={() => setSearchQuery('')} style={styles.clearButton}>
              <Ionicons name="close-circle" size={18} color={COLORS.text.secondary} />
            </TouchableOpacity>
          )}
        </View>
        
        <TouchableOpacity 
          style={[
            styles.filterButton, 
            hasFilters && styles.activeFilterButton
          ]} 
          onPress={() => setShowFilters(!showFilters)}
        >
          <Ionicons 
            name="options-outline" 
            size={20} 
            color={hasFilters ? COLORS.accent : COLORS.text.secondary} 
          />
        </TouchableOpacity>
      </View>
      
      {hasSearchOrFilters && (
        <View style={styles.clearSearchContainer}>
          <TouchableOpacity 
            style={styles.clearSearchButton}
            onPress={handleClearSearch}
          >
            <Text style={styles.clearSearchText}>Clear All</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 20,
    paddingBottom: 16,
    position: 'relative',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.05)',
  },
  headerGradient: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 150,
  },
  title: {
    fontSize: 34,
    fontWeight: '700',
    color: 'white',
    marginBottom: 20,
    letterSpacing: 0.5,
    textShadowColor: 'rgba(0, 230, 118, 0.6)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  searchInputContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.06)',
    borderRadius: 12,
    paddingHorizontal: 12,
    height: 46,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.08)',
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 46,
    color: COLORS.text.primary,
    fontSize: 16,
  },
  clearButton: {
    padding: 6,
  },
  filterButton: {
    width: 46,
    height: 46,
    borderRadius: 12,
    backgroundColor: 'rgba(255, 255, 255, 0.06)',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.08)',
  },
  activeFilterButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    borderColor: 'rgba(0, 230, 118, 0.3)',
  },
  clearSearchContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginBottom: 4,
  },
  clearSearchButton: {
    paddingVertical: 6,
    paddingHorizontal: 10,
  },
  clearSearchText: {
    color: COLORS.accent,
    fontSize: 14,
    fontWeight: '500',
  },
});

export default Header;

================================================================================
File: app/components/trending/SearchBar.tsx
================================================================================

// app/components/trending/SearchBar.tsx
import React, { memo } from 'react';
import { View, TextInput, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { Ionicons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import { LinearGradient } from 'expo-linear-gradient';
import { StrainSearchFilters } from '../../../src/DatabaseManager';
import { hasActiveFilters } from '../../../src/utils/filters';
import Animated, { useAnimatedStyle, useSharedValue, withSpring, FadeIn } from 'react-native-reanimated';

interface SearchBarProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  filters: StrainSearchFilters;
  onClear: () => void;
}

const SearchBar = memo(({
  searchQuery,
  setSearchQuery,
  showFilters,
  setShowFilters,
  filters,
  onClear
}: SearchBarProps) => {
  // Determine if we need the clear button
  const showClearButton = searchQuery.trim() || hasActiveFilters(filters);
  
  // Define filter button states
  const hasFilters = hasActiveFilters(filters);
  const isFilterActive = showFilters || hasFilters;
  
  return (
    <View style={styles.searchContainer}>
      {/* Main search input with enhanced styling */}
      <View style={styles.searchBar}>
        <LinearGradient
          colors={['rgba(0,0,0,0.2)', 'rgba(0,0,0,0.1)']}
          style={StyleSheet.absoluteFillObject}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <MaterialCommunityIcons 
          name="magnify" 
          size={22} 
          color={COLORS.text.secondary} 
          style={styles.searchIcon}
        />
        
        <TextInput
          style={styles.searchInput}
          placeholder="Search strains..."
          placeholderTextColor="rgba(255,255,255,0.4)"
          value={searchQuery}
          onChangeText={setSearchQuery}
          returnKeyType="search"
          autoCapitalize="none"
          autoCorrect={false}
          clearButtonMode="while-editing"
        />
        
        {Platform.OS === 'android' && showClearButton && (
          <TouchableOpacity 
            onPress={onClear}
            style={styles.clearButton}
          >
            <MaterialCommunityIcons 
              name="close-circle" 
              size={18} 
              color={COLORS.text.secondary} 
            />
          </TouchableOpacity>
        )}
      </View>

      {/* Enhanced filter button with states */}
      <TouchableOpacity 
        style={[styles.filterButton, isFilterActive && styles.filterButtonActive]}
        onPress={() => setShowFilters(!showFilters)}
        activeOpacity={0.7}
      >
        <LinearGradient
          colors={
            isFilterActive 
              ? ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']
              : ['rgba(0,0,0,0.2)', 'rgba(0,0,0,0.1)']
          }
          style={StyleSheet.absoluteFillObject}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <MaterialCommunityIcons 
          name="filter-variant" 
          size={22} 
          color={isFilterActive ? COLORS.primary : COLORS.text.secondary} 
        />
        
        {/* Badge indicator if filters are active */}
        {hasFilters && (
          <View style={styles.filterBadge}>
            <LinearGradient
              colors={['#00E676', '#00C853']}
              style={StyleSheet.absoluteFillObject}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            />
          </View>
        )}
      </TouchableOpacity>
    </View>
  );
});

const styles = StyleSheet.create({
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  searchBar: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.25)',
    borderRadius: 12,
    height: 44,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.12)',
    overflow: 'hidden',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  searchIcon: {
    marginLeft: 12,
    marginRight: 4,
  },
  searchInput: {
    flex: 1,
    color: '#000000',
    fontSize: 16,
    fontWeight: '400',
    paddingVertical: 10,
    paddingHorizontal: 8,
  },
  clearButton: {
    padding: 8,
    marginRight: 4,
  },
  filterButton: {
    width: 44,
    height: 44,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.25)',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.12)',
    overflow: 'hidden',
    position: 'relative',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  filterButtonActive: {
    borderColor: 'rgba(0, 230, 118, 0.3)',
  },
  filterBadge: {
    position: 'absolute',
    top: 10,
    right: 10,
    width: 8,
    height: 8,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.3)',
    overflow: 'hidden',
  },
});

export default SearchBar;

================================================================================
File: app/components/trending/SearchFilters.tsx
================================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { StrainSearchFilters } from '../../../src/DatabaseManager';
import { COLORS } from '../../../src/constants';
import { LinearGradient } from 'expo-linear-gradient';

interface SearchFiltersProps {
  filters: StrainSearchFilters;
  onFilterChange: (filters: StrainSearchFilters) => void;
  onApplyFilters: () => void;
  categories: { [key: string]: number };
}

const SORT_OPTIONS = [
  { key: 'rating', label: 'Rating', icon: 'star' },
  { key: 'name', label: 'Name', icon: 'sort-alphabetical-ascending' },
  { key: 'thc', label: 'THC', icon: 'percent' },
] as const;

const COMMON_EFFECTS = [
  'Relaxed',
  'Energetic',
  'Creative',
  'Focused',
  'Euphoric',
  'Sleepy',
  'Happy',
  'Uplifted'
];

export default function SearchFilters({ 
  filters, 
  onFilterChange, 
  onApplyFilters,
  categories 
}: SearchFiltersProps) {
  const [localFilters, setLocalFilters] = useState<StrainSearchFilters>(filters);

  const handleSortChange = (sort: StrainSearchFilters['sort']) => {
    setLocalFilters(prev => ({ ...prev, sort }));
  };

  const handleEffectToggle = (effect: string) => {
    const currentEffects = localFilters.effects || [];
    const newEffects = currentEffects.includes(effect)
      ? currentEffects.filter(e => e !== effect)
      : [...currentEffects, effect];
    setLocalFilters(prev => ({ ...prev, effects: newEffects }));
  };

  const handleGeneticTypeChange = (geneticType: string | undefined) => {
    setLocalFilters(prev => ({ ...prev, geneticType }));
  };

  const handleApply = () => {
    onFilterChange(localFilters);
    onApplyFilters();
  };

  return (
    <View style={styles.container}>
      {/* Sort Options */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Sort By</Text>
        <View style={styles.sortOptions}>
          {SORT_OPTIONS.map(({ key, label, icon }) => (
            <TouchableOpacity
              key={key}
              style={[
                styles.sortOption,
                localFilters.sort === key && styles.sortOptionActive
              ]}
              onPress={() => handleSortChange(key)}
            >
              <MaterialCommunityIcons
                name={icon}
                size={18}
                color={localFilters.sort === key ? COLORS.primary : COLORS.text.secondary}
              />
              <Text style={[
                styles.sortOptionText,
                localFilters.sort === key && styles.sortOptionTextActive
              ]}>
                {label}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Genetic Types */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Genetic Type</Text>
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          style={styles.geneticTypes}
        >
          <TouchableOpacity
            style={[
              styles.typeChip,
              !localFilters.geneticType && styles.typeChipActive
            ]}
            onPress={() => handleGeneticTypeChange(undefined)}
          >
            <Text style={[
              styles.typeChipText,
              !localFilters.geneticType && styles.typeChipTextActive
            ]}>
              All
            </Text>
          </TouchableOpacity>
          {Object.entries(categories).map(([type, count]) => (
            <TouchableOpacity
              key={type}
              style={[
                styles.typeChip,
                localFilters.geneticType === type && styles.typeChipActive
              ]}
              onPress={() => handleGeneticTypeChange(type)}
            >
              <Text style={[
                styles.typeChipText,
                localFilters.geneticType === type && styles.typeChipTextActive
              ]}>
                {type} ({count})
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>

      {/* Effects */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Effects</Text>
        <View style={styles.effectsGrid}>
          {COMMON_EFFECTS.map(effect => (
            <TouchableOpacity
              key={effect}
              style={[
                styles.effectChip,
                (localFilters.effects || []).includes(effect) && styles.effectChipActive
              ]}
              onPress={() => handleEffectToggle(effect)}
            >
              <Text style={[
                styles.effectChipText,
                (localFilters.effects || []).includes(effect) && styles.effectChipTextActive
              ]}>
                {effect}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Apply Button */}
      <TouchableOpacity 
        style={styles.applyButton}
        onPress={handleApply}
      >
        <LinearGradient
          colors={[COLORS.primary, COLORS.primaryDark]}
          style={styles.applyButtonGradient}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          <Text style={styles.applyButtonText}>Apply Filters</Text>
          <MaterialCommunityIcons 
            name="check" 
            size={20} 
            color="#FFF" 
          />
        </LinearGradient>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 12,
    padding: 16,
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  sortOptions: {
    flexDirection: 'row',
    gap: 12,
  },
  sortOption: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    gap: 6,
  },
  sortOptionActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  sortOptionText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  sortOptionTextActive: {
    color: COLORS.primary,
  },
  geneticTypes: {
    flexDirection: 'row',
  },
  typeChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    marginRight: 8,
  },
  typeChipActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  typeChipText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  typeChipTextActive: {
    color: COLORS.primary,
  },
  effectsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  effectChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  effectChipActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  effectChipText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  effectChipTextActive: {
    color: COLORS.primary,
  },
  applyButton: {
    marginTop: 20,
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  applyButtonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 8,
    width: '100%',
  },
  applyButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFF',
    marginRight: 8,
  },
});

================================================================================
File: app/components/trending/Section.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';

interface SectionProps {
  title: string;
  children: React.ReactNode;
}

const Section = memo(({ title, children }: SectionProps) => (
  <View style={styles.sectionWrapper}>
    <LinearGradient
      colors={['rgba(0,230,118,0.1)', 'transparent']}
      style={styles.sectionDivider}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 0 }}
    />
    <View style={styles.section}>
      <LinearGradient
        colors={['rgba(0,230,118,0.1)', 'rgba(0,230,118,0.02)', 'transparent']}
        style={styles.sectionGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionTitle}>{title}</Text>
      </View>
      <View style={styles.sectionContent}>
        {children}
      </View>
    </View>
  </View>
));

const styles = StyleSheet.create({
  sectionWrapper: {
    marginBottom: 32,
    position: 'relative',
  },
  sectionDivider: {
    height: 1,
    width: '100%',
    marginBottom: 16,
  },
  section: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.75)',
      android: 'rgba(26, 26, 26, 0.9)',
    }),
  },
  sectionGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  sectionHeader: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 230, 118, 0.1)',
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  sectionContent: {
    padding: 12,
    gap: 12,
  },
});

export default Section; 

================================================================================
File: app/components/trending/StrainsList.tsx
================================================================================

// app/components/trending/StrainsList.tsx
import React, { memo, useCallback } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  FlatList, 
  Platform
} from 'react-native';
import { useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';
import { Strain } from "@/src/types";
import Animated, { FadeIn } from 'react-native-reanimated';

interface StrainsListProps {
  strains: Strain[];
  onCompareToggle: (strain: Strain) => void;
  onFavoriteToggle: (strainId: number) => void;
  compareList: Strain[];
  isFavorite: (strainId: number) => boolean;
  isLoading: boolean;
  onEndReached: () => void;
}

// Rating badge component for cleaner code
const RatingBadge = ({ rating }: { rating: number }) => (
  <LinearGradient
    colors={[
      rating >= 9 ? '#00E676' : rating >= 8 ? '#1DE9B6' : '#26C6DA', 
      rating >= 9 ? '#00C853' : rating >= 8 ? '#00BFA5' : '#00ACC1'
    ]}
    style={styles.ratingBadge}
    start={{ x: 0, y: 0 }}
    end={{ x: 1, y: 1 }}
  >
    <Text style={styles.ratingText}>{rating.toFixed(1)}</Text>
  </LinearGradient>
);

// Strain type badge
const TypeBadge = ({ type }: { type: string }) => {
  let gradientColors;
  
  // Different colors for different strain types
  switch(type.toLowerCase()) {
    case 'sativa':
    case 'sativa-dominant':
    case 'sativa-dominant hybrid':
      gradientColors = ['rgba(255, 160, 0, 0.2)', 'rgba(255, 160, 0, 0.1)'];
      break;
    case 'indica':
    case 'indica-dominant':
    case 'indica-dominant hybrid':
      gradientColors = ['rgba(123, 31, 162, 0.2)', 'rgba(123, 31, 162, 0.1)'];
      break;
    case 'hybrid':
      gradientColors = ['rgba(0, 176, 255, 0.2)', 'rgba(0, 176, 255, 0.1)'];
      break;
    default:
      gradientColors = ['rgba(120, 144, 156, 0.2)', 'rgba(120, 144, 156, 0.1)'];
  }
  
  return (
    <LinearGradient
      colors={gradientColors}
      style={styles.typeBadge}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 1 }}
    >
      <Text style={styles.typeBadgeText}>{type}</Text>
    </LinearGradient>
  );
};

export const StrainsList = memo(({
  strains,
  onCompareToggle,
  onFavoriteToggle,
  compareList,
  isFavorite,
  isLoading,
  onEndReached,
}: StrainsListProps) => {
  const router = useRouter();

  // Optimize with useCallback
  const renderStrainItem = useCallback(({ item: strain, index }: { item: Strain, index: number }) => (
    <Animated.View 
    entering={FadeIn.duration(150)} // Much shorter duration, no delay
    style={styles.strainItemContainer}
  >
      <TouchableOpacity
        onPress={() => router.push({
          pathname: "/strains/details",
          params: { id: strain.id }
        } as any)}
        style={styles.strainItem}
        activeOpacity={0.8}
      >
        <LinearGradient
          colors={['rgba(0, 230, 118, 0.1)', 'rgba(0, 230, 118, 0.05)', 'rgba(0, 230, 118, 0)']}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        />
        
        {/* Left content */}
        <View style={styles.strainContent}>
          <View style={styles.strainHeader}>
            <Text style={styles.strainName}>{strain.name}</Text>
            <RatingBadge rating={strain.combined_rating} />
          </View>

          <TypeBadge type={strain.genetic_type} />
          
          <Text 
            numberOfLines={2} 
            style={styles.strainDescription}
          >
            {strain.overview}
          </Text>

          {strain.effects && (
            <View style={styles.effectsContainer}>
              {strain.effects.split(',').slice(0, 3).map((effect, idx) => (
                <View key={idx} style={styles.effectBadge}>
                  <Text style={styles.effectText}>{effect.trim()}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        {/* Action buttons */}
        <View style={styles.actionButtons}>
          <TouchableOpacity 
            onPress={() => onFavoriteToggle(strain.id!)}
            style={[
              styles.actionButton,
              isFavorite(strain.id!) && styles.favoriteButton
            ]}
          >
            <MaterialCommunityIcons 
              name={isFavorite(strain.id!) ? "heart" : "heart-outline"} 
              size={22} 
              color={isFavorite(strain.id!) ? '#FFFFFF' : COLORS.text.secondary} 
            />
          </TouchableOpacity>
          
          <TouchableOpacity 
            onPress={() => onCompareToggle(strain)}
            style={[
              styles.actionButton,
              compareList.some(s => s.id === strain.id) && styles.compareButton
            ]}
            disabled={compareList.length >= 3 && !compareList.some(s => s.id === strain.id)}
          >
            <MaterialCommunityIcons 
              name={compareList.some(s => s.id === strain.id) ? "compare" : "compare-horizontal"} 
              size={22} 
              color={compareList.some(s => s.id === strain.id) ? '#FFFFFF' : COLORS.text.secondary} 
            />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    </Animated.View>
  ), [onCompareToggle, onFavoriteToggle, compareList, isFavorite, router]);

  const keyExtractor = useCallback((item: Strain, index: number) => {
    // Use unique combination of id and index if id exists, otherwise use index-based fallback
    return item.id ? `strain-${item.id}-${index}` : `strain-index-${index}`;
  }, []);
  

  if (!strains.length && !isLoading) {
    return (
      <View style={styles.emptyContainer}>
        <MaterialCommunityIcons 
          name="cannabis" 
          size={48} 
          color={COLORS.primary}
          style={{ opacity: 0.5 }}
        />
        <Text style={styles.emptyText}>
          No strains found matching your criteria
        </Text>
      </View>
    );
  }

  return (
    <FlatList
      data={strains}
      renderItem={renderStrainItem}
      keyExtractor={keyExtractor}
      contentContainerStyle={styles.content}
      onEndReached={onEndReached}
      onEndReachedThreshold={0.5}
      showsVerticalScrollIndicator={false}
      // Performance optimizations
      removeClippedSubviews={Platform.OS === 'android'}
      windowSize={5}
      maxToRenderPerBatch={5}
      initialNumToRender={8}  // Limit initial render batch
      updateCellsBatchingPeriod={50}  // Group cell updates to optimize performance
      // Add key tracking for debugging
      maintainVisibleContentPosition={{
        minIndexForVisible: 0,
      }}
    />
  );
  
});

// Export default for expo-router
export default StrainsList;

const styles = StyleSheet.create({
  content: {
    paddingBottom: 80, // Space for the compare bar
  },
  strainItemContainer: {
    marginBottom: 16,
    borderRadius: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
  },
  strainItem: {
    backgroundColor: 'rgba(26, 32, 28, 0.95)',
    borderRadius: 16,
    overflow: 'hidden',
    flexDirection: 'row',
    padding: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.15)',
  },
  strainContent: {
    flex: 1,
  },
  strainHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  strainName: {
    fontSize: 18,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
    flex: 1,
    marginRight: 8,
  },
  ratingBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  ratingText: {
    color: '#FFFFFF',
    fontWeight: '700',
    fontSize: 16,
  },
  typeBadge: {
    alignSelf: 'flex-start',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 8,
    marginBottom: 10,
  },
  typeBadgeText: {
    fontSize: 13,
    color: COLORS.text.primary,
    fontWeight: '500',
  },
  strainDescription: {
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
    marginBottom: 12,
  },
  effectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  effectBadge: {
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
  },
  effectText: {
    fontSize: 12,
    color: COLORS.text.secondary,
  },
  actionButtons: {
    marginLeft: 16,
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  actionButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    marginVertical: 6,
  },
  favoriteButton: {
    backgroundColor: 'rgba(255, 82, 82, 0.8)',
  },
  compareButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.8)',
  },
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(26, 32, 28, 0.5)',
    padding: 40,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    marginVertical: 30,
  },
  emptyText: {
    fontSize: 16,
    color: COLORS.text.primary,
    textAlign: 'center',
    marginTop: 16,
    opacity: 0.8,
  },
});

================================================================================
File: app/context/AchievementContext.tsx
================================================================================

import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { databaseManager } from '../../src/DatabaseManager';
import { BONG_HITS_DATABASE_NAME } from '../../src/constants';
import { UserAchievementWithDetails } from '../../src/types';
import { AchievementsRepository } from '../../src/repositories/AchievementsRepository';

// We'll initialize the repository with null for now and set it properly in useEffect
let achievementsRepository: AchievementsRepository | null = null;

interface AchievementContextType {
  achievements: UserAchievementWithDetails[];
  stats: {
    total: number;
    unlocked: number;
    percentComplete: number;
  };
  newlyUnlocked: UserAchievementWithDetails | null;
  loading: boolean;
  loadAchievements: () => Promise<void>;
  checkAchievements: (actionType: string, data: any) => Promise<void>;
  clearNewlyUnlocked: () => void;
}

const defaultContext: AchievementContextType = {
  achievements: [],
  stats: {
    total: 0,
    unlocked: 0,
    percentComplete: 0
  },
  newlyUnlocked: null,
  loading: false,
  loadAchievements: async () => {},
  checkAchievements: async () => {},
  clearNewlyUnlocked: () => {},
};

export const AchievementContext = createContext<AchievementContextType>(defaultContext);

export const useAchievements = () => useContext(AchievementContext);

interface AchievementProviderProps {
  children: ReactNode;
}

export const AchievementProvider: React.FC<AchievementProviderProps> = ({ children }) => {
  const [achievements, setAchievements] = useState<UserAchievementWithDetails[]>([]);
  const [newlyUnlocked, setNewlyUnlocked] = useState<UserAchievementWithDetails | null>(null);
  const [loading, setLoading] = useState(false);
  const [repositoryReady, setRepositoryReady] = useState(false);
  const [stats, setStats] = useState({
    total: 0,
    unlocked: 0,
    percentComplete: 0
  });
  
  // In a real app, you'd get this from authentication context or similar
  const userId = 'default-user';

  // Initialize the repository
  useEffect(() => {
    const initRepository = async () => {
      try {
        // Ensure database manager is initialized
        await databaseManager.ensureInitialized();
        
        // Get the shared database connection from the main database
        const db = await databaseManager.getDatabase(BONG_HITS_DATABASE_NAME);
        
        // Create the repository
        achievementsRepository = new AchievementsRepository(db);
        setRepositoryReady(true);
      } catch (error) {
        console.error('Failed to initialize achievements repository:', error);
      }
    };

    initRepository();
    
    // No cleanup needed as databaseManager is singleton and will be cleaned up elsewhere
  }, []);
  
  const loadAchievements = async () => {
    if (!repositoryReady || !achievementsRepository) {
      console.warn('Achievements repository not ready');
      return;
    }

    try {
      setLoading(true);
      
      // Fetch achievements using the repository
      const userAchievements = await achievementsRepository.getUserAchievements(userId);
      
      if (userAchievements && Array.isArray(userAchievements)) {
        setAchievements(userAchievements);
        
        // Calculate stats
        const totalCount = userAchievements.length;
        const unlockedCount = userAchievements.filter(a => a.isUnlocked).length;
        
        setStats({
          total: totalCount,
          unlocked: unlockedCount,
          percentComplete: totalCount > 0 ? Math.round((unlockedCount / totalCount) * 100) : 0
        });
        
        // Clear new flags
        await achievementsRepository.clearAchievementNewFlags(userId);
        console.log(`[AchievementContext] Loaded ${userAchievements.length} achievements`);
      } else {
        console.error('Failed to load achievements: Invalid response format');
        setAchievements([]);
        setStats({
          total: 0,
          unlocked: 0,
          percentComplete: 0
        });
      }
    } catch (error) {
      console.error('Failed to load achievements:', error instanceof Error ? error.message : 'Unknown error');
      setAchievements([]);
      setStats({
        total: 0,
        unlocked: 0,
        percentComplete: 0
      });
    } finally {
      setLoading(false);
    }
  };
  
  const checkAchievements = async (actionType: string, data: any) => {
    if (!repositoryReady || !achievementsRepository) {
      console.warn('Achievements repository not ready');
      return;
    }

    try {
      // Check for newly unlocked achievements based on the action
      const unlockedAchievements = await achievementsRepository.checkAchievements(userId, actionType, data);
      
      if (unlockedAchievements && Array.isArray(unlockedAchievements) && unlockedAchievements.length > 0) {
        // Set the most recent achievement as newly unlocked for notification
        setNewlyUnlocked(unlockedAchievements[0]);
        
        // Refresh the achievements list to reflect changes
        loadAchievements();
      }
    } catch (error) {
      console.error('Failed to check achievements:', error instanceof Error ? error.message : 'Unknown error');
    }
  };
  
  const clearNewlyUnlocked = () => {
    setNewlyUnlocked(null);
  };
  
  // Load achievements when repository is ready
  useEffect(() => {
    if (repositoryReady) {
      loadAchievements();
    }
  }, [repositoryReady]);
  
  const value = {
    achievements,
    stats,
    newlyUnlocked,
    loading,
    loadAchievements,
    checkAchievements,
    clearNewlyUnlocked,
  };
  
  return (
    <AchievementContext.Provider value={value}>
      {children}
    </AchievementContext.Provider>
  );
};

// Add default export for expo-router
export default AchievementProvider; 

================================================================================
File: app/devices/index.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { 
  View, 
  Text, 
  FlatList, 
  TouchableOpacity, 
  StyleSheet, 
  Alert,
  ActivityIndicator 
} from 'react-native';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { SavedDevice } from '@/src/types';
import { useDeviceService } from '@/src/providers/AppProvider';
import { COLORS } from '@/src/constants';

export default function DevicesScreen() {
  const deviceService = useDeviceService();
  const [devices, setDevices] = useState<SavedDevice[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const loadDevices = async () => {
    try {
      const savedDevices = await deviceService.getSavedDevices();
      setDevices(savedDevices);
    } catch (error) {
      console.error('Failed to load devices:', error);
      Alert.alert('Error', 'Failed to load saved devices');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  useEffect(() => {
    loadDevices();
  }, []);

  const handleRefresh = () => {
    setRefreshing(true);
    loadDevices();
  };

  const handleRemoveDevice = async (device: SavedDevice) => {
    Alert.alert(
      'Remove Device',
      `Are you sure you want to remove ${device.name || device.id}?`,
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Remove',
          style: 'destructive',
          onPress: async () => {
            try {
              await deviceService.removeDevice(device);
              setDevices(devices.filter(d => d.id !== device.id));
            } catch (error) {
              console.error('Failed to remove device:', error);
              Alert.alert('Error', 'Failed to remove device');
            }
          },
        },
      ]
    );
  };

  const handleClearDevices = () => {
    if (devices.length === 0) return;
    
    Alert.alert(
      'Clear All Devices',
      'Are you sure you want to remove all saved devices?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Clear All',
          style: 'destructive',
          onPress: async () => {
            try {
              await deviceService.clearDevices();
              setDevices([]);
            } catch (error) {
              console.error('Failed to clear devices:', error);
              Alert.alert('Error', 'Failed to clear all devices');
            }
          },
        },
      ]
    );
  };

  const renderItem = ({ item }: { item: SavedDevice }) => (
    <View style={styles.deviceItem}>
      <View style={styles.deviceInfo}>
        <Text style={styles.deviceName}>{item.name || 'Unknown Device'}</Text>
        <Text style={styles.deviceId}>{item.id}</Text>
        {item.lastConnected && (
          <Text style={styles.lastConnected}>
            Last connected: {new Date(item.lastConnected).toLocaleDateString()}
          </Text>
        )}
      </View>
      <TouchableOpacity
        style={styles.removeButton}
        onPress={() => handleRemoveDevice(item)}
      >
        <Ionicons name="trash-outline" size={24} color={COLORS.text.primary} />
      </TouchableOpacity>
    </View>
  );

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>Loading saved devices...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Saved Devices</Text>
        <TouchableOpacity onPress={handleClearDevices} disabled={devices.length === 0}>
          <Text 
            style={[
              styles.clearButton, 
              devices.length === 0 ? { opacity: 0.5 } : null
            ]}
          >
            Clear All
          </Text>
        </TouchableOpacity>
      </View>

      {devices.length > 0 ? (
        <FlatList
          data={devices}
          renderItem={renderItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContent}
          refreshing={refreshing}
          onRefresh={handleRefresh}
        />
      ) : (
        <View style={styles.emptyContainer}>
          <Ionicons name="bluetooth-outline" size={64} color={COLORS.text.tertiary} />
          <Text style={styles.emptyText}>No saved devices</Text>
          <Text style={styles.emptySubtext}>
            Connect to a device to save it to this list
          </Text>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    padding: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: COLORS.text.primary,
  },
  clearButton: {
    color: COLORS.primary,
    fontSize: 16,
  },
  deviceItem: {
    flexDirection: 'row',
    backgroundColor: COLORS.cardBackground,
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  deviceInfo: {
    flex: 1,
  },
  deviceName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  deviceId: {
    fontSize: 14,
    color: COLORS.text.secondary,
    marginBottom: 4,
  },
  lastConnected: {
    fontSize: 12,
    color: COLORS.text.tertiary,
  },
  removeButton: {
    padding: 8,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
  },
  loadingText: {
    marginTop: 16,
    color: COLORS.text.primary,
    fontSize: 16,
  },
  listContent: {
    paddingBottom: 20,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
  },
  emptyText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginTop: 16,
  },
  emptySubtext: {
    fontSize: 14,
    color: COLORS.text.secondary,
    textAlign: 'center',
    marginTop: 8,
  },
}); 

================================================================================
File: app/index.tsx
================================================================================

import { Redirect } from 'expo-router';

export default function Index() {
  return <Redirect href="/(tabs)" />;
} 

================================================================================
File: app/screens/AchievementsScreen.tsx
================================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { View, StyleSheet, FlatList, Text, ActivityIndicator, RefreshControl, Platform, TouchableOpacity } from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { AchievementCard } from '../components/achievements/AchievementCard';
import { AchievementDetailModal } from '../components/achievements/AchievementDetailModal';
import { UserAchievementWithDetails } from '../../src/types';
import { LinearGradient } from 'expo-linear-gradient';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { COLORS } from '../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { useAchievements } from '../context/AchievementContext';

// Shared categories for filtering
const ACHIEVEMENT_CATEGORIES = [
  'All',
  'Daily & Weekly Streaks',
  'Strain Exploration',
  'Mood & Journaling',
  'Moderation & Goal-Oriented',
  'Medical-Focused',
  'Recreational-Focused',
  'AI Interaction',
  'Referral & Community',
  'Morning/Evening Check-Ins',
  'Long-Term Milestones',
  'Themed Celebrations'
];

type AchievementListItem = string | UserAchievementWithDetails;

export default function AchievementsScreen() {
  const [selectedAchievement, setSelectedAchievement] = useState<UserAchievementWithDetails | null>(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState('All');
  const [refreshing, setRefreshing] = useState(false);
  
  // Use the achievements context instead of direct database access
  const { achievements, stats, loading, loadAchievements } = useAchievements();
  
  const loadData = async () => {
    try {
      console.log('[AchievementsScreen] Fetching user achievements...');
      await loadAchievements();
    } catch (error) {
      console.error('[AchievementsScreen] Failed to load achievements:', error instanceof Error ? error.message : 'Unknown error');
    } finally {
      setRefreshing(false);
    }
  };
  
  useEffect(() => {
    loadData();
  }, []);
  
  useFocusEffect(
    useCallback(() => {
      loadData();
    }, [])
  );
  
  const onRefresh = () => {
    setRefreshing(true);
    loadData();
  };
  
  const handleAchievementPress = (achievement: UserAchievementWithDetails) => {
    setSelectedAchievement(achievement);
    setModalVisible(true);
  };
  
  const closeModal = () => {
    setModalVisible(false);
  };
  
  const filteredAchievements = selectedCategory === 'All'
    ? achievements
    : achievements.filter(a => a.category === selectedCategory);
  
  // Group achievements by category for the "All" view
  const groupedAchievements = filteredAchievements.reduce((groups, achievement) => {
    const category = achievement.category;
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(achievement);
    return groups;
  }, {} as Record<string, UserAchievementWithDetails[]>);
  
  const renderCategoryFilter = () => (
    <View style={styles.filterContainer}>
      <FlatList
        horizontal
        data={ACHIEVEMENT_CATEGORIES.filter(cat => 
          cat === 'All' || achievements.some(a => a.category === cat)
        )}
        keyExtractor={(item) => item}
        renderItem={({ item }) => (
          <TouchableOpacity
            style={[
              styles.filterButton,
              selectedCategory === item && styles.selectedFilterButton
            ]}
            onPress={() => setSelectedCategory(item)}
          >
            <Text 
              style={[
                styles.filterText,
                selectedCategory === item && styles.selectedFilterText
              ]}
            >
              {item}
            </Text>
          </TouchableOpacity>
        )}
        showsHorizontalScrollIndicator={false}
      />
    </View>
  );
  
  const renderHeader = () => (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.header}
    >
      <View style={styles.statsCard}>
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.statsContent}>
          <View style={styles.statItem}>
            <Text style={styles.statValue}>{stats.unlocked}</Text>
            <Text style={styles.statLabel}>Unlocked</Text>
          </View>
          
          <View style={styles.statSeparator} />
          
          <View style={styles.statItem}>
            <Text style={styles.statValue}>{stats.total}</Text>
            <Text style={styles.statLabel}>Total</Text>
          </View>
          
          <View style={styles.statSeparator} />
          
          <View style={styles.statItem}>
            <Text style={styles.statValue}>{stats.percentComplete}%</Text>
            <Text style={styles.statLabel}>Complete</Text>
          </View>
        </View>
      </View>
      
      {renderCategoryFilter()}
    </Animated.View>
  );
  
  const renderEmptyState = () => (
    <View style={styles.emptyContainer}>
      <MaterialCommunityIcons name="trophy-outline" size={60} color={COLORS.text.secondary} />
      <Text style={styles.emptyText}>No achievements available</Text>
      <Text style={styles.emptyDescription}>Achievements may still be loading or there was an error fetching your data.</Text>
      <TouchableOpacity style={styles.retryButton} onPress={onRefresh}>
        <Text style={styles.retryText}>Try Again</Text>
      </TouchableOpacity>
    </View>
  );
  
  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
      </View>
    );
  }
  
  // Determine data for the main FlatList
  const listData: AchievementListItem[] = selectedCategory === 'All'
    ? Object.keys(groupedAchievements)
    : filteredAchievements;
  
  return (
    <SafeAreaProvider>
      <View style={styles.container}>
        <FlatList
          data={listData}
          keyExtractor={(item) => {
            if (typeof item === 'string') {
              return item;
            } else {
              return item.id.toString();
            }
          }}
          renderItem={({ item }) => {
            if (selectedCategory === 'All' && typeof item === 'string') {
              // This is a category header in "All" view
              const categoryAchievements = groupedAchievements[item];
              return (
                <View style={styles.categoryHeaderContainer}>
                  <Text style={styles.categoryHeader}>{item}</Text>
                  <FlatList
                    data={categoryAchievements}
                    keyExtractor={(achievement) => achievement.id.toString()}
                    renderItem={({ item: achievement }) => (
                      <AchievementCard 
                        achievement={achievement} 
                        onPress={handleAchievementPress} 
                      />
                    )}
                    scrollEnabled={false}
                  />
                </View>
              );
            } else {
              // This is an individual achievement in filtered view
              return (
                <AchievementCard 
                  achievement={item as UserAchievementWithDetails} 
                  onPress={handleAchievementPress} 
                />
              );
            }
          }}
          ListHeaderComponent={renderHeader}
          ListEmptyComponent={renderEmptyState}
          contentContainerStyle={styles.listContent}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              colors={[COLORS.primary]}
            />
          }
        />
        
        <AchievementDetailModal
          visible={modalVisible}
          achievement={selectedAchievement}
          onClose={closeModal}
        />
      </View>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
  },
  header: {
    padding: 16,
    paddingBottom: 8,
  },
  statsCard: {
    borderRadius: 20,
    marginBottom: 16,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  statsContent: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    padding: 20,
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statValue: {
    fontSize: 24,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  statSeparator: {
    height: 40,
    width: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  filterContainer: {
    marginBottom: 8,
  },
  filterButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginRight: 8,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
  },
  selectedFilterButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
  },
  filterText: {
    color: COLORS.text.secondary,
    fontSize: 14,
  },
  selectedFilterText: {
    color: COLORS.primary,
    fontWeight: '600',
  },
  listContent: {
    paddingHorizontal: 16,
    paddingBottom: 16,
  },
  categoryHeaderContainer: {
    marginTop: 16,
    marginBottom: 8,
  },
  categoryHeader: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
    letterSpacing: 0.35,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
  },
  emptyText: {
    color: COLORS.text.secondary,
    fontSize: 16,
    marginTop: 16,
  },
  emptyDescription: {
    color: COLORS.text.secondary,
    fontSize: 14,
    marginTop: 8,
    textAlign: 'center',
    paddingHorizontal: 20,
  },
  retryButton: {
    marginTop: 20,
    paddingVertical: 10,
    paddingHorizontal: 20,
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
    borderRadius: 20,
  },
  retryText: {
    color: COLORS.primary,
    fontWeight: '600',
  },
});

================================================================================
File: app/screens/TestDataScreen.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, ActivityIndicator, Alert, TextInput } from 'react-native';
import { useRouter } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { getInsertStatements, COLORS, BONG_HITS_DATABASE_NAME } from '../../src/constants';
import { DatabaseManager } from '../../src/DatabaseManager';
import { BluetoothService } from '../../src/services/BluetoothService';
import { BongHitsRepository } from '../../src/repositories/BongHitsRepository';
import { DeviceService } from '../../src/services/DeviceService';
import { StorageService } from '../../src/services/StorageService';
import { parseRawTimestamp } from '../../src/utils/functions';

// Test durations in seconds
const TEST_DURATIONS = [
  0.123, // 123ms
  0.456, // 456ms
  0.789, // 789ms
  1.234, // 1234ms
];

// Time offsets in hours for test data (relative to current time)
const TIME_OFFSETS = [
  0,     // Current time
  2,     // 2 hours ago
  6,     // 6 hours ago
  24,    // 1 day ago
];

export default function TestDataScreen() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<string | null>(null);
  const [bluetoothService, setBluetoothService] = useState<BluetoothService | null>(null);
  const [customTimestamp, setCustomTimestamp] = useState('');
  const [customDuration, setCustomDuration] = useState('');

  // Function to generate a timestamp string based on current date with an offset
  const getTestTimestamp = (offsetHours: number = 0): string => {
    const now = new Date();
    now.setHours(now.getHours() - offsetHours);
    
    const day = now.toLocaleString('en-US', { weekday: 'long' });
    const month = now.toLocaleString('en-US', { month: 'long' });
    const date = now.getDate();
    const year = now.getFullYear();
    const time = now.toLocaleTimeString('en-US', { 
      hour: '2-digit', 
      minute: '2-digit',
      second: '2-digit',
      hour12: false 
    });
    
    return `${day}, ${month} ${date} ${year} ${time}`;
  };

  // Initialize the services when component mounts
  useEffect(() => {
    const initServices = async () => {
      try {
        const dbManager = DatabaseManager.getInstance();
        await dbManager.ensureInitialized();
        const db = await dbManager.getDatabase(BONG_HITS_DATABASE_NAME);
        
        // Create repositories and services with proper dependencies
        const bongHitsRepo = new BongHitsRepository(db);
        const storageService = new StorageService();
        const deviceService = new DeviceService(storageService);
        
        // Create the BluetoothService using our repositories
        const btService = new BluetoothService(deviceService, bongHitsRepo);
        setBluetoothService(btService);
        
        console.log('[TestDataScreen] Services initialized successfully');
      } catch (error) {
        console.error('[TestDataScreen] Error initializing services:', error);
        Alert.alert('Error', 'Failed to initialize services');
      }
    };
    
    initServices();
  }, []);

  // Function to directly call the handleReceivedData method of BluetoothService
  const simulateBongHit = async (rawTimestamp: string, durationInSeconds: number) => {
    if (!bluetoothService) {
      Alert.alert('Error', 'BluetoothService not initialized');
      return;
    }
    
    try {
      setLoading(true);
      setResult(null);
      
      // This normally happens inside BluetoothHandler and gets passed to BluetoothService
      // We're simulating that flow here
      console.log(`[TestDataScreen] Simulating data - Raw: ${rawTimestamp}, Duration: ${durationInSeconds}s`);
      
      // Parse the raw timestamp to ISO format
      const isoTimestamp = parseRawTimestamp(rawTimestamp);
      console.log(`[TestDataScreen] Parsed ISO timestamp: ${isoTimestamp}`);
      
      // Add random milliseconds to ensure uniqueness for the database
      const date = new Date(isoTimestamp);
      date.setMilliseconds(Math.floor(Math.random() * 1000));
      const uniqueTimestamp = date.toISOString();
      console.log(`[TestDataScreen] Unique ISO timestamp: ${uniqueTimestamp}`);
      
      // Convert duration from seconds to milliseconds
      const durationMs = durationInSeconds * 1000;
      
      // Access the private handleReceivedData method through our trick
      // @ts-ignore - We know this is private but we're accessing it for testing
      await (bluetoothService as any).handleReceivedData(rawTimestamp, uniqueTimestamp, durationMs);
      
      setResult(`Successfully processed bong hit:\nRaw: ${rawTimestamp}\nISO: ${uniqueTimestamp}\nDuration: ${durationMs}ms`);
      
      // Force navigation back to update the UI
      router.push('/(tabs)/mydata');
    } catch (error) {
      console.error('[TestDataScreen] Error simulating bong hit:', error);
      setResult(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  const insertTestTimestamps = async () => {
    setLoading(true);
    setResult(null);
    
    try {
      const dbManager = DatabaseManager.getInstance();
      await dbManager.ensureInitialized();
      const db = await dbManager.getDatabase(BONG_HITS_DATABASE_NAME);
      
      // Clear existing data if needed
      await db.execAsync('DELETE FROM BongHits');
      
      // Get SQL insert statements from constants.ts
      const insertStatements = getInsertStatements();
      
      // Execute each statement
      const statements = insertStatements.split(';').filter(stmt => stmt.trim().length > 0);
      
      for (const statement of statements) {
        await db.execAsync(`${statement.trim()};`);
      }
      
      // Get count to verify
      const result = await db.getFirstAsync<{ count: number }>('SELECT COUNT(*) as count FROM BongHits');
      
      setResult(`Successfully inserted ${result?.count || 0} test timestamps.`);
      Alert.alert('Success', `Inserted ${result?.count || 0} test timestamps into the database.`);
      
      // Navigate to MyData to see results
      router.push('/(tabs)/mydata');
    } catch (error) {
      console.error('Error inserting test data:', error);
      setResult(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
      Alert.alert('Error', `Failed to insert test data: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  const handleCustomTestData = async () => {
    if (!customTimestamp || !customDuration) {
      Alert.alert('Missing Data', 'Please enter both timestamp and duration');
      return;
    }
    
    try {
      const durationValue = parseFloat(customDuration);
      if (isNaN(durationValue) || durationValue <= 0) {
        Alert.alert('Invalid Duration', 'Duration must be a positive number');
        return;
      }
      
      await simulateBongHit(customTimestamp, durationValue);
    } catch (error) {
      console.error('[TestDataScreen] Error processing custom data:', error);
      Alert.alert('Error', 'Failed to process custom data');
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.primary} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Bluetooth Testing Interface</Text>
      </View>

      <ScrollView style={styles.content}>
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Simulate Bluetooth Data</Text>
          <Text style={styles.sectionDescription}>
            Send test data through the entire Bluetooth pipeline, including data processing and 
            database storage. This simulates exactly what happens when real Bluetooth data is received.
          </Text>
          
          {/* Preset test data */}
          <View style={styles.testDataContainer}>
            <Text style={styles.subsectionTitle}>Preset Test Cases</Text>
            {TIME_OFFSETS.map((offset, index) => {
              const timestamp = getTestTimestamp(offset);
              const duration = TEST_DURATIONS[index % TEST_DURATIONS.length];
              const timeDesc = offset === 0 
                ? 'Current time' 
                : offset < 24 
                  ? `${offset} hours ago` 
                  : `${Math.floor(offset/24)} day${offset >= 48 ? 's' : ''} ago`;
              
              return (
                <TouchableOpacity 
                  key={index}
                  style={styles.testDataButton}
                  onPress={() => simulateBongHit(timestamp, duration)}
                  disabled={loading || !bluetoothService}
                >
                  <Ionicons name="pulse-outline" size={18} color="#fff" style={styles.buttonIcon} />
                  <View style={styles.testDataInfo}>
                    <Text style={styles.testDataText}>{timeDesc}</Text>
                    <Text style={styles.testDataSubtext}>Duration: {duration}s</Text>
                  </View>
                </TouchableOpacity>
              );
            })}
          </View>
          
          {/* Custom test data */}
          <View style={styles.testDataContainer}>
            <Text style={styles.subsectionTitle}>Custom Test Data</Text>
            <TextInput
              style={styles.textInput}
              placeholder="Raw timestamp (e.g. Tuesday, March 28 2024 15:40:12)"
              placeholderTextColor="rgba(255,255,255,0.5)"
              value={customTimestamp}
              onChangeText={setCustomTimestamp}
            />
            <TextInput
              style={styles.textInput}
              placeholder="Duration in seconds (e.g. 0.123)"
              placeholderTextColor="rgba(255,255,255,0.5)"
              keyboardType="numeric"
              value={customDuration}
              onChangeText={setCustomDuration}
            />
            <TouchableOpacity 
              style={styles.customDataButton}
              onPress={handleCustomTestData}
              disabled={loading || !bluetoothService}
            >
              <Ionicons name="send-outline" size={18} color="#fff" style={styles.buttonIcon} />
              <Text style={styles.buttonText}>Send Custom Data</Text>
            </TouchableOpacity>
          </View>
          
          {/* Database insertion */}
          <View style={styles.testDataContainer}>
            <Text style={styles.subsectionTitle}>Bulk Test Data</Text>
            <TouchableOpacity 
              style={styles.actionButton}
              onPress={insertTestTimestamps}
              disabled={loading}
            >
              <Ionicons name="time-outline" size={20} color="#fff" style={styles.buttonIcon} />
              <Text style={styles.buttonText}>
                {loading ? 'Inserting Data...' : 'Insert Bulk Test Data'}
              </Text>
              {loading && <ActivityIndicator color="#fff" style={{ marginLeft: 10 }} />}
            </TouchableOpacity>
          </View>
          
          {result && (
            <View style={styles.resultContainer}>
              <Text style={styles.resultText}>{result}</Text>
            </View>
          )}
        </View>
        
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>View Data</Text>
          <Text style={styles.sectionDescription}>
            After inserting test data, you can view it on the MyData page.
          </Text>
          
          <TouchableOpacity 
            style={[styles.actionButton, { backgroundColor: '#2196F3' }]}
            onPress={() => router.push('/(tabs)/mydata')}
          >
            <Ionicons name="analytics-outline" size={20} color="#fff" style={styles.buttonIcon} />
            <Text style={styles.buttonText}>Go to MyData</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255,255,255,0.1)',
  },
  backButton: {
    padding: 8,
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: COLORS.text.primary,
  },
  content: {
    flex: 1,
  },
  section: {
    padding: 16,
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 8,
  },
  sectionDescription: {
    fontSize: 16,
    color: COLORS.text.secondary,
    marginBottom: 20,
    lineHeight: 22,
  },
  subsectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  actionButton: {
    backgroundColor: COLORS.primary,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 20,
    marginBottom: 12,
  },
  buttonIcon: {
    marginRight: 8,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  resultContainer: {
    marginTop: 16,
    padding: 12,
    backgroundColor: 'rgba(255,255,255,0.1)',
    borderRadius: 8,
  },
  resultText: {
    color: COLORS.text.primary,
    fontSize: 14,
  },
  testDataContainer: {
    marginBottom: 20,
    backgroundColor: 'rgba(255,255,255,0.05)',
    borderRadius: 8,
    padding: 16,
  },
  testDataButton: {
    backgroundColor: 'rgba(0,120,255,0.6)',
    flexDirection: 'row',
    alignItems: 'center',
    borderRadius: 8,
    padding: 12,
    marginBottom: 10,
  },
  testDataInfo: {
    flex: 1,
  },
  testDataText: {
    color: COLORS.text.primary,
    fontSize: 14,
    fontWeight: '500',
  },
  testDataSubtext: {
    color: COLORS.text.secondary,
    fontSize: 12,
    marginTop: 4,
  },
  textInput: {
    backgroundColor: 'rgba(255,255,255,0.1)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 12,
    color: COLORS.text.primary,
    fontSize: 14,
  },
  customDataButton: {
    backgroundColor: '#00aa55',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 20,
    marginBottom: 12,
  },
}); 

================================================================================
File: app/strains/_layout.tsx
================================================================================

import { Stack } from 'expo-router';

export default function StrainsLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="popular" 
        options={{ 
          title: "Popular Strains",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="details" 
        options={{ 
          title: "Strain Details",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="compare" 
        options={{ 
          title: "Compare Strains",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
    </Stack>
  );
}

================================================================================
File: app/strains/compare.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../src/constants';
import { Strain } from "@/src/types";
import { databaseManager } from '../../src/DatabaseManager';

export default function CompareStrains() {
  const { ids } = useLocalSearchParams();
  const strainIds = typeof ids === 'string' ? ids.split(',') : [];
  
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Compare Strains
      </Text>
      <Text style={{ color: COLORS.text.secondary, marginTop: 8 }}>
        Comparing IDs: {strainIds.join(', ')}
      </Text>
    </View>
  );
}

================================================================================
File: app/strains/details.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { Redirect, useLocalSearchParams } from 'expo-router';
import { COLORS } from '@/src/constants';

export default function StrainDetailsRedirect() {
  const { id } = useLocalSearchParams();
  return <Redirect href={`/dataOverviews/strains/strainDetails?id=${id}`} />;
}

================================================================================
File: app/strains/popular.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList,
  TouchableOpacity,
  Platform 
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { COLORS } from '../../src/constants';
import { Strain } from "@/src/types";
import { databaseManager } from '../../src/DatabaseManager';

const PopularStrains = () => {
  const router = useRouter();
  const [strains, setStrains] = useState<Strain[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadStrains = async () => {
      try {
        setLoading(true);
        const popularStrains = await databaseManager.getPopularStrains();
        setStrains(popularStrains);
      } catch (error) {
        console.error('Failed to load popular strains', error);
      } finally {
        setLoading(false);
      }
    };

    loadStrains();
  }, []);

  const renderItem = ({ item }: { item: Strain }) => (
    <TouchableOpacity 
      style={styles.strainItem}
      onPress={() => item.id && router.push({pathname: `/strains/${item.id}`} as any)}
    >
      <View style={styles.iconContainer}>
        <MaterialCommunityIcons name="cannabis" size={24} color="#fff" />
      </View>
      <View style={styles.textContainer}>
        <Text style={styles.strainName}>{item.name}</Text>
        <Text style={styles.strainDescription}>{item.overview}</Text>
        {item.thc_range && (
          <Text style={styles.thcContent}>THC: {item.thc_range}</Text>
        )}
      </View>
      <MaterialCommunityIcons 
        name="chevron-right" 
        size={24} 
        color={colors.label.secondary} 
      />
    </TouchableOpacity>
  );

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <MaterialCommunityIcons 
            name="chevron-left" 
            size={28} 
            color={colors.label.primary} 
          />
        </TouchableOpacity>
        <Text style={styles.headerText}>Popular Strains</Text>
      </View>
      <FlatList
        data={strains}
        renderItem={renderItem}
        keyExtractor={item => item.id ? item.id.toString() : ''}
        contentContainerStyle={styles.listContainer}
        showsVerticalScrollIndicator={false}
      />
    </SafeAreaView>
  );
};

const colors = {
  label: {
    primary: "#FFFFFF",
    secondary: "#8E8E93",
    tertiary: "#636366",
  },
  background: {
    primary: "#000000",
    secondary: "#1C1C1E",
    tertiary: "#2C2C2E",
  }
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background.primary,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    paddingTop: 8,
    borderBottomWidth: 1,
    borderBottomColor: colors.background.secondary,
  },
  backButton: {
    marginRight: 8,
    padding: 4,
  },
  headerText: {
    fontSize: 24,
    fontWeight: Platform.select({ ios: '600', android: 'bold' }),
    color: colors.label.primary,
  },
  listContainer: {
    padding: 16,
  },
  strainItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    backgroundColor: colors.background.secondary,
    borderRadius: 12,
    marginBottom: 12,
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: colors.background.tertiary,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  textContainer: {
    flex: 1,
  },
  strainName: {
    fontSize: 17,
    fontWeight: Platform.select({ ios: '600', android: 'bold' }),
    color: colors.label.primary,
    marginBottom: 4,
  },
  strainDescription: {
    fontSize: 14,
    color: colors.label.secondary,
    marginBottom: 4,
  },
  thcContent: {
    fontSize: 12,
    color: colors.label.tertiary,
    fontWeight: '500',
  },
});

export default PopularStrains; 

================================================================================
File: components/charts/WeeklyOverviewChart.tsx
================================================================================

import { Card } from "@/components/Card";
import { StyleSheet, View, Text, Dimensions } from "react-native";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { BarChart } from "react-native-chart-kit";
import { LinearGradient } from "expo-linear-gradient";
import { Datapoint } from "@/src/types";
import { useMemo } from "react";

// Keep COLORS here for now, we'll move it to constants later
const COLORS = {
  background: '#000000',
  cardBackground: '#1A1A1A',
  primary: '#00E676',       // Neon green 
  primaryLight: '#69F0AE',  // Light neon green
  primaryDark: '#00C853',   // Darker green
  text: {
    primary: '#FFFFFF',
    secondary: '#FFFFFFCC',  // 80% white
    tertiary: '#FFFFFF99',   // 60% white
  },
  chart: {
    primary: '#00E676',
    secondary: '#69F0AE',
    background: '#1A1A1A',
  },
  gradientColors: {
    start: 'rgba(0,230,118,0.4)',
    middle: 'rgba(105,240,174,0.2)',
    end: 'rgba(0,0,0,0)',
  }
};

const windowWidth = Dimensions.get("window").width;

interface WeeklyOverviewChartProps {
  data: Datapoint[];
  onPress?: () => void;
}

export function WeeklyOverviewChart({ data }: WeeklyOverviewChartProps) {
  // Memoize the chart width calculation
  const chartWidth = useMemo(() => Math.max(windowWidth - 64, 200), [windowWidth]);

  // Base chart config with optimizations
  const baseChartConfig = useMemo(() => ({
    backgroundColor: COLORS.chart.background,
    backgroundGradientFrom: COLORS.chart.background,
    backgroundGradientTo: COLORS.chart.background,
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
    labelColor: (opacity = 0.8) => `rgba(255, 255, 255, ${opacity})`,
    barPercentage: 0.7,
    useShadowColorFromDataset: false,
    withInnerLines: false,
    withVerticalLabels: true,
    withHorizontalLabels: true,
    withVerticalLines: false,
    withHorizontalLines: true,
    propsForBackgroundLines: {
      stroke: COLORS.text.tertiary,
      strokeWidth: 1,
    },
    propsForDots: {
      r: "4",
      strokeWidth: "2",
      stroke: COLORS.primaryLight,
    },
    style: {
      borderRadius: 16,
    },
    formatYLabel: (value: string) => Math.round(Number(value)).toString(),
    formatXLabel: (label: string) => label.substring(0, 3),
    segments: 4,
  }), []);

  // Memoize the data transformation
  const chartData = useMemo(() => ({
    labels: data.map((d) => d.label),
    datasets: [{ 
      data: data.map((d) => d.value),
      color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
      strokeWidth: 2,
    }]
  }), [data]);

  if (!data?.length) {
    return (
      <Card style={styles.card}>
        <View style={styles.cardHeader}>
          <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
          <Text style={styles.cardTitle}>Weekly Overview</Text>
        </View>
        <View style={styles.chartContainer}>
          <Text style={styles.noDataText}>No data available</Text>
        </View>
      </Card>
    );
  }

  return (
    <Card style={styles.card}>
      <View style={styles.cardHeader}>
        <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
        <Text style={styles.cardTitle}>Weekly Overview</Text>
      </View>
      <Text style={styles.cardDescription}>Compare your usage across different days</Text>
      <View style={styles.chartContainer}>
        <LinearGradient
          colors={[
            COLORS.gradientColors.start,
            COLORS.gradientColors.middle,
            COLORS.gradientColors.end
          ]}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
          style={styles.chartGradient}
        />
        <BarChart
          data={chartData}
          width={chartWidth}
          height={180}
          chartConfig={baseChartConfig}
          style={styles.chart}
          showValuesOnTopOfBars
          fromZero
          segments={4}
          flatColor={true}
          withCustomBarColorFromData={true}
        />
      </View>
    </Card>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#1A1A1A',
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 16,
    padding: 16,
    shadowColor: '#00E676',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  cardTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 10,
  },
  cardDescription: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 16,
    lineHeight: 20,
  },
  chartContainer: {
    marginTop: 16,
    alignItems: "center",
    paddingHorizontal: 8,
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 4,
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
    backgroundColor: COLORS.cardBackground,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 6,
  },
  chartGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 16,
  },
  noDataText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    padding: 20,
  }
}); 

================================================================================
File: components/Leaderboard.tsx
================================================================================

import React from 'react';
import { View, Text, FlatList, StyleSheet } from 'react-native';

interface LeaderboardEntry {
  id: string;
  name: string;
  score: number;
}

interface LeaderboardProps {
  data: LeaderboardEntry[];
  title: string;
}

const Leaderboard: React.FC<LeaderboardProps> = ({ title, data }) => {
  const renderItem = ({ item, index }: { item: LeaderboardEntry; index: number }) => (
    <View style={[styles.row, index === 0 ? styles.topRank : {}]}>
      <Text style={styles.rank}>{index + 1}</Text>
      <Text style={styles.name}>{item.name}</Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
      <FlatList
        data={data.sort((a, b) => b.score - a.score)} // Sort by score in descending order
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        ListEmptyComponent={<Text style={styles.empty}>No entries yet!</Text>}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 16,
    color: '#333',
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    marginVertical: 4,
    backgroundColor: '#fff',
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  topRank: {
    backgroundColor: '#ffd700', // Gold for top rank
  },
  rank: {
    fontSize: 18,
    fontWeight: 'bold',
    width: 40,
    textAlign: 'center',
  },
  name: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginLeft: 8,
  },
  score: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#12a35f',
  },
  empty: {
    textAlign: 'center',
    fontSize: 16,
    color: '#aaa',
    marginTop: 20,
  },
});

export default Leaderboard;

================================================================================
File: context.py
================================================================================

#!/usr/bin/env python3
"""
Context Extractor for React Native/TypeScript Cannabis Recommendation Codebase

This script extracts structured context from a React Native/TypeScript codebase, focusing on:
- React component definitions and props
- Hooks and their usage
- Service classes and methods
- API endpoints and connections
- TypeScript interfaces and types
- State management patterns

Usage:
  python context_extractor.py [output_file]
"""

import os
import re
import sys
import json
import argparse
from typing import List, Dict, Tuple, Any, Optional, Set
from collections import defaultdict
import datetime

# Configuration
DEFAULT_CONFIG = {
    "extensions": [".tsx", ".ts", ".js", ".jsx", ".json"],
    "exclude_dirs": [
        "node_modules", "__tests__", "coverage", "build", "dist", "android", "ios",
        ".expo", ".expo-shared", ".git", ".github", "web-build"
    ],
    "exclude_files": [
        ".test.", ".spec.", ".min.js", ".map", "setup.js",
        ".gitignore", "package-lock.json", ".env"
    ],
    "include_dirs": [
        "app", "src"
    ],
    "max_file_size": 1024 * 1024,  # 1MB
    "max_lines": 15000,  # Target maximum lines for output
    "analyze_performance": False,   # Whether to analyze performance issues
    "analyze_data_flow": False,     # Whether to analyze data flow
    "show_component_tree": False,   # Whether to show component hierarchy tree
    "analyze_react_native": False   # Whether to include React Native specific analysis
}

class CodeContextExtractor:
    """Extracts structured context from a React Native/TypeScript codebase"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.component_props = {}
        self.hooks = []
        self.services = []
        self.api_endpoints = []
        self.interfaces = {}
        self.state_management = []
        self.navigation_routes = []
        self.file_summaries = []
        self.total_lines = 0
        # Add tracking structures
        self.component_hierarchy = defaultdict(set)  # Parent -> Children
        self.hook_usages = defaultdict(set)  # Component -> Hooks used
        self.api_calls = defaultdict(set)  # Component/Hook -> API services called
        self.component_complexity = []  # Track complex components
        self.files = []  # Track all processed files
        self.performance_issues = []  # Track performance issues
        self.react_native_issues = []  # Track React Native specific issues
        self.state_flows = {}  # Track state flows between components
        self.api_flows = {}  # Track API data flows
        self.database_schemas = []  # Track database schemas
        # New tracking properties for enhanced analysis
        self.import_dependencies = []  # Track module dependencies
        self.complex_types = []  # Track complex type relationships
        self.enhanced_api_endpoints = []  # Enhanced API endpoint documentation
        self.prop_flows = []  # Track component prop flows
        self.style_patterns = []  # Track styling patterns
        self.hook_usages_analysis = []  # Enhanced hook usage analysis
        self.enhanced_navigation = []  # Enhanced navigation route analysis
        self.security_patterns = []  # Security pattern analysis
    
    def should_exclude_file(self, file_path: str) -> bool:
        """Check if a file should be excluded based on config"""
        normalized_path = os.path.normpath(file_path)
        
        # Check excluded patterns
        for pattern in self.config["exclude_files"]:
            if pattern in normalized_path:
                return True
        
        # Check file extension        
        ext = os.path.splitext(file_path)[1].lower()
        if ext not in self.config["extensions"]:
            return True
            
        return False

    def should_exclude_dir(self, dir_path: str) -> bool:
        """Check if a directory should be excluded based on config"""
        normalized_path = os.path.normpath(dir_path)
        dir_name = os.path.basename(normalized_path)
        
        # Check if the directory name itself is in the exclude list
        if dir_name in self.config["exclude_dirs"]:
            print(f"Excluding directory (name match): {normalized_path}")
            return True
            
        # Check if the path contains any of the excluded directory patterns
        for exclude_dir in self.config["exclude_dirs"]:
            if exclude_dir in normalized_path:
                print(f"Excluding directory (path match): {normalized_path} - matched: {exclude_dir}")
                return True
        
        # If we have include_dirs, check if this is in it
        if self.config["include_dirs"]:
            for include_dir in self.config["include_dirs"]:
                if include_dir in normalized_path:
                    return False
            # If not in any include_dirs, exclude it
            return True
                
        return False

    def collect_files(self, root_dir: str) -> List[Tuple[str, str]]:
        """Collect all eligible files in the directory"""
        results = []
        print(f"Collecting files from: {root_dir}")
        print(f"Exclusion patterns: {self.config['exclude_dirs']}")
        
        for root, dirs, files in os.walk(root_dir):
            # Process directories
            dirs_before = len(dirs)
            dirs[:] = [d for d in dirs if not self.should_exclude_dir(os.path.join(root, d))]
            if dirs_before > len(dirs):
                print(f"  In {root}: Filtered out {dirs_before - len(dirs)} directories")
            
            for file in files:
                file_path = os.path.join(root, file)
                rel_path = os.path.relpath(file_path, root_dir)
                
                # Check exclusion patterns
                if self.should_exclude_file(rel_path):
                    continue
                    
                # Check file size
                if os.path.getsize(file_path) > self.config["max_file_size"]:
                    continue
                
                # Check if the file is in an excluded directory
                file_dir = os.path.dirname(file_path)
                if self.should_exclude_dir(file_dir):
                    print(f"  Skipping file in excluded directory: {rel_path}")
                    continue
                    
                results.append((file_path, rel_path))
                
        print(f"Collected {len(results)} files for processing")
        return results

    def extract_react_component(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract React component information from file content"""
        components = []
        
        # Match functional components
        func_component_pattern = r'(?:export\s+)?(?:const|function)\s+([A-Z][a-zA-Z0-9_]*)\s*(?:<.*?>)?\s*(?:=\s*(?:\([^)]*\)|[^=]*)\s*=>|[({])'
        func_matches = re.finditer(func_component_pattern, content)
        
        for match in func_matches:
            component_name = match.group(1)
            if component_name.endswith('Provider') or component_name.endswith('Context'):
                continue  # Skip context providers, process them separately
            
            start_pos = match.start()
            
            # Find JSX start position
            jsx_start = content.find('return (', start_pos)
            if jsx_start == -1:
                jsx_start = content.find('return {', start_pos)
            
            # Find component props
            props_match = re.search(r'\(\s*(?:{\s*([^}]*)\s*}|\s*props\s*|\s*([^)]*)\s*)', content[start_pos:start_pos+500])
            props = []
            
            if props_match:
                props_text = props_match.group(1) or props_match.group(2) or ''
                # Parse prop names
                prop_matches = re.finditer(r'(\w+)(?::\s*([^,\s]+))?', props_text)
                props = [{'name': m.group(1), 'type': m.group(2) if m.group(2) else 'any'} for m in prop_matches]
            
            # Extract hooks used
            hook_usages = []
            hook_matches = re.finditer(r'use[A-Z][a-zA-Z0-9]*', content[:jsx_start] if jsx_start != -1 else content)
            for hook_match in hook_matches:
                hook_usages.append(hook_match.group())
                self.hook_usages[component_name].add(hook_match.group())
            
            # Extract API calls
            api_calls = []
            api_patterns = [
                r'([a-zA-Z0-9_]+)\.(?:get|post|put|delete|patch)\(',
                r'fetch\(',
                r'axios\.(?:get|post|put|delete|patch)\(',
                r'api\.(?:[a-zA-Z0-9_]+)\('
            ]
            
            for pattern in api_patterns:
                api_matches = re.finditer(pattern, content)
                for api_match in api_matches:
                    api_calls.append(api_match.group())
                    self.api_calls[component_name].add(api_match.group())
            
            # Calculate complexity based on number of hooks, conditionals, etc.
            complexity = len(hook_usages) + len(api_calls)
            complexity += content.count('if (') + content.count('? ')
            
            component_data = {
                'name': component_name,
                'type': 'functional',
                'file_path': file_path,
                'props': props,
                'hooks_used': hook_usages,
                'api_calls': api_calls,
                'complexity': complexity
            }
            
            # Add performance analysis if enabled
            if self.config.get("analyze_performance", False):
                performance_issues = self.analyze_performance_issues(content, component_name)
                if performance_issues:
                    component_data['performance_issues'] = performance_issues
                    self.performance_issues.append({
                        'component': component_name,
                        'file_path': file_path,
                        'issues': performance_issues
                    })
            
            # Add React Native analysis if enabled
            if self.config.get("analyze_react_native", False):
                rn_issues = self.analyze_react_native_patterns(content, component_name)
                if rn_issues:
                    component_data['react_native_issues'] = rn_issues
                    self.react_native_issues.append({
                        'component': component_name,
                        'file_path': file_path,
                        'issues': rn_issues
                    })
            
            # Add state flow analysis if enabled
            if self.config.get("analyze_data_flow", False):
                state_flows = self.track_state_flow(content, component_name)
                if state_flows:
                    component_data['state_flows'] = state_flows
                    self.state_flows.update(state_flows)
            
            components.append(component_data)
            
            # Track complex components
            if complexity > 10:
                self.component_complexity.append({
                    'name': component_name,
                    'file_path': file_path,
                    'complexity': complexity
                })
            
            # Store props information for reference
            self.component_props[component_name] = props
        
        # Match class components
        class_component_pattern = r'class\s+([A-Z][a-zA-Z0-9_]*)\s+extends\s+(?:React\.)?Component'
        class_matches = re.finditer(class_component_pattern, content)
        
        for match in class_matches:
            component_name = match.group(1)
            start_pos = match.start()
            
            # Find render method
            render_start = content.find('render()', start_pos)
            if render_start == -1:
                render_start = content.find('render () {', start_pos)
            if render_start == -1:
                render_start = content.find('render() {', start_pos)
            
            # Extract API calls
            api_calls = []
            api_patterns = [
                r'([a-zA-Z0-9_]+)\.(?:get|post|put|delete|patch)\(',
                r'fetch\(',
                r'axios\.(?:get|post|put|delete|patch)\(',
                r'api\.(?:[a-zA-Z0-9_]+)\('
            ]
            
            for pattern in api_patterns:
                api_matches = re.finditer(pattern, content)
                for api_match in api_matches:
                    api_calls.append(api_match.group())
                    self.api_calls[component_name].add(api_match.group())
            
            # Calculate complexity
            complexity = len(api_calls)
            complexity += content.count('if (') + content.count('? ')
            complexity += content.count('this.state') + content.count('this.setState')
            
            component_data = {
                'name': component_name,
                'type': 'class',
                'file_path': file_path,
                'api_calls': api_calls,
                'complexity': complexity
            }
            
            # Add performance analysis if enabled
            if self.config.get("analyze_performance", False):
                performance_issues = self.analyze_performance_issues(content, component_name)
                if performance_issues:
                    component_data['performance_issues'] = performance_issues
                    self.performance_issues.append({
                        'component': component_name,
                        'file_path': file_path,
                        'issues': performance_issues
                    })
            
            # Add React Native analysis if enabled
            if self.config.get("analyze_react_native", False):
                rn_issues = self.analyze_react_native_patterns(content, component_name)
                if rn_issues:
                    component_data['react_native_issues'] = rn_issues
                    self.react_native_issues.append({
                        'component': component_name,
                        'file_path': file_path,
                        'issues': rn_issues
                    })
            
            components.append(component_data)
            
            # Track complex components
            if complexity > 10:
                self.component_complexity.append({
                    'name': component_name,
                    'file_path': file_path,
                    'complexity': complexity
                })
        
        return components

    def extract_hooks(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract custom hooks from file content"""
        hooks = []
        
        # Match custom hooks
        hook_pattern = r'(?:export\s+)?(?:const|function)\s+(use[A-Z][a-zA-Z0-9_]*)\s*(?:<.*?>)?\s*(?:=\s*(?:\([^)]*\)|[^=]*)\s*=>|[({])'
        hook_matches = re.finditer(hook_pattern, content)
        
        for match in hook_matches:
            hook_name = match.group(1)
            start_pos = match.start()
            
            # Find hook parameters
            params_match = re.search(r'\(\s*([^)]*)\s*\)', content[start_pos:start_pos+200])
            params = []
            
            if params_match:
                params_text = params_match.group(1)
                # Parse parameter names
                param_matches = re.finditer(r'(\w+)(?::\s*([^,\s]+))?', params_text)
                params = [{'name': m.group(1), 'type': m.group(2) if m.group(2) else 'any'} for m in param_matches]
            
            # Find return type (look for useState, useReducer patterns)
            return_values = []
            
            # Look for useState hooks
            state_hooks = re.finditer(r'const\s+\[\s*(\w+)\s*,\s*set(\w+)\s*\]\s*=\s*useState[<(]', content[start_pos:])
            for state_match in state_hooks:
                state_name = state_match.group(1)
                setter_name = 'set' + state_match.group(2)
                return_values.append(f"[{state_name}, {setter_name}]")
            
            # Look for other React hooks
            hook_usages = []
            hook_matches = re.finditer(r'(use[A-Z][a-zA-Z0-9]*)', content[start_pos:])
            for hook_match in hook_matches:
                if hook_match.group(1) != hook_name:  # Avoid self-reference
                    hook_usages.append(hook_match.group(1))
            
            # Extract API calls
            api_calls = []
            api_patterns = [
                r'([a-zA-Z0-9_]+)\.(?:get|post|put|delete|patch)\(',
                r'fetch\(',
                r'axios\.(?:get|post|put|delete|patch)\(',
                r'api\.(?:[a-zA-Z0-9_]+)\('
            ]
            
            for pattern in api_patterns:
                api_matches = re.finditer(pattern, content[start_pos:])
                for api_match in api_matches:
                    api_calls.append(api_match.group())
            
            hooks.append({
                'name': hook_name,
                'file_path': file_path,
                'params': params,
                'returns': return_values,
                'uses_hooks': hook_usages,
                'api_calls': api_calls
            })
            
            # Add to class hook list
            self.hooks.append({
                'name': hook_name,
                'file_path': file_path,
                'params': params,
                'returns': return_values,
                'uses_hooks': hook_usages,
                'api_calls': api_calls
            })
        
        return hooks

    def extract_services(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract service classes and methods from file content"""
        services = []
        
        # Check if it's a service file by filename pattern
        file_name = os.path.basename(file_path)
        is_service = "Service" in file_name or "/services/" in file_path
        
        if not is_service:
            return services
        
        # Match class definitions
        class_pattern = r'(?:export\s+)?class\s+(\w+)(?:\s+extends\s+(\w+))?'
        class_matches = re.finditer(class_pattern, content)
        
        for match in class_matches:
            service_name = match.group(1)
            parent_class = match.group(2) if match.group(2) else None
            start_pos = match.start()
            
            # Find methods
            methods = []
            method_pattern = r'(?:async\s+)?(\w+)\s*\(([^)]*)\)\s*(?::\s*([^{]+))?\s*{'
            method_matches = re.finditer(method_pattern, content[start_pos:])
            
            for method_match in method_matches:
                method_name = method_match.group(1)
                if method_name in ['constructor', 'render']:
                    continue  # Skip standard methods
                
                params_str = method_match.group(2)
                return_type = method_match.group(3).strip() if method_match.group(3) else None
                
                # Parse params
                params = []
                if params_str:
                    param_matches = re.finditer(r'(\w+)(?::\s*([^,]+))?', params_str)
                    params = [{'name': m.group(1), 'type': m.group(2).strip() if m.group(2) else 'any'} for m in param_matches]
                
                methods.append({
                    'name': method_name,
                    'params': params,
                    'return_type': return_type
                })
            
            # Detect singleton pattern
            is_singleton = 'getInstance' in content and 'private constructor' in content
            
            # Extract API endpoints
            api_endpoints = []
            api_patterns = [
                r'(?:fetch|axios)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]',
                r'(?:get|post|put|delete|patch)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]'
            ]
            
            for pattern in api_patterns:
                endpoint_matches = re.finditer(pattern, content[start_pos:])
                for endpoint_match in endpoint_matches:
                    api_endpoints.append(endpoint_match.group(1))
            
            services.append({
                'name': service_name,
                'file_path': file_path,
                'parent_class': parent_class,
                'is_singleton': is_singleton,
                'methods': methods,
                'api_endpoints': api_endpoints
            })
            
            # Add to class services list
            self.services.append({
                'name': service_name,
                'file_path': file_path,
                'parent_class': parent_class,
                'is_singleton': is_singleton,
                'methods': methods,
                'api_endpoints': api_endpoints
            })
            
            # Add API endpoints to global list
            for endpoint in api_endpoints:
                self.api_endpoints.append({
                    'endpoint': endpoint,
                    'service': service_name,
                    'file_path': file_path
                })
        
        return services

    def extract_types(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract TypeScript interfaces and types"""
        types_info = {
            'interfaces': [],
            'types': [],
            'enums': []
        }
        
        # Extract interfaces
        interface_pattern = r'(?:export\s+)?interface\s+(\w+)(?:<[^>]*>)?\s*(?:extends\s+(\w+)(?:<[^>]*>)?)?\s*{'
        interface_matches = re.finditer(interface_pattern, content)
        
        for match in interface_matches:
            interface_name = match.group(1)
            parent_interface = match.group(2) if match.group(2) else None
            start_pos = match.start()
            
            # Find the end of the interface (closing brace)
            braces_count = 1
            end_pos = content.find('{', start_pos) + 1
            
            while braces_count > 0 and end_pos < len(content):
                if content[end_pos] == '{':
                    braces_count += 1
                elif content[end_pos] == '}':
                    braces_count -= 1
                end_pos += 1
            
            interface_content = content[start_pos:end_pos]
            
            # Extract properties
            properties = []
            property_pattern = r'(\w+)\??\s*:\s*([^;]+);'
            property_matches = re.finditer(property_pattern, interface_content)
            
            for prop_match in property_matches:
                prop_name = prop_match.group(1)
                prop_type = prop_match.group(2).strip()
                
                properties.append({
                    'name': prop_name,
                    'type': prop_type
                })
            
            types_info['interfaces'].append({
                'name': interface_name,
                'file_path': file_path,
                'parent': parent_interface,
                'properties': properties
            })
            
            # Add to global interfaces dict
            self.interfaces[interface_name] = {
                'file_path': file_path,
                'parent': parent_interface,
                'properties': properties
            }
        
        # Extract type aliases
        type_pattern = r'(?:export\s+)?type\s+(\w+)(?:<[^>]*>)?\s*=\s*([^;]+);'
        type_matches = re.finditer(type_pattern, content)
        
        for match in type_matches:
            type_name = match.group(1)
            type_definition = match.group(2).strip()
            
            types_info['types'].append({
                'name': type_name,
                'file_path': file_path,
                'definition': type_definition
            })
        
        # Extract enums
        enum_pattern = r'(?:export\s+)?enum\s+(\w+)\s*{'
        enum_matches = re.finditer(enum_pattern, content)
        
        for match in enum_matches:
            enum_name = match.group(1)
            start_pos = match.start()
            
            # Find the end of the enum (closing brace)
            braces_count = 1
            end_pos = content.find('{', start_pos) + 1
            
            while braces_count > 0 and end_pos < len(content):
                if content[end_pos] == '{':
                    braces_count += 1
                elif content[end_pos] == '}':
                    braces_count -= 1
                end_pos += 1
            
            enum_content = content[start_pos:end_pos]
            
            # Extract values
            values = []
            value_pattern = r'(\w+)(?:\s*=\s*([^,]+))?'
            value_matches = re.finditer(value_pattern, enum_content)
            
            for val_match in value_matches:
                val_name = val_match.group(1)
                if val_name in ['enum', 'export']:
                    continue  # Skip keywords
                
                val_value = val_match.group(2).strip() if val_match.group(2) else None
                
                values.append({
                    'name': val_name,
                    'value': val_value
                })
            
            types_info['enums'].append({
                'name': enum_name,
                'file_path': file_path,
                'values': values
            })
        
        return types_info

    def extract_navigation(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract navigation routes from file content"""
        routes = []
        
        # Check if it's a navigation file
        if not ("navigation" in file_path.lower() or "router" in file_path.lower()):
            return routes
        
        # Look for screen definitions
        screen_patterns = [
            r'<Stack\.Screen\s+name=[\'"]([^\'"]+)[\'"](?:\s+component={([^}]+)})?',
            r'<Tab\.Screen\s+name=[\'"]([^\'"]+)[\'"](?:\s+component={([^}]+)})?',
            r'<Drawer\.Screen\s+name=[\'"]([^\'"]+)[\'"](?:\s+component={([^}]+)})?',
            r'createStackNavigator\(\s*{\s*([^}]+)\s*}\s*\)',
            r'createBottomTabNavigator\(\s*{\s*([^}]+)\s*}\s*\)',
            r'createDrawerNavigator\(\s*{\s*([^}]+)\s*}\s*\)'
        ]
        
        for pattern in screen_patterns:
            matches = re.finditer(pattern, content)
            
            for match in matches:
                if match.group(1):
                    route_name = match.group(1)
                    component = match.group(2) if len(match.groups()) > 1 and match.group(2) else None
                    
                    routes.append({
                        'name': route_name,
                        'component': component,
                        'file_path': file_path
                    })
                else:
                    # For createXNavigator patterns, extract from the object
                    navigator_content = match.group(1)
                    route_matches = re.finditer(r'([A-Za-z0-9_]+)\s*:\s*([A-Za-z0-9_]+)', navigator_content)
                    
                    for route_match in route_matches:
                        route_name = route_match.group(1)
                        component = route_match.group(2)
                        
                        routes.append({
                            'name': route_name,
                            'component': component,
                            'file_path': file_path
                        })
        
        # Add to class navigation routes
        self.navigation_routes.extend(routes)
        
        return routes

    def extract_state_management(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Extract state management patterns (Redux, Context API, etc.)"""
        state_patterns = []
        
        # Check for Redux
        redux_indicators = ['createStore', 'createSlice', 'useDispatch', 'useSelector', 'combineReducers', 'Provider']
        redux_count = sum(1 for indicator in redux_indicators if indicator in content)
        
        if redux_count >= 2:  # At least 2 indicators suggests Redux usage
            # Extract reducers
            reducer_pattern = r'(?:export\s+)?(?:const|function)\s+(\w+)Reducer\s*='
            reducer_matches = re.finditer(reducer_pattern, content)
            
            for match in reducer_matches:
                reducer_name = match.group(1)
                
                state_patterns.append({
                    'type': 'redux_reducer',
                    'name': f"{reducer_name}Reducer",
                    'file_path': file_path
                })
            
            # Extract slices (Redux Toolkit)
            slice_pattern = r'(?:export\s+)?const\s+(\w+)Slice\s*=\s*createSlice\('
            slice_matches = re.finditer(slice_pattern, content)
            
            for match in slice_matches:
                slice_name = match.group(1)
                
                state_patterns.append({
                    'type': 'redux_slice',
                    'name': f"{slice_name}Slice",
                    'file_path': file_path
                })
            
            # Extract actions
            action_pattern = r'(?:export\s+)?const\s+{\s*([^}]+)\s*}\s*=\s*(\w+)Slice\.actions'
            action_matches = re.finditer(action_pattern, content)
            
            for match in action_matches:
                actions = [a.strip() for a in match.group(1).split(',')]
                slice_name = match.group(2)
                
                for action in actions:
                    state_patterns.append({
                        'type': 'redux_action',
                        'name': action,
                        'slice': slice_name,
                        'file_path': file_path
                    })
        
        # Check for Context API
        if 'createContext' in content:
            # Extract contexts
            context_pattern = r'(?:export\s+)?const\s+(\w+)Context\s*=\s*(?:React\.)?createContext\('
            context_matches = re.finditer(context_pattern, content)
            
            for match in context_matches:
                context_name = match.group(1)
                
                state_patterns.append({
                    'type': 'context',
                    'name': f"{context_name}Context",
                    'file_path': file_path
                })
            
            # Extract providers
            provider_pattern = r'(?:export\s+)?(?:const|function)\s+(\w+)Provider\s*=\s*\(\s*{\s*children\s*}'
            provider_matches = re.finditer(provider_pattern, content)
            
            for match in provider_matches:
                provider_name = match.group(1)
                
                state_patterns.append({
                    'type': 'context_provider',
                    'name': f"{provider_name}Provider",
                    'file_path': file_path
                })
        
        # Add to class state management list
        self.state_management.extend(state_patterns)
        
        return state_patterns

    def build_component_hierarchy(self):
        """Build a tree of component relationships based on JSX usage"""
        hierarchy = {}
        
        for file_path, rel_path in self.files:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
                
            # Extract component imports
            import_matches = re.finditer(r'import\s+{([^}]+)}\s+from', content)
            imported_components = []
            for match in import_matches:
                components = [c.strip() for c in match.group(1).split(',')]
                imported_components.extend(components)
            
            # Find component usages in JSX
            for component in imported_components:
                # Look for <ComponentName patterns
                usage_pattern = r'<\s*' + re.escape(component) + r'\s*[^>]*>'
                if re.search(usage_pattern, content):
                    # Find the parent component
                    for extracted_component in self.extract_react_component(content, file_path):
                        if extracted_component:
                            parent_name = extracted_component['name']
                            if parent_name not in hierarchy:
                                hierarchy[parent_name] = []
                            if component not in hierarchy[parent_name]:
                                hierarchy[parent_name].append(component)
        
        return hierarchy

    def track_state_flow(self, content, component_name):
        """Track state passing between components via props"""
        state_flows = {}
        
        # Find useState declarations
        state_matches = re.finditer(r'const\s+\[\s*(\w+)\s*,\s*set(\w+)\s*\]\s*=\s*useState', content)
        for match in state_matches:
            state_name = match.group(1)
            
            # Find where this state is passed as props
            prop_pattern = r'<(\w+)[^>]*\b' + re.escape(state_name) + r'={[^}]*}'
            prop_matches = re.finditer(prop_pattern, content)
            
            for prop_match in prop_matches:
                child_component = prop_match.group(1)
                if component_name not in state_flows:
                    state_flows[component_name] = {}
                
                if child_component not in state_flows[component_name]:
                    state_flows[component_name][child_component] = []
                    
                state_flows[component_name][child_component].append(state_name)
        
        return state_flows
        
    def analyze_performance_issues(self, content, component_name):
        """Identify potential performance issues in React components"""
        issues = []
        
        # Check for missing dependency arrays in useEffect
        effect_missing_deps = re.findall(r'useEffect\(\s*\(\)\s*=>\s*{[^}]+}\s*\)', content)
        if effect_missing_deps:
            issues.append(f"Component '{component_name}' has useEffect without dependency array")
        
        # Check for inline function definitions in JSX
        inline_functions = re.findall(r'<\w+\s+\w+={(?:\(\)\s*=>|function\s*\([^)]*\)\s*{)[^}]+}', content)
        if inline_functions:
            issues.append(f"Component '{component_name}' has {len(inline_functions)} inline functions in JSX")
        
        # Check for missing memo or React.memo usage in exported components
        if not re.search(r'memo\(\s*' + re.escape(component_name), content) and not re.search(r'React\.memo\(\s*' + re.escape(component_name), content):
            # Only flag for components with props that might need memoization
            if re.search(r'const\s+' + re.escape(component_name) + r'\s*=\s*\(\s*{\s*[^}]+}\s*\)', content):
                issues.append(f"Component '{component_name}' could benefit from memoization")
        
        return issues

    def analyze_react_native_patterns(self, content, component_name):
        """Analyze React Native specific patterns and potential issues"""
        issues = []
        
        # Check for inline styles (better to use StyleSheet)
        inline_styles = re.findall(r'style={{\s*[^}]+}}', content)
        if inline_styles:
            issues.append(f"Component '{component_name}' has {len(inline_styles)} inline styles that should use StyleSheet")
        
        # Check for missing platform-specific code
        if 'Platform.OS' not in content and ('SafeAreaView' in content or 'StatusBar' in content):
            issues.append(f"Component '{component_name}' might need platform-specific handling")
        
        # Check for large image resources without resize mode
        if 'Image' in content and 'source' in content and 'resizeMode' not in content:
            issues.append(f"Component '{component_name}' has Image without resizeMode specified")
        
        # Check for potential memory leaks in navigation events
        if ('useEffect' in content and 'navigation' in content and 
            ('addEventListener' in content or 'addListener' in content) and 
            'return' not in content):
            issues.append(f"Component '{component_name}' might have memory leaks from navigation event listeners")
        
        return issues

    def extract_database_schema(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract database schema information from file content"""
        schemas = []
        
        # Extract constant definitions for database names
        db_name_pattern = r'(?:const|let|var|export\s+const)\s+(\w+)_DATABASE_NAME\s*=\s*[\'"]([^\'"]+)[\'"]'
        db_names = {}
        for match in re.finditer(db_name_pattern, content):
            prefix = match.group(1)
            value = match.group(2)
            db_names[prefix] = value
            db_names[f"{prefix}_DATABASE_NAME"] = value  # Store both forms
        
        # Look for CREATE TABLE statements with both literal and template variable names
        # This pattern now handles both "TableName" and "${VARIABLE_NAME}"
        table_pattern = r'CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(?:([`"\w]+)|[$]{([^}]+)})\s*\(([^;]+)\)'
        table_matches = re.finditer(table_pattern, content, re.IGNORECASE | re.DOTALL)
        
        for match in table_matches:
            # Either direct table name or variable reference
            table_name = match.group(1) if match.group(1) else match.group(2)
            columns_def = match.group(3).strip()
            
            # If it's a variable reference, try to resolve it from known DB names
            if not match.group(1) and table_name in db_names:
                table_name = db_names[table_name]
            elif not match.group(1):
                # For template literals we couldn't resolve, use the variable name as table name
                table_name = f"{table_name} (variable)"
            else:
                # For direct table names, clean up quotes
                table_name = table_name.strip('`"')
            
            # Parse columns
            columns = []
            primary_keys = []
            foreign_keys = []
            
            # Split by commas, but handle complex constraints that may contain commas
            column_lines = []
            current_line = ""
            paren_count = 0
            
            for char in columns_def:
                current_line += char
                if char == '(':
                    paren_count += 1
                elif char == ')':
                    paren_count -= 1
                elif char == ',' and paren_count == 0:
                    column_lines.append(current_line.strip().rstrip(','))
                    current_line = ""
            
            if current_line.strip():
                column_lines.append(current_line.strip())
            
            # Process column definitions
            for line in column_lines:
                # Check if this is a column definition or constraint
                if re.match(r'^\s*(?:CONSTRAINT|PRIMARY\s+KEY|FOREIGN\s+KEY|UNIQUE|CHECK)', line, re.IGNORECASE):
                    # Handle constraints
                    if re.search(r'PRIMARY\s+KEY', line, re.IGNORECASE):
                        pk_match = re.search(r'PRIMARY\s+KEY\s*\(([^)]+)\)', line, re.IGNORECASE)
                        if pk_match:
                            pks = [pk.strip('`"') for pk in pk_match.group(1).split(',')]
                            primary_keys.extend(pks)
                    
                    if re.search(r'FOREIGN\s+KEY', line, re.IGNORECASE):
                        fk_match = re.search(r'FOREIGN\s+KEY\s*\(([^)]+)\)\s*REFERENCES\s*([`"\w]+|\${[^}]+})\s*\(([^)]+)\)', line, re.IGNORECASE)
                        if fk_match:
                            fk_cols = [col.strip('`"') for col in fk_match.group(1).split(',')]
                            ref_table = fk_match.group(2).strip('`"')
                            
                            # Handle variable reference in foreign key
                            if ref_table.startswith('${') and ref_table.endswith('}'):
                                var_name = ref_table[2:-1]
                                if var_name in db_names:
                                    ref_table = db_names[var_name]
                                else:
                                    ref_table = f"{var_name} (variable)"
                                    
                            ref_cols = [col.strip('`"') for col in fk_match.group(3).split(',')]
                            
                            for i, fk_col in enumerate(fk_cols):
                                ref_col = ref_cols[i] if i < len(ref_cols) else ref_cols[-1]
                                foreign_keys.append({
                                    'column': fk_col,
                                    'ref_table': ref_table,
                                    'ref_column': ref_col
                                })
                else:
                    # Regular column definition
                    parts = line.split()
                    if len(parts) >= 2:
                        col_name = parts[0].strip('`"')
                        col_type = parts[1].split('(')[0]  # Extract base type without size
                        
                        column = {
                            'name': col_name,
                            'type': col_type
                        }
                        
                        # Check for constraints in column definition
                        if 'NOT NULL' in line.upper():
                            column['nullable'] = False
                        else:
                            column['nullable'] = True
                        
                        if 'PRIMARY KEY' in line.upper():
                            primary_keys.append(col_name)
                        
                        if 'DEFAULT' in line.upper():
                            default_match = re.search(r'DEFAULT\s+([^,\s]+)', line, re.IGNORECASE)
                            if default_match:
                                column['default'] = default_match.group(1)
                        
                        columns.append(column)
            
            # Look for INDEX statements related to this table
            # This pattern now handles both "TableName" and "${VARIABLE_NAME}"
            index_pattern = r'CREATE\s+(?:UNIQUE\s+)?INDEX\s+(?:IF\s+NOT\s+EXISTS\s+)?(\w+)\s+ON\s+(?:([`"\w]+)|[$]{([^}]+)})\s*\(([^)]+)\)'
            index_matches = re.finditer(index_pattern, content, re.IGNORECASE)
            
            indices = []
            for idx_match in index_matches:
                idx_table = idx_match.group(2) if idx_match.group(2) else idx_match.group(3)
                
                # If it's a variable, try to resolve it
                if not idx_match.group(2) and idx_table in db_names:
                    idx_table = db_names[idx_table]
                
                # Check if this index belongs to our table (either by name or by variable)
                if idx_table == table_name or (table_name.endswith(' (variable)') and idx_table == table_name[:-11]):
                    idx_name = idx_match.group(1)
                    idx_columns = [col.strip('`"') for col in idx_match.group(4).split(',')]
                    unique = 'UNIQUE' in idx_match.group(0).upper()
                    
                    indices.append({
                        'name': idx_name,
                        'columns': idx_columns,
                        'unique': unique
                    })
            
            # Extract additional table info from constants file if available
            schema_description = None
            schema_source = file_path
            
            schemas.append({
                'table_name': table_name,
                'columns': columns,
                'primary_keys': primary_keys,
                'foreign_keys': foreign_keys,
                'indices': indices,
                'description': schema_description,
                'file_path': schema_source
            })
        
        return {'schemas': schemas}

    def extract_import_dependencies(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract import statements and build dependency relationships"""
        dependencies = []
        
        # Match import statements
        import_patterns = [
            r'import\s+{([^}]+)}\s+from\s+[\'"]([^\'"]+)[\'"]',  # import { X } from 'Y'
            r'import\s+(\w+)\s+from\s+[\'"]([^\'"]+)[\'"]',      # import X from 'Y'
            r'import\s+[\'"]([^\'"]+)[\'"]'                     # import 'X'
        ]
        
        for pattern in import_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                if len(match.groups()) == 2:
                    # Named imports or default import
                    if '{' in match.group(0):
                        # Named imports
                        imported_items = [item.strip() for item in match.group(1).split(',')]
                        source = match.group(2)
                        
                        for item in imported_items:
                            dependencies.append({
                                'type': 'named',
                                'name': item,
                                'source': source
                            })
                    else:
                        # Default import
                        name = match.group(1)
                        source = match.group(2)
                        
                        dependencies.append({
                            'type': 'default',
                            'name': name,
                            'source': source
                        })
                elif len(match.groups()) == 1:
                    # Side effect import
                    source = match.group(1)
                    
                    dependencies.append({
                        'type': 'side_effect',
                        'source': source
                    })
        
        return {'dependencies': dependencies}

    def extract_complex_types(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract and analyze complex TypeScript types with relationships"""
        type_system = {
            'interfaces': [],
            'types': [],
            'enums': [],
            'type_relationships': []
        }
        
        # Extract interfaces with inheritance
        interface_pattern = r'(?:export\s+)?interface\s+(\w+)(?:<[^>]*>)?\s*(?:extends\s+([^{]+))?\s*{([^}]*)}'
        interface_matches = re.finditer(interface_pattern, content, re.DOTALL)
        
        for match in interface_matches:
            interface_name = match.group(1)
            extends = match.group(2).strip() if match.group(2) else None
            body = match.group(3).strip()
            
            # Extract properties with types
            properties = []
            property_pattern = r'(\w+)(?:\?)?:\s*([^;]+);'
            property_matches = re.finditer(property_pattern, body)
            
            for prop_match in property_matches:
                prop_name = prop_match.group(1)
                prop_type = prop_match.group(2).strip()
                
                properties.append({
                    'name': prop_name,
                    'type': prop_type
                })
            
            interface_info = {
                'name': interface_name,
                'extends': extends,
                'properties': properties,
                'file_path': file_path
            }
            
            type_system['interfaces'].append(interface_info)
            
            # Track inheritance relationships
            if extends:
                parent_interfaces = [p.strip() for p in extends.split(',')]
                for parent in parent_interfaces:
                    type_system['type_relationships'].append({
                        'from': interface_name,
                        'to': parent,
                        'type': 'extends'
                    })
        
        # Extract complex type aliases
        type_pattern = r'(?:export\s+)?type\s+(\w+)(?:<[^>]*>)?\s*=\s*([^;]+);'
        type_matches = re.finditer(type_pattern, content)
        
        for match in type_matches:
            type_name = match.group(1)
            type_definition = match.group(2).strip()
            
            # Analyze union, intersection, mapped types
            type_info = {
                'name': type_name,
                'definition': type_definition,
                'file_path': file_path,
                'category': self.categorize_type(type_definition)
            }
            
            type_system['types'].append(type_info)
            
            # Track type dependencies
            for other_type in self.extract_type_references(type_definition):
                type_system['type_relationships'].append({
                    'from': type_name,
                    'to': other_type,
                    'type': 'references'
                })
        
        return type_system

    def categorize_type(self, type_definition: str) -> str:
        """Categorize the kind of type definition"""
        if '|' in type_definition:
            return 'union'
        elif '&' in type_definition:
            return 'intersection'
        elif type_definition.startswith('Record<') or type_definition.startswith('Partial<'):
            return 'utility'
        elif type_definition.startswith('{') and '=>' in type_definition:
            return 'function'
        elif type_definition.startswith('[') and ']' in type_definition:
            return 'tuple'
        elif '{' in type_definition and '}' in type_definition:
            return 'object'
        else:
            return 'basic'

    def extract_type_references(self, type_definition: str) -> List[str]:
        """Extract referenced types from a type definition"""
        # Basic regex to find type names
        referenced_types = []
        type_refs = re.finditer(r'(?<![\'"`])(\b[A-Z]\w+)\b(?![\'"`])', type_definition)
        
        for match in type_refs:
            referenced_types.append(match.group(1))
        
        return referenced_types

    def extract_api_endpoints(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract API endpoints from service files"""
        endpoints = []
        
        # Match various API call patterns
        patterns = [
            # Fetch pattern
            r'fetch\([\'"]([^\'"]+)[\'"](?:,\s*({[^}]+}))?\)',
            
            # Axios pattern
            r'axios\.(?:get|post|put|delete|patch)\([\'"]([^\'"]+)[\'"](?:,\s*([^,)]+))?\)',
            
            # Custom API client pattern
            r'api\.(?:get|post|put|delete|patch)\([\'"]([^\'"]+)[\'"](?:,\s*([^,)]+))?\)',
            
            # REST method pattern
            r'(?:get|post|put|delete|patch)\([\'"]([^\'"]+)[\'"](?:,\s*([^,)]+))?\)'
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                endpoint = match.group(1)
                
                # Try to extract request body/params if available
                request_data = None
                if len(match.groups()) > 1 and match.group(2):
                    request_data = match.group(2)
                
                # Determine HTTP method
                method = 'GET'  # Default
                if 'post(' in match.group(0).lower():
                    method = 'POST'
                elif 'put(' in match.group(0).lower():
                    method = 'PUT'
                elif 'delete(' in match.group(0).lower():
                    method = 'DELETE'
                elif 'patch(' in match.group(0).lower():
                    method = 'PATCH'
                
                # Try to extract surrounding function name
                function_name = self.extract_containing_function(content, match.start())
                
                # Extract return type if available
                return_type = self.extract_return_type(content, match.start())
                
                endpoints.append({
                    'endpoint': endpoint,
                    'method': method,
                    'request_data': request_data,
                    'function': function_name,
                    'return_type': return_type,
                    'file_path': file_path
                })
        
        return {'api_endpoints': endpoints}
    
    def extract_containing_function(self, content: str, position: int) -> Optional[str]:
        """Extract the name of the function containing the given position"""
        # Find the nearest function declaration before the position
        function_pattern = r'(?:async\s+)?(?:function\s+(\w+)|const\s+(\w+)\s*=\s*(?:async\s+)?\([^)]*\)\s*=>)'
        matches = list(re.finditer(function_pattern, content[:position]))
        
        if matches:
            last_match = matches[-1]
            return last_match.group(1) or last_match.group(2)
        
        return None
    
    def extract_return_type(self, content: str, position: int) -> Optional[str]:
        """Extract return type of the function containing the given position"""
        function_with_return = r'(?:function\s+\w+|const\s+\w+\s*=\s*(?:async\s+)?\([^)]*\))\s*:\s*([^{]+)'
        matches = list(re.finditer(function_with_return, content[:position]))
        
        if matches:
            last_match = matches[-1]
            return last_match.group(1).strip()
        
        return None

    def analyze_prop_flow(self, file_path: str, component_name: str, props: List[Dict]) -> Dict[str, Any]:
        """Analyze how props flow through a component"""
        with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()
        
        prop_usage = {}
        
        for prop in props:
            prop_name = prop['name']
            
            # Find where this prop is used within the component
            usages = []
            
            # Direct usage pattern (props.X or X from destructured props)
            direct_pattern = r'(?:props\.{0}|{0})\b'.format(prop_name)
            direct_matches = re.finditer(direct_pattern, content)
            for match in direct_matches:
                context = self.get_context_snippet(content, match.start(), 60)
                usages.append({
                    'type': 'direct',
                    'context': context
                })
            
            # Passed to child component pattern (<ChildComponent propName={X})
            passed_pattern = r'<(\w+)[^>]*{0}={[^}]+}'.format(prop_name)
            passed_matches = re.finditer(passed_pattern, content)
            for match in passed_matches:
                child_component = match.group(1)
                context = self.get_context_snippet(content, match.start(), 60)
                usages.append({
                    'type': 'passed_to_child',
                    'child_component': child_component,
                    'context': context
                })
            
            # Used in conditional rendering
            conditional_pattern = r'{\s*(?:props\.)?{0}\s*\?.+?:'.format(prop_name)
            conditional_matches = re.finditer(conditional_pattern, content)
            for match in conditional_matches:
                context = self.get_context_snippet(content, match.start(), 60)
                usages.append({
                    'type': 'conditional_rendering',
                    'context': context
                })
            
            prop_usage[prop_name] = usages
        
        return {
            'component': component_name,
            'file_path': file_path,
            'prop_usage': prop_usage
        }
    
    def get_context_snippet(self, content: str, position: int, context_length: int) -> str:
        """Get a snippet of content around the specified position"""
        start = max(0, position - context_length // 2)
        end = min(len(content), position + context_length // 2)
        return content[start:end].replace('\n', ' ').strip()

    def extract_style_patterns(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract and analyze styling patterns"""
        style_info = {
            'style_definitions': [],
            'inline_styles': [],
            'theme_usages': [],
            'style_patterns': []
        }
        
        # Extract StyleSheet.create definitions
        stylesheet_pattern = r'(?:const|let|var)\s+(\w+)\s*=\s*StyleSheet\.create\(\s*({[^}]+})\s*\)'
        stylesheet_matches = re.finditer(stylesheet_pattern, content, re.DOTALL)
        
        for match in stylesheet_matches:
            style_name = match.group(1)
            style_content = match.group(2)
            
            style_info['style_definitions'].append({
                'name': style_name,
                'content': style_content,
                'file_path': file_path
            })
            
            # Parse individual style rules
            style_rule_pattern = r'(\w+):\s*{([^}]+)}'
            style_rule_matches = re.finditer(style_rule_pattern, style_content)
            
            for rule_match in style_rule_matches:
                rule_name = rule_match.group(1)
                rule_content = rule_match.group(2)
                
                style_info['style_patterns'].append({
                    'stylesheet': style_name,
                    'rule_name': rule_name,
                    'rule_content': rule_content
                })
        
        # Extract inline styles
        inline_style_pattern = r'style={({[^}]+})}'
        inline_style_matches = re.finditer(inline_style_pattern, content)
        
        for match in inline_style_matches:
            style_content = match.group(1)
            context = self.get_context_snippet(content, match.start(), 100)
            
            style_info['inline_styles'].append({
                'content': style_content,
                'context': context,
                'file_path': file_path
            })
        
        # Extract theme usages (COLORS, etc.)
        theme_usage_pattern = r'(COLORS\.\w+(?:\.\w+)?)'
        theme_usage_matches = re.finditer(theme_usage_pattern, content)
        
        for match in theme_usage_matches:
            theme_var = match.group(1)
            context = self.get_context_snippet(content, match.start(), 60)
            
            style_info['theme_usages'].append({
                'variable': theme_var,
                'context': context,
                'file_path': file_path
            })
        
        return style_info

    def analyze_hook_usage(self, content: str, file_path: str) -> Dict[str, Any]:
        """Analyze custom hook implementations and usage patterns"""
        hook_analysis = {
            'hook_definitions': [],
            'hook_usages': [],
            'dependencies': [],
            'state_management': []
        }
        
        # Extract hook definitions
        hook_pattern = r'(?:export\s+)?(?:function|const)\s+(use\w+)'
        hook_matches = re.finditer(hook_pattern, content)
        
        for match in hook_matches:
            hook_name = match.group(1)
            hook_start = match.start()
            
            # Find the function end (this is a simplification)
            hook_body = self.extract_function_body(content, hook_start)
            
            # Analyze useState calls
            state_pattern = r'const\s+\[\s*(\w+)\s*,\s*set(\w+)\s*\]\s*=\s*useState(?:<[^>]*>)?\(([^)]*)\)'
            state_matches = re.finditer(state_pattern, hook_body)
            
            states = []
            for state_match in state_matches:
                state_name = state_match.group(1)
                setter_name = 'set' + state_match.group(2)
                initial_value = state_match.group(3).strip()
                
                states.append({
                    'name': state_name,
                    'setter': setter_name,
                    'initial_value': initial_value
                })
            
            # Analyze useEffect calls
            effect_pattern = r'useEffect\(\(\)\s*=>\s*{([^}]+)}\s*,\s*\[([^]]*)\]\)'
            effect_matches = re.finditer(effect_pattern, hook_body)
            
            effects = []
            for effect_match in effect_matches:
                effect_body = effect_match.group(1).strip()
                dependencies = effect_match.group(2).strip()
                
                dep_list = []
                if dependencies:
                    dep_list = [dep.strip() for dep in dependencies.split(',')]
                
                effects.append({
                    'body': effect_body,
                    'dependencies': dep_list
                })
            
            # Analyze useCallback/useMemo calls
            memo_pattern = r'(?:useCallback|useMemo)\((?:\([^)]*\))?\s*=>\s*{([^}]+)}\s*,\s*\[([^]]*)\]\)'
            memo_matches = re.finditer(memo_pattern, hook_body)
            
            memoized = []
            for memo_match in memo_matches:
                memo_body = memo_match.group(1).strip()
                dependencies = memo_match.group(2).strip()
                
                dep_list = []
                if dependencies:
                    dep_list = [dep.strip() for dep in dependencies.split(',')]
                
                is_callback = 'useCallback' in memo_match.group(0)
                
                memoized.append({
                    'type': 'callback' if is_callback else 'memo',
                    'body': memo_body,
                    'dependencies': dep_list
                })
            
            hook_analysis['hook_definitions'].append({
                'name': hook_name,
                'file_path': file_path,
                'states': states,
                'effects': effects,
                'memoized': memoized
            })
        
        # Find hook usages in non-hook functions
        component_pattern = r'(?:export\s+)?(?:function|const)\s+([A-Z]\w+)'
        component_matches = re.finditer(component_pattern, content)
        
        for match in component_matches:
            component_name = match.group(1)
            component_start = match.start()
            
            component_body = self.extract_function_body(content, component_start)
            
            # Find hook calls within this component
            hook_call_pattern = r'(?:const\s+(?:\w+|\[[^\]]+\])\s*=\s*)?(use\w+)\('
            hook_call_matches = re.finditer(hook_call_pattern, component_body)
            
            component_hooks = []
            for hook_call in hook_call_matches:
                hook_name = hook_call.group(1)
                context = self.get_context_snippet(component_body, hook_call.start(), 80)
                
                component_hooks.append({
                    'hook': hook_name,
                    'context': context
                })
            
            if component_hooks:
                hook_analysis['hook_usages'].append({
                    'component': component_name,
                    'file_path': file_path,
                    'hooks': component_hooks
                })
        
        return hook_analysis
    
    def extract_function_body(self, content: str, start_pos: int) -> str:
        """Extract the function body from a given starting position"""
        # Find opening brace
        brace_pos = content.find('{', start_pos)
        if brace_pos == -1:
            return ""
        
        # Track nested braces to find the matching closing brace
        brace_count = 1
        pos = brace_pos + 1
        
        while pos < len(content) and brace_count > 0:
            if content[pos] == '{':
                brace_count += 1
            elif content[pos] == '}':
                brace_count -= 1
            pos += 1
        
        if brace_count == 0:
            return content[brace_pos:pos]
        
        return content[brace_pos:]

    def extract_navigation_routes(self, content: str, file_path: str) -> Dict[str, Any]:
        """Extract and analyze navigation routes and screen transitions"""
        navigation_info = {
            'routes': [],
            'screens': [],
            'transitions': [],
            'params': []
        }
        
        # Extract Expo Router route definitions
        router_pattern = r'<(Stack|Tabs|Drawer)\.Screen\s+name=[\'"]([^\'"]+)[\'"]'
        router_matches = re.finditer(router_pattern, content)
        
        for match in router_matches:
            nav_type = match.group(1)
            route_name = match.group(2)
            
            # Try to extract options
            options_start = content.find('options=', match.start())
            options_content = ""
            if options_start > 0 and options_start < match.start() + 200:  # Within reasonable range
                options_end = content.find('/>', options_start)
                if options_end > 0:
                    options_content = content[options_start:options_end]
            
            navigation_info['routes'].append({
                'type': nav_type,
                'name': route_name,
                'options': options_content,
                'file_path': file_path
            })
        
        # Extract useRouter().push calls
        push_pattern = r'(?:router|navigation)\.(?:push|navigate)\(\s*[\'"]([^\'"]+)[\'"](?:\s*,\s*({[^}]+}))?\s*\)'
        push_matches = re.finditer(push_pattern, content)
        
        for match in push_matches:
            route = match.group(1)
            params = match.group(2) if len(match.groups()) > 1 and match.group(2) else None
            
            navigation_info['transitions'].append({
                'to': route,
                'params': params,
                'context': self.get_context_snippet(content, match.start(), 120),
                'file_path': file_path
            })
        
        # Extract Expo Router route params
        param_pattern = r'useLocalSearchParams\(\)'
        param_matches = re.finditer(param_pattern, content)
        
        for match in param_matches:
            # Look for destrucutred params
            destruct_pattern = r'const\s+{([^}]+)}\s*=\s*useLocalSearchParams\(\)'
            destruct_match = re.search(destruct_pattern, content[max(0, match.start()-50):match.start()+50])
            
            if destruct_match:
                params = [param.strip() for param in destruct_match.group(1).split(',')]
                
                navigation_info['params'].append({
                    'params': params,
                    'file_path': file_path
                })
        
        return navigation_info

    def analyze_security_patterns(self, content: str, file_path: str) -> Dict[str, Any]:
        """Analyze security practices and patterns in the code"""
        security_info = {
            'data_validation': [],
            'authentication_checks': [],
            'sensitive_data': [],
            'security_concerns': []
        }
        
        # Look for input validation
        validation_patterns = [
            r'\.validate\(',
            r'\.isValid\(',
            r'validator\.',
            r'new\s+Validator\(',
            r'schema\.validate\('
        ]
        
        for pattern in validation_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                context = self.get_context_snippet(content, match.start(), 100)
                security_info['data_validation'].append({
                    'pattern': pattern,
                    'context': context,
                    'file_path': file_path
                })
        
        # Look for authentication checks
        auth_patterns = [
            r'isAuthenticated\(',
            r'requireAuth',
            r'checkAuth',
            r'AuthContext',
            r'useAuth\(',
            r'isLoggedIn'
        ]
        
        for pattern in auth_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                context = self.get_context_snippet(content, match.start(), 100)
                security_info['authentication_checks'].append({
                    'pattern': pattern,
                    'context': context,
                    'file_path': file_path
                })
        
        # Look for potential sensitive data
        sensitive_patterns = [
            r'password',
            r'token',
            r'secret',
            r'auth',
            r'key',
            r'credentials'
        ]
        
        for pattern in sensitive_patterns:
            matches = re.finditer(r'\b' + pattern + r'\b', content, re.IGNORECASE)
            for match in matches:
                context = self.get_context_snippet(content, match.start(), 100)
                
                # Filter out false positives (in comments, etc.)
                if not (
                    '// ' in context[:context.find(match.group(0))] or
                    '/* ' in context[:context.find(match.group(0))]
                ):
                    security_info['sensitive_data'].append({
                        'term': match.group(0),
                        'context': context,
                        'file_path': file_path
                    })
        
        # Identify security concerns
        concern_patterns = {
            'Hardcoded secrets': r'(?:apiKey|secretKey|password|token)\s*=\s*[\'"][^\'"]+[\'"]',
            'Insecure storage': r'localStorage\.setItem\([\'"](?:token|auth|password)[\'"]',
            'SQL injection risk': r'executeQuery\([\'"]SELECT.+\$\{',
            'XSS risk': r'(?:innerHTML|dangerouslySetInnerHTML)\s*=',
            'Potential CSRF': r'fetch\(.+{credentials:\s*[\'"]include[\'"]'
        }
        
        for concern, pattern in concern_patterns.items():
            matches = re.finditer(pattern, content)
            for match in matches:
                context = self.get_context_snippet(content, match.start(), 100)
                security_info['security_concerns'].append({
                    'issue': concern,
                    'pattern': pattern,
                    'context': context,
                    'file_path': file_path
                })
        
        return security_info

    def track_api_data_flow(self):
        """Track data flow from API calls to component state"""
        api_flows = {}
        
        for file_path, rel_path in self.files:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
            
            # Find API calls that update state
            api_call_pattern = r'(get|post|put|delete|patch|fetch)\([^)]+\)(?:.*?)\.then\(\s*(?:\([^)]*\)\s*=>\s*{\s*(?:set(\w+)|this\.setState\(\s*{\s*(\w+)))'
            api_matches = re.finditer(api_call_pattern, content, re.DOTALL)
            
            for match in api_matches:
                api_method = match.group(1)
                state_updated = match.group(2) or match.group(3)
                
                # Find the component for this file
                for component in self.extract_react_component(content, file_path):
                    if component:
                        component_name = component['name']
                        if component_name not in api_flows:
                            api_flows[component_name] = []
                        
                        api_flows[component_name].append({
                            'api_method': api_method,
                            'state_updated': state_updated
                        })
        
        return api_flows
        
    def analyze_hook_patterns(self):
        """Analyze patterns and potential optimizations in hook usage"""
        hook_patterns = {}
        
        # For each custom hook
        for hook in self.hooks:
            hook_name = hook['name']
            hook_patterns[hook_name] = {
                'usage_count': 0,
                'components': [],
                'potential_optimizations': []
            }
            
            # Find components using this hook
            for component_name, used_hooks in self.hook_usages.items():
                if hook_name in used_hooks:
                    hook_patterns[hook_name]['usage_count'] += 1
                    hook_patterns[hook_name]['components'].append(component_name)
            
            # Check for potential optimizations
            if hook['api_calls'] and not any('useCallback' in h for h in hook['uses_hooks']):
                hook_patterns[hook_name]['potential_optimizations'].append(
                    f"API calls in '{hook_name}' could benefit from useCallback"
                )
                
            if hook['api_calls'] and not any('useMemo' in h for h in hook['uses_hooks']):
                hook_patterns[hook_name]['potential_optimizations'].append(
                    f"Data processing in '{hook_name}' could benefit from useMemo"
                )
        
        return hook_patterns

    def generate_output(self, format='text'):
        """Generate output in different formats (text, json, markdown, html)"""
        if format == 'text':
            return self.generate_text_output()
        elif format == 'json':
            return self.generate_json_output()
        elif format == 'markdown':
            return self.generate_markdown_output()
        elif format == 'html':
            return self.generate_html_output()
        else:
            raise ValueError(f"Unsupported output format: {format}")

    def generate_json_output(self):
        """Generate JSON output"""
        data = {
            'components': self.component_complexity,
            'hooks': self.hooks,
            'services': self.services,
            'api_endpoints': self.api_endpoints,
            'interfaces': self.interfaces,
            'navigation_routes': self.navigation_routes,
            'component_hierarchy': self.build_component_hierarchy()
        }
        return json.dumps(data, indent=2)

    def generate_markdown_output(self):
        """Generate Markdown output"""
        lines = []
        
        # Header
        lines.append("# React Native/TypeScript Codebase Analysis")
        lines.append(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append("")
        
        # Component Hierarchy Section
        lines.append("## Component Hierarchy")
        hierarchy = self.build_component_hierarchy()
        for parent, children in hierarchy.items():
            lines.append(f"### {parent}")
            for child in children:
                lines.append(f"- {child}")
            lines.append("")
        
        # Complex Components Section
        lines.append("## Complex Components")
        sorted_components = sorted(self.component_complexity, key=lambda x: x['complexity'], reverse=True)
        lines.append("| Component | Complexity | File |")
        lines.append("|-----------|------------|------|")
        for component in sorted_components[:20]:
            lines.append(f"| {component['name']} | {component['complexity']} | {os.path.basename(component['file_path'])} |")
        
        # Hooks Section
        lines.append("\n## Custom Hooks")
        for hook in self.hooks:
            lines.append(f"### {hook['name']}")
            if hook['params']:
                lines.append("**Parameters:**")
                for param in hook['params']:
                    lines.append(f"- {param['name']}: {param.get('type', 'any')}")
            if hook['uses_hooks']:
                lines.append("**Uses hooks:**")
                for used_hook in hook['uses_hooks']:
                    lines.append(f"- {used_hook}")
            lines.append("")
        
        # Navigation Routes
        lines.append("## Navigation Routes")
        for route in self.navigation_routes:
            component_str = f"  {route['component']}" if route['component'] else ""
            lines.append(f"- {route['name']}{component_str}")
        
        # API Endpoints
        lines.append("\n## API Endpoints")
        for endpoint in self.api_endpoints:
            lines.append(f"- {endpoint['endpoint']} (from {endpoint['service']})")
        
        # Database Schemas Section
        if self.database_schemas:
            lines.append("\n## Database Schemas")
            for schema in self.database_schemas:
                lines.append(f"\n### Table: {schema['table_name']}")
                
                # Columns
                lines.append("#### Columns")
                for column in schema['columns']:
                    nullable = "NULL" if column.get('nullable', True) else "NOT NULL"
                    default = f" DEFAULT {column['default']}" if 'default' in column else ""
                    pk = " PRIMARY KEY" if column['name'] in schema['primary_keys'] else ""
                    lines.append(f"- {column['name']}: {column['type']} {nullable}{default}{pk}")
                
                # Primary Keys
                if schema['primary_keys']:
                    lines.append("\n#### Primary Keys")
                    for pk in schema['primary_keys']:
                        lines.append(f"- {pk}")
                
                # Foreign Keys
                if schema['foreign_keys']:
                    lines.append("\n#### Foreign Keys")
                    for fk in schema['foreign_keys']:
                        lines.append(f"- {fk['column']}  {fk['ref_table']}.{fk['ref_column']}")
                
                # Indices
                if schema['indices']:
                    lines.append("\n#### Indices")
                    for idx in schema['indices']:
                        unique = "UNIQUE " if idx['unique'] else ""
                        lines.append(f"- {unique}INDEX {idx['name']} ({', '.join(idx['columns'])})")
        
        # Module Dependencies Section
        if self.import_dependencies:
            lines.append("\n## Module Dependencies")
            
            # Group dependencies by source
            by_source = defaultdict(list)
            for dep in self.import_dependencies:
                if 'source' in dep:
                    by_source[dep['source']].append(dep)
            
            # Take the top most imported modules
            top_modules = sorted(by_source.items(), key=lambda x: len(x[1]), reverse=True)[:10]
            
            lines.append("\n### Top Imported Modules")
            lines.append("| Module | Import Count | Types |")
            lines.append("|--------|--------------|-------|")
            
            for source, deps in top_modules:
                named = len([d for d in deps if d.get('type') == 'named'])
                default = len([d for d in deps if d.get('type') == 'default'])
                side_effect = len([d for d in deps if d.get('type') == 'side_effect'])
                
                types = []
                if named > 0:
                    types.append(f"{named} named")
                if default > 0:
                    types.append(f"{default} default")
                if side_effect > 0:
                    types.append(f"{side_effect} side-effect")
                
                lines.append(f"| {source} | {len(deps)} | {', '.join(types)} |")
        
        # Type System Analysis
        if self.complex_types:
            lines.append("\n## Type System Analysis")
            
            # Count interfaces and types
            interfaces = [t for t in self.complex_types if 'properties' in t]
            types = [t for t in self.complex_types if 'definition' in t]
            
            if interfaces:
                lines.append(f"\n### Interfaces ({len(interfaces)} defined)")
                
                # Show top 5 most complex interfaces
                complex_interfaces = sorted(interfaces, key=lambda x: len(x.get('properties', [])), reverse=True)[:5]
                
                lines.append("| Interface | Properties | Extends |")
                lines.append("|-----------|------------|---------|")
                
                for interface in complex_interfaces:
                    extends = interface.get('extends', 'N/A')
                    lines.append(f"| {interface['name']} | {len(interface.get('properties', []))} | {extends} |")
            
            if types:
                lines.append(f"\n### Type Aliases ({len(types)} defined)")
                
                # Count by category
                categories = {}
                for t in types:
                    cat = t.get('category', 'unknown')
                    categories[cat] = categories.get(cat, 0) + 1
                
                lines.append("| Category | Count |")
                lines.append("|----------|-------|")
                
                for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
                    lines.append(f"| {cat} | {count} |")
        
        # Enhanced API Endpoints
        if self.enhanced_api_endpoints:
            lines.append("\n## Enhanced API Documentation")
            
            # Group by method
            by_method = defaultdict(list)
            for endpoint in self.enhanced_api_endpoints:
                by_method[endpoint['method']].append(endpoint)
            
            method_count = {method: len(endpoints) for method, endpoints in by_method.items()}
            
            lines.append("| HTTP Method | Endpoint Count |")
            lines.append("|------------|---------------|")
            
            for method, count in sorted(method_count.items(), key=lambda x: x[1], reverse=True):
                lines.append(f"| {method} | {count} |")
            
            lines.append("\n### Sample Endpoints")
            for method, endpoints in sorted(by_method.items(), key=lambda x: len(x[1]), reverse=True)[:3]:
                lines.append(f"\n#### {method} Endpoints (showing top 3)")
                for endpoint in endpoints[:3]:
                    lines.append(f"- `{endpoint['endpoint']}`")
                    if endpoint.get('function'):
                        lines.append(f"  - Function: `{endpoint['function']}`")
        
        # Security Analysis
        if self.security_patterns:
            lines.append("\n## Security Analysis")
            
            # Group by issue type
            by_issue = defaultdict(list)
            for concern in self.security_patterns:
                by_issue[concern['issue']].append(concern)
            
            lines.append("| Security Concern | Occurrences |")
            lines.append("|------------------|-------------|")
            
            for issue, concerns in sorted(by_issue.items(), key=lambda x: len(x[1]), reverse=True):
                lines.append(f"| {issue} | {len(concerns)} |")
        
        return "\n".join(lines)

    def format_file_summary(self, file_path: str, rel_path: str, file_info: Dict[str, Any]) -> List[str]:
        """Format the summary of a file for the output"""
        ext = os.path.splitext(file_path)[1].lower()
        lines = []
        
        if ext in ['.tsx', '.ts', '.jsx', '.js']:
            # Add imports summary
            if file_info.get('imports'):
                lines.append("# Imports:")
                for import_info in file_info['imports'][:5]:  # Show first 5 imports
                    module = import_info['module']
                    imports = ", ".join(import_info['imports'])
                    lines.append(f"# import {{ {imports} }} from '{module}'")
                
                if len(file_info['imports']) > 5:
                    lines.append(f"# ... and {len(file_info['imports']) - 5} more imports")
                
                lines.append("")
            
            # Add components
            if file_info.get('components'):
                lines.append("# Components:")
                for component in file_info['components']:
                    lines.extend(self.format_component_info(component))
                    lines.append("")
            
            # Add hooks
            if file_info.get('hooks'):
                lines.append("# Hooks:")
                for hook in file_info['hooks']:
                    lines.extend(self.format_hook_info(hook))
                    lines.append("")
            
            # Add services
            if file_info.get('services'):
                lines.append("# Services:")
                for service in file_info['services']:
                    lines.extend(self.format_service_info(service))
                    lines.append("")
            
            # Add types
            if file_info.get('types') and any(file_info['types'].values()):
                lines.append("# Type Definitions:")
                lines.extend(self.format_type_info(file_info['types']))
                lines.append("")
            
            # Add navigation
            if file_info.get('navigation'):
                lines.append("# Navigation:")
                lines.extend(self.format_navigation_info(file_info['navigation']))
                lines.append("")
            
            # Add state management
            if file_info.get('state_management'):
                lines.append("# State Management:")
                lines.extend(self.format_state_management_info(file_info['state_management']))
                lines.append("")
        
        elif ext == '.json':
            # For JSON files, try to parse and summarize
            try:
                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    json_data = json.load(f)
                
                lines.append("# JSON Structure:")
                
                # For package.json, show dependencies
                if file_path.endswith('package.json'):
                    if 'dependencies' in json_data:
                        lines.append("# Dependencies:")
                        for dep, version in list(json_data['dependencies'].items())[:10]:
                            lines.append(f"#   {dep}: {version}")
                        
                        if len(json_data['dependencies']) > 10:
                            lines.append(f"#   ... and {len(json_data['dependencies']) - 10} more dependencies")
                    
                    if 'devDependencies' in json_data:
                        lines.append("# Dev Dependencies:")
                        for dep, version in list(json_data['devDependencies'].items())[:5]:
                            lines.append(f"#   {dep}: {version}")
                        
                        if len(json_data['devDependencies']) > 5:
                            lines.append(f"#   ... and {len(json_data['devDependencies']) - 5} more dev dependencies")
                    
                    if 'scripts' in json_data:
                        lines.append("# Scripts:")
                        for script, command in list(json_data['scripts'].items())[:5]:
                            lines.append(f"#   {script}: {command}")
                        
                        if len(json_data['scripts']) > 5:
                            lines.append(f"#   ... and {len(json_data['scripts']) - 5} more scripts")
                else:
                    # For other JSON files, show top-level keys
                    lines.append("# Top-level keys:")
                    for key in json_data.keys():
                        value_type = type(json_data[key]).__name__
                        lines.append(f"#   {key}: {value_type}")
            
            except json.JSONDecodeError:
                lines.append("# Invalid JSON file")
            
            lines.append("")
        
        else:
            # Basic info for other file types
            lines.append(f"# {ext[1:]} file - detailed extraction not supported")
        
        return lines

    def process_file(self, file_path: str) -> Dict[str, Any]:
        """Process a file based on its type"""
        ext = os.path.splitext(file_path)[1].lower()
        result = {}
        
        if ext in ['.tsx', '.ts', '.jsx', '.js']:
            result = self.process_tsx_file(file_path)
        elif ext == '.json':
            try:
                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    json_data = json.load(f)
                result = {'json_data': json_data}
            except json.JSONDecodeError:
                result = {'error': 'Invalid JSON file'}
        else:
            # Just return basic info for other file types
            result = {"type": ext[1:], "info": f"File summary not available for {ext} files"}
        
        # Add database schema extraction
        try:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
            
            # Extract database schema regardless of file type
            db_schemas = self.extract_database_schema(content, file_path)
            if db_schemas.get('schemas'):
                result['database_schemas'] = db_schemas
                # Add to global list of schemas
                self.database_schemas.extend(db_schemas['schemas'])
            
            # Apply new enhanced analysis functions
            if ext in ['.tsx', '.ts', '.jsx', '.js']:
                # Import dependencies
                import_deps = self.extract_import_dependencies(content, file_path)
                if import_deps.get('dependencies'):
                    result['import_dependencies'] = import_deps
                    self.import_dependencies.extend(import_deps['dependencies'])
                
                # Complex type analysis
                if ext in ['.ts', '.tsx']:
                    complex_types = self.extract_complex_types(content, file_path)
                    if complex_types.get('interfaces') or complex_types.get('types'):
                        result['complex_types'] = complex_types
                        if complex_types.get('interfaces'):
                            self.complex_types.extend(complex_types['interfaces'])
                        if complex_types.get('types'):
                            self.complex_types.extend(complex_types['types'])
                
                # Enhanced API endpoint analysis
                api_endpoints = self.extract_api_endpoints(content, file_path)
                if api_endpoints.get('api_endpoints'):
                    result['api_endpoints_enhanced'] = api_endpoints
                    self.enhanced_api_endpoints.extend(api_endpoints['api_endpoints'])
                
                # Style pattern analysis
                style_patterns = self.extract_style_patterns(content, file_path)
                if any(style_patterns.values()):
                    result['style_patterns'] = style_patterns
                    if style_patterns.get('style_definitions'):
                        self.style_patterns.extend(style_patterns['style_definitions'])
                
                # Hook usage analysis
                hook_analysis = self.analyze_hook_usage(content, file_path)
                if any(hook_analysis.values()):
                    result['hook_analysis'] = hook_analysis
                    if hook_analysis.get('hook_definitions'):
                        self.hook_usages_analysis.extend(hook_analysis['hook_definitions'])
                
                # Navigation route analysis
                nav_routes = self.extract_navigation_routes(content, file_path)
                if any(nav_routes.values()):
                    result['navigation_routes_enhanced'] = nav_routes
                    if nav_routes.get('routes'):
                        self.enhanced_navigation.extend(nav_routes['routes'])
                
                # Security pattern analysis
                security_patterns = self.analyze_security_patterns(content, file_path)
                if any(security_patterns.values()):
                    result['security_patterns'] = security_patterns
                    if security_patterns.get('security_concerns'):
                        self.security_patterns.extend(security_patterns['security_concerns'])
                
        except Exception as e:
            print(f"Error in enhanced analysis for {file_path}: {str(e)}")
        
        return result

    def extract_context(self, root_dir: str, output_file: str, format='text') -> None:
        """Extract context from codebase and write to output file"""
        print(f"Processing project directory: {root_dir}")
        print(f"Using configuration:")
        print(f"  - Exclude directories: {self.config['exclude_dirs']}")
        print(f"  - Include directories: {self.config['include_dirs']}")
        print(f"  - Exclude files: {self.config['exclude_files']}")
        print(f"  - File extensions: {self.config['extensions']}")
        print(f"  - Output format: {format}")
        
        # Collect files
        try:
            self.files = self.collect_files(root_dir)
            print(f"Found {len(self.files)} eligible files")
            self.files.sort(key=lambda x: x[1])  # Sort by relative path
        except Exception as e:
            print(f"Error collecting files: {str(e)}")
            return
        
        # Process all files to gather relationships
        processed_count = 0
        excluded_count = 0
        error_count = 0
        
        for file_path, rel_path in self.files:
            # Skip processing if we've hit line limit
            if self.total_lines >= self.config["max_lines"]:
                print(f"Reached line limit of {self.config['max_lines']} lines. Stopping...")
                break
                
            try:
                # Process the file
                file_info = self.process_file(file_path)
                processed_count += 1
                
                # Format the file summary
                summary_lines = self.format_file_summary(file_path, rel_path, file_info)
                
                # Skip if no useful info extracted
                if not summary_lines:
                    excluded_count += 1
                    continue
                    
                # Check if adding this file would exceed our line limit
                if self.total_lines + len(summary_lines) + 3 > self.config["max_lines"]:
                    print(f"Reached target line limit ({self.config['max_lines']}). Stopping...")
                    break
                    
                # Add file info with header
                self.file_summaries.append({
                    "path": rel_path,
                    "lines": summary_lines
                })
                
                self.total_lines += len(summary_lines) + 3  # +3 for separator and file name lines
                
                # Periodically report progress
                if processed_count % 10 == 0:
                    print(f"Processed {processed_count} files, total lines: {self.total_lines}")
            
            except Exception as e:
                print(f"Error processing file {rel_path}: {str(e)}")
                error_count += 1
        
        print(f"Processing complete:")
        print(f"  - Processed: {processed_count} files")
        print(f"  - Excluded (no useful info): {excluded_count} files")
        print(f"  - Errors: {error_count} files")
        
        # Now generate output in the requested format
        try:
            output_content = self.generate_output(format)
            with open(output_file, 'w', encoding='utf-8') as out:
                out.write(output_content)
            
            print(f"Context extraction complete! Generated output in {format} format to {output_file}")
        except Exception as e:
            print(f"Error writing to output file: {str(e)}")

    def process_tsx_file(self, file_path: str) -> Dict[str, Any]:
        """Process a TypeScript/JavaScript file and extract information"""
        result = {}
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
                
            # Extract components
            components = self.extract_react_component(content, file_path)
            if components:
                result['components'] = components
                
            # Extract hooks
            hooks = self.extract_hooks(content, file_path)
            if hooks:
                result['hooks'] = hooks
                
            # Extract services
            services = self.extract_services(content, file_path)
            if services:
                result['services'] = services
                
            # Extract type information
            types = self.extract_types(content, file_path)
            if any(types.values()):
                result['types'] = types
                
            # Extract navigation information
            navigation = self.extract_navigation(content, file_path)
            if navigation:
                result['navigation'] = navigation
                
            # Extract state management
            state_management = self.extract_state_management(content, file_path)
            if state_management:
                result['state_management'] = state_management
                
            # Extract import information (basic version)
            imports = []
            import_pattern = r'import\s+(?:{([^}]+)}|(\w+))\s+from\s+[\'"]([^\'"]+)[\'"]'
            import_matches = re.finditer(import_pattern, content)
            
            for match in import_matches:
                if match.group(1):  # Named imports
                    imports_list = [name.strip() for name in match.group(1).split(',')]
                    imports.append({
                        'module': match.group(3),
                        'imports': imports_list
                    })
                elif match.group(2):  # Default import
                    imports.append({
                        'module': match.group(3),
                        'imports': [match.group(2)]
                    })
                    
            if imports:
                result['imports'] = imports
            
        except Exception as e:
            print(f"Error processing {file_path}: {str(e)}")
            return {'error': str(e)}
            
        return result

    def generate_text_output(self):
        """Generate text-based output"""
        lines = []
        
        # Header
        lines.append("=== AI KNOWLEDGE BASE CODE CONTEXT ===")
        lines.append(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"Total files processed: {len(self.files)}")
        lines.append("")
        
        # Component Complexity Section
        if self.component_complexity:
            lines.append("=== COMPONENT COMPLEXITY ===")
            lines.append("(Components with complexity > 10, sorted by complexity)")
            lines.append("Component Name | Complexity | File")
            lines.append("--------------|------------|-----")
            
            sorted_components = sorted(self.component_complexity, key=lambda x: x['complexity'], reverse=True)
            for component in sorted_components[:20]:  # Show top 20
                file_name = os.path.basename(component['file_path'])
                lines.append(f"{component['name']} | {component['complexity']} | {file_name}")
            
            lines.append("")
            lines.append("Complexity Guidelines:")
            lines.append("- 0-5: Simple component")
            lines.append("- 6-10: Moderate complexity")
            lines.append("- 11-20: Complex component")
            lines.append("- 21+: Very complex, consider refactoring")
            lines.append("")
        
        # Hooks Section
        if self.hooks:
            lines.append("=== CUSTOM HOOKS ===")
            for hook in self.hooks:
                lines.append(f"Hook: {hook['name']} (from {os.path.basename(hook['file_path'])})")
                
                if hook['params']:
                    lines.append("  Parameters:")
                    for param in hook['params']:
                        lines.append(f"    - {param['name']}: {param.get('type', 'any')}")
                
                if hook['returns']:
                    lines.append("  Returns:")
                    for ret in hook['returns']:
                        lines.append(f"    - {ret}")
                
                if hook['uses_hooks']:
                    lines.append("  Uses hooks:")
                    for used_hook in hook['uses_hooks']:
                        lines.append(f"    - {used_hook}")
                
                if hook['api_calls']:
                    lines.append("  API calls:")
                    for api_call in hook['api_calls']:
                        lines.append(f"    - {api_call}")
                
                lines.append("")
        
        # Services Section
        if self.services:
            lines.append("=== SERVICES ===")
            for service in self.services:
                singleton = " (Singleton)" if service.get('is_singleton') else ""
                parent = f" extends {service['parent_class']}" if service.get('parent_class') else ""
                lines.append(f"Service: {service['name']}{singleton}{parent} (from {os.path.basename(service['file_path'])})")
                
                if service['methods']:
                    lines.append("  Methods:")
                    for method in service['methods']:
                        params = ', '.join([f"{p['name']}: {p['type']}" for p in method['params']])
                        return_type = f" -> {method['return_type']}" if method.get('return_type') else ""
                        lines.append(f"    - {method['name']}({params}){return_type}")
                
                if service['api_endpoints']:
                    lines.append("  API Endpoints:")
                    for endpoint in service['api_endpoints']:
                        lines.append(f"    - {endpoint}")
                
                lines.append("")
        
        # API Endpoints Section
        if self.api_endpoints:
            lines.append("=== API ENDPOINTS ===")
            for endpoint in self.api_endpoints:
                lines.append(f"Endpoint: {endpoint['endpoint']}")
                lines.append(f"  Service: {endpoint['service']}")
                lines.append(f"  File: {os.path.basename(endpoint['file_path'])}")
                lines.append("")
        
        # Navigation Routes Section
        if self.navigation_routes:
            lines.append("=== NAVIGATION ROUTES ===")
            for route in self.navigation_routes:
                component = f" -> {route['component']}" if route.get('component') else ""
                lines.append(f"Route: {route['name']}{component}")
                lines.append(f"  File: {os.path.basename(route['file_path'])}")
                lines.append("")
        
        # State Management Section
        if self.state_management:
            lines.append("=== STATE MANAGEMENT ===")
            
            # Group by type
            state_by_type = {}
            for state in self.state_management:
                if state['type'] not in state_by_type:
                    state_by_type[state['type']] = []
                state_by_type[state['type']].append(state)
            
            for state_type, states in state_by_type.items():
                lines.append(f"{state_type.replace('_', ' ').title()}:")
                for state in states:
                    lines.append(f"  - {state['name']} (from {os.path.basename(state['file_path'])})")
                lines.append("")
        
        # Database Schemas Section
        if self.database_schemas:
            lines.append("=== DATABASE SCHEMAS ===")
            for schema in self.database_schemas:
                lines.append(f"Table: {schema['table_name']} (from {os.path.basename(schema['file_path'])})")
                
                # Columns
                lines.append("  Columns:")
                for column in schema['columns']:
                    nullable = "NULL" if column.get('nullable', True) else "NOT NULL"
                    default = f" DEFAULT {column['default']}" if 'default' in column else ""
                    pk = " PRIMARY KEY" if column['name'] in schema['primary_keys'] else ""
                    lines.append(f"    - {column['name']}: {column['type']} {nullable}{default}{pk}")
                
                # Primary Keys
                if schema['primary_keys']:
                    lines.append("  Primary Keys:")
                    for pk in schema['primary_keys']:
                        lines.append(f"    - {pk}")
                
                # Foreign Keys
                if schema['foreign_keys']:
                    lines.append("  Foreign Keys:")
                    for fk in schema['foreign_keys']:
                        lines.append(f"    - {fk['column']}  {fk['ref_table']}.{fk['ref_column']}")
                
                # Indices
                if schema['indices']:
                    lines.append("  Indices:")
                    for idx in schema['indices']:
                        unique = "UNIQUE " if idx['unique'] else ""
                        lines.append(f"    - {unique}INDEX {idx['name']} ({', '.join(idx['columns'])})")
                
                lines.append("")
        
        # Module Dependencies Section
        if self.import_dependencies:
            lines.append("=== MODULE DEPENDENCIES ===")
            
            # Group dependencies by source
            by_source = defaultdict(list)
            for dep in self.import_dependencies:
                if 'source' in dep:
                    by_source[dep['source']].append(dep)
            
            # Take top 20 most imported modules
            top_modules = sorted(by_source.items(), key=lambda x: len(x[1]), reverse=True)[:20]
            
            for source, deps in top_modules:
                named = len([d for d in deps if d.get('type') == 'named'])
                default = len([d for d in deps if d.get('type') == 'default'])
                side_effect = len([d for d in deps if d.get('type') == 'side_effect'])
                
                types = []
                if named > 0:
                    types.append(f"{named} named")
                if default > 0:
                    types.append(f"{default} default")
                if side_effect > 0:
                    types.append(f"{side_effect} side-effect")
                
                lines.append(f"Module: {source} - {len(deps)} imports ({', '.join(types)})")
            
            lines.append("")
        
        # Type System Analysis
        if self.complex_types:
            lines.append("=== TYPE SYSTEM ANALYSIS ===")
            
            # Count interfaces and types
            interfaces = [t for t in self.complex_types if 'properties' in t]
            types = [t for t in self.complex_types if 'definition' in t]
            
            lines.append(f"Total Interfaces: {len(interfaces)}")
            lines.append(f"Total Type Aliases: {len(types)}")
            lines.append("")
            
            if interfaces:
                lines.append("Most Complex Interfaces:")
                
                # Show top 5 most complex interfaces
                complex_interfaces = sorted(interfaces, key=lambda x: len(x.get('properties', [])), reverse=True)[:5]
                
                for interface in complex_interfaces:
                    extends = f" extends {interface['extends']}" if interface.get('extends') else ""
                    lines.append(f"- {interface['name']}{extends} - {len(interface.get('properties', []))} properties")
            
            lines.append("")
            
            if types:
                lines.append("Type Alias Categories:")
                
                # Count by category
                categories = {}
                for t in types:
                    cat = t.get('category', 'unknown')
                    categories[cat] = categories.get(cat, 0) + 1
                
                for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
                    lines.append(f"- {cat}: {count}")
            
            lines.append("")
        
        # Enhanced API Documentation
        if self.enhanced_api_endpoints:
            lines.append("=== ENHANCED API DOCUMENTATION ===")
            
            # Group by method
            by_method = defaultdict(list)
            for endpoint in self.enhanced_api_endpoints:
                by_method[endpoint['method']].append(endpoint)
            
            for method, endpoints in sorted(by_method.items()):
                lines.append(f"{method} Endpoints ({len(endpoints)}):")
                for endpoint in endpoints[:10]:  # Show top 10 of each method
                    lines.append(f"- {endpoint['endpoint']}")
                    if endpoint.get('function'):
                        lines.append(f"  Function: {endpoint['function']}")
                    if endpoint.get('return_type'):
                        lines.append(f"  Returns: {endpoint['return_type']}")
                
                if len(endpoints) > 10:
                    lines.append(f"  ... and {len(endpoints) - 10} more {method} endpoints")
                
                lines.append("")
        
        # Style Patterns
        if self.style_patterns:
            lines.append("=== STYLE PATTERNS ===")
            
            total_style_rules = sum(len(style.get('style_patterns', [])) for style in self.style_patterns) 
            lines.append(f"Total StyleSheet Rules: {total_style_rules}")
            
            inline_count = sum(1 for pattern in self.style_patterns if pattern.get('inline_styles'))
            if inline_count > 0:
                lines.append(f"Components with Inline Styles: {inline_count}")
            
            lines.append("")
        
        # Hook Usage Analysis
        if self.hook_usages_analysis:
            lines.append("=== ENHANCED HOOK ANALYSIS ===")
            
            for hook in self.hook_usages_analysis:
                lines.append(f"Hook: {hook['name']}")
                
                if hook.get('states'):
                    lines.append(f"  State Variables: {len(hook['states'])}")
                    for state in hook['states'][:3]:  # Show first 3
                        initial = f" = {state['initial_value']}" if state.get('initial_value') else ""
                        lines.append(f"    - {state['name']}{initial}")
                    
                    if len(hook['states']) > 3:
                        lines.append(f"    ... and {len(hook['states']) - 3} more state variables")
                
                if hook.get('effects'):
                    lines.append(f"  Effects: {len(hook['effects'])}")
                    for effect in hook['effects'][:2]:  # Show first 2
                        deps = ", ".join(effect['dependencies']) if effect['dependencies'] else "[]"
                        lines.append(f"    - Dependencies: [{deps}]")
                    
                    if len(hook['effects']) > 2:
                        lines.append(f"    ... and {len(hook['effects']) - 2} more effects")
                
                if hook.get('memoized'):
                    callbacks = len([m for m in hook['memoized'] if m['type'] == 'callback'])
                    memos = len([m for m in hook['memoized'] if m['type'] == 'memo'])
                    
                    if callbacks > 0:
                        lines.append(f"  Callbacks: {callbacks}")
                    
                    if memos > 0:
                        lines.append(f"  Memoized Values: {memos}")
                    
                    lines.append("")
        
        # Navigation Routes Analysis
        if self.enhanced_navigation:
            lines.append("=== ENHANCED NAVIGATION ROUTES ===")
            
            # Group by type
            routes_by_type = defaultdict(list)
            for route in self.enhanced_navigation:
                routes_by_type[route.get('type', 'Unknown')].append(route)
            
            for route_type, routes in routes_by_type.items():
                lines.append(f"{route_type} Routes ({len(routes)}):")
                
                for route in routes[:10]:  # Show top 10 of each type
                    options = f" (with options)" if route.get('options') else ""
                    lines.append(f"- {route['name']}{options}")
                
                if len(routes) > 10:
                    lines.append(f"  ... and {len(routes) - 10} more {route_type} routes")
                
                lines.append("")
        
        # Security Analysis
        if self.security_patterns:
            lines.append("=== SECURITY ANALYSIS ===")
            
            # Group by issue
            issues_by_type = defaultdict(list)
            for issue in self.security_patterns:
                issues_by_type[issue.get('issue', 'Unknown')].append(issue)
            
            for issue_type, issues in sorted(issues_by_type.items(), key=lambda x: len(x[1]), reverse=True):
                lines.append(f"{issue_type} ({len(issues)} occurrences):")
                
                for i, issue in enumerate(issues[:5]):  # Show first 5 examples
                    file_name = os.path.basename(issue['file_path'])
                    context = issue['context'][:100] + "..." if len(issue['context']) > 100 else issue['context']
                    lines.append(f"- In {file_name}: `{context}`")
                
                if len(issues) > 5:
                    lines.append(f"  ... and {len(issues) - 5} more occurrences")
                
                lines.append("")
        
        # File Summaries
        if self.file_summaries:
            lines.append("=== FILE SUMMARIES ===")
            
            for file_info in self.file_summaries:
                lines.append(f"=== {file_info['path']} ===")
                lines.extend(file_info['lines'])
                lines.append("")
                lines.append("-" * 80)
                lines.append("")
        
        return "\n".join(lines)

    def format_component_info(self, component: Dict[str, Any]) -> List[str]:
        """Format component information for the output"""
        lines = []
        lines.append(f"Component: {component['name']} ({component['type']})")
        
        if component.get('props'):
            lines.append("  Props:")
            for prop in component['props']:
                lines.append(f"    - {prop['name']}: {prop.get('type', 'any')}")
        
        if component.get('hooks_used'):
            lines.append("  Hooks used:")
            for hook in component['hooks_used']:
                lines.append(f"    - {hook}")
        
        if component.get('api_calls'):
            lines.append("  API calls:")
            for api_call in component['api_calls']:
                lines.append(f"    - {api_call}")
        
        if component.get('performance_issues'):
            lines.append("  Performance issues:")
            for issue in component['performance_issues']:
                lines.append(f"    - {issue}")
        
        if component.get('react_native_issues'):
            lines.append("  React Native issues:")
            for issue in component['react_native_issues']:
                lines.append(f"    - {issue}")
        
        return lines
    
    def format_hook_info(self, hook: Dict[str, Any]) -> List[str]:
        """Format hook information for the output"""
        lines = []
        lines.append(f"Hook: {hook['name']}")
        
        if hook.get('params'):
            lines.append("  Parameters:")
            for param in hook['params']:
                lines.append(f"    - {param['name']}: {param.get('type', 'any')}")
        
        if hook.get('returns'):
            lines.append("  Returns:")
            for ret in hook['returns']:
                lines.append(f"    - {ret}")
        
        if hook.get('uses_hooks'):
            lines.append("  Uses hooks:")
            for used_hook in hook['uses_hooks']:
                lines.append(f"    - {used_hook}")
        
        if hook.get('api_calls'):
            lines.append("  API calls:")
            for api_call in hook['api_calls']:
                lines.append(f"    - {api_call}")
        
        return lines
    
    def format_service_info(self, service: Dict[str, Any]) -> List[str]:
        """Format service information for the output"""
        lines = []
        singleton = " (Singleton)" if service.get('is_singleton') else ""
        parent = f" extends {service['parent_class']}" if service.get('parent_class') else ""
        lines.append(f"Service: {service['name']}{singleton}{parent}")
        
        if service.get('methods'):
            lines.append("  Methods:")
            for method in service['methods']:
                params = ', '.join([f"{p['name']}: {p['type']}" for p in method['params']])
                return_type = f" -> {method['return_type']}" if method.get('return_type') else ""
                lines.append(f"    - {method['name']}({params}){return_type}")
        
        if service.get('api_endpoints'):
            lines.append("  API Endpoints:")
            for endpoint in service['api_endpoints']:
                lines.append(f"    - {endpoint}")
        
        return lines
    
    def format_type_info(self, types: Dict[str, List[Dict[str, Any]]]) -> List[str]:
        """Format type information for the output"""
        lines = []
        
        if types.get('interfaces'):
            lines.append("  Interfaces:")
            for interface in types['interfaces']:
                parent = f" extends {interface['parent']}" if interface.get('parent') else ""
                lines.append(f"    - {interface['name']}{parent}")
                
                if interface.get('properties'):
                    for prop in interface['properties']:
                        lines.append(f"      - {prop['name']}: {prop['type']}")
        
        if types.get('types'):
            lines.append("  Type Aliases:")
            for type_alias in types['types']:
                lines.append(f"    - {type_alias['name']} = {type_alias['definition']}")
        
        if types.get('enums'):
            lines.append("  Enums:")
            for enum in types['enums']:
                lines.append(f"    - {enum['name']}")
                
                if enum.get('values'):
                    for val in enum['values']:
                        value = f" = {val['value']}" if val.get('value') else ""
                        lines.append(f"      - {val['name']}{value}")
        
        return lines
    
    def format_navigation_info(self, navigation: List[Dict[str, Any]]) -> List[str]:
        """Format navigation information for the output"""
        lines = []
        
        for route in navigation:
            component_str = f" -> {route['component']}" if route.get('component') else ""
            lines.append(f"  Route: {route['name']}{component_str}")
        
        return lines
    
    def format_state_management_info(self, state_management: List[Dict[str, Any]]) -> List[str]:
        """Format state management information for the output"""
        lines = []
        
        # Group by type
        state_by_type = {}
        for state in state_management:
            if state['type'] not in state_by_type:
                state_by_type[state['type']] = []
            state_by_type[state['type']].append(state)
        
        for state_type, states in state_by_type.items():
            lines.append(f"  {state_type.replace('_', ' ').title()}:")
            for state in states:
                lines.append(f"    - {state['name']}")
        
        return lines
    
    def format_database_schema(self, schema: Dict[str, Any]) -> List[str]:
        """Format database schema information for the output"""
        lines = []
        
        for db_schema in schema.get('schemas', []):
            lines.append(f"  Table: {db_schema['table_name']}")
            
            # Columns
            lines.append("    Columns:")
            for column in db_schema['columns']:
                nullable = "NULL" if column.get('nullable', True) else "NOT NULL"
                default = f" DEFAULT {column['default']}" if 'default' in column else ""
                pk = " PRIMARY KEY" if column['name'] in db_schema['primary_keys'] else ""
                lines.append(f"      - {column['name']}: {column['type']} {nullable}{default}{pk}")
            
            # Primary Keys
            if db_schema['primary_keys']:
                lines.append("    Primary Keys:")
                for pk in db_schema['primary_keys']:
                    lines.append(f"      - {pk}")
            
            # Foreign Keys
            if db_schema['foreign_keys']:
                lines.append("    Foreign Keys:")
                for fk in db_schema['foreign_keys']:
                    lines.append(f"      - {fk['column']}  {fk['ref_table']}.{fk['ref_column']}")
            
            # Indices
            if db_schema['indices']:
                lines.append("    Indices:")
                for idx in db_schema['indices']:
                    unique = "UNIQUE " if idx['unique'] else ""
                    lines.append(f"      - {unique}INDEX {idx['name']} ({', '.join(idx['columns'])})")
        
        return lines

def main():
    """Main function to execute the script"""
    parser = argparse.ArgumentParser(description="Extract structured context from a React Native/TypeScript codebase")
    parser.add_argument("output_file", nargs="?", default="code_context.txt", 
                      help="Output file path (default: code_context.txt)")
    parser.add_argument("--root-dir", "-d", default=os.getcwd(),
                      help="Root directory to process (default: current directory)")
    parser.add_argument("--exclude", "-e", action="append", default=[],
                      help="Additional directories to exclude (can be used multiple times)")
    parser.add_argument("--include", "-i", action="append", default=[],
                      help="Additional directories to include (can be used multiple times)")
    parser.add_argument("--max-lines", "-m", type=int, default=DEFAULT_CONFIG["max_lines"],
                      help=f"Maximum number of lines in output (default: {DEFAULT_CONFIG['max_lines']})")
    parser.add_argument("--format", "-f", choices=["text", "json", "markdown", "html"], default="text",
                      help="Output format (default: text)")
    parser.add_argument("--analyze-performance", "-p", action="store_true",
                      help="Include performance analysis")
    parser.add_argument("--analyze-data-flow", "-df", action="store_true",
                      help="Include data flow analysis")
    parser.add_argument("--show-component-tree", "-t", action="store_true",
                      help="Include component hierarchy tree")
    parser.add_argument("--analyze-react-native", "-rn", action="store_true",
                      help="Include React Native specific analysis")
    
    args = parser.parse_args()
    
    # Create a copy of the default config
    config = DEFAULT_CONFIG.copy()
    
    # Update config with command-line args
    config["exclude_dirs"].extend(args.exclude)
    config["include_dirs"].extend(args.include)
    config["max_lines"] = args.max_lines
    config["analyze_performance"] = args.analyze_performance
    config["analyze_data_flow"] = args.analyze_data_flow
    config["show_component_tree"] = args.show_component_tree
    config["analyze_react_native"] = args.analyze_react_native
    
    try:
        extractor = CodeContextExtractor(config)
        extractor.extract_context(args.root_dir, args.output_file, format=args.format)
    except KeyboardInterrupt:
        print("\nExtraction stopped by user.")
    except Exception as e:
        print(f"Error during extraction: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()

================================================================================
File: package.json
================================================================================

{
  "name": "canovareactnativeapp",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.37.0",
    "@expo/vector-icons": "^14.0.4",
    "@react-native-async-storage/async-storage": "^1.23.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "commander": "^13.1.0",
    "expo": "~52.0.37",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.7",
    "expo-dev-client": "~5.0.12",
    "expo-device": "^7.0.2",
    "expo-file-system": "^18.0.12",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.0",
    "expo-linear-gradient": "~14.0.2",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.17",
    "expo-sharing": "^13.0.1",
    "expo-splash-screen": "^0.29.22",
    "expo-sqlite": "~15.1.2",
    "expo-status-bar": "~2.0.0",
    "expo-symbols": "~0.2.2",
    "expo-system-ui": "~4.0.8",
    "expo-web-browser": "~14.0.2",
    "install": "^0.13.0",
    "lucide-react": "^0.475.0",
    "papaparse": "^5.5.2",
    "parse": "^3.5.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-native": "^0.76.5",
    "react-native-base64": "^0.2.1",
    "react-native-ble-plx": "^3.5.0",
    "react-native-calendars": "^1.1310.0",
    "react-native-chart-kit": "^6.12.0",
    "react-native-dotenv": "^3.4.11",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.7",
    "react-native-safe-area-context": "^4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "^15.11.2",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5"
  },
  "devDependencies": {
    "@babel/core": "^7.26.9",
    "@babel/parser": "^7.26.10",
    "@babel/traverse": "^7.26.10",
    "@react-native-community/cli": "^15.1.3",
    "@types/jest": "^29.5.14",
    "@types/react": "~18.3.12",
    "@types/react-native-base64": "^0.2.2",
    "@types/react-test-renderer": "^18.3.1",
    "jest": "^29.7.0",
    "jest-expo": "~52.0.5",
    "react-test-renderer": "^18.3.1",
    "typescript": "^5.7.3"
  },
  "private": true
}


================================================================================
File: src/contexts/BluetoothContext.ts
================================================================================

import { createContext } from "react";
import { Alert, PermissionsAndroid, Platform } from "react-native";
import * as ExpoDevice from "expo-device";
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';
import base64 from "react-native-base64";
import { parseRawTimestamp } from "../utils/functions";

type ConnectedDevice = {
    device: Device;
    serviceUUID: string;
    characteristicUUID: string
}

export class BluetoothHandler {
    private manager: BleManager;
    private connectedDevice: ConnectedDevice | null;
    // Update callback signature to include rawTimestamp
    private onDataCallback: ((rawTimestamp: string, timestamp: string, duration: number) => void) | null = null;

    constructor() {
        this.manager = new BleManager();
        this.connectedDevice = null;
    }

    // Update the expected callback signature
    public setOnDataCallback(callback: (rawTimestamp: string, timestamp: string, duration: number) => void): void {
        this.onDataCallback = callback;
    }

    public async connectToDevice(deviceId: string) {
        if (this.connectedDevice !== null) {
            // If we already have a connected device, we should:
            // 1. Check if it's the same device - if so, just return
            // 2. If it's a different device, disconnect from the current one first
            if (this.connectedDevice.device.id === deviceId) {
                console.log("Already connected to this device");
                return;
            }
            
            console.log("Disconnecting from current device before connecting to new one");
            this.disconnectFromDevice(this.connectedDevice.device);
            this.connectedDevice = null;
        }
        
        try {
            const deviceConnection: Device = await this.manager.connectToDevice(deviceId);
            await deviceConnection.discoverAllServicesAndCharacteristics();
            const services = await deviceConnection.services();
            if (services.length !== 1) {
                throw Error("Bad number of services");
            }

            const service = services[0];
            const characteristics = await service.characteristics();
            if (characteristics.length !== 1) {
                throw Error("Bad number of characteristics");
            }
            const characteristic = characteristics[0];
            this.connectedDevice = {
                device: deviceConnection,
                serviceUUID: service.uuid,
                characteristicUUID: characteristic.uuid
            }

        } catch (error) {
            console.error('Error discovering services/characteristics:', error);
            throw error; // Re-throw to allow caller to handle the error
        } finally {
            this.manager.stopDeviceScan();
        }
    }

    public disconnectFromDevice(connectedDevice: Device) {
        if (connectedDevice) {
            this.manager.cancelDeviceConnection(connectedDevice.id);
            if (this.connectedDevice?.device.id === connectedDevice.id) {
                this.connectedDevice = null;
            }
        }
    }

    /*
     * This function starts listening for data on the connected device
     */
    public streamOnConnectedDevice() {
        if (this.connectedDevice === null) {
            throw Error("Tried to stream with no device connected");
        } 
        
        // Sync data
        this.sendCurrentTimestamp()
        this.connectedDevice.device.monitorCharacteristicForService(
            this.connectedDevice.serviceUUID,
            this.connectedDevice.characteristicUUID,
            this.handleBluetoothConnection.bind(this)
        );
    }

    /* 
     * This function encapsulates all logic relating to listening to on the bluetooth conneciton
     */
    private handleBluetoothConnection(error: BleError | null, characteristic: Characteristic | null) {
        if (error) {
          console.log("Stream error:", error);
          return; // Return void instead of -1
        } else if (!characteristic?.value) {
          console.log("No data was received");
          return; // Return void instead of -1
        }

        try {
            const rawData: string[] = base64.decode(characteristic.value).split(';');
            // Ensure we handle cases where split might not produce enough parts
            if (rawData.length < 2) {
                console.error("Received malformed data:", rawData);
                return;
            }
            const rawTimestamp: string = rawData[0]; //Tuesday, March 25 2025 21:40:12
            const duration: number = parseFloat(rawData[1])*1000; // 0.17
            
            if (isNaN(duration) || duration <= 0) {
                console.error(`[BluetoothContext] Invalid duration value: ${rawData[1]}`);
                return;
            }
            
            console.log(`[BluetoothContext] Raw timestamp received: ${rawTimestamp}`);
            const timestamp: string = parseRawTimestamp(rawTimestamp);
            console.log(`[BluetoothContext] Parsed ISO timestamp: ${timestamp}`);
            
            // Instead of directly calling databaseManager, use the callback
            if (this.onDataCallback) {
                // Pass rawTimestamp along with parsed timestamp and duration
                this.onDataCallback(rawTimestamp, timestamp, duration);
            } else {
                console.error("No data callback set to handle bong hit data");
                // Fallback alert if no callback is set
                Alert.alert(`(No Callback) Timestamp: ${rawTimestamp}\n Duration: ${duration}ms`);
            }
        } catch (error) {
            console.error('[BluetoothContext] Error processing Bluetooth data:', error);
            Alert.alert('Error', 'Failed to process data from device');
        }
    }

    /*
     * This function generates the current timestamp which will be used to sync the Trak+ to an accurate timestamp on connection.
     */
    private async sendCurrentTimestamp() {
        if (!this.connectedDevice) {
            throw new Error("Tried to send timestamp to device, but connection not found");
        }
        try {
            const timestamp = Math.floor(Date.now() / 1000); // Seconds, not milliseconds
            const gmtOffset = new Date().getTimezoneOffset() * 60;  // Offset in seconds (e.g., GMT-5 -> -18000)
            const base64Timestamp = base64.encode( `${timestamp},${gmtOffset}`)

            // Write data to the characteristic
            await this.manager.writeCharacteristicWithResponseForDevice(
              this.connectedDevice.device.id,
              this.connectedDevice.serviceUUID,
              this.connectedDevice.characteristicUUID,
              base64Timestamp
            );
      
            console.log(`Sent: Timestamp ${timestamp}, GMT Offset ${gmtOffset}`);
            return true;
          } catch (error) {
            console.error('Error sending data:', error);
            return false;
          }
    }

    public getBLEManager(): BleManager {
        return this.manager;
    }

    public getConnectedDevice(): Device | undefined {
        return this.connectedDevice?.device;
    }

    /*
     * Requests bluetooth permissions, accounting for platform differences
     */
    private async requestPermissions() {
        if (Platform.OS === "android") {
            if ((ExpoDevice.platformApiLevel ?? -1) < 31) {
                // Android version below 31
                const granted = await PermissionsAndroid.request(
                    PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
                    {
                        title: "Location Permission",
                        message: "Bluetooth Low Energy requires Location",
                        buttonPositive: "OK",
                    }
                );
                return granted === PermissionsAndroid.RESULTS.GRANTED;
            } else {
                // Android version above 31
                const isAndroid31PermissionsGranted = await this.requestAndroid31Permissions();

                return isAndroid31PermissionsGranted;
            }
        } else {
            //ios
            return true;
        }
    }

    private async requestAndroid31Permissions() {
        const bluetoothScanPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_SCAN,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );
        const bluetoothConnectPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_CONNECT,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );
        const fineLocationPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );

        return (
            bluetoothScanPermission === "granted" &&
            bluetoothConnectPermission === "granted" &&
            fineLocationPermission === "granted"
        );
    }
}

export const BluetoothContext = createContext<BluetoothHandler | undefined>(undefined);


================================================================================
File: src/DatabaseManager.ts
================================================================================

// File: src/DatabaseManager.ts
// Refactored DatabaseManager that focuses on database connection management and migrations.

import AsyncStorage from "@react-native-async-storage/async-storage";
import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import {
  BONG_HITS_DATABASE_NAME,
  STRAINS_DATABASE_NAME,
  SAMPLE_STRAINS
} from "./constants";
import { migrations } from "./migrations";
import { getWeeklyStatsQuery, getMonthlyStatsQuery, getTimeDistributionQuery, getUsageStatsQuery, getDateRangeFilter } from "./utils/SqlTemplates";

// Export constants for use by other modules
export const DB_VERSION_KEY = "dbVersion";
export const CURRENT_DB_VERSION = 1; // Keeping at version 1 since there's no v2 migration
export const SAFETY_DB_NAME = "SafetyRecords";
export const ACHIEVEMENTS_DB_NAME = "achievements.db";

// Define the pagination parameters interface
export interface PaginationParams {
  page: number;
  limit: number;
}

// Define the strain search filters interface
export interface StrainSearchFilters {
  geneticType?: string;
  effects?: string[];
  sort?: 'rating' | 'name' | 'thc';
}

/**
 * Helper function to format weekly stats results
 */
function formatWeeklyResults(results: any[]): any[] {
  // Format results for day names
  const dayMapping: { [key: string]: string } = {
    '0': 'Sun', '1': 'Mon', '2': 'Tue', '3': 'Wed', 
    '4': 'Thu', '5': 'Fri', '6': 'Sat'
  };
  
  // If no results, return zero values for each day
  if (!results || results.length === 0) {
    console.log('[DatabaseManager] No weekly data found, returning zeros');
    return [
      { label: 'Sun', value: 0 },
      { label: 'Mon', value: 0 },
      { label: 'Tue', value: 0 },
      { label: 'Wed', value: 0 },
      { label: 'Thu', value: 0 },
      { label: 'Fri', value: 0 },
      { label: 'Sat', value: 0 }
    ];
  }
  
  console.log('[DatabaseManager] Formatting weekly data:', JSON.stringify(results));
  
  // Convert the results to the expected format
  const formattedResults = results.map((row: any) => ({
    label: dayMapping[row.day_of_week] || 'Unknown',
    value: row.count || 0,
    // Include the original day number for sorting
    dayNumber: parseInt(row.day_of_week, 10)
  }));
  
  // Make sure all days are represented
  const dayValues = Object.keys(dayMapping).sort().map(day => dayMapping[day]);
  const dataByDay = new Map(formattedResults.map(item => [item.label, item]));
  
  // Create array with all days in order, using values from results when available
  const orderedData = dayValues.map(day => 
    dataByDay.get(day) || { label: day, value: 0 }
  );
  
  return orderedData;
}

/**
 * Helper function to format monthly stats results
 */
function formatMonthlyResults(results: any[]): any[] {
  // Month name mapping
  const monthMapping: { [key: string]: string } = {
    '01': 'Jan', '02': 'Feb', '03': 'Mar', '04': 'Apr', 
    '05': 'May', '06': 'Jun', '07': 'Jul', '08': 'Aug',
    '09': 'Sep', '10': 'Oct', '11': 'Nov', '12': 'Dec',
    // Add single-digit versions for robustness
    '1': 'Jan', '2': 'Feb', '3': 'Mar', '4': 'Apr',
    '5': 'May', '6': 'Jun', '7': 'Jul', '8': 'Aug',
    '9': 'Sep'
  };
  
  // If no results, return zero values for each month
  if (!results || results.length === 0) {
    console.log('[DatabaseManager] No monthly data found, returning zeros');
    return Object.entries(monthMapping)
      .filter(([key]) => key.length === 2) // Only use the two-digit keys 
      .map(([_, month]) => ({
        label: month,
        value: 0
      }));
  }
  
  console.log('[DatabaseManager] Formatting monthly data:', JSON.stringify(results));
  
  // Convert the results to the expected format
  const formattedResults = results.map((row: any) => {
    // Ensure month is properly padded with leading zero if needed
    const monthKey = row.month?.length === 1 ? `0${row.month}` : row.month;
    return {
      label: monthMapping[monthKey] || 'Unknown',
      value: row.count || 0,
      // Store numeric month for sorting
      monthNum: parseInt(row.month, 10)
    };
  });
  
  // Make sure all months are represented (use two-digit keys)
  const monthValues = Object.entries(monthMapping)
    .filter(([key]) => key.length === 2)
    .map(([_, label]) => label);
  
  const dataByMonth = new Map(formattedResults.map(item => [item.label, item]));
  
  // Create array with all months, using values from results when available
  return monthValues.map(month => 
    dataByMonth.get(month) || { label: month, value: 0 }
  );
}

/**
 * DatabaseManager: Handles database connections and migrations
 */
export class DatabaseManager {
  private databaseConnections: Map<string, SQLiteDatabase> = new Map();
  private initialized: boolean = false;
  private initializationPromise: Promise<void> | null = null;
  private static instance: DatabaseManager;

  /**
   * Get the singleton instance of DatabaseManager
   */
  public static getInstance(): DatabaseManager {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new DatabaseManager();
    }
    return DatabaseManager.instance;
  }

  /**
   * Constructor for DatabaseManager
   */
  public constructor() {}

  /**
   * Initializes all databases and manages migrations
   */
  public async initialize(options: { forceCleanup?: boolean } = {}): Promise<void> {
    // If forced cleanup is requested, close existing connections first
    if (options.forceCleanup) {
      await this.cleanup();
      this.initialized = false; // Reset initialized state after cleanup
    }

    // If already initialized, return immediately
    if (this.initialized) {
      return;
    }
    
    // If initialization is in progress, wait for it to complete
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    
    console.info('[DatabaseManager] Initializing databases...');
    
    // Create a promise for initialization
    this.initializationPromise = this.doInitialize().finally(() => {
      this.initializationPromise = null;
    });
    
    return this.initializationPromise;
  }

  /**
   * Internal method to perform actual initialization logic
   */
  private async doInitialize(): Promise<void> {
    try {
      console.log('[DatabaseManager] Starting database initialization...');
      
      // Get current DB version
      const storedVersion = parseInt(await AsyncStorage.getItem(DB_VERSION_KEY) || '0');
      
      // Check if we need to update/initialize
      if (storedVersion < CURRENT_DB_VERSION) {
        await this.runMigrations(storedVersion);
        
        // Update the stored version
        await AsyncStorage.setItem(DB_VERSION_KEY, CURRENT_DB_VERSION.toString());
        console.log(`[DatabaseManager] Database upgraded to version ${CURRENT_DB_VERSION}`);
      } else {
        console.log('[DatabaseManager] Database already at current version');
      }
      
      this.initialized = true;
      console.log('[DatabaseManager] Database initialization successful');
    } catch (error) {
      this.initialized = false; // Ensure state reflects failure
      console.error('[DatabaseManager] Error during database initialization:', error);
      throw error;
    }
  }

  /**
   * Run migrations from the current version to the latest version
   */
  private async runMigrations(currentVersion: number): Promise<void> {
    console.log('[DatabaseManager] Starting migrations from version', currentVersion);
    
    // Use a consistent DB for migration tracking
    const migrationTrackingDb = await this.getDatabase(BONG_HITS_DATABASE_NAME);

    await migrationTrackingDb.execAsync(
      `CREATE TABLE IF NOT EXISTS migrations (
        version INTEGER PRIMARY KEY,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`
    );
    
    const appliedMigrations = await migrationTrackingDb.getAllAsync<{ version: number }>(
      'SELECT version FROM migrations ORDER BY version ASC'
    );
    
    const appliedVersions = appliedMigrations.map(m => m.version);
    
    for (let v = currentVersion + 1; v <= CURRENT_DB_VERSION; v++) {
      if (appliedVersions.includes(v)) continue;

      console.log(`[DatabaseManager] Applying migration version ${v}`);
      try {
        await migrationTrackingDb.execAsync('BEGIN TRANSACTION');

        // Use the migration registry instead of dynamic require
        if (migrations[v] && typeof migrations[v].up === 'function') {
          await migrations[v].up(migrationTrackingDb);
        } else {
          throw new Error(`Migration script v${v} is invalid or missing 'up' function.`);
        }

        await migrationTrackingDb.runAsync('INSERT INTO migrations (version) VALUES (?)', [v]);
        await migrationTrackingDb.execAsync('COMMIT');
        console.log(`[DatabaseManager] Migration version ${v} applied successfully`);
      } catch (migrationError) {
        console.error(`[DatabaseManager] Migration version ${v} failed:`, migrationError);
        try { 
          await migrationTrackingDb.execAsync('ROLLBACK'); 
        } catch (rbError) { 
          console.error('Rollback failed:', rbError); 
        }
        throw migrationError; // Stop further migrations
      }
    }
    console.log('[DatabaseManager] All migrations applied successfully');
  }

  /**
   * Ensures the database manager has been initialized
   */
  public async ensureInitialized(): Promise<void> {
    if (this.initialized) {
      return;
    }
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    // Should ideally be called early in app lifecycle, but this handles lazy init
    console.warn('[DatabaseManager] ensureInitialized called before explicit initialization. Initializing now.');
    return this.initialize();
  }

  /**
   * Gets a database connection, opening it if necessary
   */
  public async getDatabase(dbName: string): Promise<SQLiteDatabase> {
    if (this.databaseConnections.has(dbName)) {
      const db = this.databaseConnections.get(dbName)!;
      // Basic check if connection might be closed
      try {
        await db.getFirstAsync('SELECT 1');
        return db;
      } catch (e) {
        console.warn(`[DatabaseManager] Connection test failed for ${dbName}, reopening.`);
        this.databaseConnections.delete(dbName);
      }
    }

    try {
      console.log(`[DatabaseManager] Opening database: ${dbName}`);
      const db = await openDatabaseAsync(dbName);
      
      // Set WAL mode immediately after opening, BEFORE any transactions start
      try {
        await db.execAsync('PRAGMA journal_mode = WAL;');
        console.log(`[DatabaseManager] Set journal mode to WAL for ${dbName}`);
      } catch (walError) {
        // WAL mode might fail in some specific scenarios (e.g., certain file systems)
        // Log the error but don't necessarily fail the connection
        console.warn(`[DatabaseManager] Failed to set WAL mode for ${dbName}:`, walError);
      }
      
      this.databaseConnections.set(dbName, db);
      return db;
    } catch (error) {
      console.error(`[DatabaseManager] Error opening database ${dbName}:`, error);
      throw error;
    }
  }

  /**
   * Closes all open database connections
   */
  public async cleanup(): Promise<void> {
    console.log('[DatabaseManager] Closing all cached database connections...');
    const closePromises = Array.from(this.databaseConnections.entries())
      .map(async ([name, db]) => {
        try {
          await db.closeAsync();
          console.log(`[DatabaseManager] Closed database: ${name}`);
        } catch (closeError) {
          console.error(`[DatabaseManager] Error closing database ${name}:`, closeError);
        }
      });
    
    await Promise.all(closePromises);
    this.databaseConnections.clear();
    this.initialized = false;
    console.log('[DatabaseManager] All cached database connections closed.');
  }

  /**
   * Gets weekly stats for data visualization
   * @param startDate Optional ISO date string for the start of the date range 
   * @param endDate Optional ISO date string for the end of the date range
   */
  public async getWeeklyStats(startDate?: string, endDate?: string) {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      console.log(`[DatabaseManager] Fetching weekly stats from ${startDate || 'all'} to ${endDate || 'now'}`);
      
      // Use the SQL template with date filtering
      const templateQuery = getWeeklyStatsQuery(BONG_HITS_DATABASE_NAME);
      const { clause, params } = getDateRangeFilter(startDate, endDate);
      const finalQuery = templateQuery.replace('-- DATE FILTER ADDED EXTERNALLY', clause);
      
      console.log(`[DatabaseManager] Weekly Stats Query: ${finalQuery}, Params: ${JSON.stringify(params)}`);
      const results = await db.getAllAsync(finalQuery, params);
      
      // Process the results to get the proper format for charts
      const formattedResults = formatWeeklyResults(results);
      
      console.log(`[DatabaseManager] Formatting weekly data: ${JSON.stringify(results)} -> Formatted: ${JSON.stringify(formattedResults)}`);
      
      return {
        success: true,
        data: formattedResults
      };
    } catch (error) {
      console.error('[DatabaseManager] Error getting weekly stats:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        data: null
      };
    }
  }

  /**
   * Gets monthly stats for data visualization
   * @param startDate Optional ISO date string for the start of the date range 
   * @param endDate Optional ISO date string for the end of the date range
   */
  public async getMonthlyStats(startDate?: string, endDate?: string) {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      console.log(`[DatabaseManager] Fetching monthly stats from ${startDate || 'all'} to ${endDate || 'now'}`);
      
      // Use the SQL template with date filtering
      const templateQuery = getMonthlyStatsQuery(BONG_HITS_DATABASE_NAME);
      const { clause, params } = getDateRangeFilter(startDate, endDate);
      const finalQuery = templateQuery.replace('-- DATE FILTER ADDED EXTERNALLY', clause);
      
      console.log(`[DatabaseManager] Monthly Stats Query: ${finalQuery}, Params: ${JSON.stringify(params)}`);
      const results = await db.getAllAsync(finalQuery, params);
      
      // Format the results for the UI
      const formattedResults = formatMonthlyResults(results);
      
      console.log(`[DatabaseManager] Formatting monthly data: ${JSON.stringify(results)} -> Formatted: ${JSON.stringify(formattedResults)}`);
      
      return {
        success: true,
        data: formattedResults
      };
    } catch (error) {
      console.error('[DatabaseManager] Error getting monthly stats:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        data: null
      };
    }
  }

  /**
   * Gets usage statistics with date range filtering
   * @param startDate Optional ISO date string for the start of the date range 
   * @param endDate Optional ISO date string for the end of the date range
   */
  public async getUsageStats(startDate?: string, endDate?: string) {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      console.log(`[DatabaseManager] Fetching usage stats from ${startDate || 'all'} to ${endDate || 'now'}`);
      
      // Get usage statistics with date range
      const templateQuery = getUsageStatsQuery(BONG_HITS_DATABASE_NAME);
      const { clause, params } = getDateRangeFilter(startDate, endDate);
      const finalQuery = templateQuery.replace('-- DATE FILTER ADDED EXTERNALLY', clause);
      
      console.log(`[DatabaseManager] Usage Stats Query: ${finalQuery}, Params: ${JSON.stringify(params)}`);
      
      // Define the expected type for better TypeScript support
      interface UsageStatsResult {
        total_hits: number;
        active_days: number;
        avg_hits_per_active_day: number;
        avg_duration_ms: number;
        total_duration_ms: number;
        max_hits_in_day: number;
        min_hits_in_day: number;
        longest_hit: number;
        shortest_hit: number;
        most_active_hour: number;
        least_active_hour: number;
      }
      
      // Use type assertion to handle the database result
      const usageStats = await db.getFirstAsync(finalQuery, params) as UsageStatsResult | null;
      
      // No need to check for results - if the query returns no rows, we'll get empty data
      if (!usageStats) {
        return {
          success: true,
          data: {
            totalHits: 0,
            averageHitsPerDay: 0,
            peakDayHits: 0,
            lowestDayHits: 0,
            averageDuration: 0,
            totalDuration: 0,
            longestHit: 0,
            shortestHit: 0,
            mostActiveHour: 0,
            leastActiveHour: 0,
            averageHitsPerHour: 0,
            weekdayStats: null,
            consistency: 0
          }
        };
      }
      
      // Get weekday vs weekend stats with the same date range
      const weekdayStats = await this.getWeekdayStats(db, startDate, endDate);
      
      // Format the results
      const formattedResults = {
        totalHits: usageStats.total_hits || 0,
        averageHitsPerDay: usageStats.avg_hits_per_active_day || 0,
        peakDayHits: usageStats.max_hits_in_day || 0,
        lowestDayHits: usageStats.min_hits_in_day || 0, // Updated to use min_hits_in_day
        averageDuration: usageStats.avg_duration_ms || 0,
        totalDuration: usageStats.total_duration_ms || 0,
        longestHit: usageStats.longest_hit || 0, // Updated to use longest_hit
        shortestHit: usageStats.shortest_hit || 0, // Updated to use shortest_hit
        mostActiveHour: usageStats.most_active_hour || 0, // Updated to use most_active_hour
        leastActiveHour: usageStats.least_active_hour || 0, // Updated to use least_active_hour
        averageHitsPerHour: 0, // Not calculated in the query
        weekdayStats: weekdayStats,
        consistency: 0 // This needs to be calculated
      };
      
      console.log(`[DatabaseManager] Usage Stats Result: ${JSON.stringify(usageStats)} -> Formatted: ${JSON.stringify(formattedResults)}`);
      
      return {
        success: true,
        data: formattedResults
      };
    } catch (error) {
      console.error('[DatabaseManager] Error getting usage stats:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        data: null
      };
    }
  }

  /**
   * Gets weekday vs weekend statistics
   */
  private async getWeekdayStats(db: SQLiteDatabase, startDate?: string, endDate?: string) {
    // Create SQL with date filtering
    const { clause, params } = getDateRangeFilter(startDate, endDate);
    
    const query = `
      WITH NormalizedData AS (
        SELECT
          strftime('%w', timestamp, 'utc') as weekday,
          strftime('%Y-%m-%d', timestamp, 'utc') as date_str
        FROM ${BONG_HITS_DATABASE_NAME}
        ${clause}
      )
      SELECT
        SUM(CASE WHEN weekday IN ('1','2','3','4','5') THEN 1 ELSE 0 END) as weekday_hits,
        SUM(CASE WHEN weekday IN ('0','6') THEN 1 ELSE 0 END) as weekend_hits,
        COUNT(DISTINCT CASE WHEN weekday IN ('1','2','3','4','5') 
          THEN date_str END) as weekday_days,
        COUNT(DISTINCT CASE WHEN weekday IN ('0','6') 
          THEN date_str END) as weekend_days
      FROM NormalizedData
    `;
    
    try {
      console.log(`[DatabaseManager] Weekday Stats Query: ${query}, Params: ${JSON.stringify(params)}`);
      
      // Define type for better TypeScript support
      interface WeekdayStatsResult {
        weekday_hits: number;
        weekend_hits: number;
        weekday_days: number;
        weekend_days: number;
      }
      
      // Use type assertion to handle the database result
      const result = await db.getFirstAsync(query, params) as WeekdayStatsResult | null;
      
      if (!result) {
        return {
          weekday: { total: 0, avg: 0 },
          weekend: { total: 0, avg: 0 }
        };
      }
      
      const weekdayAvg = result.weekday_days > 0 ? result.weekday_hits / result.weekday_days : 0;
      const weekendAvg = result.weekend_days > 0 ? result.weekend_hits / result.weekend_days : 0;
      
      return {
        weekday: { total: result.weekday_hits || 0, avg: weekdayAvg },
        weekend: { total: result.weekend_hits || 0, avg: weekendAvg }
      };
    } catch (error) {
      console.error('[DatabaseManager] Error getting weekday stats:', error);
      return {
        weekday: { total: 0, avg: 0 },
        weekend: { total: 0, avg: 0 }
      };
    }
  }

  /**
   * Gets time distribution statistics based on date range
   * @param startDate Optional ISO date string for the start of the date range 
   * @param endDate Optional ISO date string for the end of the date range
   */
  public async getTimeDistribution(startDate?: string, endDate?: string) {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      console.log(`[DatabaseManager] Fetching time distribution from ${startDate || 'all'} to ${endDate || 'now'}`);
      
      // Use the SQL template with date filtering
      const templateQuery = getTimeDistributionQuery(BONG_HITS_DATABASE_NAME);
      const { clause, params } = getDateRangeFilter(startDate, endDate);
      const finalQuery = templateQuery.replace('-- DATE FILTER ADDED EXTERNALLY', clause);
      
      console.log(`[DatabaseManager] Time Distribution Query: ${finalQuery}, Params: ${JSON.stringify(params)}`);
      
      // Define the expected result type
      interface TimeDistributionResult {
        morning: number;
        afternoon: number;
        evening: number;
        night: number;
      }
      
      const result = await db.getFirstAsync(finalQuery, params) as TimeDistributionResult | null;
      
      console.log(`[DatabaseManager] Time Distribution Result: ${JSON.stringify(result)}`);
      
      // If no data, return zeros
      if (!result) {
        return {
          success: true,
          data: {
            morning: 0,
            afternoon: 0, 
            evening: 0,
            night: 0
          }
        };
      }
      
      return {
        success: true,
        data: {
          morning: result.morning || 0,
          afternoon: result.afternoon || 0,
          evening: result.evening || 0,
          night: result.night || 0
        }
      };
    } catch (error) {
      console.error('[DatabaseManager] Error getting time distribution:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        data: null
      };
    }
  }

  /**
   * Gets all bong hit logs
   */
  public async getAllBongHitLogs() {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      const results = await db.getAllAsync(`
        SELECT 
          timestamp,
          duration_ms
        FROM ${BONG_HITS_DATABASE_NAME}
        ORDER BY timestamp DESC
      `);
      
      return {
        success: true,
        data: results
      };
    } catch (error) {
      console.error('[DatabaseManager] Error getting bong hit logs:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Gets saved devices
   */
  public async getSavedDevices() {
    try {
      await this.ensureInitialized();
      // For now, returning empty data
      return {
        success: true,
        data: []
      };
    } catch (error) {
      console.error('[DatabaseManager] Error getting saved devices:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Gets popular strains
   */
  public async getPopularStrains() {
    try {
      await this.ensureInitialized();
      // Use the imported sample strains
      
      // Add IDs to the strains
      const popularStrains = SAMPLE_STRAINS.map((strain, index) => ({
        ...strain,
        id: index + 1 // Add sequential IDs starting from 1
      }));
      
      return popularStrains;
    } catch (error) {
      console.error('[DatabaseManager] Error getting popular strains:', error);
      return [];
    }
  }

  /**
   * Search strains based on criteria
   */
  public async searchStrains(
    query: string,
    filters: StrainSearchFilters = {},
    pagination: PaginationParams = { page: 1, limit: 10 }
  ) {
    try {
      await this.ensureInitialized();
      
      // Add IDs to the strains
      const strainsWithIds = SAMPLE_STRAINS.map((strain, index) => ({
        ...strain,
        id: index + 1
      }));
      
      // Filter by query if provided
      let filteredStrains = strainsWithIds;
      if (query) {
        const lowerQuery = query.toLowerCase();
        filteredStrains = filteredStrains.filter(strain => 
          strain.name.toLowerCase().includes(lowerQuery) || 
          strain.overview.toLowerCase().includes(lowerQuery)
        );
      }
      
      // Apply genetic type filter if specified
      if (filters.geneticType) {
        filteredStrains = filteredStrains.filter(strain => 
          strain.genetic_type.includes(filters.geneticType!)
        );
      }
      
      // Apply effects filter if provided - using AND logic
      if (filters.effects && filters.effects.length > 0) {
        filteredStrains = filteredStrains.filter(strain => {
          if (!strain.effects) return false;
          // Check if ALL of the filter effects are included in the strain effects
          return filters.effects!.every((effect: string) => 
            strain.effects.toLowerCase().includes(effect.toLowerCase())
          );
        });
      }
      
      // Apply sort - default is rating in descending order
      filteredStrains.sort((a, b) => b.combined_rating - a.combined_rating); // Default sort
      
      if (filters.sort) {
        switch(filters.sort) {
          case 'name':
            filteredStrains.sort((a, b) => a.name.localeCompare(b.name));
            break;
          case 'thc':
            filteredStrains.sort((a, b) => b.thc_rating - a.thc_rating);
            break;
          // 'rating' is already handled by default above
        }
      }
      
      // Calculate pagination
      const total = filteredStrains.length;
      const totalPages = Math.ceil(total / pagination.limit);
      const startIndex = (pagination.page - 1) * pagination.limit;
      const endIndex = startIndex + pagination.limit;
      const paginatedStrains = filteredStrains.slice(startIndex, endIndex);
      
      return {
        data: paginatedStrains,
        total,
        currentPage: pagination.page,
        totalPages,
        hasMore: pagination.page < totalPages
      };
      
    } catch (error) {
      console.error('[DatabaseManager] Error searching strains:', error);
      return {
        data: [],
        total: 0,
        currentPage: 1,
        totalPages: 0,
        hasMore: false
      };
    }
  }
  
  /**
   * Gets strain categories
   */
  public async getStrainCategories() {
    try {
      await this.ensureInitialized();
      
      // Count strains by genetic type
      const indicaCount = SAMPLE_STRAINS.filter(strain => 
        strain.genetic_type.includes('Indica')).length;
      
      const sativaCount = SAMPLE_STRAINS.filter(strain => 
        strain.genetic_type.includes('Sativa')).length;
      
      const hybridCount = SAMPLE_STRAINS.filter(strain => 
        strain.genetic_type.includes('Hybrid')).length;
      
      const total = SAMPLE_STRAINS.length;
      
      return {
        'Sativa': sativaCount,
        'Indica': indicaCount,
        'Hybrid': hybridCount,
        'Total': total
      };
    } catch (error) {
      console.error('[DatabaseManager] Error getting strain categories:', error);
      return {};
    }
  }
  
  /**
   * Gets strain by ID
   */
  public async getStrainById(id: number) {
    try {
      await this.ensureInitialized();
      
      // Find the strain with the matching ID (arrays are 0-based but we use 1-based IDs)
      if (id > 0 && id <= SAMPLE_STRAINS.length) {
        return {
          ...SAMPLE_STRAINS[id - 1],
          id
        };
      }
      
      return null;
    } catch (error) {
      console.error('[DatabaseManager] Error getting strain by ID:', error);
      return null;
    }
  }
  
  /**
   * Gets related strains
   */
  public async getRelatedStrains(strain: any) {
    try {
      await this.ensureInitialized();
      
      // Get strains with the same genetic type
      const strainsWithIds = SAMPLE_STRAINS.map((s, index) => ({
        ...s,
        id: index + 1
      }));
      
      // Filter to get related strains (same genetic type, excluding the original strain)
      const relatedStrains = strainsWithIds.filter(s => 
        s.genetic_type === strain.genetic_type && 
        s.name !== strain.name
      );
      
      // Return the first few related strains
      return relatedStrains.slice(0, 3);
    } catch (error) {
      console.error('[DatabaseManager] Error getting related strains:', error);
      return [];
    }
  }

  /**
   * Validates a recommendation request for safety concerns
   * @param request The recommendation request to validate
   * @returns SafetyValidationResult indicating if the request is valid
   */
  public async validateRecommendationRequest(request: any): Promise<any> {
    try {
      await this.ensureInitialized();
      
      // Basic safety check - in a real implementation, this would check against a database
      // For now, we'll just return a valid result to allow the application to function
      return {
        valid: true,
        safetyFlags: [],
        warningLevel: 'info'
      };
    } catch (error) {
      console.error('[DatabaseManager] Error validating recommendation request:', error);
      // In case of error, return a valid result with a warning
      return {
        valid: true,
        safetyFlags: ['Safety validation could not be completed'],
        warningLevel: 'warning'
      };
    }
  }

  /**
   * Process a recommendation response for safety
   * @param response The raw recommendation response
   * @param userProfile The user profile
   * @param journalEntries Recent journal entries
   * @returns Processed recommendation response
   */
  public async processRecommendationResponse(response: any, userProfile: any, journalEntries: any[] = []): Promise<any> {
    try {
      await this.ensureInitialized();
      
      // In a real implementation, this would process the response through safety checks
      // For now, we'll just return the response as is
      return response;
    } catch (error) {
      console.error('[DatabaseManager] Error processing recommendation response:', error);
      return response;
    }
  }

  /**
   * Get safety history for a user
   * @param userId The user ID
   * @returns Array of safety records
   */
  public async getSafetyHistory(userId: string): Promise<any[]> {
    try {
      await this.ensureInitialized();
      
      // For now, return an empty array
      return [];
    } catch (error) {
      console.error('[DatabaseManager] Error getting safety history:', error);
      return [];
    }
  }
}

// Export a singleton instance
export const databaseManager = DatabaseManager.getInstance(); 

================================================================================
File: src/dbchecker/dbValidator.ts
================================================================================

import { databaseManager } from "../DatabaseManager";
import { 
  BONG_HITS_DATABASE_NAME, 
  STRAINS_DATABASE_NAME 
} from "../constants";
import { DatabaseResponse, Strain } from "../types";

/**
 * DbValidator - Utility to validate the database implementation
 * Runs a series of checks to verify that everything is working correctly
 */
export class DbValidator {
  public static async validateDatabaseSetup(): Promise<ValidationResult> {
    console.log('[DbValidator] Starting database validation...');
    const results: ValidationResult = {
      success: true,
      errors: [],
      warnings: [],
      componentResults: {},
    };

    // Validate database manager
    try {
      await this.validateDatabaseManager(results);
    } catch (error) {
      results.success = false;
      results.errors.push(`DatabaseManager validation failed: ${error instanceof Error ? error.message : String(error)}`);
    }

    console.log('[DbValidator] Database validation completed.');
    console.log('[DbValidator] Success:', results.success);
    
    if (results.errors.length) {
      console.error('[DbValidator] Errors:', results.errors);
    }
    
    if (results.warnings.length) {
      console.warn('[DbValidator] Warnings:', results.warnings);
    }

    return results;
  }

  private static async validateDatabaseManager(results: ValidationResult): Promise<void> {
    console.log('[DbValidator] Validating DatabaseManager...');
    
    // Check if we can initialize
    await databaseManager.ensureInitialized();
    
    // Check if database connections work
    const bongHitsDb = await databaseManager.getDatabase(BONG_HITS_DATABASE_NAME);
    const strainsDb = await databaseManager.getDatabase(STRAINS_DATABASE_NAME);
    
    // Validate BongHits table exists
    try {
      const bongHitsTableInfo = await bongHitsDb.getAllAsync('PRAGMA table_info(bong_hits)');
      results.componentResults.bongHitsTableExists = bongHitsTableInfo.length > 0;
      
      if (!results.componentResults.bongHitsTableExists) {
        results.warnings.push('BongHits table does not exist');
      }
    } catch (error) {
      results.componentResults.bongHitsTableExists = false;
      results.warnings.push(`Error checking BongHits table: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Validate Strains table exists
    try {
      const strainsTableInfo = await strainsDb.getAllAsync('PRAGMA table_info(strains)');
      results.componentResults.strainsTableExists = strainsTableInfo.length > 0;
      
      if (!results.componentResults.strainsTableExists) {
        results.warnings.push('Strains table does not exist');
      }
    } catch (error) {
      results.componentResults.strainsTableExists = false;
      results.warnings.push(`Error checking Strains table: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if transactions work
    try {
      await databaseManager.executeTransactionByName(BONG_HITS_DATABASE_NAME, async (db) => {
        const result = await db.getAllAsync('SELECT 1 as test');
        return result;
      });
      results.componentResults.transactionsWork = true;
    } catch (error) {
      results.componentResults.transactionsWork = false;
      results.errors.push(`Transactions failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can get weekly stats
    try {
      const weeklyStats = await databaseManager.getWeeklyStats();
      results.componentResults.weeklyStatsWork = weeklyStats.success;
      
      if (!weeklyStats.success) {
        results.warnings.push(`Weekly stats failed: ${weeklyStats.error}`);
      }
    } catch (error) {
      results.componentResults.weeklyStatsWork = false;
      results.warnings.push(`Weekly stats failed with exception: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can get strain data
    try {
      const popularStrains: Strain[] = await databaseManager.getPopularStrains(1);
      if (popularStrains && popularStrains.length > 0) {
        results.componentResults.strainsDataWorks = true;
      } else {
        results.componentResults.strainsDataWorks = false;
        results.warnings.push('No strain data returned');
      }
    } catch (error) {
      results.componentResults.strainsDataWorks = false;
      results.warnings.push(`Strain data retrieval failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can perform AsyncStorage operations
    try {
      const testKey = 'dbValidator_test';
      const testValue = { test: true, timestamp: Date.now() };
      
      await databaseManager.setValue(testKey, testValue);
      const retrievedValue = await databaseManager.getValue<{ test: boolean; timestamp: number }>(testKey);
      
      results.componentResults.asyncStorageWorks = 
        retrievedValue !== null && typeof retrievedValue === 'object' && 'test' in retrievedValue;
      
      // Clean up
      await databaseManager.removeValue(testKey);
    } catch (error) {
      results.componentResults.asyncStorageWorks = false;
      results.errors.push(`AsyncStorage operations failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    console.log('[DbValidator] DatabaseManager validation completed');
  }
}

export interface ValidationResult {
  success: boolean;
  errors: string[];
  warnings: string[];
  componentResults: {
    [key: string]: boolean | undefined;
    bongHitsTableExists?: boolean;
    strainsTableExists?: boolean;
    transactionsWork?: boolean;
    asyncStorageWorks?: boolean;
    expoSqliteWorks?: boolean;
    weeklyStatsWork?: boolean;
    strainsDataWorks?: boolean;
  };
}

// Export a function to run the validation
export async function validateDatabase(): Promise<ValidationResult> {
  return DbValidator.validateDatabaseSetup();
}

export default validateDatabase; 

================================================================================
File: src/hooks/useAIRecommendations.ts
================================================================================

import { useState, useEffect, useCallback, useRef } from 'react';
import { AIService } from '../services/ai';
import { ChatRequest } from '../services/ai/types/requests';
import { databaseManager } from '../DatabaseManager';
import { 
  RecommendationRequest, 
  RecommendationResponse, 
  ChatMessage, 
  UserProfile,
  JournalEntry,
  SafetyValidationResult,
  SafetyRecord
} from '../types';
import { DatabaseResponse } from '../types';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Cache keys
const RECOMMENDATIONS_CACHE_KEY = 'ai_recommendations_cache';
const RECOMMENDATIONS_CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

export const useAIRecommendations = () => {
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [recommendations, setRecommendations] = useState<RecommendationResponse | null>(null);
  const [safetyValidation, setSafetyValidation] = useState<SafetyValidationResult | null>(null);
  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  
  // Track initialization state
  const isInitialized = useRef<boolean>(false);
  const cleanupCalled = useRef<boolean>(false);
  
  // Get AIService instance
  const aiService = AIService.getInstance();
  
  // Initialize services
  useEffect(() => {
    const initServices = async () => {
      if (isInitialized.current) return;
      
      try {
        // First ensure database is initialized
        await databaseManager.ensureInitialized();
        
        // Then initialize AI service
        await aiService.initialize();
        
        isInitialized.current = true;
        
        // Load cached recommendations only after initialization
        await loadCachedRecommendations();
      } catch (err) {
        console.error('Error initializing AI or Database services:', err);
        setError('Failed to initialize recommendation services');
      }
    };
    
    initServices();
    
    return () => {
      // Cleanup only if not already called
      if (!cleanupCalled.current) {
        cleanupCalled.current = true;
      }
    };
  }, []);
  
  // Load cached recommendations
  const loadCachedRecommendations = async () => {
    try {
      const cachedData = await AsyncStorage.getItem(RECOMMENDATIONS_CACHE_KEY);
      
      if (cachedData) {
        const { recommendations: cachedRecommendations, timestamp } = JSON.parse(cachedData);
        
        // Check if cache is still valid
        if (Date.now() - timestamp < RECOMMENDATIONS_CACHE_EXPIRY) {
          setRecommendations(cachedRecommendations);
        }
      }
    } catch (err) {
      console.warn('Error loading cached recommendations:', err);
      // Non-critical error, don't set error state
    }
  };
  
  // Cache recommendations
  const cacheRecommendations = async (recommendations: RecommendationResponse) => {
    try {
      await AsyncStorage.setItem(
        RECOMMENDATIONS_CACHE_KEY,
        JSON.stringify({
          recommendations,
          timestamp: Date.now()
        })
      );
    } catch (err) {
      console.warn('Error caching recommendations:', err);
      // Non-critical error, don't set error state
    }
  };
  
  // Get strain recommendations with safety checks
  const getRecommendations = useCallback(async (
    request: RecommendationRequest,
    recentEntries: JournalEntry[] = []
  ): Promise<RecommendationResponse | null> => {
    setLoading(true);
    setError(null);
    
    try {
      // Validate request for safety concerns
      const validationResult = await databaseManager.validateRecommendationRequest(request);
      setSafetyValidation(validationResult);
      
      // If request is invalid due to safety concerns, return early
      if (!validationResult.valid) {
        setError(validationResult.reason || 'Request failed safety validation');
        setLoading(false);
        return null;
      }
      
      // Apply any safety modifications to the request
      const safeRequest = validationResult.modifications 
        ? { ...request, ...validationResult.modifications }
        : request;
      
      // Get recommendations from AI service
      const rawRecommendations = await aiService.getRecommendations(safeRequest);
      
      // Process recommendations through safety service
      const safeRecommendations = await databaseManager.processRecommendationResponse(
        rawRecommendations,
        request.userProfile,
        recentEntries
      );
      
      // Update state and cache
      setRecommendations(safeRecommendations);
      cacheRecommendations(safeRecommendations);
      
      setLoading(false);
      return safeRecommendations;
      
    } catch (err) {
      console.error('Error getting recommendations:', err);
      setError('Failed to get recommendations. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [aiService]);
  
  // Get chat response
  const getChatResponse = useCallback(async (
    message: string,
    userProfile: UserProfile
  ): Promise<ChatMessage | null> => {
    setLoading(true);
    setError(null);
    
    try {
      // Add user message to history
      const userMessage: ChatMessage = {
        id: `user_${Date.now()}`,
        content: message,
        role: 'user',
        timestamp: new Date().toISOString()
      };
      
      setChatHistory(prev => [...prev, userMessage]);
      
      // Create chat request - convert ChatMessage to the simplified format expected by AIService
      const chatRequest: ChatRequest = {
        message,
        userProfile,
        // Only include the role and content properties that AIService needs
        previousMessages: chatHistory.length > 0 
          ? chatHistory.map(msg => ({ 
              role: msg.role, 
              content: msg.content 
            })) as any // Use type assertion to bypass the type check
          : undefined
      };
      
      // Get AI response
      const aiResponseData = await aiService.getChatResponse(chatRequest);
      
      // Create chat message from response
      const aiResponseMessage: ChatMessage = {
        id: `assistant_${Date.now()}`,
        content: aiResponseData.response,
        role: 'assistant',
        timestamp: new Date().toISOString()
      };
      
      // Add AI response to history
      setChatHistory(prev => [...prev, aiResponseMessage]);
      
      setLoading(false);
      return aiResponseMessage;
      
    } catch (err) {
      console.error('Error getting chat response:', err);
      setError('Failed to get response. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [chatHistory, aiService]);
  
  // Analyze journal patterns
  const analyzeJournalPatterns = useCallback(async (
    entries: JournalEntry[],
    userProfile: UserProfile
  ) => {
    setLoading(true);
    setError(null);
    
    try {
      const analysis = await aiService.analyzeJournalEntries(userProfile.id, entries);
      setLoading(false);
      return analysis;
      
    } catch (err) {
      console.error('Error analyzing journal patterns:', err);
      setError('Failed to analyze journal entries. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [aiService]);
  
  // Clear chat history
  const clearChatHistory = useCallback(() => {
    setChatHistory([]);
  }, []);
  
  // Get safety history
  const getSafetyHistory = useCallback(async (userId: string) => {
    try {
      return await databaseManager.getSafetyHistory(userId);
    } catch (err) {
      console.error('Error getting safety history:', err);
      return [];
    }
  }, []);
  
  return {
    loading,
    error,
    recommendations,
    safetyValidation,
    chatHistory,
    getRecommendations,
    getChatResponse,
    analyzeJournalPatterns,
    clearChatHistory,
    getSafetyHistory
  };
};

export default useAIRecommendations; 

================================================================================
File: src/hooks/useCurrentWeekData.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { useBongHitsRepository } from '@/src/providers/AppProvider';
import { getCurrentWeekProgressRangeLocal } from '@/src/utils/timeUtils';

export function useCurrentWeekData() {
  const [currentWeekAverage, setCurrentWeekAverage] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const bongHitsRepository = useBongHitsRepository();

  const fetchWeekData = useCallback(async () => {
    console.log('[useCurrentWeekData] Fetching average for current week...');
    setIsLoading(true);
    setError(null);
    try {
      // Use the specific repository method for current week average
      const response = await bongHitsRepository.getAverageHitsForCurrentWeek();

      if (response.success) {
        setCurrentWeekAverage(response.data ?? 0);
        console.log(`[useCurrentWeekData] Current week average: ${response.data}`);
      } else {
        setError(response.error ?? 'Failed to fetch weekly average');
        setCurrentWeekAverage(0);
        console.error(`[useCurrentWeekData] Error: ${response.error}`);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error fetching weekly data';
      setError(message);
      setCurrentWeekAverage(0);
      console.error(`[useCurrentWeekData] Exception: ${message}`);
    } finally {
      setIsLoading(false);
    }
  }, [bongHitsRepository]);

  useEffect(() => {
    fetchWeekData();
    // Optional: Refetch periodically or based on other triggers
  }, [fetchWeekData]);

  return { currentWeekAverage, isLoading, error, refresh: fetchWeekData };
} 

================================================================================
File: src/hooks/useDailyAverageData.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { useBongHitsRepository } from '@/src/providers/AppProvider';
import { ChartDataPoint, DatabaseResponse } from '@/src/types';
import {
    getTodayRangeLocal,
    getCurrentWeekProgressRangeLocal,
    getCurrentFullWeekRangeLocal 
} from '@/src/utils/timeUtils';
import { databaseManager } from '@/src/DatabaseManager'; // Import databaseManager

// Define the shape of the data we'll store for each time range
interface TimeRangeResult {
    average: number;
    chartData: ChartDataPoint[];
    // Add other stats if needed (max, min, etc.)
}

// Define the state structure for the hook
interface DailyAverageDataState {
    daily: TimeRangeResult | null;
    weekly: TimeRangeResult | null;
    monthly: TimeRangeResult | null;
    yearly: TimeRangeResult | null;
    isLoading: boolean;
    error: string | null;
}

const INITIAL_STATE: DailyAverageDataState = {
    daily: null,
    weekly: null,
    monthly: null,
    yearly: null,
    isLoading: true,
    error: null,
};

export function useDailyAverageData() {
    const [state, setState] = useState<DailyAverageDataState>(INITIAL_STATE);
    const bongHitsRepository = useBongHitsRepository();

    const fetchDataForAllRanges = useCallback(async () => {
        console.log('[useDailyAverageData] Fetching data for all ranges...');
        setState(prev => ({ ...prev, isLoading: true, error: null }));

        try {
            // --- Fetch Daily Data ---
            const todayRange = getTodayRangeLocal();
            const dailyHitsResponse = await bongHitsRepository.getHitCountForDateRange(todayRange.startDate, todayRange.endDate);
            const dailyAvgResponse = await bongHitsRepository.getAverageHitsPerDayForDateRange(todayRange.startDate, todayRange.endDate); // Avg over 1 day is just the count
            const dailyChartResponse = await bongHitsRepository.getHourlyAveragesForDay(todayRange.startDate, todayRange.endDate); // Hourly for 'D'

            // --- Fetch Weekly Data ---
            const weekRange = getCurrentWeekProgressRangeLocal(); // Use progress range for average
            const fullWeekRange = getCurrentFullWeekRangeLocal(); // Use full range for chart
            const weeklyAvgResponse = await bongHitsRepository.getAverageHitsForCurrentWeek(); // Use dedicated method
            const weeklyChartResponse = await databaseManager.getWeeklyStats(fullWeekRange.startDate.toISOString(), fullWeekRange.endDate.toISOString()); // Fetch week chart data

            // --- Fetch Monthly Data ---
            const now = new Date();
            const monthStartDate = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthEndDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
            const monthlyAvgResponse = await bongHitsRepository.getAverageHitsPerDayForDateRange(monthStartDate, monthEndDate);
            const monthlyChartResponse = await bongHitsRepository.getHitsByDayOfMonth(monthStartDate, monthEndDate); // Daily breakdown for 'M'

            // --- Fetch Yearly Data ---
            const yearEndDate = new Date();
            const yearStartDate = new Date();
            yearStartDate.setFullYear(yearEndDate.getFullYear() - 1);
            yearStartDate.setDate(yearStartDate.getDate() + 1); // Start exactly one year ago
            yearStartDate.setHours(0, 0, 0, 0);
            const yearlyAvgResponse = await bongHitsRepository.getAverageHitsPerDayForDateRange(yearStartDate, yearEndDate);
            const yearlyChartResponse = await databaseManager.getMonthlyStats(yearStartDate.toISOString(), yearEndDate.toISOString()); // Monthly breakdown for 'Y'

            // --- Consolidate Results ---
            const newState: DailyAverageDataState = {
                daily: {
                    average: dailyAvgResponse.success ? (dailyAvgResponse.data ?? 0) : 0,
                    chartData: dailyChartResponse.success ? (dailyChartResponse.data ?? []) : [],
                },
                weekly: {
                    average: weeklyAvgResponse.success ? (weeklyAvgResponse.data ?? 0) : 0,
                    chartData: weeklyChartResponse.success ? (weeklyChartResponse.data ?? []) : [],
                },
                monthly: {
                    average: monthlyAvgResponse.success ? (monthlyAvgResponse.data ?? 0) : 0,
                    chartData: monthlyChartResponse.success ? (monthlyChartResponse.data ?? []) : [],
                },
                yearly: {
                    average: yearlyAvgResponse.success ? (yearlyAvgResponse.data ?? 0) : 0,
                    chartData: yearlyChartResponse.success ? (yearlyChartResponse.data ?? []) : [],
                },
                isLoading: false,
                error: null, // Reset error on successful fetch
            };

            // Check for any errors during fetch
            const errors = [
                dailyHitsResponse.error, dailyAvgResponse.error, dailyChartResponse.error,
                weeklyAvgResponse.error, weeklyChartResponse.error,
                monthlyAvgResponse.error, monthlyChartResponse.error,
                yearlyAvgResponse.error, yearlyChartResponse.error
            ].filter(Boolean);

            if (errors.length > 0) {
                newState.error = `Failed to fetch some data: ${errors.join(', ')}`;
                console.error("[useDailyAverageData] Fetch errors:", errors);
            }

            setState(newState);
            console.log('[useDailyAverageData] Fetched and processed data for all ranges.');

        } catch (err) {
            console.error('[useDailyAverageData] Critical error fetching all data:', err);
            setState({
                ...INITIAL_STATE,
                isLoading: false,
                error: err instanceof Error ? err.message : 'An unknown error occurred',
            });
        }
    }, [bongHitsRepository]); // Include repository in dependencies

    // Fetch data on mount
    useEffect(() => {
        fetchDataForAllRanges();
    }, [fetchDataForAllRanges]); // Run effect when the fetch function itself changes (which it shouldn't after first render)

    // Provide a refresh function
    const refreshData = useCallback(() => {
        fetchDataForAllRanges();
    }, [fetchDataForAllRanges]);

    return { ...state, refreshData };
} 

================================================================================
File: src/hooks/useDailyData.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { useBongHitsRepository } from '@/src/providers/AppProvider';
import { getTodayRangeLocal } from '@/src/utils/timeUtils';

export function useDailyData() {
  const [hitsToday, setHitsToday] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const bongHitsRepository = useBongHitsRepository();

  const fetchDailyData = useCallback(async () => {
    console.log('[useDailyData] Fetching data for today...');
    setIsLoading(true);
    setError(null);
    try {
      const { startDate, endDate } = getTodayRangeLocal();
      // Use getHitCountForDateRange for consistency, though getHitsForDate works too
      const response = await bongHitsRepository.getHitCountForDateRange(startDate, endDate);

      if (response.success) {
        setHitsToday(response.data ?? 0);
        console.log(`[useDailyData] Today's hits: ${response.data}`);
      } else {
        setError(response.error ?? 'Failed to fetch daily data');
        setHitsToday(0);
        console.error(`[useDailyData] Error: ${response.error}`);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error fetching daily data';
      setError(message);
      setHitsToday(0);
      console.error(`[useDailyData] Exception: ${message}`);
    } finally {
      setIsLoading(false);
    }
  }, [bongHitsRepository]);

  useEffect(() => {
    fetchDailyData();
    // Optional: Set up an interval to refetch daily data periodically if needed
    // const intervalId = setInterval(fetchDailyData, 60 * 60 * 1000); // e.g., every hour
    // return () => clearInterval(intervalId);
  }, [fetchDailyData]);

  return { hitsToday, isLoading, error, refresh: fetchDailyData };
} 

================================================================================
File: src/hooks/useDataService.ts
================================================================================

import { useState, useEffect, useCallback, useMemo } from 'react';
import { databaseManager } from '@/src/DatabaseManager';
import { DataState, ChartDataPoint, UsageStats, WeekdayStats } from '@/src/types';
import { dataChangeEmitter, dbEvents } from '../utils/EventEmitter';

const DEFAULT_STATE: DataState = {
  weeklyData: [],
  monthlyData: [],
  usageStats: {
    averageHitsPerDay: 0,
    totalHits: 0,
    peakDayHits: 0,
    lowestDayHits: 0,
    averageDuration: 0,
    longestHit: 0,
    shortestHit: 0,
    mostActiveHour: 0,
    leastActiveHour: 0,
    totalDuration: 0,
    averageHitsPerHour: 0,
    consistency: 0,
    weekdayStats: {
      weekday: { avg: 0, total: 0 },
      weekend: { avg: 0, total: 0 }
    }
  },
  timeDistribution: {
    morning: 0,
    afternoon: 0,
    evening: 0,
    night: 0
  },
  isLoading: true,
  error: null
};

export function useDataService() {
  const [state, setState] = useState<DataState>(DEFAULT_STATE);
  const [isRefreshing, setIsRefreshing] = useState(false); // New state for manual refresh

  // Memoize default date range to prevent recreating on each render
  const defaultDateRange = useMemo(() => {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setFullYear(startDate.getFullYear() - 1); // Default to last year
    return { startDate, endDate };
  }, []);

  // Helper function to ensure data is in the correct format
  const ensureChartDataFormat = (data: any[] | null | undefined): ChartDataPoint[] => {
    if (!data || data.length === 0) return [];
    
    // Check if data already has the right format (label and value properties)
    if (data[0].label !== undefined && data[0].value !== undefined) {
      return data as ChartDataPoint[];
    }
    
    // Otherwise, map to the right format
    return [];
  };
  
  // Function to load data with specific date range
  const loadDataWithDateRange = useCallback(async (startDate?: Date, endDate?: Date, isManualRefresh = false) => {
    const currentStartDate = startDate || defaultDateRange.startDate;
    const currentEndDate = endDate || defaultDateRange.endDate;
    
    // Format dates for database queries
    const startDateStr = currentStartDate.toISOString();
    const endDateStr = currentEndDate.toISOString();
    
    console.log(`[useDataService] ${isManualRefresh ? 'Refreshing' : 'Loading'} data with date range: ${startDateStr} to ${endDateStr}`);
    
    // Set appropriate loading state
    if (isManualRefresh) {
      setIsRefreshing(true);
    } else {
      setState(prev => ({ ...prev, isLoading: true, error: null }));
    }
    
    try {
      // Fetch data with date range
      console.log('[useDataService] Fetching weekly stats...');
      const weeklyStats = await databaseManager.getWeeklyStats(startDateStr, endDateStr);
      
      console.log('[useDataService] Fetching monthly stats...');
      const monthlyStats = await databaseManager.getMonthlyStats(startDateStr, endDateStr);
      
      console.log('[useDataService] Fetching usage stats...');
      const usageStats = await databaseManager.getUsageStats(startDateStr, endDateStr);
      
      console.log('[useDataService] Fetching time distribution...');
      const timeDistribution = await databaseManager.getTimeDistribution(startDateStr, endDateStr);
      
      // Collect any errors from the responses
      const errors: string[] = [];
      if (!weeklyStats.success) errors.push(`Weekly stats: ${weeklyStats.error}`);
      if (!monthlyStats.success) errors.push(`Monthly stats: ${monthlyStats.error}`);
      if (!usageStats.success) errors.push(`Usage stats: ${usageStats.error}`);
      if (!timeDistribution.success) errors.push(`Time distribution: ${timeDistribution.error}`);
      
      if (errors.length > 0) {
        const errorMessage = errors.join('; ');
        console.error('[useDataService] Data fetch errors:', errorMessage);
        setState(prev => ({
          ...prev,
          isLoading: false,
          error: errorMessage
        }));
        setIsRefreshing(false);
        return;
      }
      
      // Check if we actually have data in any of the datasets
      const hasUsageStats = usageStats.data && usageStats.data.totalHits > 0;
      // Check if weekly/monthly data has any non-zero values
      const hasWeeklyData = weeklyStats.data && weeklyStats.data.some((d: ChartDataPoint) => d.value > 0);
      const hasMonthlyData = monthlyStats.data && monthlyStats.data.some((d: ChartDataPoint) => d.value > 0);
      
      // Determine overall hasData based on any data existing
      const hasData = hasUsageStats || hasWeeklyData || hasMonthlyData;
      
      console.log(`[useDataService] Data fetch complete. Has data: ${hasData} (Usage: ${hasUsageStats}, Weekly: ${hasWeeklyData}, Monthly: ${hasMonthlyData})`);
      
      // Update state based on whether we have actual data or not
      setState({
        weeklyData: ensureChartDataFormat(weeklyStats.data),
        monthlyData: ensureChartDataFormat(monthlyStats.data),
        // Conditionally apply usageStats only if they contain data
        usageStats: hasUsageStats
                    ? (usageStats.data as UsageStats)
                    : DEFAULT_STATE.usageStats, // Use default if no usage stats
        // Conditionally apply timeDistribution only if there's any data
        timeDistribution: hasData
                        ? (timeDistribution.data || DEFAULT_STATE.timeDistribution)
                        : DEFAULT_STATE.timeDistribution,
        isLoading: false,
        error: null
      });
    } catch (error) {
      console.error('[useDataService] Unexpected error in loadData:', error);
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error instanceof Error ? error.message : 'An unexpected error occurred while fetching data'
      }));
    } finally {
      setIsRefreshing(false); // Always reset refreshing state
    }
  }, [defaultDateRange]);

  // Function for manual refresh
  const refreshData = useCallback(() => {
    return loadDataWithDateRange(defaultDateRange.startDate, defaultDateRange.endDate, true);
  }, [loadDataWithDateRange, defaultDateRange]);

  // Initial data load - only run once on mount
  useEffect(() => {
    console.log('[useDataService] Initial data load...');
    loadDataWithDateRange(defaultDateRange.startDate, defaultDateRange.endDate);
  }, [loadDataWithDateRange, defaultDateRange]); // Dependencies for ensuring it only runs when needed

  // Listen for database change events
  useEffect(() => {
    console.log('[useDataService] Setting up database change listener');
    
    const handleDataChange = () => {
      console.log('[useDataService] Database change detected, refreshing data...');
      refreshData();
    };
    
    dataChangeEmitter.on(dbEvents.DATA_CHANGED, handleDataChange);
    
    return () => {
      console.log('[useDataService] Cleaning up database change listener');
      dataChangeEmitter.off(dbEvents.DATA_CHANGED, handleDataChange);
    };
  }, [refreshData]);

  return {
    ...state,
    isRefreshing,
    refreshData,
    loadDataWithDateRange // Keep this for compatibility with existing code
  };
} 

================================================================================
File: src/hooks/useStrains.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { StrainSearchFilters, PaginationParams } from '../DatabaseManager';
import { databaseManager } from '../DatabaseManager';
import { Strain } from "../types";

export interface UseStrainState {
  strains: Strain[];
  popularStrains: Strain[];
  categories: { [key: string]: number };
  isLoading: boolean;
  error: string | null;
  pagination: {
    total: number;
    currentPage: number;
    totalPages: number;
    hasMore: boolean;
  };
}

export interface UseStrainActions {
  searchStrains: (query: string, filters: StrainSearchFilters) => Promise<void>;
  loadMore: () => void;
  toggleFavorite: (strainId: number) => Promise<void>;
  isFavorite: (strainId: number) => boolean;
  clearSearch: () => void;
  getStrainDetails: (id: number) => Promise<Strain | null>;
  getRelatedStrains: (strain: Strain) => Promise<Strain[]>;
}

const INITIAL_STATE: UseStrainState = {
  strains: [],
  popularStrains: [],
  categories: {},
  isLoading: false,
  error: null,
  pagination: {
    total: 0,
    currentPage: 1,
    totalPages: 1,
    hasMore: false
  }
};

export function useStrains(): UseStrainState & UseStrainActions {
  const [state, setState] = useState<UseStrainState>(INITIAL_STATE);
  const [filters, setFilters] = useState<StrainSearchFilters>({});
  const [favoriteStrains, setFavoriteStrains] = useState<number[]>([]);

  // Load initial data
  useEffect(() => {
    loadInitialData();
  }, []);

  const loadInitialData = async () => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      
      const [popularStrains, categories] = await Promise.all([
        databaseManager.getPopularStrains(),
        databaseManager.getStrainCategories()
      ]);

      setState(prev => ({
        ...prev,
        popularStrains,
        categories,
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Failed to load initial data',
        isLoading: false
      }));
    }
  };

  const searchStrains = useCallback(async (
    query: string,
    newFilters: StrainSearchFilters = {},
    page: number = 1
  ) => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      setFilters(newFilters);

      const result = await databaseManager.searchStrains(query, newFilters, { page, limit: 10 });

      setState(prev => ({
        ...prev,
        strains: page === 1 ? result.data : [...prev.strains, ...result.data],
        pagination: {
          total: result.total,
          currentPage: result.currentPage,
          totalPages: result.totalPages,
          hasMore: result.hasMore
        },
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Search failed',
        isLoading: false
      }));
    }
  }, []);

  const loadMore = useCallback(() => {
    if (state.pagination.hasMore && !state.isLoading) {
      const nextPage = state.pagination.currentPage + 1;
      searchStrains('', filters, nextPage);
    }
  }, [state.pagination, state.isLoading, filters, searchStrains]);

  const toggleFavorite = useCallback(async (strainId: number) => {
    setFavoriteStrains(prev => {
      const isFavorited = prev.includes(strainId);
      return isFavorited 
        ? prev.filter(id => id !== strainId)
        : [...prev, strainId];
    });
  }, []);

  const isFavorite = useCallback((strainId: number) => {
    return favoriteStrains.includes(strainId);
  }, [favoriteStrains]);

  const clearSearch = useCallback(() => {
    setState(prev => ({
      ...prev,
      strains: [],
      pagination: {
        total: 0,
        currentPage: 1,
        totalPages: 1,
        hasMore: false
      }
    }));
  }, []);

  const getStrainDetails = useCallback(async (id: number): Promise<Strain | null> => {
    try {
      return await databaseManager.getStrainById(id);
    } catch (error) {
      console.error('[useStrains] Error getting strain details:', error);
      return null;
    }
  }, []);

  const getRelatedStrains = useCallback(async (strain: Strain): Promise<Strain[]> => {
    try {
      return await databaseManager.getRelatedStrains(strain);
    } catch (error) {
      console.error('[useStrains] Error getting related strains:', error);
      return [];
    }
  }, []);

  return {
    ...state,
    searchStrains,
    loadMore,
    toggleFavorite,
    isFavorite,
    clearSearch,
    getStrainDetails,
    getRelatedStrains
  };
} 

================================================================================
File: src/hooks/useTimeRangeData.ts
================================================================================

import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { useDataService } from './useDataService';
import { UsageStats, ChartDataPoint, TimeDistribution } from '@/src/types';
import { useBongHitsRepository } from '@/src/providers/AppProvider';

export type TimeRange = 'D' | 'W' | 'M' | 'Y';

interface TimeRangeData {
  chartData: number[];
  chartLabels: string[];
  averageValue: number;
  maxValue: number;
  minValue: number;
  weekdayAvg?: number;
  weekendAvg?: number;
}

// Helper function to get date range based on time range selection
// This MUST be a pure function or memoized correctly.
function calculateDateRangeForTimeRange(range: TimeRange): { startDate: Date, endDate: Date } {
  const now = new Date(); // Base end date on current time
  let startDate = new Date();
  let endDate = new Date();

  switch(range) {
    case 'D': // Today only - calendar day
      startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0); // Start of today
      endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999); // End of today
      break;
    case 'W': // Week - Sunday to Saturday
      // Get the current day of the week (0 = Sunday, 6 = Saturday)
      const dayOfWeek = now.getDay();
      // Set start date to the beginning of the current week (Sunday)
      startDate.setDate(now.getDate() - dayOfWeek);
      startDate.setHours(0, 0, 0, 0); // Start of Sunday
      
      // Set end date to the end of this week (Saturday)
      const daysToEnd = 6 - dayOfWeek; // Days until Saturday
      const weekEndDate = new Date(now);
      weekEndDate.setDate(now.getDate() + daysToEnd);
      weekEndDate.setHours(23, 59, 59, 999); // End of Saturday
      
      // Only use the calculated end date if it's in the future
      if (weekEndDate <= now) {
        // We're already past Saturday, so use current time as end
        endDate.setHours(23, 59, 59, 999); // End of today
      } else {
        // Use the end of Saturday as end date
        endDate.setTime(weekEndDate.getTime());
      }
      break;
    case 'M': // Current calendar month
      startDate = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0); // First day of month
      // Last day of month (0th day of next month is last day of current month)
      endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
      break;
    case 'Y': // Last 365 days (1 year)
      endDate = new Date();
      endDate.setHours(23, 59, 59, 999); // End of today
      startDate = new Date();
      startDate.setFullYear(endDate.getFullYear() - 1);
      startDate.setDate(startDate.getDate() + 1); // Start exactly one year ago
      startDate.setHours(0, 0, 0, 0); // Start of the first day
      break;
  }

  // Format dates to ISO strings for consistent logging
  const startIso = startDate.toISOString();
  const endIso = endDate.toISOString();
  console.log(`[calculateDateRange] Range: ${range}, Start: ${startIso}, End: ${endIso}`);
  
  return { startDate, endDate };
}

const DEFAULT_TIMERANGE_DATA: TimeRangeData = {
  chartData: [],
  chartLabels: [],
  averageValue: 0,
  maxValue: 0,
  minValue: 0,
  weekdayAvg: 0,
  weekendAvg: 0
};

// Helper function to calculate statistics from chart data
function calculateStats(data: number[]): { avg: number; max: number; min: number } {
  if (!data || data.length === 0) {
    return { avg: 0, max: 0, min: 0 };
  }

  const sum = data.reduce((acc, value) => acc + value, 0);
  const avg = sum / data.length;
  const max = Math.max(...data);
  
  // For min, filter out zeros if other values exist
  const nonZeroValues = data.filter(value => value > 0);
  const min = nonZeroValues.length > 0 
    ? Math.min(...nonZeroValues) 
    : 0;

  return {
    avg,
    max,
    min
  };
}

export function useTimeRangeData(initialRange: TimeRange = 'W') {
  // Use ref to prevent unnecessary re-renders when checking busy state
  const isFetchingRef = useRef(false);
  
  // Use the useDataService hook - get the whole object to avoid dependency issues
  const dataService = useDataService();
  
  // Get the BongHitsRepository instance for direct data access
  const bongHitsRepository = useBongHitsRepository();

  const [timeRange, setTimeRange] = useState<TimeRange>(initialRange);

  // --- Memoize the date range calculation ---
  // This is crucial. Calculate start/end dates based *only* on the timeRange state.
  const { startDate, endDate } = useMemo(() => {
    console.log(`[useTimeRangeData] Recalculating date range for ${timeRange}`);
    return calculateDateRangeForTimeRange(timeRange);
    // Recalculate ONLY when timeRange changes
  }, [timeRange]);

  const [data, setData] = useState<TimeRangeData>(DEFAULT_TIMERANGE_DATA);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);

  // Function to process and format the data after it's been loaded
  const processData = useCallback((
    stats: UsageStats,
    weekly: ChartDataPoint[],
    monthly: ChartDataPoint[],
    range: TimeRange,
    directData?: ChartDataPoint[] // New parameter for direct repository data
  ): TimeRangeData => {
    console.log(`[useTimeRangeData] Processing data for range ${range}`);
    
    let chartData: number[] = [];
    let chartLabels: string[] = [];
    let weekdayAvg = 0;
    let weekendAvg = 0;
    let calculatedStats = { avg: 0, max: 0, min: 0 };
    
    // Generate chart data based on time range
    switch(range) {
      case 'D':
        // Use directly fetched data if available
        if (directData && directData.length > 0) {
          chartData = directData.map(d => d.value);
          chartLabels = directData.map(d => d.label);
          calculatedStats = calculateStats(chartData);
        } else {
          // Fallback to placeholder if no data
          const hourLabels = Array.from({ length: 24 }, (_, i) => `${(new Date().getHours() - 23 + i + 24) % 24}:00`);
          chartData = Array(24).fill(0);
          chartLabels = hourLabels;
        }
        break;

      case 'W':
        if (weekly && weekly.length > 0) {
          chartData = weekly.map(d => d.value);
          chartLabels = weekly.map(d => d.label);
          calculatedStats = calculateStats(chartData);
        } else {
          const dayLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((_, i, arr) => arr[(new Date().getDay() - 6 + i + 7) % 7]);
          chartData = Array(7).fill(0);
          chartLabels = dayLabels;
        }
        break;

      case 'M':
        // Use directly fetched data if available
        if (directData && directData.length > 0) {
          chartData = directData.map(d => d.value);
          chartLabels = directData.map(d => d.label);
          calculatedStats = calculateStats(chartData);
        } else {
          // Fallback to placeholder if no data
          const monthLabels = Array.from({ length: 30 }, (_, i) => `${new Date(Date.now() - (29 - i) * 86400000).getDate()}`);
          chartData = Array(30).fill(0);
          chartLabels = monthLabels;
        }
        break;

      case 'Y':
        if (monthly && monthly.length > 0) {
          chartData = monthly.map(d => d.value);
          chartLabels = monthly.map(d => d.label);
          calculatedStats = calculateStats(chartData);
        } else {
          const yearLabels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'].map((_, i, arr) => arr[(new Date().getMonth() - 11 + i + 12) % 12]);
          chartData = Array(12).fill(0);
          chartLabels = yearLabels;
        }
        break;
    }

    // Determine if we have data
    const hasData = (stats?.totalHits > 0 || chartData.some(value => value > 0));

    // Use global stats from dataService if available, otherwise use calculated stats
    const averageValue = hasData && stats?.averageHitsPerDay 
      ? stats.averageHitsPerDay 
      : calculatedStats.avg;
      
    const maxValue = hasData && stats?.peakDayHits 
      ? stats.peakDayHits
      : calculatedStats.max;
      
    const minValue = hasData && stats?.lowestDayHits
      ? stats.lowestDayHits 
      : calculatedStats.min;
    
    if (hasData && stats?.weekdayStats) {
      weekdayAvg = stats.weekdayStats.weekday?.avg || 0;
      weekendAvg = stats.weekdayStats.weekend?.avg || 0;
    }

    return {
      chartData,
      chartLabels,
      averageValue: hasData ? averageValue : 0,
      maxValue: hasData ? maxValue : 0,
      minValue: hasData ? minValue : 0,
      weekdayAvg,
      weekendAvg
    };
  }, []);

  // State to hold directly fetched data
  const [directData, setDirectData] = useState<ChartDataPoint[] | undefined>(undefined);

  // Function to fetch data based on the memoized date range
  // Refactored to only fetch, not process data
  const fetchDataForCurrentRange = useCallback(async (manualRefresh = false) => {
    if (isFetchingRef.current && !manualRefresh) {
      console.log('[useTimeRangeData] Already fetching data, skipping fetch.');
      return;
    }

    // Use local copies of dates to ensure stability if called rapidly
    const currentStartDate = startDate;
    const currentEndDate = endDate;
    const currentRange = timeRange; // Capture the current range
    
    // Format the date range for logging/debugging
    const formatDate = (date: Date) => date.toISOString().split('T')[0];
    console.log(`[useTimeRangeData] ${manualRefresh ? 'Refreshing' : 'Fetching'} data for range ${currentRange} (${formatDate(currentStartDate)} to ${formatDate(currentEndDate)})`);

    if (manualRefresh) {
      setIsRefreshing(true);
    } else {
      setIsLoading(true);
    }
    
    setError(null);
    isFetchingRef.current = true;

    try {
      let directResult: ChartDataPoint[] | undefined = undefined;
      
      // For day and month ranges, fetch data directly from the repository
      if (currentRange === 'D') {
        const hourlyResponse = await bongHitsRepository.getHourlyAveragesForDay(currentStartDate, currentEndDate);
        if (hourlyResponse.success && hourlyResponse.data) {
          directResult = hourlyResponse.data;
        } else if (hourlyResponse.error) {
          setError(hourlyResponse.error);
        }
      } else if (currentRange === 'M') {
        const dailyResponse = await bongHitsRepository.getHitsByDayOfMonth(currentStartDate, currentEndDate);
        if (dailyResponse.success && dailyResponse.data) {
          directResult = dailyResponse.data;
        } else if (dailyResponse.error) {
          setError(dailyResponse.error);
        }
      }
      
      // Store directData in state for the processing effect to use
      setDirectData(directResult);
      
      // Still trigger dataService load for stats and other ranges
      await dataService.loadDataWithDateRange(currentStartDate, currentEndDate, manualRefresh);
      
      // Only handle errors from the fetch call if not already set
      if (dataService.error && !error) {
        setError(dataService.error);
      }
    } catch (err) {
      console.error("[useTimeRangeData] Error triggering data fetch:", err);
      setError(err instanceof Error ? err.message : "An unknown error occurred during fetch trigger");
    } finally {
      isFetchingRef.current = false;
      // Don't reset loading states here - the processing effect will do that
    }
  }, [
    startDate, 
    endDate, 
    timeRange,
    // Only include stable method references, not the entire objects
    bongHitsRepository.getHourlyAveragesForDay, 
    bongHitsRepository.getHitsByDayOfMonth,
    dataService.loadDataWithDateRange
  ]);

  // Effect to *trigger* fetch when date range changes (i.e., timeRange changes)
  useEffect(() => {
    console.log(`[useTimeRangeData] Date Range Effect: Trigger fetch for ${timeRange}`);
    
    // Add a cancel flag to prevent state updates after unmount
    let isCancelled = false;
    
    // Trigger fetch
    fetchDataForCurrentRange(false).then(() => {
      if (isCancelled) {
        console.log('[useTimeRangeData] Fetch completed but component unmounted, skipping updates');
      }
    });
    
    // Cleanup function
    return () => {
      isCancelled = true;
      console.log('[useTimeRangeData] Cleanup fetch effect');
    };
  }, [fetchDataForCurrentRange]);

  // SEPARATE Effect to PROCESS data when it changes
  useEffect(() => {
    // Only process if the underlying service is NOT loading and we are not actively fetching
    if (!dataService.isLoading && !isFetchingRef.current) {
      console.log('[useTimeRangeData] Processing Effect: Handling data updated from services');
      
      const processed = processData(
        dataService.usageStats,
        dataService.weeklyData,
        dataService.monthlyData,
        timeRange,
        directData
      );
      
      setData(processed);
      setError(dataService.error); // Update error state from service
      setIsLoading(false);       // Mark this hook as not loading
      setIsRefreshing(false);    // Mark this hook as not refreshing
    }
  }, [
    // Dependencies for processing effect
    dataService.usageStats,
    dataService.weeklyData,
    dataService.monthlyData,
    dataService.isLoading,
    dataService.error,
    directData,
    timeRange,
    processData
  ]);

  // Function for manual refresh - stable
  const refreshTimeRangeData = useCallback(() => {
    console.log(`[useTimeRangeData] Manual refresh called for range ${timeRange}`);
    return fetchDataForCurrentRange(true);
  }, [fetchDataForCurrentRange, timeRange]);

  return {
    timeRange,
    setTimeRange,
    data,
    // isLoading should reflect if *either* hook is loading initially
    isLoading: isLoading || (dataService.isLoading && !isRefreshing),
    isRefreshing,
    error,
    refreshTimeRangeData
  };
} 

================================================================================
File: src/migrations/index.ts
================================================================================

// src/migrations/index.ts
// Registry for all migrations to enable static imports

import * as v1 from './v1';
// Import future migration versions here
// import * as v2 from './v2';
// import * as v3 from './v3';

/**
 * Migration module interface
 */
export interface MigrationModule {
  up: (db: any) => Promise<void>;
  down?: (db: any) => Promise<void>;
}

/**
 * Migrations registry
 * Maps version numbers to migration modules
 */
export const migrations: Record<number, MigrationModule> = {
  1: v1,
  // Add future migrations here as they are created
  // 2: v2,
  // 3: v3,
}; 

================================================================================
File: src/migrations/v1.ts
================================================================================

import { SQLiteDatabase } from 'expo-sqlite';
import { 
  BONG_HITS_DATABASE_NAME, 
  STRAINS_DATABASE_NAME,
  SAMPLE_STRAINS,
  ACHIEVEMENTS
} from '../constants';

// Helper to execute schema - breaking statements by semicolons
async function executeSchema(db: SQLiteDatabase, schema: string): Promise<void> {
  const statements = schema.split(';').filter(s => s.trim() !== '');
  for (const statement of statements) {
    await db.execAsync(statement.trim() + ';');
  }
}

/**
 * Migration v1: Creates initial schemas for all databases
 */
export async function up(db: SQLiteDatabase): Promise<void> {
  console.log('[Migration V1] Applying migration...');

  // BongHits DB Schema
  const bongHitsSchema = `
    CREATE TABLE IF NOT EXISTS ${BONG_HITS_DATABASE_NAME} (
      timestamp TIMESTAMP PRIMARY KEY NOT NULL,
      duration_ms INTEGER NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_timestamp ON ${BONG_HITS_DATABASE_NAME}(timestamp)
  `;
  await executeSchema(db, bongHitsSchema);
  console.log('[Migration V1] BongHits schema applied.');

  // Strains DB Schema - we'll apply it to the same database for simplicity
  // In a real app, this might be better separated
  const strainsSchema = `
    CREATE TABLE IF NOT EXISTS ${STRAINS_DATABASE_NAME} (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL UNIQUE,
      overview TEXT,
      genetic_type TEXT,
      lineage TEXT,
      thc_range TEXT,
      cbd_level TEXT,
      dominant_terpenes TEXT,
      qualitative_insights TEXT,
      effects TEXT,
      negatives TEXT,
      uses TEXT,
      thc_rating REAL,
      user_rating REAL,
      combined_rating REAL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    CREATE INDEX IF NOT EXISTS idx_strain_name ON ${STRAINS_DATABASE_NAME}(name);
    CREATE INDEX IF NOT EXISTS idx_strain_genetic_type ON ${STRAINS_DATABASE_NAME}(genetic_type);
    CREATE INDEX IF NOT EXISTS idx_strain_effects ON ${STRAINS_DATABASE_NAME}(effects);
    CREATE INDEX IF NOT EXISTS idx_strain_rating ON ${STRAINS_DATABASE_NAME}(combined_rating DESC)
  `;
  await executeSchema(db, strainsSchema);
  console.log('[Migration V1] Strains schema applied.');

  // Safety DB Schema
  const safetySchema = `
    CREATE TABLE IF NOT EXISTS safety_records (
      id TEXT PRIMARY KEY NOT NULL,
      user_id TEXT NOT NULL,
      concern_type TEXT NOT NULL,
      concern_details TEXT NOT NULL,
      resolution_suggestions TEXT,
      cooling_off_until INTEGER,
      created_at INTEGER NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_user_id ON safety_records(user_id);
    CREATE INDEX IF NOT EXISTS idx_created_at ON safety_records(created_at);
    CREATE INDEX IF NOT EXISTS idx_concern_type ON safety_records(concern_type);
    CREATE INDEX IF NOT EXISTS idx_cooling_off_until ON safety_records(cooling_off_until)
  `;
  await executeSchema(db, safetySchema);
  console.log('[Migration V1] Safety schema applied.');

  // Achievements DB Schema
  const achievementsSchema = `
    CREATE TABLE IF NOT EXISTS achievements (
      id INTEGER PRIMARY KEY,
      category TEXT NOT NULL,
      name TEXT NOT NULL,
      unlock_condition TEXT NOT NULL,
      notes TEXT,
      icon TEXT,
      complexity INTEGER DEFAULT 1
    );
    CREATE TABLE IF NOT EXISTS user_achievements (
      user_id TEXT NOT NULL,
      achievement_id INTEGER NOT NULL,
      progress REAL DEFAULT 0,
      date_unlocked TEXT,
      is_unlocked INTEGER DEFAULT 0,
      is_new INTEGER DEFAULT 0,
      progress_data TEXT,
      PRIMARY KEY (user_id, achievement_id),
      FOREIGN KEY (achievement_id) REFERENCES achievements(id)
    )
  `;
  await executeSchema(db, achievementsSchema);
  console.log('[Migration V1] Achievements schema applied.');

  // --- START SEEDING ACHIEVEMENTS ---
  console.log('[Migration V1] Seeding achievements definitions...');
  try {
    for (const achievement of ACHIEVEMENTS) {
      await db.runAsync(
        `INSERT INTO achievements (id, category, name, unlock_condition, notes, icon, complexity)
         VALUES (?, ?, ?, ?, ?, ?, ?)
         ON CONFLICT(id) DO NOTHING;`, // ON CONFLICT avoids errors if run again
        [
          achievement.id,
          achievement.category,
          achievement.name,
          achievement.unlockCondition,
          achievement.notes || null,
          achievement.icon || null,
          achievement.complexity || 1
        ]
      );
    }
    console.log(`[Migration V1] Seeded ${ACHIEVEMENTS.length} achievements definitions.`);
  } catch(seedError) {
    console.error('[Migration V1] Error seeding achievements:', seedError);
    // Propagate the error to ensure the migration fails if seeding fails
    throw seedError;
  }
  // --- END SEEDING ACHIEVEMENTS ---

  // Journal DB Schema
  const journalSchema = `
    CREATE TABLE IF NOT EXISTS journal_entries (
      id TEXT PRIMARY KEY NOT NULL,
      user_id TEXT NOT NULL,
      entry_date INTEGER NOT NULL,
      strain_id INTEGER NOT NULL,
      strain_name TEXT NOT NULL,
      consumption_method TEXT NOT NULL,
      dosage REAL NOT NULL,
      dosage_unit TEXT NOT NULL,
      effects_felt TEXT NOT NULL,
      rating INTEGER NOT NULL,
      effectiveness INTEGER NOT NULL,
      notes TEXT,
      mood_before TEXT,
      mood_after TEXT,
      medical_symptoms_relieved TEXT,
      negative_effects TEXT,
      duration_minutes INTEGER,
      created_at INTEGER NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_journal_user_id ON journal_entries(user_id);
    CREATE INDEX IF NOT EXISTS idx_journal_entry_date ON journal_entries(entry_date);
    CREATE INDEX IF NOT EXISTS idx_journal_strain_id ON journal_entries(strain_id);
    CREATE INDEX IF NOT EXISTS idx_journal_strain_name ON journal_entries(strain_name);
    CREATE INDEX IF NOT EXISTS idx_journal_consumption_method ON journal_entries(consumption_method);
    CREATE INDEX IF NOT EXISTS idx_journal_rating ON journal_entries(rating);
    CREATE INDEX IF NOT EXISTS idx_journal_effectiveness ON journal_entries(effectiveness)
  `;
  await executeSchema(db, journalSchema);
  console.log('[Migration V1] Journal schema applied.');

  console.log('[Migration V1] Migration completed successfully.');
}

/**
 * Optional down migration to revert changes
 */
export async function down(db: SQLiteDatabase): Promise<void> {
  console.log('[Migration V1] Rolling back migration...');
  
  // Drop tables in reverse order of creation (for proper foreign key constraints)
  await db.execAsync('DROP TABLE IF EXISTS journal_entries');
  await db.execAsync('DROP TABLE IF EXISTS user_achievements');
  await db.execAsync('DROP TABLE IF EXISTS achievements');
  await db.execAsync('DROP TABLE IF EXISTS safety_records');
  await db.execAsync(`DROP TABLE IF EXISTS ${STRAINS_DATABASE_NAME}`);
  await db.execAsync(`DROP TABLE IF EXISTS ${BONG_HITS_DATABASE_NAME}`);
  
  console.log('[Migration V1] Migration rolled back successfully.');
} 

================================================================================
File: src/providers/AppProvider.tsx
================================================================================

import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';
import { DatabaseManager, databaseManager } from '../DatabaseManager';
import { BongHitsRepository } from '../repositories/BongHitsRepository';
import { StrainsRepository } from '../repositories/StrainsRepository';
import { StorageService } from '../services/StorageService';
import { DeviceService } from '../services/DeviceService';
import { BluetoothService } from '../services/BluetoothService';
import { AppSetupService } from '../services/AppSetupService';
import { BONG_HITS_DATABASE_NAME } from '../constants';
import { BluetoothHandler } from '../contexts/BluetoothContext';

// Define the AppContext type
interface AppContextType {
  databaseManager: DatabaseManager;
  bongHitsRepository: BongHitsRepository;
  strainsRepository: StrainsRepository;
  storageService: StorageService;
  deviceService: DeviceService;
  bluetoothService: BluetoothService;
  appSetupService: AppSetupService;
  initialized: boolean;
}

// Create the context with a default value
const AppContext = createContext<AppContextType | null>(null);

// Define the provider props
interface AppProviderProps {
  children: ReactNode;
  bluetoothHandler?: BluetoothHandler; // Optional existing bluetoothHandler
}

/**
 * AppProvider component that initializes all services and repositories
 * and provides them via React Context
 */
export const AppProvider: React.FC<AppProviderProps> = ({ children, bluetoothHandler }) => {
  const [initialized, setInitialized] = useState(false);
  const [services, setServices] = useState<AppContextType | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function setupApp() {
      try {
        console.log('Setting up app dependencies...');
        
        // Use singleton database manager instance
        const storageService = new StorageService();
        
        // Initialize database connections
        await databaseManager.initialize();
        
        // Use a single database connection for all repositories
        const db = await databaseManager.getDatabase(BONG_HITS_DATABASE_NAME);
        
        // Initialize repositories with the same database connection
        const bongHitsRepository = new BongHitsRepository(db);
        const strainsRepository = new StrainsRepository(db);
        
        // Initialize services that depend on repositories
        const deviceService = new DeviceService(storageService);
        const bluetoothService = new BluetoothService(
          deviceService,
          bongHitsRepository,
          bluetoothHandler
        );
        const appSetupService = new AppSetupService(
          storageService,
          databaseManager,
          strainsRepository
        );
        
        // Check if this is first launch and perform setup if needed
        await appSetupService.ensureInitialized();
        
        // Set all services in state for context
        setServices({
          databaseManager,
          bongHitsRepository,
          strainsRepository,
          storageService,
          deviceService,
          bluetoothService,
          appSetupService,
          initialized: true
        });
        
        setInitialized(true);
        console.log('App dependencies setup complete');
      } catch (err: any) {
        console.error('Error setting up app:', err);
        setError(err.message || 'Failed to initialize app');
      }
    }
    
    setupApp();
    
    // Cleanup function
    return () => {
      // Close database connections when app is unmounted
      if (services?.databaseManager) {
        services.databaseManager.cleanup().catch(err => {
          console.error('Error cleaning up database connections:', err);
        });
      }
    };
  }, [bluetoothHandler]);

  // Loading state
  if (!initialized || !services) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#00e676" />
        <Text style={{ marginTop: 20, color: '#fff' }}>Initializing app...</Text>
      </View>
    );
  }

  // Error state
  if (error) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text style={{ color: '#ff4444', fontSize: 16, marginBottom: 10 }}>
          Error
        </Text>
        <Text style={{ color: '#fff', textAlign: 'center', paddingHorizontal: 20 }}>
          {error}
        </Text>
      </View>
    );
  }

  // Render children with context
  return (
    <AppContext.Provider value={services}>
      {children}
    </AppContext.Provider>
  );
};

/**
 * Custom hook to use the app context
 * @returns AppContextType The app context
 * @throws Error if used outside of AppProvider
 */
export function useAppContext(): AppContextType {
  const context = useContext(AppContext);
  if (context === null) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
}

/**
 * Custom hook to get the BongHitsRepository
 * @returns BongHitsRepository The repository for bong hits data
 */
export function useBongHitsRepository(): BongHitsRepository {
  const { bongHitsRepository } = useAppContext();
  return bongHitsRepository;
}

/**
 * Custom hook to get the StrainsRepository
 * @returns StrainsRepository The repository for strains data
 */
export function useStrainsRepository(): StrainsRepository {
  const { strainsRepository } = useAppContext();
  return strainsRepository;
}

/**
 * Custom hook to get the StorageService
 * @returns StorageService The service for async storage operations
 */
export function useStorageService(): StorageService {
  const { storageService } = useAppContext();
  return storageService;
}

/**
 * Custom hook to get the DeviceService
 * @returns DeviceService The service for device management
 */
export function useDeviceService(): DeviceService {
  const { deviceService } = useAppContext();
  return deviceService;
}

/**
 * Custom hook to get the BluetoothService
 * @returns BluetoothService The service for Bluetooth operations
 */
export function useBluetoothService(): BluetoothService {
  const { bluetoothService } = useAppContext();
  return bluetoothService;
}

/**
 * Custom hook to get the AppSetupService
 * @returns AppSetupService The service for app setup
 */
export function useAppSetupService(): AppSetupService {
  const { appSetupService } = useAppContext();
  return appSetupService;
} 

================================================================================
File: src/repositories/AchievementsRepository.ts
================================================================================

import { SQLiteDatabase } from 'expo-sqlite';
import { BaseRepository } from './BaseRepository';
import { UserAchievementWithDetails } from '../types';
import { validateNotEmpty } from '../utils/validators';
import { ACHIEVEMENTS } from '../constants';

/**
 * Repository for managing achievement data
 */
export class AchievementsRepository extends BaseRepository {
  /**
   * Constructor for AchievementsRepository
   * @param db SQLite database connection
   */
  constructor(db: SQLiteDatabase) {
    super(db);
  }

  /**
   * Initializes the achievements table with data from ACHIEVEMENTS constant if it's empty
   */
  public async initializeData(): Promise<void> {
    try {
      console.log('[AchievementsRepository] Checking if achievements need to be seeded...');
      
      // Check if achievements table is already populated
      const result = await this.db.getFirstAsync<{ count: number }>(
        `SELECT COUNT(*) as count FROM achievements`
      );
      
      const count = result?.count ?? 0;
      
      if (count === 0) {
        console.log('[AchievementsRepository] Seeding achievements data...');
        
        // Use a transaction for better performance and atomicity
        await this.executeTransaction(async () => {
          for (const achievement of ACHIEVEMENTS) {
            await this.db.runAsync(
              `INSERT INTO achievements (
                id, category, name, unlock_condition, notes, icon, complexity
              ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
              [
                achievement.id,
                achievement.category,
                achievement.name,
                achievement.unlockCondition,
                achievement.notes || null,
                achievement.icon || null,
                achievement.complexity || 1
              ]
            );
          }
        });
        
        console.log(`[AchievementsRepository] Seeded ${ACHIEVEMENTS.length} achievements.`);
      } else {
        console.log(`[AchievementsRepository] Achievements table already contains ${count} records.`);
      }
    } catch (error) {
      console.error('[AchievementsRepository] Failed to initialize achievements data:', error);
      throw error;
    }
  }

  /**
   * Get achievements for a user with details
   * @param userId The user ID
   * @returns List of user achievements with details
   */
  async getUserAchievements(userId: string): Promise<UserAchievementWithDetails[]> {
    try {
      validateNotEmpty(userId, 'userId');

      const query = `
        SELECT 
          a.id, 
          a.category, 
          a.name, 
          a.unlock_condition AS unlockCondition, 
          a.notes, 
          a.icon, 
          a.complexity,
          ua.progress, 
          ua.date_unlocked AS dateUnlocked, 
          ua.is_unlocked AS isUnlocked,
          ua.is_new AS isNew
        FROM achievements a
        LEFT JOIN user_achievements ua ON a.id = ua.achievement_id AND ua.user_id = ?
        ORDER BY a.category, a.name
      `;

      const achievements = await this.db.getAllAsync<UserAchievementWithDetails>(query, [userId]);
      return achievements || [];
    } catch (error) {
      console.error('[AchievementsRepository] Error getting user achievements:', error);
      return [];
    }
  }

  /**
   * Clear the 'new' flag for achievements that have been viewed
   * @param userId The user ID
   */
  async clearAchievementNewFlags(userId: string): Promise<void> {
    try {
      validateNotEmpty(userId, 'userId');

      await this.db.runAsync(
        'UPDATE user_achievements SET is_new = 0 WHERE user_id = ? AND is_new = 1',
        [userId]
      );
    } catch (error) {
      console.error('[AchievementsRepository] Error clearing achievement new flags:', error);
    }
  }

  /**
   * Check for achievements that may be unlocked based on an action
   * @param userId The user ID
   * @param actionType The type of action performed
   * @param actionData Data associated with the action
   * @returns Newly unlocked achievements
   */
  async checkAchievements(
    userId: string, 
    actionType: string, 
    actionData: any
  ): Promise<UserAchievementWithDetails[]> {
    try {
      validateNotEmpty(userId, 'userId');
      validateNotEmpty(actionType, 'actionType');

      // Start a transaction
      await this.db.execAsync('BEGIN TRANSACTION');

      // Get achievements that could be affected by this action type
      const eligibleAchievements = await this.db.getAllAsync<{
        id: number;
        name: string;
        category: string;
        unlockCondition: string;
        notes: string;
        icon: string;
        complexity: number;
      }>(`
        SELECT 
          id, 
          name, 
          category, 
          unlock_condition AS unlockCondition, 
          notes, 
          icon, 
          complexity
        FROM achievements 
        WHERE unlock_condition LIKE ?
      `, [`%${actionType}%`]);

      if (!eligibleAchievements || eligibleAchievements.length === 0) {
        await this.db.execAsync('COMMIT');
        return [];
      }

      // For each eligible achievement, check if it should be unlocked
      const newlyUnlocked: UserAchievementWithDetails[] = [];

      for (const achievement of eligibleAchievements) {
        // Check if already unlocked
        const userAchievement = await this.db.getFirstAsync<{
          isUnlocked: number;
          progress: number;
        }>(`
          SELECT is_unlocked AS isUnlocked, progress 
          FROM user_achievements 
          WHERE user_id = ? AND achievement_id = ?
        `, [userId, achievement.id]);

        // If already unlocked, skip
        if (userAchievement?.isUnlocked) continue;

        // Calculate new progress based on the action
        let newProgress = userAchievement?.progress || 0;
        let shouldUnlock = false;

        // Different logic based on action type
        switch (actionType) {
          case 'bong_hit_recorded':
            // For bong hit related achievements
            newProgress = await this.calculateBongHitProgress(userId, achievement.id);
            shouldUnlock = newProgress >= 100;
            break;
          
          case 'strain_added':
            // For strain related achievements
            newProgress = await this.calculateStrainProgress(userId, achievement.id);
            shouldUnlock = newProgress >= 100;
            break;
            
          // Add more action types as needed
            
          default:
            newProgress = Math.min(100, newProgress + 10); // Default increment
            shouldUnlock = newProgress >= 100;
        }

        // Insert or update user achievement record
        if (userAchievement) {
          // Update existing record
          await this.db.runAsync(`
            UPDATE user_achievements 
            SET 
              progress = ?, 
              is_unlocked = ?, 
              date_unlocked = ?, 
              is_new = ?
            WHERE user_id = ? AND achievement_id = ?
          `, [
            newProgress,
            shouldUnlock ? 1 : 0,
            shouldUnlock ? new Date().toISOString() : null,
            shouldUnlock ? 1 : 0,
            userId,
            achievement.id
          ]);
        } else {
          // Insert new record
          await this.db.runAsync(`
            INSERT INTO user_achievements (
              user_id, 
              achievement_id, 
              progress, 
              is_unlocked, 
              date_unlocked, 
              is_new
            ) VALUES (?, ?, ?, ?, ?, ?)
          `, [
            userId,
            achievement.id,
            newProgress,
            shouldUnlock ? 1 : 0,
            shouldUnlock ? new Date().toISOString() : null,
            shouldUnlock ? 1 : 0
          ]);
        }

        // If newly unlocked, add to return array
        if (shouldUnlock) {
          newlyUnlocked.push({
            ...achievement,
            userId,
            achievementId: achievement.id,
            progress: 100,
            isUnlocked: true,
            dateUnlocked: new Date().toISOString(),
            isNew: true
          });
        }
      }

      await this.db.execAsync('COMMIT');
      return newlyUnlocked;
    } catch (error) {
      // Rollback on error
      try {
        await this.db.execAsync('ROLLBACK');
      } catch (rollbackError) {
        console.error('[AchievementsRepository] Error rolling back transaction:', rollbackError);
      }
      
      console.error('[AchievementsRepository] Error checking achievements:', error);
      return [];
    }
  }

  /**
   * Calculate progress for bong hit related achievements
   * @private
   */
  private async calculateBongHitProgress(userId: string, achievementId: number): Promise<number> {
    try {
      // Get achievement details to determine criteria
      const achievement = await this.db.getFirstAsync<{ unlockCondition: string }>(
        'SELECT unlock_condition AS unlockCondition FROM achievements WHERE id = ?',
        [achievementId]
      );

      if (!achievement) return 0;

      // Calculate progress based on unlock condition
      if (achievement.unlockCondition.includes('first_bong_hit')) {
        // Check if user has any bong hits
        const hitCount = await this.db.getFirstAsync<{ count: number }>(
          'SELECT COUNT(*) as count FROM bong_hits',
          []
        );
        return hitCount && hitCount.count > 0 ? 100 : 0;
      }

      if (achievement.unlockCondition.includes('hit_count_10')) {
        // Check if user has at least 10 bong hits
        const hitCount = await this.db.getFirstAsync<{ count: number }>(
          'SELECT COUNT(*) as count FROM bong_hits',
          []
        );
        return hitCount ? Math.min(100, (hitCount.count / 10) * 100) : 0;
      }

      // Add more achievement criteria as needed
      
      return 0;
    } catch (error) {
      console.error('[AchievementsRepository] Error calculating bong hit progress:', error);
      return 0;
    }
  }

  /**
   * Calculate progress for strain related achievements
   * @private
   */
  private async calculateStrainProgress(userId: string, achievementId: number): Promise<number> {
    try {
      // Similar implementation to calculateBongHitProgress but for strains
      return 0;
    } catch (error) {
      console.error('[AchievementsRepository] Error calculating strain progress:', error);
      return 0;
    }
  }
} 

================================================================================
File: src/repositories/BaseRepository.ts
================================================================================

import { SQLiteDatabase } from "expo-sqlite";
import { DatabaseResponse } from "../types";

/**
 * Base Repository class that all repositories will extend
 * Provides common functionality like transaction management
 */
export class BaseRepository {
  protected db: SQLiteDatabase;

  /**
   * Constructor for the repository
   * @param db SQLiteDatabase instance from DatabaseManager
   */
  constructor(db: SQLiteDatabase) {
    this.db = db;
  }

  /**
   * Execute multiple database operations in a transaction
   * @param operations Function containing database operations to execute in transaction
   * @returns Result of operations
   */
  protected async executeTransaction<T>(operations: () => Promise<T>): Promise<T> {
    try {
      await this.db.execAsync('BEGIN TRANSACTION');
      const result = await operations();
      await this.db.execAsync('COMMIT');
      return result;
    } catch (error) {
      console.error('[Transaction] Error during transaction, rolling back:', error);
      try {
        await this.db.execAsync('ROLLBACK');
      } catch (rollbackError) {
        console.error('[Transaction] Error rolling back transaction:', rollbackError);
      }
      throw error;
    }
  }

  /**
   * Standard error handler for database operations
   * @param error The error that occurred
   * @param operation Description of the operation that failed
   * @returns Standardized error response
   */
  protected handleError<T>(error: unknown, operation: string): DatabaseResponse<T> {
    const errorMessage = error instanceof Error ? error.message : `Failed to ${operation}`;
    console.error(`[Repository] Error in ${operation}:`, error);
    return {
      success: false,
      error: errorMessage
    };
  }
} 

================================================================================
File: src/repositories/BongHitsRepository.ts
================================================================================

import { BaseRepository } from "./BaseRepository";
import { 
  BongHit, 
  BongHitStats, 
  Datapoint, 
  AverageHourCount, 
  DatabaseResponse,
  ChartDataPoint,
  UsageStats,
  TimeDistribution,
} from "../types";
import { BONG_HITS_DATABASE_NAME, dayLookUpTable } from "../constants";
import { validateBongHit } from "../utils/validators";
import { getWeeklyStatsQuery, getMonthlyStatsQuery, getTimeDistributionQuery, getUsageStatsQuery, getDateRangeFilter } from "../utils/SqlTemplates";

/**
 * Repository for managing bong hit data
 */
export class BongHitsRepository extends BaseRepository {
  /**
   * Record a new bong hit
   * @param timestamp ISO string timestamp of the hit
   * @param durationMs Duration of the hit in milliseconds
   */
  public async recordBongHit(timestamp: string, durationMs: number): Promise<void> {
    const hit: BongHit = { timestamp: timestamp, duration_ms: durationMs };
    const validationError = validateBongHit(hit);
    
    if (validationError) {
      console.error(`[BongHitsRepository] Validation error: ${validationError}`);
      throw new Error(validationError);
    }
    
    try {
      await this.executeTransaction(async () => {
        await this.db.runAsync(
          `INSERT INTO ${BONG_HITS_DATABASE_NAME} (timestamp, duration_ms) 
           VALUES (?, ?)`,
          [timestamp, durationMs]
        );
      });
    } catch (error) {
      console.error('[BongHitsRepository] Error recording bong hit:', error);
      throw error;
    }
  }

  /**
   * Retrieves average and max duration over the past n days
   * @param days Number of days to look back
   */
  public async getBongHitStats(days?: number, range?: { startDate: Date, endDate: Date }): Promise<BongHitStats> {
    try {
      let filterClause = '';
      let filterParams: string[] = [];

      if (range) {
        const { clause, params } = getDateRangeFilter(range.startDate.toISOString(), range.endDate.toISOString());
        filterClause = clause;
        filterParams = params;
      } else if (days) {
        const startDate = this.getStartDateISO(days);
        const { clause, params } = getDateRangeFilter(startDate);
        filterClause = clause;
        filterParams = params;
      }
      // If neither is provided, query runs without date filter

      const query = `
        SELECT
          AVG(duration_ms) AS avg_duration,
          MAX(duration_ms) AS max_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        ${filterClause}
      `;
      console.log(`[BongHitsRepository] getBongHitStats Query: ${query}, Params: ${JSON.stringify(filterParams)}`);
      const results = await this.db.getAllAsync<{avg_duration: number, max_duration: number}>(query, filterParams);
      
      if (!results.length) return this.validateBongHitStats({ averageDuration: 0, longestHit: 0 });
      const row = results[0];
      return this.validateBongHitStats({ averageDuration: row.avg_duration || 0, longestHit: row.max_duration || 0 });
    } catch (error) {
      console.error("[BongHitsRepository] Error in getBongHitStats:", error);
      throw error;
    }
  }

  /**
   * Counts hits per day over the past week (filling day indices 0..6)
   * @param days Number of days to look back
   */
  public async getHitsPerDay(days?: number, range?: { startDate: Date, endDate: Date }): Promise<DatabaseResponse<Datapoint[]>> {
    try {
      let filterClause = '';
      let filterParams: string[] = [];

      if (range) {
        const { clause, params } = getDateRangeFilter(range.startDate.toISOString(), range.endDate.toISOString());
        filterClause = clause;
        filterParams = params;
      } else if (days) {
        const startDate = this.getStartDateISO(days);
        const { clause, params } = getDateRangeFilter(startDate);
        filterClause = clause;
        filterParams = params;
      }

      const query = `
        SELECT 
          strftime('%w', timestamp, 'utc') AS day,
          COUNT(*) AS hit_count
        FROM ${BONG_HITS_DATABASE_NAME}
        ${filterClause}
        GROUP BY day
        ORDER BY day
      `;
      console.log(`[BongHitsRepository] getHitsPerDay Query: ${query}, Params: ${JSON.stringify(filterParams)}`);
      const results = await this.db.getAllAsync<{day: string, hit_count: number}>(query, filterParams);

      // Prepare an array for Sunday..Saturday
      const weekData: Datapoint[] = Array.from({ length: 7 }, (_, i) => ({
        x: dayLookUpTable.get(i) || "", // Use Map for day names
        y: 0,
      }));

      // Populate with actual data
      results.forEach(row => {
        const dayIndex = parseInt(row.day, 10);
        if (dayIndex >= 0 && dayIndex < 7) {
          weekData[dayIndex] = this.validateDatapoint({
            label: dayLookUpTable.get(dayIndex) || "", // Use Map
            value: row.hit_count,
          });
        }
      });

      return { success: true, data: weekData };
    } catch (error) {
      return this.handleError(error, "getHitsPerDay");
    }
  }

  /**
   * Returns a list of (hourOfDay -> # of hits) since n days ago,
   * filling missing hours with 0
   * @param days Number of days to look back
   */
  public async getHourlyAverages(days: number = 7): Promise<DatabaseResponse<AverageHourCount[]>> {
    try {
      // Calculate start date based on days parameter
      const startDate = this.getStartDateISO(days);
      
      const results = await this.db.getAllAsync<{hourOfDay: string, count: number}>(`
        SELECT 
          strftime('%H', timestamp) AS hourOfDay,
          COUNT(*) AS count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= ?
        GROUP BY hourOfDay
        ORDER BY hourOfDay
      `, [startDate]);

      // Hours "00" through "23"
      const allHours = Array.from({ length: 24 }, (_, i) => i.toString().padStart(2, "0"));
      const dataMap = new Map<string, number>(
        results.map(item => [item.hourOfDay, item.count])
      );

      const data = allHours.map((hour) =>
        this.validateAverageHourCount({
          hourOfDay: hour,
          count: dataMap.get(hour) || 0,
        })
      );

      return {
        success: true,
        data
      };
    } catch (error) {
      return this.handleError(error, "getHourlyAverages");
    }
  }

  /**
   * Get weekly statistics
   * @param days Number of days to look back
   */
  public async getWeeklyStats(days: number = 30): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      // Calculate start date based on days parameter
      const startDate = this.getStartDateISO(days);
      
      // Modify SQL template to accept date parameter
      const templateQuery = getWeeklyStatsQuery(BONG_HITS_DATABASE_NAME);
      const query = templateQuery.replace(/WHERE timestamp >= '[^']+'/g, 'WHERE timestamp >= ?');
      
      const weekData = await this.db.getAllAsync<{ label: string; value: number; avg_duration: number }>(
        query, [startDate]
      );
      
      if (!weekData || weekData.length === 0) {
        return {
          success: true,
          data: []
        };
      }
      
      // Format data for chart display
      const data: ChartDataPoint[] = weekData.map(point => ({
        label: point.label,
        value: parseInt(String(point.value || 0)),
        meta: { avgDuration: Math.round(point.avg_duration || 0) }
      }));
      
      return { success: true, data };
    } catch (error) {
      return this.handleError(error, 'getWeeklyStats');
    }
  }
  
  /**
   * Get monthly statistics
   * @param days Number of days to look back
   */
  public async getMonthlyStats(days: number = 90): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      // Calculate start date based on days parameter
      const startDate = this.getStartDateISO(days);
      
      // Modify SQL template to accept date parameter
      const templateQuery = getMonthlyStatsQuery(BONG_HITS_DATABASE_NAME);
      const query = templateQuery.replace(/WHERE timestamp >= '[^']+'/g, 'WHERE timestamp >= ?');
      
      const monthData = await this.db.getAllAsync<{ label: string; value: number; avg_duration: number }>(
        query, [startDate]
      );
      
      if (!monthData || monthData.length === 0) {
        return {
          success: true,
          data: []
        };
      }
      
      // Format data for chart display
      const data: ChartDataPoint[] = monthData.map(point => ({
        label: point.label,
        value: parseInt(String(point.value || 0)),
        meta: { avgDuration: Math.round(point.avg_duration || 0) }
      }));
      
      return { success: true, data };
    } catch (error) {
      return this.handleError(error, 'getMonthlyStats');
    }
  }

  /**
   * Get time distribution of usage
   * @param days Number of days to look back
   */
  public async getTimeDistribution(days: number = 30): Promise<DatabaseResponse<TimeDistribution>> {
    try {
      // Calculate start date based on days parameter
      const startDate = this.getStartDateISO(days);
      
      // Modify SQL template to accept date parameter
      const templateQuery = getTimeDistributionQuery(BONG_HITS_DATABASE_NAME);
      const { clause, params } = getDateRangeFilter(startDate);
      const finalQuery = templateQuery.replace('-- DATE FILTER ADDED EXTERNALLY', clause);
      
      // Execute query with proper params
      const result = await this.db.getFirstAsync<TimeDistribution>(finalQuery, params);
      
      if (!result) {
        return {
          success: true,
          data: {
            morning: 0,
            afternoon: 0,
            evening: 0,
            night: 0
          }
        };
      }
      
      return {
        success: true,
        data: {
          morning: result.morning || 0,
          afternoon: result.afternoon || 0,
          evening: result.evening || 0,
          night: result.night || 0
        }
      };
    } catch (error) {
      return this.handleError(error, 'getTimeDistribution');
    }
  }

  /**
   * Get usage statistics
   * @param days Number of days to look back
   */
  public async getUsageStats(days: number = 30): Promise<DatabaseResponse<UsageStats>> {
    try {
      // Calculate start date based on days parameter
      const startDate = this.getStartDateISO(days);
      
      // Modify SQL template to accept date parameter
      const templateQuery = getUsageStatsQuery(BONG_HITS_DATABASE_NAME);
      const { clause, params } = getDateRangeFilter(startDate);
      const finalQuery = templateQuery.replace('-- DATE FILTER ADDED EXTERNALLY', clause);
      
      // Execute the query
      const rawStats = await this.db.getFirstAsync<any>(finalQuery, params);
      
      if (!rawStats) {
        return {
          success: true,
          data: this.createEmptyUsageStats()
        };
      }
      
      // Fetch daily patterns
      const { weekdayAvg, weekendAvg } = await this.calculateWeekdayWeekendAverage(startDate);
      
      // Format the usage stats
      const usageStats: UsageStats = {
        totalHits: rawStats.total_hits || 0,
        averageHitsPerDay: rawStats.avg_hits_per_active_day || 0,
        peakDayHits: rawStats.max_hits_in_day || 0,
        lowestDayHits: rawStats.min_hits_in_day || 0,
        averageDuration: rawStats.avg_duration_ms || 0,
        totalDuration: rawStats.total_duration_ms || 0,
        longestHit: rawStats.longest_hit || 0,
        shortestHit: rawStats.shortest_hit || 0,
        mostActiveHour: rawStats.most_active_hour || 0,
        leastActiveHour: rawStats.least_active_hour || 0,
        
        // For these more complex statistics, we'd need to do deeper analysis
        averageHitsPerHour: 0, // Not implemented yet
        consistency: 0, // Not implemented yet
        
        // Weekday vs Weekend stats
        weekdayStats: {
          weekday: { avg: weekdayAvg, total: 0 }, // We're only interested in the average
          weekend: { avg: weekendAvg, total: 0 }  // Total counts less relevant for comparison
        }
      };
      
      return { success: true, data: usageStats };
    } catch (error) {
      return this.handleError(error, 'getUsageStats');
    }
  }

  /**
   * Get all bong hit logs from the database
   */
  public async getAllBongHitLogs(): Promise<DatabaseResponse<BongHit[]>> {
    try {
      const results = await this.db.getAllAsync<BongHit>(`
        SELECT 
          timestamp,
          duration_ms
        FROM ${BONG_HITS_DATABASE_NAME}
        ORDER BY timestamp DESC
      `);

      return {
        success: true,
        data: results
      };
    } catch (error) {
      return this.handleError(error, 'getAllBongHitLogs');
    }
  }

  /**
   * Calculate the standard deviation of an array of numbers
   */
  private calculateStandardDeviation(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDifferences = values.map(val => Math.pow(val - mean, 2));
    const variance = squaredDifferences.reduce((sum, val) => sum + val, 0) / values.length;
    
    return Math.sqrt(variance);
  }

  /**
   * Helper to get ISO date string for n days ago
   */
  private getStartDateISO(days: number): string {
    const date = new Date();
    date.setDate(date.getDate() - days);
    return date.toISOString();
  }

  /**
   * Validate BongHitStats to ensure correct types/values
   */
  private validateBongHitStats = (stats: BongHitStats): BongHitStats => ({
    averageDuration: Math.max(0, Number(stats.averageDuration) || 0),
    longestHit: Math.max(0, Number(stats.longestHit) || 0),
  });

  /**
   * Convert ChartDataPoint to Datapoint
   */
  private chartDataToDatapoint(point: ChartDataPoint): Datapoint {
    return {
      x: point.label,
      y: point.value
    };
  }

  /**
   * Validate Datapoint to ensure correct types/values
   */
  private validateDatapoint = (point: {label: string, value: number}): Datapoint => ({
    x: String(point.label || ""),
    y: Math.max(0, Number(point.value) || 0),
  });

  /**
   * Validate AverageHourCount to ensure correct types/values
   */
  private validateAverageHourCount = (count: AverageHourCount): AverageHourCount => ({
    hourOfDay: String(count.hourOfDay || "00"),
    count: Math.max(0, Number(count.count) || 0),
  });

  /**
   * Get the number of hits recorded on a specific date.
   * @param date The date to check (as a Date object).
   */
  public async getHitsForDate(date: Date): Promise<DatabaseResponse<number>> {
    const startOfDay = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
    const endOfDay = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
    return this.getHitCountForDateRange(startOfDay, endOfDay);
  }

  /**
   * Gets the total hit count within a specific date range.
   * @param startDate The start date (local).
   * @param endDate The end date (local).
   */
  public async getHitCountForDateRange(startDate: Date, endDate: Date): Promise<DatabaseResponse<number>> {
    try {
      // Convert local Date objects to ISO strings for the filter function
      const startDateStr = startDate.toISOString();
      const endDateStr = endDate.toISOString();

      console.log(`[BongHitsRepository] Fetching hit count for range: ${startDateStr} to ${endDateStr}`);

      const { clause, params } = getDateRangeFilter(startDateStr, endDateStr);

      const query = `
        SELECT COUNT(*) as count
        FROM ${BONG_HITS_DATABASE_NAME}
        ${clause}
      `;

      console.log(`[BongHitsRepository] getHitCountForDateRange Query: ${query}, Params: ${JSON.stringify(params)}`);
      const result = await this.db.getFirstAsync<{ count: number }>(query, params);

      const count = result?.count ?? 0;
      console.log(`[BongHitsRepository] Hits found for range: ${count}`);

      return { success: true, data: count };
    } catch (error) {
      console.error(`[BongHitsRepository] Error getting hit count for range:`, error);
      return this.handleError(error, "getHitCountForDateRange");
    }
  }

  /**
   * Gets the average hits per day within a specific date range.
   * @param startDate The start date (local).
   * @param endDate The end date (local).
   */
  public async getAverageHitsPerDayForDateRange(startDate: Date, endDate: Date): Promise<DatabaseResponse<number>> {
    try {
      const startDateStr = startDate.toISOString();
      const endDateStr = endDate.toISOString();

      console.log(`[BongHitsRepository] Calculating average hits for range: ${startDateStr} to ${endDateStr}`);

      const { clause, params } = getDateRangeFilter(startDateStr, endDateStr);

      const query = `
        SELECT
          COUNT(*) as total_hits,
          COUNT(DISTINCT strftime('%Y-%m-%d', timestamp, 'utc')) as active_days_in_range
        FROM ${BONG_HITS_DATABASE_NAME}
        ${clause}
      `;

      console.log(`[BongHitsRepository] Range Avg Query: ${query}, Params: ${JSON.stringify(params)}`);
      const result = await this.db.getFirstAsync<{ total_hits: number; active_days_in_range: number }>(query, params);

      const totalHits = result?.total_hits ?? 0;
      const activeDays = result?.active_days_in_range ?? 0;

      // Calculate duration of the range in days for averaging
      const diffTime = Math.abs(endDate.getTime() - startDate.getTime());
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      const numberOfDaysInRange = Math.max(1, diffDays); // Ensure at least 1 day

      // Average based on the number of days in the range
      const average = numberOfDaysInRange > 0 ? totalHits / numberOfDaysInRange : 0;

      console.log(`[BongHitsRepository] Range Hits: ${totalHits}, Days in Range: ${numberOfDaysInRange}, Average: ${average}`);

      return { success: true, data: average };
    } catch (error) {
      console.error(`[BongHitsRepository] Error getting average hits for range:`, error);
      return this.handleError(error, "getAverageHitsPerDayForDateRange");
    }
  }

  /**
   * Gets the average hits per day for the current calendar week (Sunday to Saturday).
   */
  public async getAverageHitsForCurrentWeek(): Promise<DatabaseResponse<number>> {
    const now = new Date();
    const todayDayOfWeek = now.getDay(); // 0 = Sunday

    // Calculate start of the week (Sunday)
    const startOfWeek = new Date(now);
    startOfWeek.setDate(now.getDate() - todayDayOfWeek);
    startOfWeek.setHours(0, 0, 0, 0);

    // Use end of *today* for the range
    const endOfToday = new Date();
    endOfToday.setHours(23, 59, 59, 999);

    // Fetch total hits for the range Sun -> Today
    const hitsResponse = await this.getHitCountForDateRange(startOfWeek, endOfToday);

    if (!hitsResponse.success) {
      return hitsResponse; // Propagate error
    }

    const totalHits = hitsResponse.data ?? 0;
    const daysPassedInWeek = todayDayOfWeek + 1; // 1 for Sun, ..., 7 for Sat
    const average = daysPassedInWeek > 0 ? totalHits / daysPassedInWeek : 0;

    console.log(`[BongHitsRepository] Current Week Avg Recalculated - Hits: ${totalHits}, Days Passed: ${daysPassedInWeek}, Average: ${average}`);
    return { success: true, data: average };
  }

  /**
   * Helper method to create empty usage stats object
   */
  private createEmptyUsageStats(): UsageStats {
    return {
      totalHits: 0,
      averageHitsPerDay: 0,
      averageHitsPerHour: 0,
      averageDuration: 0,
      totalDuration: 0,
      peakDayHits: 0,
      lowestDayHits: 0,
      mostActiveHour: 0,
      leastActiveHour: 0,
      longestHit: 0,
      shortestHit: 0,
      consistency: 0,
      weekdayStats: {
        weekday: { total: 0, avg: 0 },
        weekend: { total: 0, avg: 0 }
      }
    };
  }

  /**
   * Calculate average hits for weekdays and weekends
   */
  private async calculateWeekdayWeekendAverage(startDate: string): Promise<{ weekdayAvg: number, weekendAvg: number }> {
    try {
      const query = `
        WITH DayStats AS (
          SELECT 
            CASE WHEN strftime('%w', timestamp, 'utc') IN ('0', '6') THEN 'weekend' ELSE 'weekday' END as day_type,
            strftime('%Y-%m-%d', timestamp, 'utc') as date,
            COUNT(*) as hits
          FROM ${BONG_HITS_DATABASE_NAME}
          WHERE timestamp >= ?
          GROUP BY day_type, date
        )
        SELECT 
          day_type,
          AVG(hits) as avg_hits
        FROM DayStats
        GROUP BY day_type
      `;
      
      const results = await this.db.getAllAsync<{ day_type: string, avg_hits: number }>(query, [startDate]);
      
      let weekdayAvg = 0;
      let weekendAvg = 0;
      
      results.forEach(row => {
        if (row.day_type === 'weekday') {
          weekdayAvg = row.avg_hits || 0;
        } else {
          weekendAvg = row.avg_hits || 0;
        }
      });
      
      return { weekdayAvg, weekendAvg };
    } catch (error) {
      console.error('[BongHitsRepository] Error calculating weekday/weekend averages:', error);
      return { weekdayAvg: 0, weekendAvg: 0 };
    }
  }

  /**
   * Gets hourly averages for a specific day, grouped into 3-hour segments for better visualization
   * @param startDate The start date (local).
   * @param endDate The end date (local).
   */
  public async getHourlyAveragesForDay(startDate: Date, endDate: Date): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      const startDateStr = startDate.toISOString();
      const endDateStr = endDate.toISOString();
      const { clause, params } = getDateRangeFilter(startDateStr, endDateStr);

      // Group by hour of day in local time
      const query = `
        SELECT
          strftime('%H', timestamp, 'localtime') AS hourOfDay, 
          COUNT(*) AS count
        FROM ${BONG_HITS_DATABASE_NAME}
        ${clause}
        GROUP BY hourOfDay
        ORDER BY hourOfDay
      `;
      
      console.log(`[BongHitsRepository] getHourlyAveragesForDay Query: ${query}, Params: ${JSON.stringify(params)}`);
      const results = await this.db.getAllAsync<{hourOfDay: string, count: number}>(query, params);

      // Fill missing hours with zeros and create 3-hour segments
      const hourSegments = [
        { label: "12-3 AM", hours: ["00", "01", "02"], value: 0 },
        { label: "3-6 AM", hours: ["03", "04", "05"], value: 0 },
        { label: "6-9 AM", hours: ["06", "07", "08"], value: 0 },
        { label: "9-12 PM", hours: ["09", "10", "11"], value: 0 },
        { label: "12-3 PM", hours: ["12", "13", "14"], value: 0 },
        { label: "3-6 PM", hours: ["15", "16", "17"], value: 0 },
        { label: "6-9 PM", hours: ["18", "19", "20"], value: 0 },
        { label: "9-12 AM", hours: ["21", "22", "23"], value: 0 }
      ];

      // Map hourOfDay -> count for easy lookup
      const hourMap = new Map<string, number>();
      results.forEach(row => {
        hourMap.set(row.hourOfDay, row.count);
      });

      // Aggregate hours into segments
      hourSegments.forEach(segment => {
        segment.hours.forEach(hour => {
          segment.value += hourMap.get(hour) || 0;
        });
      });

      // Convert to ChartDataPoint
      const data: ChartDataPoint[] = hourSegments.map(segment => ({
        label: segment.label,
        value: segment.value
      }));

      return { success: true, data };
    } catch (error) {
      console.error(`[BongHitsRepository] Error getting hourly averages for day:`, error);
      return this.handleError(error, "getHourlyAveragesForDay");
    }
  }

  /**
   * Gets hits grouped by day of the month and organized into weeks
   * @param startDate The start date (local).
   * @param endDate The end date (local).
   */
  public async getHitsByDayOfMonth(startDate: Date, endDate: Date): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      const startDateStr = startDate.toISOString();
      const endDateStr = endDate.toISOString();
      const { clause, params } = getDateRangeFilter(startDateStr, endDateStr);

      // Query to get hits by date
      const query = `
        SELECT
          strftime('%Y-%m-%d', timestamp, 'localtime') as date,
          COUNT(*) as count
        FROM ${BONG_HITS_DATABASE_NAME}
        ${clause}
        GROUP BY date
        ORDER BY date ASC
      `;

      console.log(`[BongHitsRepository] getHitsByDayOfMonth Query: ${query}, Params: ${JSON.stringify(params)}`);
      const results = await this.db.getAllAsync<{ date: string; count: number }>(query, params);

      // If no results, return empty array
      if (!results || results.length === 0) {
        return { success: true, data: [] };
      }

      // Group days into week segments
      const firstDate = new Date(results[0].date);
      const weekSunday = new Date(firstDate);
      weekSunday.setDate(firstDate.getDate() - firstDate.getDay()); // Go back to the previous Sunday

      // Prepare week segments
      const weekSegments: { startDate: Date; endDate: Date; label: string; value: number }[] = [];
      let currentWeekStart = new Date(weekSunday);

      // Create segments for the weeks in the month
      for (let i = 0; i < 5; i++) { // Max 5 weeks in a month
        const weekEnd = new Date(currentWeekStart);
        weekEnd.setDate(currentWeekStart.getDate() + 6); // Saturday

        if (weekEnd < startDate) {
          // Skip weeks before our date range
          currentWeekStart.setDate(currentWeekStart.getDate() + 7);
          continue;
        }

        if (currentWeekStart > endDate) {
          // Stop if we've gone beyond our date range
          break;
        }

        const formattedStartDate = `${currentWeekStart.getDate()}`;
        const formattedEndDate = `${weekEnd.getDate()}`;

        weekSegments.push({
          startDate: new Date(currentWeekStart),
          endDate: new Date(weekEnd),
          label: `${formattedStartDate}-${formattedEndDate}`,
          value: 0
        });

        currentWeekStart.setDate(currentWeekStart.getDate() + 7);
      }

      // Map date string -> count for easy lookup
      const dateMap = new Map<string, number>();
      results.forEach(row => {
        dateMap.set(row.date, row.count);
      });

      // Aggregate days into week segments
      for (const segment of weekSegments) {
        let currentDate = new Date(segment.startDate);
        while (currentDate <= segment.endDate) {
          const dateString = currentDate.toISOString().split('T')[0]; // YYYY-MM-DD
          segment.value += dateMap.get(dateString) || 0;
          currentDate.setDate(currentDate.getDate() + 1);
        }
      }

      // Convert to ChartDataPoint
      const data: ChartDataPoint[] = weekSegments.map(segment => ({
        label: segment.label,
        value: segment.value
      }));

      return { success: true, data };
    } catch (error) {
      console.error(`[BongHitsRepository] Error getting hits by day of month:`, error);
      return this.handleError(error, "getHitsByDayOfMonth");
    }
  }
} 

================================================================================
File: src/repositories/StrainsRepository.ts
================================================================================

import { BaseRepository } from "./BaseRepository";
import { 
  Strain, 
  DatabaseResponse,
  StrainSearchFilters,
  PaginationParams,
  StrainSearchResult
} from "../types";
import { STRAINS_DATABASE_NAME, SAMPLE_STRAINS } from "../constants";
import { validateStrain, createValidationError, createValidationSuccess, ValidationResult } from "../utils/validators";

/**
 * Repository for managing strain data
 */
export class StrainsRepository extends BaseRepository {
  /**
   * Initialize the strains database with sample data if empty
   */
  public async initializeData(): Promise<void> {
    try {
      // Check if we already have strains data
      const result = await this.db.getFirstAsync<{ count: number }>(
        `SELECT COUNT(*) as count FROM ${STRAINS_DATABASE_NAME}`
      );
      
      const count = result?.count ?? 0;
      
      if (count === 0) {
        console.log('[StrainsRepository] Inserting initial strain data...');
        
        // Use a transaction for better performance and atomicity
        await this.executeTransaction(async () => {
          for (const strain of SAMPLE_STRAINS) {
            // Validate strain data before inserting
            const validationError = validateStrain(strain);
            if (validationError) {
              console.warn(`[StrainsRepository] Skipping invalid strain: ${validationError}`, strain);
              continue;
            }
            
            await this.db.runAsync(
              `INSERT INTO ${STRAINS_DATABASE_NAME} (
                name, overview, genetic_type, lineage, thc_range, 
                cbd_level, dominant_terpenes, qualitative_insights, 
                effects, negatives, uses, thc_rating, user_rating, combined_rating
              ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
              [
                strain.name,
                strain.overview,
                strain.genetic_type,
                strain.lineage,
                strain.thc_range,
                strain.cbd_level,
                strain.dominant_terpenes,
                strain.qualitative_insights,
                strain.effects,
                strain.negatives,
                strain.uses,
                strain.thc_rating,
                strain.user_rating,
                strain.combined_rating
              ]
            );
          }
        });
        
        console.log(`[StrainsRepository] Inserted ${SAMPLE_STRAINS.length} initial strains.`);
      } else {
        console.log(`[StrainsRepository] Strains table already contains ${count} records.`);
      }
    } catch (error) {
      console.error('[StrainsRepository] Failed to initialize strain data:', error);
      throw error;
    }
  }

  /**
   * Search strains with filters and pagination
   */
  public async searchStrains(
    query: string,
    filters: StrainSearchFilters = {},
    pagination: PaginationParams = { page: 1, limit: 10 }
  ): Promise<DatabaseResponse<StrainSearchResult<Strain>>> {
    try {
      const { page, limit } = pagination;
      const offset = (page - 1) * limit;

      // Build where clause and parameters
      const whereClauses = [];
      const params: any[] = [];

      // Search by name if query is provided
      if (query && query.trim()) {
        whereClauses.push('(name LIKE ? OR overview LIKE ?)');
        params.push(`%${query.trim()}%`, `%${query.trim()}%`);
      }

      // Filter by genetic type
      if (filters.geneticType) {
        whereClauses.push('genetic_type LIKE ?');
        params.push(`%${filters.geneticType}%`);
      }

      // Filter by effects - using AND logic
      if (filters.effects && filters.effects.length > 0) {
        const effectClauses = filters.effects.map(() => 'effects LIKE ?');
        whereClauses.push(`(${effectClauses.join(' AND ')})`);
        filters.effects.forEach(effect => params.push(`%${effect}%`));
      }

      // Filter by THC range
      if (filters.minTHC !== undefined) {
        whereClauses.push('CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) >= ?');
        params.push(filters.minTHC);
      }

      if (filters.maxTHC !== undefined) {
        whereClauses.push('CAST(SUBSTR(thc_range, INSTR(thc_range, "-")+1) AS FLOAT) <= ?');
        params.push(filters.maxTHC);
      }

      // Construct the final WHERE clause
      const whereClause = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';

      // Get total count for pagination
      const [countResult] = await this.db.getAllAsync<{ total: number }>(
        `SELECT COUNT(*) as total FROM ${STRAINS_DATABASE_NAME} ${whereClause}`,
        params
      );

      // Default sort order is by rating if not specified
      const sortOrder = this.getSortOrder(filters.sort || 'rating');

      // Get filtered results
      const results = await this.db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} 
         ${whereClause} 
         ORDER BY ${sortOrder}
         LIMIT ? OFFSET ?`,
        [...params, limit, offset]
      );

      const total = countResult?.total || 0;
      const totalPages = Math.ceil(total / limit);

      return {
        success: true,
        data: {
          data: results,
          total,
          currentPage: page,
          totalPages,
          hasMore: page < totalPages
        }
      };
    } catch (error) {
      return this.handleError(error, 'searchStrains');
    }
  }

  /**
   * Get strain by ID
   */
  public async getStrainById(id: number): Promise<ValidationResult<Strain | null>> {
    try {
      // Validate input
      if (!id || typeof id !== 'number' || id <= 0) {
        return createValidationError('INVALID_ID', 'Invalid strain ID provided');
      }
      
      const results = await this.db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} WHERE id = ? LIMIT 1`,
        [id]
      );
      
      const strain = results[0] || null;
      
      if (strain) {
        const validationError = validateStrain(strain);
        if (validationError) {
          return createValidationError('INVALID_STRAIN_DATA', validationError, { id });
        }
      }
      
      return createValidationSuccess(strain);
    } catch (error) {
      console.error('[StrainsRepository] Error getting strain by id:', error);
      return createValidationError('DB_ERROR', 'Failed to retrieve strain', { id });
    }
  }

  /**
   * Get popular strains
   */
  public async getPopularStrains(limit: number = 10): Promise<DatabaseResponse<Strain[]>> {
    try {
      const results = await this.db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} ORDER BY combined_rating DESC LIMIT ?`,
        [limit]
      );
      
      return {
        success: true,
        data: results
      };
    } catch (error) {
      return this.handleError(error, 'getPopularStrains');
    }
  }

  /**
   * Get related strains
   */
  public async getRelatedStrains(strain: Strain): Promise<ValidationResult<Strain[]>> {
    try {
      // Validate input
      const validationError = validateStrain(strain);
      if (validationError) {
        return createValidationError('INVALID_STRAIN', validationError);
      }
      
      if (!strain.id) {
        return createValidationError('MISSING_ID', 'Strain ID is required');
      }
      
      // Get strains with similar genetic type and effects
      const results = await this.db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME}
         WHERE id != ? 
         AND (
           genetic_type = ? 
           OR effects LIKE ?
         )
         ORDER BY combined_rating DESC
         LIMIT 5`,
        [strain.id, strain.genetic_type, `%${strain.effects.split(',')[0]}%`]
      );
      
      // Validate results
      for (const relatedStrain of results) {
        const strainError = validateStrain(relatedStrain);
        if (strainError) {
          console.warn(`[StrainsRepository] Invalid related strain: ${strainError}`, relatedStrain);
        }
      }
      
      return createValidationSuccess(results);
    } catch (error) {
      console.error('[StrainsRepository] Error getting related strains:', error);
      return createValidationError('DB_ERROR', 'Failed to retrieve related strains');
    }
  }

  /**
   * Get strain categories
   */
  public async getStrainCategories(): Promise<DatabaseResponse<{ [key: string]: number }>> {
    try {
      const results = await this.db.getAllAsync<{ genetic_type: string; count: number }>(
        `SELECT genetic_type, COUNT(*) as count
         FROM ${STRAINS_DATABASE_NAME}
         GROUP BY genetic_type`
      );
      
      // Create a more accurate categorization
      const categories: { [key: string]: number } = {
        'Indica': 0,
        'Sativa': 0,
        'Hybrid': 0
      };
      
      // Count each strain in its primary category
      for (const { genetic_type, count } of results) {
        if (genetic_type.includes('Indica')) {
          categories['Indica'] += count;
        } else if (genetic_type.includes('Sativa')) {
          categories['Sativa'] += count;
        } else if (genetic_type.includes('Hybrid')) {
          categories['Hybrid'] += count;
        }
      }
      
      // Add total count
      const [totalResult] = await this.db.getAllAsync<{ total: number }>(
        `SELECT COUNT(*) as total FROM ${STRAINS_DATABASE_NAME}`
      );
      
      if (totalResult) {
        categories['Total'] = totalResult.total;
      }
      
      return {
        success: true,
        data: categories
      };
    } catch (error) {
      return this.handleError(error, 'getStrainCategories');
    }
  }

  /**
   * Helper method to get sort order for strain queries
   */
  private getSortOrder(sort?: StrainSearchFilters['sort']): string {
    switch (sort) {
      case 'name':
        return 'name ASC';
      case 'thc':
        return 'CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) DESC';
      case 'rating':
      default:
        return 'combined_rating DESC';
    }
  }
} 

================================================================================
File: src/services/ai/AIService.ts
================================================================================

import * as Logger from './utils/logging';
import { DatabaseManager } from './database/DatabaseManager';
import { CacheManager } from './cache/CacheManager';
import { FeedbackService } from './feedback/FeedbackService';
import { AnthropicAPI } from './api/AnthropicAPI';
import { AIServiceError, AIServiceErrorType } from './types/errors';
import { 
  RecommendationRequest, 
  ChatRequest 
} from './types/requests';
import { 
  RecommendationResponse, 
  ChatResponse,
  JournalAnalysisResult,
  SafetyValidationResult,
  DrugInteractionResult,
  OveruseDetectionResult
} from './types/responses';
import { UserFeedback, QualityScore } from './types/feedback';
import { DEFAULT_CACHE_TTL } from './types/common';
// Import types from the main app types
import { 
  UserProfile, 
  JournalEntry, 
  StrainRecommendation, 
  DosageSuggestion,
  ChatMessage
} from '../../types';
import { MemoryCache } from './cache/MemoryCache';
import { PersistentCache } from './cache/PersistentCache';
import { databaseManager } from "../../DatabaseManager";
import { Strain } from "@/src/types";

const MODULE_NAME = 'AIService';

/**
 * AI Service
 * Main service for AI-powered features in the Canova app
 */
export class AIService {
  private static instance: AIService;
  private cacheManager: CacheManager;
  private feedbackService: FeedbackService;
  private api: AnthropicAPI;
  private initialized: boolean = false;
  private useMockResponses: boolean = false;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {
    this.cacheManager = CacheManager.getInstance();
    this.feedbackService = FeedbackService.getInstance();
    this.api = new AnthropicAPI();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of AIService
   */
  public static getInstance(): AIService {
    if (!AIService.instance) {
      AIService.instance = new AIService();
    }
    return AIService.instance;
  }

  /**
   * Initialize the AI service and its dependencies
   */
  public async initialize(): Promise<void> {
    // If already initialized, return immediately
    if (this.initialized) {
      return;
    }
    
    // If initialization is in progress, wait for it to complete
    if (this.initializationPromise) {
      return this.initializationPromise;
    }

    console.info('[AIService] Initializing AI service');
    
    // Create a promise for initialization
    this.initializationPromise = (async () => {
      try {
        // First ensure DatabaseManager is initialized
        await databaseManager.ensureInitialized();
        
        // Initialize cache manager
        console.info('[CacheManager] Initializing cache manager');
        this.cacheManager = CacheManager.getInstance();
        await this.cacheManager.initialize();
        console.info('[CacheManager] Cache manager initialized successfully');
        
        // Initialize feedback service (after cache manager)
        console.info('[FeedbackService] Initializing feedback service');
        this.feedbackService = FeedbackService.getInstance();
        await this.feedbackService.initialize();
        console.info('[FeedbackService] Feedback service initialized successfully');
        
        // Initialize API client - use existing method
        this.api = new AnthropicAPI();
        
        this.initialized = true;
        console.info('[AIService] AI service initialized successfully');
      } catch (error) {
        console.error('[AIService] Failed to initialize:', error);
        throw error;
      } finally {
        this.initializationPromise = null;
      }
    })();
    
    return this.initializationPromise;
  }

  /**
   * Configure the AI service
   */
  public configure(options: {
    useMockResponses?: boolean;
    cacheEnabled?: boolean;
    cacheTtl?: number;
    cacheMaxSize?: number;
  }): void {
    if (options.useMockResponses !== undefined) {
      this.useMockResponses = options.useMockResponses;
      Logger.info(MODULE_NAME, `Mock responses ${this.useMockResponses ? 'enabled' : 'disabled'}`);
    }
    
    // Configure cache if options provided
    if (options.cacheEnabled !== undefined || options.cacheTtl !== undefined || options.cacheMaxSize !== undefined) {
      try {
        this.cacheManager.configure(
          options.cacheEnabled ?? true,
          options.cacheTtl ?? DEFAULT_CACHE_TTL,
          options.cacheMaxSize ?? 100
        );
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to configure cache manager');
      }
    }
  }

  /**
   * Check if the service is initialized
   */
  private checkInitialized(): void {
    if (!this.initialized) {
      console.warn('[AIService] AI service not initialized, initializing now...');
      // Instead of throwing an error, start initialization and continue
      // This prevents errors when components try to use the service before initialization
      this.initialize().catch(err => {
        console.error('[AIService] Initialization failed:', err);
      });
    }
  }

  /**
   * Get real strain recommendations from the database based on user preferences
   */
  private async getRealStrainRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    try {
      Logger.info(MODULE_NAME, 'Getting real strain recommendations from database');
      
      // Extract desired effects from the request
      const { desiredEffects, context, medicalNeeds } = request;
      Logger.info(MODULE_NAME, `Desired effects: ${desiredEffects.join(', ')}`);
      
      // Get all strains from the database
      const allStrainsResult = await databaseManager.searchStrains('', {}, { page: 1, limit: 100 });
      Logger.info(MODULE_NAME, `All strains search result: Found ${allStrainsResult.data?.length || 0} strains`);
      
      if (!allStrainsResult.data || allStrainsResult.data.length === 0) {
        Logger.warn(MODULE_NAME, 'No strains found in database at all');
        return this.getMockRecommendations(request); // Fallback to mock data if no results
      }
      
      // Log some sample effects from the database to understand what's available
      const sampleEffects = allStrainsResult.data.slice(0, 5).map((strain: Strain) => {
        return `${strain.name}: ${strain.effects}`;
      });
      Logger.info(MODULE_NAME, `Sample effects in database: ${sampleEffects.join(' | ')}`);
      
      // Use the AI to interpret the natural language query and match it to strain effects
      const matchedStrains = await this.matchStrainsWithAI(desiredEffects, allStrainsResult.data, context, medicalNeeds);
      
      // If we don't have any recommendations, use mock data
      if (!matchedStrains || matchedStrains.length === 0) {
        Logger.warn(MODULE_NAME, 'No matching strains found after AI matching');
        return this.getMockRecommendations(request);
      }
      
      // Log the top 5 scored strains
      const topScores = matchedStrains.slice(0, 5).map(s => `${s.strain.name}: ${s.matchScore}%`);
      Logger.info(MODULE_NAME, `Top scored strains: ${topScores.join(', ')}`);
      
      // Take top 5 recommendations
      const topRecommendations = matchedStrains
        .slice(0, 5)
        .map(s => ({
          strainId: s.strain.id || 0,
          strainName: s.strain.name,
          matchScore: s.matchScore,
          reasoningFactors: s.reasoningFactors,
          alternativeStrains: [] // Could be populated with similar strains
        }));
      
      Logger.info(MODULE_NAME, `Returning ${topRecommendations.length} recommendations`);
      
      return {
        recommendations: topRecommendations,
        reasoning: `Based on your request for "${desiredEffects.join(', ')}", I've found strains that are likely to match your preferences.`,
        confidenceScore: 90,
        disclaimers: [
          'Individual experiences may vary',
          'Start with a low dose and gradually increase as needed',
          'Consult with a healthcare professional before use, especially if you have medical conditions or take medications'
        ],
        dosageSuggestion: {
          minDosage: 5,
          maxDosage: 10,
          unit: 'mg THC',
          gradualApproach: true,
          notes: 'Start low and go slow. Wait at least 2 hours before consuming more edibles.'
        },
        safetyNotes: [
          'Do not drive or operate heavy machinery after use',
          'Keep out of reach of children and pets',
          'Store in a cool, dry place away from direct sunlight'
        ]
      };
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get real strain recommendations');
      // Fallback to mock data if there's an error
      return this.getMockRecommendations(request);
    }
  }

  /**
   * Use AI to match strains with natural language queries
   */
  private async matchStrainsWithAI(
    desiredEffects: string[], 
    strains: Strain[], 
    context?: string,
    medicalNeeds?: string[]
  ): Promise<Array<{
    strain: Strain;
    matchScore: number;
    reasoningFactors: Array<{ factor: string; weight: number }>;
  }>> {
    try {
      // If we're not using the real API, use a simpler matching approach
      if (this.useMockResponses) {
        return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
      }
      
      // Create a prompt for the AI to match strains
      const prompt = `
        You are an expert cannabis strain matcher. I need you to match the following user's desired effects with the most appropriate strains from our database.
        
        User's desired effects: "${desiredEffects.join(', ')}"
        ${context ? `Context: ${context}` : ''}
        ${medicalNeeds && medicalNeeds.length > 0 ? `Medical needs: ${medicalNeeds.join(', ')}` : ''}
        
        Here are the available strains with their effects:
        ${strains.slice(0, 50).map(strain => 
          `- ${strain.name} (${strain.genetic_type}, THC: ${strain.thc_range}): ${strain.effects}${strain.uses ? ` | Uses: ${strain.uses}` : ''}`
        ).join('\n')}
        
        Please analyze the user's request and match it with the most appropriate strains. For each matched strain, provide:
        1. The strain name
        2. A match score (0-100)
        3. 2-3 specific reasoning factors explaining why this strain matches the user's request
        
        Return your response as a JSON array with the following structure:
        [
          {
            "strainName": "Strain Name",
            "matchScore": 85,
            "reasoningFactors": [
              {"factor": "Specific reason this strain matches", "weight": 0.5},
              {"factor": "Another specific reason", "weight": 0.3},
              {"factor": "Additional information about the strain", "weight": 0.2}
            ]
          }
        ]
        
        Only include strains with a match score above 50. Limit your response to the top 10 matches.
      `;
      
      // Call the AI API
      const response = await this.api.sendMessage([
        { role: 'user', content: prompt }
      ], 2000, 0.7);
      
      // Parse the response
      try {
        // Extract JSON from the response (it might be wrapped in markdown code blocks)
        const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)\s*```/) || 
                          response.match(/\[\s*\{\s*"strainName"/);
        
        const jsonStr = jsonMatch ? jsonMatch[1] || response : response;
        const matches = JSON.parse(jsonStr);
        
        if (!Array.isArray(matches)) {
          throw new Error('Response is not an array');
        }
        
        // Map the AI matches to our strain objects
        const matchedStrains = matches.map(match => {
          // Find the corresponding strain object
          const strain = strains.find(s => s.name === match.strainName);
          
          if (!strain) {
            Logger.warn(MODULE_NAME, `Strain not found: ${match.strainName}`);
            return null;
          }
          
          return {
            strain,
            matchScore: match.matchScore,
            reasoningFactors: match.reasoningFactors
          };
        }).filter((match): match is { 
          strain: Strain; 
          matchScore: number; 
          reasoningFactors: Array<{ factor: string; weight: number }> 
        } => match !== null);
        
        Logger.info(MODULE_NAME, `AI matched ${matchedStrains.length} strains`);
        
        return matchedStrains;
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to parse AI strain matching response');
        // Fallback to simple matching
        return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to match strains with AI');
      // Fallback to simple matching
      return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
    }
  }
  
  /**
   * Simple strain matching algorithm as a fallback
   */
  private matchStrainsSimple(
    desiredEffects: string[], 
    strains: Strain[], 
    context?: string,
    medicalNeeds?: string[]
  ): Array<{
    strain: Strain;
    matchScore: number;
    reasoningFactors: Array<{ factor: string; weight: number }>;
  }> {
    // Common cannabis effects for basic matching
    const commonEffects = {
      'happy': ['euphoric', 'uplifted', 'joyful', 'cheerful', 'blissful'],
      'relaxed': ['calm', 'peaceful', 'tranquil', 'mellow', 'soothing'],
      'creative': ['inspired', 'imaginative', 'artistic', 'focused'],
      'energetic': ['active', 'lively', 'stimulating', 'invigorating'],
      'sleepy': ['sedated', 'drowsy', 'restful', 'sleep', 'tired'],
      'hungry': ['appetite', 'munchies', 'food'],
      'pain relief': ['analgesic', 'pain', 'ache', 'sore'],
      'stress relief': ['stress', 'anxiety', 'tension', 'worry']
    };
    
    // Score each strain
    const scoredStrains = strains.map(strain => {
      // Parse effects into an array
      const strainEffects = strain.effects.split(',').map(e => e.trim().toLowerCase());
      
      // Calculate a basic match score
      let matchScore = 0;
      const matchedEffects: string[] = [];
      
      // Check each desired effect against strain effects
      desiredEffects.forEach(desiredEffect => {
        const desiredLower = desiredEffect.toLowerCase();
        
        // Direct match
        const directMatch = strainEffects.some(effect => 
          effect.includes(desiredLower) || desiredLower.includes(effect)
        );
        
        if (directMatch) {
          matchScore += 25;
          matchedEffects.push(desiredEffect);
          return;
        }
        
        // Check against common effects
        for (const [effect, synonyms] of Object.entries(commonEffects)) {
          // If desired effect contains this effect or synonyms
          if (desiredLower.includes(effect) || synonyms.some(s => desiredLower.includes(s))) {
            // Check if strain has this effect
            const hasEffect = strainEffects.some(strainEffect => 
              strainEffect.includes(effect) || synonyms.some(s => strainEffect.includes(s))
            );
            
            if (hasEffect) {
              matchScore += 20;
              matchedEffects.push(effect);
              return;
            }
          }
        }
        
        // Check for partial word matches
        const desiredWords = desiredLower.split(/\s+/).filter(w => w.length > 3);
        const hasPartialMatch = strainEffects.some(effect => 
          desiredWords.some(word => effect.includes(word))
        );
        
        if (hasPartialMatch) {
          matchScore += 10;
        }
      });
      
      // Boost score for context matches
      if (context === 'medical' && strain.uses && 
          (strain.uses.toLowerCase().includes('medical') || 
           (medicalNeeds && medicalNeeds.some(need => strain.uses.toLowerCase().includes(need.toLowerCase()))))) {
        matchScore += 15;
      } else if (context === 'recreational' && strainEffects.some(e => e.includes('euphoric'))) {
        matchScore += 15;
      }
      
      // Cap score at 100
      matchScore = Math.min(matchScore, 100);
      
      // Create reasoning factors
      const reasoningFactors = [];
      
      if (matchedEffects.length > 0) {
        reasoningFactors.push({
          factor: `Matches your desired effects: ${matchedEffects.join(', ')}`,
          weight: 0.5
        });
      }
      
      if (context === 'medical' && strain.uses) {
        reasoningFactors.push({
          factor: `Good for medical use: ${strain.uses}`,
          weight: 0.3
        });
      }
      
      reasoningFactors.push({
        factor: `${strain.genetic_type} with ${strain.thc_range} THC content`,
        weight: 0.2
      });
      
      return {
        strain,
        matchScore,
        reasoningFactors
      };
    });
    
    // Sort by match score (highest first) and filter out low scores
    return scoredStrains
      .filter(s => s.matchScore > 0)
      .sort((a, b) => b.matchScore - a.matchScore);
  }

  /**
   * Get strain recommendations based on user profile and preferences
   */
  public async getRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Getting strain recommendations');
      
      // Generate a unique response ID
      const responseId = `rec_${Date.now()}`;
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey(request);
      const cachedResponse = await this.cacheManager.get<RecommendationResponse>(cacheKey);
      
      if (cachedResponse) {
        Logger.info(MODULE_NAME, 'Returning cached recommendations');
        // Add the responseId to the cached response
        return { ...cachedResponse, responseId };
      }
      
      // If using mock responses, return a mock response
      if (this.useMockResponses) {
        const mockResponse = this.getMockRecommendations(request);
        
        // Cache the response
        await this.cacheManager.set(cacheKey, mockResponse);
        
        Logger.info(MODULE_NAME, 'Returning mock recommendations');
        return { ...mockResponse, responseId };
      }
      
      // Get real recommendations from the database
      const realRecommendations = await this.getRealStrainRecommendations(request);
      
      // Add the responseId
      const result: RecommendationResponse = {
        ...realRecommendations,
        responseId
      };
      
      // Cache the response
      await this.cacheManager.set(cacheKey, result);
      
      Logger.info(MODULE_NAME, 'Recommendations generated successfully');
      return result;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get recommendations');
      throw error;
    }
  }

  /**
   * Format a recommendation prompt for the AI
   */
  private formatRecommendationPrompt(request: RecommendationRequest): string {
    // Create a detailed prompt for the AI
    return `
      You are an AI assistant for a cannabis recommendation app called Canova.
      Please provide personalized cannabis strain recommendations based on the following user profile and preferences:
      
      User Profile:
      ${JSON.stringify(request.userProfile, null, 2)}
      
      Desired Effects:
      ${request.desiredEffects.join(', ')}
      
      ${request.medicalNeeds ? `Medical Needs: ${request.medicalNeeds.join(', ')}` : ''}
      ${request.context ? `Context: ${request.context}` : ''}
      ${request.locationCode ? `Location Code: ${request.locationCode}` : ''}
      
      ${request.journalEntries ? `Recent Journal Entries:
      ${JSON.stringify(request.journalEntries, null, 2)}` : ''}
      
      Please provide:
      1. A list of 3-5 strain recommendations with detailed information about each
      2. A brief explanation of why each strain was recommended
      3. Suggested dosage guidelines
      4. Any safety considerations or warnings
      
      Format your response as a JSON object with the following structure:
      {
        "recommendations": [
          {
            "name": "Strain Name",
            "type": "Indica/Sativa/Hybrid",
            "thcContent": "THC percentage range",
            "cbdContent": "CBD percentage range",
            "effects": ["effect1", "effect2", ...],
            "medicalBenefits": ["benefit1", "benefit2", ...],
            "flavors": ["flavor1", "flavor2", ...],
            "description": "Detailed description"
          }
        ],
        "reasoning": "Explanation of recommendations",
        "confidenceScore": 0-100,
        "disclaimers": ["disclaimer1", "disclaimer2", ...],
        "dosageSuggestion": {
          "beginner": "Beginner dosage",
          "intermediate": "Intermediate dosage",
          "experienced": "Experienced dosage",
          "notes": "Additional notes"
        },
        "safetyNotes": ["note1", "note2", ...]
      }
    `;
  }

  /**
   * Parse the AI response into a structured recommendation
   */
  private parseRecommendationResponse(response: string): RecommendationResponse {
    try {
      // Try to parse the response as JSON
      const parsedResponse = JSON.parse(response) as RecommendationResponse;
      
      // Validate the response structure
      if (!parsedResponse.recommendations || !Array.isArray(parsedResponse.recommendations)) {
        throw new Error('Invalid response structure: recommendations array missing');
      }
      
      return parsedResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to parse recommendation response');
      
      // If parsing fails, try to extract information from the text response
      // This is a fallback mechanism for when the AI doesn't return valid JSON
      
      // For now, return a simple error response
      return {
        recommendations: [],
        reasoning: 'Failed to parse AI response',
        confidenceScore: 0,
        disclaimers: ['The AI response could not be properly parsed'],
        error: {
          message: 'Failed to parse AI response',
          type: 'parsing_error',
          recoverable: false
        }
      };
    }
  }

  /**
   * Generate mock recommendations for testing
   */
  private getMockRecommendations(request: RecommendationRequest): RecommendationResponse {
    return {
      recommendations: [
        {
          strainId: 1,
          strainName: 'Blue Dream',
          matchScore: 95,
          reasoningFactors: [
            { factor: 'Matches desired effects', weight: 0.5 },
            { factor: 'Good for stress relief', weight: 0.3 },
            { factor: 'Balanced hybrid', weight: 0.2 }
          ],
          alternativeStrains: [
            { strainId: 4, strainName: 'Harlequin', reason: 'Higher CBD content' }
          ]
        },
        {
          strainId: 2,
          strainName: 'OG Kush',
          matchScore: 90,
          reasoningFactors: [
            { factor: 'Strong pain relief', weight: 0.6 },
            { factor: 'Matches user experience level', weight: 0.4 }
          ],
          alternativeStrains: [
            { strainId: 5, strainName: 'Bubba Kush', reason: 'Similar effects with more sedation' }
          ]
        },
        {
          strainId: 3,
          strainName: 'Granddaddy Purple',
          matchScore: 85,
          reasoningFactors: [
            { factor: 'Good for sleep', weight: 0.7 },
            { factor: 'Matches flavor preferences', weight: 0.3 }
          ],
          alternativeStrains: [
            { strainId: 6, strainName: 'Northern Lights', reason: 'Similar relaxation effects' }
          ]
        }
      ],
      reasoning: `Based on the user's profile and preferences, I've recommended strains that align with their desired effects and medical needs. Blue Dream offers a balanced experience, OG Kush provides potent relief, and Granddaddy Purple is excellent for relaxation and sleep.`,
      confidenceScore: 85,
      disclaimers: [
        'Individual experiences may vary',
        'Start with a low dose and gradually increase as needed',
        'Consult with a healthcare professional before use, especially if you have medical conditions or take medications'
      ],
      dosageSuggestion: {
        minDosage: 5,
        maxDosage: 10,
        unit: 'mg THC',
        gradualApproach: true,
        notes: 'Start low and go slow. Wait at least 2 hours before consuming more edibles.'
      },
      safetyNotes: [
        'Do not drive or operate heavy machinery after use',
        'Keep out of reach of children and pets',
        'Store in a cool, dry place away from direct sunlight'
      ]
    };
  }

  /**
   * Submit user feedback for a recommendation
   */
  public async submitRecommendationFeedback(
    userId: string,
    responseId: string,
    helpful: boolean,
    accurate: boolean,
    relevance: number,
    comments?: string
  ): Promise<string> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Submitting recommendation feedback for response: ${responseId}`);
      
      const feedback: UserFeedback = {
        userId,
        responseId,
        responseType: 'recommendation',
        helpful,
        accurate,
        relevance,
        comments,
        timestamp: Date.now()
      };
      
      // Submit the feedback using the feedback service
      const feedbackId = await this.feedbackService.submitFeedback(feedback);
      
      Logger.info(MODULE_NAME, `Recommendation feedback submitted: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit recommendation feedback for response: ${responseId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to submit recommendation feedback',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while submitting your feedback. Please try again later.'
      );
    }
  }

  /**
   * Get a response to a user's chat message
   */
  public async getChatResponse(request: ChatRequest): Promise<ChatResponse> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Getting chat response');
      
      // Generate a unique response ID
      const responseId = `chat_${Date.now()}`;
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey(request);
      const cachedResponse = await this.cacheManager.get<ChatResponse>(cacheKey);
      
      if (cachedResponse) {
        Logger.info(MODULE_NAME, 'Returning cached chat response');
        return cachedResponse;
      }
      
      // If using mock responses, return a mock response
      if (this.useMockResponses) {
        const mockResponse = this.getMockChatResponse(request);
        
        // Cache the response
        await this.cacheManager.set(cacheKey, mockResponse);
        
        Logger.info(MODULE_NAME, 'Returning mock chat response');
        return mockResponse;
      }
      
      // Format messages for the API
      const messages = this.formatChatMessages(request);
      
      // Call the API
      const response = await this.api.sendMessage(messages, 2000, 0.7);
      
      // Parse the response
      const chatResponse = this.parseChatResponse(response);
      
      // Cache the response
      await this.cacheManager.set(cacheKey, chatResponse);
      
      Logger.info(MODULE_NAME, 'Chat response generated successfully');
      return chatResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get chat response');
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to get chat response',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while generating a response. Please try again later.'
      );
    }
  }

  /**
   * Format chat messages for the API
   */
  private formatChatMessages(request: ChatRequest): Array<{ role: 'user' | 'assistant'; content: string }> {
    const messages: Array<{ role: 'user' | 'assistant'; content: string }> = [];
    
    // Add system message with context
    messages.push({
      role: 'user',
      content: `You are an AI assistant for a cannabis app called Canova. You provide helpful, accurate, and educational information about cannabis. 
      
      User Profile:
      ${JSON.stringify(request.userProfile, null, 2)}
      
      ${request.locationCode ? `Location Code: ${request.locationCode}` : ''}
      
      Please provide informative, educational responses. Include relevant scientific information when appropriate. Always prioritize safety and responsible use. If you don't know something, say so rather than providing incorrect information.`
    });
    
    // Add previous messages if available
    if (request.previousMessages && request.previousMessages.length > 0) {
      request.previousMessages.forEach(msg => {
        messages.push({
          role: msg.role as 'user' | 'assistant',
          content: msg.content
        });
      });
    }
    
    // Add the current message
    messages.push({
      role: 'user',
      content: request.message
    });
    
    return messages;
  }

  /**
   * Parse the AI response into a structured chat response
   */
  private parseChatResponse(response: string): ChatResponse {
    // For chat, we can use the response text directly
    const chatResponse: ChatResponse = {
      response: response,
      // Extract educational links if present
      educationalLinks: this.extractLinks(response),
      // Add disclaimers
      disclaimers: [
        'This information is for educational purposes only and not medical advice.',
        'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
      ]
    };
    
    return chatResponse;
  }

  /**
   * Extract links from a text response
   */
  private extractLinks(text: string): string[] {
    const links: string[] = [];
    const linkRegex = /https?:\/\/[^\s]+/g;
    const matches = text.match(linkRegex);
    
    if (matches) {
      matches.forEach(link => {
        links.push(link);
      });
    }
    
    return links;
  }

  /**
   * Generate a mock chat response for testing
   */
  private getMockChatResponse(request: ChatRequest): ChatResponse {
    // Simple mock response based on the request message
    const message = request.message.toLowerCase();
    
    if (message.includes('strain') || message.includes('recommend')) {
      return {
        response: `Based on your profile, I'd recommend considering strains like Blue Dream, OG Kush, or Granddaddy Purple. Blue Dream is a balanced hybrid that provides relaxation without sedation, OG Kush offers potent relief from stress and pain, and Granddaddy Purple is excellent for sleep and deep relaxation. Always start with a low dose, especially if you're new to cannabis.`,
        educationalLinks: ['https://www.leafly.com/strains/blue-dream', 'https://www.leafly.com/strains/og-kush'],
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    } else if (message.includes('cbd') || message.includes('thc')) {
      return {
        response: `THC (tetrahydrocannabinol) and CBD (cannabidiol) are the two most well-known cannabinoids in cannabis. THC is primarily responsible for the psychoactive effects or "high," while CBD is non-intoxicating and associated with various potential therapeutic benefits. The ratio of THC to CBD in a strain can significantly influence its effects. High-THC strains tend to be more intoxicating, while high-CBD strains are often used for their potential therapeutic properties without strong psychoactive effects.`,
        educationalLinks: ['https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5345356/'],
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    } else {
      return {
        response: `Thank you for your question about cannabis. I'm here to provide educational information and guidance based on scientific research. If you have specific questions about strains, effects, consumption methods, or safety considerations, feel free to ask. Remember that individual experiences with cannabis can vary significantly based on factors like body chemistry, tolerance, and the specific product used.`,
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    }
  }

  /**
   * Submit user feedback for a chat response
   */
  public async submitChatFeedback(
    userId: string,
    responseId: string,
    helpful: boolean,
    accurate: boolean,
    relevance: number,
    comments?: string
  ): Promise<string> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Submitting chat feedback for response: ${responseId}`);
      
      const feedback: UserFeedback = {
        userId,
        responseId,
        responseType: 'chat',
        helpful,
        accurate,
        relevance,
        comments,
        timestamp: Date.now()
      };
      
      // Submit the feedback using the feedback service
      const feedbackId = await this.feedbackService.submitFeedback(feedback);
      
      Logger.info(MODULE_NAME, `Chat feedback submitted: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit chat feedback for response: ${responseId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to submit chat feedback',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while submitting your feedback. Please try again later.'
      );
    }
  }

  /**
   * Analyze journal entries for patterns and insights
   */
  public async analyzeJournalEntries(
    userId: string,
    journalEntries: JournalEntry[]
  ): Promise<JournalAnalysisResult> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Analyzing journal entries for user: ${userId}`);
      
      // If no entries, return empty analysis
      if (!journalEntries || journalEntries.length === 0) {
        Logger.info(MODULE_NAME, 'No journal entries to analyze');
        return {
          patterns: [],
          insights: [],
          recommendations: []
        };
      }
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey({
        userId,
        journalEntries: journalEntries.map(entry => ({
          id: entry.id,
          created_at: entry.created_at
        }))
      });
      
      const cachedAnalysis = await this.cacheManager.get<JournalAnalysisResult>(cacheKey);
      
      if (cachedAnalysis) {
        Logger.info(MODULE_NAME, 'Returning cached journal analysis');
        return cachedAnalysis;
      }
      
      // If using mock responses, return a mock analysis
      if (this.useMockResponses) {
        const mockAnalysis = this.getMockJournalAnalysis(journalEntries);
        
        // Cache the analysis
        await this.cacheManager.set(cacheKey, mockAnalysis);
        
        Logger.info(MODULE_NAME, 'Returning mock journal analysis');
        return mockAnalysis;
      }
      
      // Format the prompt for the AI
      const prompt = this.formatJournalAnalysisPrompt(journalEntries);
      
      // Call the API
      const response = await this.api.sendMessage([
        { role: 'user', content: prompt }
      ], 2000, 0.7);
      
      // Parse the response
      const analysis = this.parseJournalAnalysisResponse(response);
      
      // Cache the analysis
      await this.cacheManager.set(cacheKey, analysis);
      
      Logger.info(MODULE_NAME, 'Journal analysis completed successfully');
      return analysis;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to analyze journal entries for user: ${userId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to analyze journal entries',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while analyzing your journal entries. Please try again later.'
      );
    }
  }

  /**
   * Format a journal analysis prompt for the AI
   */
  private formatJournalAnalysisPrompt(journalEntries: JournalEntry[]): string {
    return `
      You are an AI assistant for a cannabis app called Canova.
      Please analyze the following journal entries to identify patterns, insights, and potential recommendations:
      
      Journal Entries:
      ${JSON.stringify(journalEntries, null, 2)}
      
      For each entry, consider:
      - Strain used
      - Dosage
      - Consumption method
      - Effects experienced
      - Time of day
      - User's mood before and after
      - Any side effects
      
      Please provide:
      1. Patterns you've identified across entries
      2. Insights about what works well and what doesn't for this user
      3. Recommendations for strains, dosages, or consumption methods based on the data
      4. Any safety flags or concerns that should be addressed
      
      Format your response as a JSON object with the following structure:
      {
        "patterns": ["pattern1", "pattern2", ...],
        "insights": ["insight1", "insight2", ...],
        "recommendations": ["recommendation1", "recommendation2", ...],
        "safetyFlags": ["flag1", "flag2", ...] // Optional, include only if relevant
      }
    `;
  }

  /**
   * Parse the AI response into a structured journal analysis
   */
  private parseJournalAnalysisResponse(response: string): JournalAnalysisResult {
    try {
      // Try to parse the response as JSON
      const parsedResponse = JSON.parse(response) as JournalAnalysisResult;
      
      // Validate the response structure
      if (!parsedResponse.patterns || !parsedResponse.insights || !parsedResponse.recommendations) {
        throw new Error('Invalid response structure: required fields missing');
      }
      
      return parsedResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to parse journal analysis response');
      
      // Return a simple error response
      return {
        patterns: ['Could not identify patterns due to parsing error'],
        insights: ['Could not generate insights due to parsing error'],
        recommendations: ['Please try again later or contact support']
      };
    }
  }

  /**
   * Generate mock journal analysis for testing
   */
  private getMockJournalAnalysis(journalEntries: JournalEntry[]): JournalAnalysisResult {
    // Simple mock analysis based on the number of entries
    if (journalEntries.length >= 5) {
      return {
        patterns: [
          'Higher satisfaction with indica strains in the evening',
          'Edibles tend to cause more anxiety than vaping',
          'Morning use of low-THC strains improves focus without impairment'
        ],
        insights: [
          'You respond well to balanced THC:CBD ratios for pain management',
          'Strains high in limonene terpenes seem to elevate your mood consistently',
          'Consumption 2-3 hours before bedtime improves sleep quality'
        ],
        recommendations: [
          'Try Granddaddy Purple for evening relaxation',
          'Consider microdosing with a 1:1 THC:CBD tincture for daytime pain relief',
          'Experiment with lower temperatures when vaping to reduce throat irritation'
        ]
      };
    } else {
      return {
        patterns: [
          'Not enough entries to identify reliable patterns yet',
          'Initial preference for hybrid strains noted'
        ],
        insights: [
          'More journal entries needed for meaningful insights',
          'Consider recording more details about effects and context'
        ],
        recommendations: [
          'Continue journaling consistently to build more data',
          'Try varying your consumption methods to compare effects',
          'Record your experience with different terpene profiles'
        ]
      };
    }
  }

  /**
   * Validate the safety of a recommendation request
   */
  public async validateRecommendationSafety(
    request: RecommendationRequest
  ): Promise<SafetyValidationResult> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Validating recommendation request safety');
      
      // Check for basic safety issues
      const basicSafetyCheck = this.performBasicSafetyCheck(request);
      if (!basicSafetyCheck.valid) {
        Logger.info(MODULE_NAME, `Safety validation failed: ${basicSafetyCheck.reason}`);
        return basicSafetyCheck;
      }
      
      // Check for potential drug interactions
      const interactionResult = await this.checkDrugInteractions(request);
      if (interactionResult.hasInteractions && interactionResult.severity === 'severe') {
        Logger.info(MODULE_NAME, 'Safety validation failed: Severe drug interactions detected');
        return {
          valid: false,
          reason: 'Potential severe drug interactions detected',
          safetyFlags: interactionResult.details,
          warningLevel: 'critical'
        };
      }
      
      // Check for potential overuse
      const overuseResult = await this.detectOveruse(request.userProfile.id);
      if (overuseResult.detected && overuseResult.level === 'severe') {
        Logger.info(MODULE_NAME, 'Safety validation failed: Severe overuse pattern detected');
        return {
          valid: false,
          reason: 'Potential overuse pattern detected',
          safetyFlags: [overuseResult.details || 'Frequent high-dose usage pattern detected'],
          warningLevel: 'critical'
        };
      }
      
      // If there are moderate concerns, return valid but with warnings
      if (
        (interactionResult.hasInteractions && interactionResult.severity === 'moderate') ||
        (overuseResult.detected && overuseResult.level === 'moderate')
      ) {
        const safetyFlags = [
          ...(interactionResult.hasInteractions ? interactionResult.details || [] : []),
          ...(overuseResult.detected && overuseResult.details ? [overuseResult.details] : [])
        ];
        
        Logger.info(MODULE_NAME, 'Safety validation passed with warnings');
        return {
          valid: true,
          safetyFlags,
          warningLevel: 'warning'
        };
      }
      
      // If there are mild concerns, return valid but with info
      if (
        (interactionResult.hasInteractions && interactionResult.severity === 'mild') ||
        (overuseResult.detected && overuseResult.level === 'mild')
      ) {
        const safetyFlags = [
          ...(interactionResult.hasInteractions ? interactionResult.details || [] : []),
          ...(overuseResult.detected && overuseResult.details ? [overuseResult.details] : [])
        ];
        
        Logger.info(MODULE_NAME, 'Safety validation passed with information');
        return {
          valid: true,
          safetyFlags,
          warningLevel: 'info'
        };
      }
      
      // All checks passed
      Logger.info(MODULE_NAME, 'Safety validation passed');
      return {
        valid: true
      };
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to validate recommendation safety');
      
      // Return a conservative result in case of error
      return {
        valid: true,
        reason: 'Safety validation could not be completed',
        safetyFlags: ['Safety validation encountered an error, proceed with caution'],
        warningLevel: 'warning'
      };
    }
  }

  /**
   * Perform basic safety checks on a recommendation request
   */
  private performBasicSafetyCheck(request: RecommendationRequest): SafetyValidationResult {
    // Check for underage users based on experience level
    if (request.userProfile.experience_level === 'beginner') {
      // For beginners, we'll add extra caution
      return {
        valid: true,
        safetyFlags: ['User is a beginner, recommend starting with low doses'],
        warningLevel: 'info'
      };
    }
    
    // Check for pregnancy or other medical conditions
    if (request.userProfile.medical_needs && 
        request.userProfile.medical_needs.some((condition: string) => 
          condition.toLowerCase().includes('pregnant') || 
          condition.toLowerCase().includes('pregnancy')
        )) {
      return {
        valid: false,
        reason: 'Cannabis use is not recommended during pregnancy',
        warningLevel: 'critical'
      };
    }
    
    // Check for severe mental health conditions
    const severeConditions = ['schizophrenia', 'psychosis', 'severe depression', 'bipolar disorder'];
    if (request.userProfile.medical_needs && 
        request.userProfile.medical_needs.some((condition: string) => 
          severeConditions.some(severe => condition.toLowerCase().includes(severe))
        )) {
      return {
        valid: false,
        reason: 'Cannabis use may exacerbate certain mental health conditions',
        warningLevel: 'critical'
      };
    }
    
    // All basic checks passed
    return {
      valid: true
    };
  }

  /**
   * Check for potential drug interactions
   */
  private async checkDrugInteractions(request: RecommendationRequest): Promise<DrugInteractionResult> {
    // In a real implementation, this would check against a database of known drug interactions
    // For now, we'll just check for some common medications that have known interactions
    
    const highRiskMedications = [
      'warfarin', 'clopidogrel', 'amiodarone', 'tacrolimus', 'cyclosporine',
      'sedative', 'benzodiazepine', 'opioid', 'alcohol'
    ];
    
    const moderateRiskMedications = [
      'antidepressant', 'ssri', 'antipsychotic', 'stimulant', 'adhd medication',
      'blood pressure', 'hypertension', 'beta blocker'
    ];
    
    if (!request.userProfile.medications || request.userProfile.medications.length === 0) {
      return {
        hasInteractions: false
      };
    }
    
    const highRiskFound = request.userProfile.medications.some((med: string) => 
      highRiskMedications.some(risk => med.toLowerCase().includes(risk))
    );
    
    if (highRiskFound) {
      return {
        hasInteractions: true,
        severity: 'severe',
        details: [
          'Potential severe interaction with one or more medications',
          'Cannabis may increase or decrease the effects of certain medications',
          'Consult with a healthcare provider before using cannabis'
        ],
        recommendations: [
          'Consult with a healthcare provider before using cannabis',
          'Consider alternative treatments',
          'If approved by a healthcare provider, start with very low doses and monitor closely'
        ]
      };
    }
    
    const moderateRiskFound = request.userProfile.medications.some((med: string) => 
      moderateRiskMedications.some(risk => med.toLowerCase().includes(risk))
    );
    
    if (moderateRiskFound) {
      return {
        hasInteractions: true,
        severity: 'moderate',
        details: [
          'Potential moderate interaction with one or more medications',
          'Cannabis may affect how your medications work'
        ],
        recommendations: [
          'Consult with a healthcare provider before using cannabis',
          'Start with low doses and monitor for any adverse effects',
          'Keep a journal of effects to share with your healthcare provider'
        ]
      };
    }
    
    // No known interactions found
    return {
      hasInteractions: false
    };
  }

  /**
   * Detect potential overuse patterns
   */
  private async detectOveruse(userId: string): Promise<OveruseDetectionResult> {
    // In a real implementation, this would analyze usage patterns from the user's history
    // For now, we'll just return a mock result
    
    // Simulate a 10% chance of detecting mild overuse
    const randomValue = Math.random();
    
    if (randomValue < 0.01) {
      // 1% chance of severe overuse
      return {
        detected: true,
        level: 'severe',
        details: 'Frequent high-dose usage pattern detected',
        recommendedAction: 'Consider taking a tolerance break and consulting with a healthcare provider',
        coolingOffPeriod: 14 // 14 days
      };
    } else if (randomValue < 0.05) {
      // 4% chance of moderate overuse
      return {
        detected: true,
        level: 'moderate',
        details: 'Increasing frequency of use detected',
        recommendedAction: 'Consider moderating use and monitoring effects more closely',
        coolingOffPeriod: 7 // 7 days
      };
    } else if (randomValue < 0.10) {
      // 5% chance of mild overuse
      return {
        detected: true,
        level: 'mild',
        details: 'Slight increase in usage frequency noted',
        recommendedAction: 'Be mindful of consumption patterns and consider occasional breaks',
        coolingOffPeriod: 2 // 2 days
      };
    }
    
    // No overuse detected
    return {
      detected: false
    };
  }
} 

================================================================================
File: src/services/ai/cache/CacheManager.ts
================================================================================

import * as Logger from '../utils/logging';
import { MemoryCache } from './MemoryCache';
import { PersistentCache } from './PersistentCache';
import { SHA256 } from '../utils/hash';
import { DEFAULT_CACHE_TTL, MAX_CACHE_SIZE, CacheDbEntry } from '../types/common';
import { DatabaseManager } from '../database/DatabaseManager';

const MODULE_NAME = 'CacheManager';

/**
 * Cache Manager
 * Orchestrates both memory and persistent caches
 */
export class CacheManager {
  private static instance: CacheManager;
  private memoryCache: MemoryCache;
  private persistentCache: PersistentCache;
  private enabled: boolean = true;
  private defaultTtl: number = DEFAULT_CACHE_TTL;
  private initialized: boolean = false;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {
    this.memoryCache = new MemoryCache(MAX_CACHE_SIZE);
    this.persistentCache = new PersistentCache();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of CacheManager
   */
  public static getInstance(): CacheManager {
    if (!CacheManager.instance) {
      CacheManager.instance = new CacheManager();
    }
    return CacheManager.instance;
  }

  /**
   * Initialize the cache manager
   */
  public async initialize(): Promise<void> {
    // If already initialized, return immediately
    if (this.initialized) {
      console.debug('[CacheManager] Already initialized');
      return;
    }
    
    // If initialization is already in progress, wait for it to complete
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    
    console.info('[CacheManager] Initializing cache manager');
    
    // Create a promise for initialization
    this.initializationPromise = (async () => {
      try {
        // Wait for DatabaseManager to be initialized first
        const dbManager = DatabaseManager.getInstance();
        await dbManager.initialize();
        
        // Load frequently accessed entries into memory cache
        await this.loadFrequentEntries();
        
        // Delete expired entries
        await this.pruneCache();
        
        this.initialized = true;
        console.info('[CacheManager] Cache manager initialized successfully');
      } catch (error) {
        console.error('[CacheManager] Failed to initialize cache manager:', error);
        throw error;
      } finally {
        this.initializationPromise = null;
      }
    })();
    
    return this.initializationPromise;
  }

  /**
   * Configure the cache
   */
  public configure(enabled: boolean, ttlMs: number = DEFAULT_CACHE_TTL, maxSize: number = MAX_CACHE_SIZE): void {
    this.enabled = enabled;
    this.defaultTtl = ttlMs;
    this.memoryCache.setMaxSize(maxSize);
    
    Logger.info(MODULE_NAME, `Cache configured: enabled=${enabled}, ttl=${ttlMs}ms, maxSize=${maxSize}`);
  }

  /**
   * Generate a cache key from request data
   */
  public generateKey(requestData: any): string {
    try {
      // Create a stable representation of the request data
      const stableRepresentation = this.createStableRepresentation(requestData);
      
      // Generate a hash of the stable representation
      const hash = SHA256(stableRepresentation);
      
      // Extract user ID if available for easier cache invalidation
      let userId = '';
      if (requestData.userProfile && requestData.userProfile.id) {
        userId = requestData.userProfile.id;
      } else if (requestData.userId) {
        userId = requestData.userId;
      }
      
      // Create a key with user ID prefix for easier user-specific cache invalidation
      const key = userId ? `user:${userId}:${hash}` : hash;
      
      Logger.debug(MODULE_NAME, `Generated cache key: ${key}`);
      return key;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to generate cache key');
      // Return a timestamp-based key as fallback
      return `fallback:${Date.now()}`;
    }
  }

  /**
   * Create a stable representation of an object
   * Ensures that the same object always produces the same string
   * regardless of property order
   */
  private createStableRepresentation(obj: any): string {
    if (obj === null || obj === undefined) {
      return '';
    }
    
    if (typeof obj !== 'object') {
      return String(obj);
    }
    
    if (Array.isArray(obj)) {
      return '[' + obj.map(item => this.createStableRepresentation(item)).join(',') + ']';
    }
    
    // Sort keys to ensure stable order
    const sortedKeys = Object.keys(obj).sort();
    
    return '{' + sortedKeys.map(key => {
      // Skip functions and undefined values
      if (typeof obj[key] === 'function' || obj[key] === undefined) {
        return '';
      }
      return `"${key}":${this.createStableRepresentation(obj[key])}`;
    }).filter(Boolean).join(',') + '}';
  }

  /**
   * Get a value from the cache
   */
  public async get<T>(key: string): Promise<T | null> {
    if (!this.enabled) {
      Logger.debug(MODULE_NAME, 'Cache is disabled, skipping get');
      return null;
    }
    
    try {
      // Check if initialized
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Cache not initialized, initializing now...');
        await this.initialize();
      }
      
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      // Try memory cache first
      const memoryEntry = this.memoryCache.get<T>(key);
      if (memoryEntry) {
        // Check if the entry is expired
        if (memoryEntry.expiresAt < Date.now()) {
          Logger.debug(MODULE_NAME, `Memory cache entry expired for key: ${key}`);
          this.memoryCache.delete(key);
          return null;
        }
        
        Logger.debug(MODULE_NAME, `Memory cache hit for key: ${key}`);
        return memoryEntry.data;
      }
      
      // Try persistent cache
      const persistentData = await this.persistentCache.get<T>(key);
      if (persistentData) {
        // Store in memory cache for faster access next time
        this.memoryCache.set(key, persistentData, this.defaultTtl);
        
        Logger.debug(MODULE_NAME, `Persistent cache hit for key: ${key}`);
        return persistentData;
      }
      
      Logger.debug(MODULE_NAME, `Cache miss for key: ${key}`);
      return null;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      return null;
    }
  }

  /**
   * Set a value in the cache
   */
  public async set<T>(key: string, data: T, ttl: number = this.defaultTtl): Promise<void> {
    if (!this.enabled) {
      Logger.debug(MODULE_NAME, 'Cache is disabled, skipping set');
      return;
    }
    
    if (data === null || data === undefined) {
      Logger.error(MODULE_NAME, `Cannot cache null or undefined data for key: ${key}`);
      return;
    }
    
    try {
      // Check if initialized
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Cache not initialized, initializing now...');
        await this.initialize();
      }
      
      Logger.debug(MODULE_NAME, `Setting cache entry with key: ${key}`);
      
      // Store in memory cache
      this.memoryCache.set(key, data, ttl);
      
      // Store in persistent cache
      await this.persistentCache.set(key, data, ttl);
      
      Logger.debug(MODULE_NAME, `Cache entry set for key: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to set cache entry: ${key}`);
      // If persistent cache fails, delete from memory cache to maintain consistency
      this.memoryCache.delete(key);
    }
  }

  /**
   * Delete a value from the cache
   */
  public async delete(key: string): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      
      // Delete from memory cache
      this.memoryCache.delete(key);
      
      // Delete from persistent cache
      await this.persistentCache.delete(key);
      
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
    }
  }

  /**
   * Delete all cache entries that match a pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      
      // Delete from memory cache
      const memoryCount = this.memoryCache.deleteByPattern(pattern);
      
      // Delete from persistent cache
      const persistentCount = await this.persistentCache.deleteByPattern(pattern);
      
      Logger.debug(MODULE_NAME, `Deleted ${memoryCount} memory cache entries and ${persistentCount} persistent cache entries matching pattern: ${pattern}`);
      return Math.max(memoryCount, persistentCount);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      return 0;
    }
  }

  /**
   * Clear all cache entries
   */
  public async clear(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      
      // Clear memory cache
      this.memoryCache.clear();
      
      // Clear persistent cache
      await this.persistentCache.clear();
      
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
    }
  }

  /**
   * Delete all cache entries for a specific user
   */
  public async deleteForUser(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entries for user: ${userId}`);
      
      // Delete from memory cache
      const memoryCount = this.memoryCache.deleteByPattern(`user:${userId}`);
      
      // Get all keys for the user from persistent cache
      const keys = await this.persistentCache.getKeysForUser(userId);
      
      // Delete each key from persistent cache
      for (const key of keys) {
        await this.persistentCache.delete(key);
      }
      
      Logger.debug(MODULE_NAME, `Deleted ${memoryCount} memory cache entries and ${keys.length} persistent cache entries for user: ${userId}`);
      return keys.length;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries for user: ${userId}`);
      return 0;
    }
  }

  /**
   * Prune the cache by removing expired entries
   */
  public async pruneCache(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Pruning cache');
      
      // Delete expired entries from memory cache
      const memoryCount = this.memoryCache.deleteExpired();
      
      // Delete expired entries from persistent cache
      const persistentCount = await this.persistentCache.deleteExpired();
      
      Logger.debug(MODULE_NAME, `Pruned ${memoryCount} memory cache entries and ${persistentCount} persistent cache entries`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to prune cache');
    }
  }

  /**
   * Load frequently accessed entries into memory cache
   */
  private async loadFrequentEntries(limit: number = 20): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Loading ${limit} most frequently accessed cache entries into memory`);
      
      // Get most frequently used entries from persistent cache
      const entries = await this.persistentCache.getMostFrequentlyUsed(limit);
      
      // Load each entry into memory cache
      for (const entry of entries) {
        try {
          const data = JSON.parse(entry.data);
          const ttl = entry.expires_at - Date.now();
          
          // Only load if not expired
          if (ttl > 0) {
            this.memoryCache.set(entry.key, data, ttl);
          }
        } catch (error) {
          Logger.logError(MODULE_NAME, error as Error, `Failed to parse data for key: ${entry.key}`);
        }
      }
      
      Logger.debug(MODULE_NAME, `Loaded ${entries.length} cache entries into memory`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to load frequent cache entries');
    }
  }
} 

================================================================================
File: src/services/ai/cache/index.ts
================================================================================

export { CacheManager } from './CacheManager';
export { MemoryCache } from './MemoryCache';
export { PersistentCache } from './PersistentCache'; 

================================================================================
File: src/services/ai/cache/MemoryCache.ts
================================================================================

import * as Logger from '../utils/logging';
import { CacheEntry, MAX_CACHE_SIZE } from '../types/common';

const MODULE_NAME = 'MemoryCache';

/**
 * In-memory cache implementation
 * Provides fast access to frequently used cache entries
 */
export class MemoryCache {
  private cache: Map<string, CacheEntry<any>> = new Map();
  private maxSize: number;

  constructor(maxSize: number = MAX_CACHE_SIZE) {
    this.maxSize = maxSize;
    Logger.debug(MODULE_NAME, `Initialized with max size: ${maxSize}`);
  }

  /**
   * Set the maximum size of the cache
   */
  public setMaxSize(size: number): void {
    this.maxSize = size;
    Logger.debug(MODULE_NAME, `Max size updated to: ${size}`);
    
    // If the current size exceeds the new max size, prune the cache
    if (this.cache.size > this.maxSize) {
      this.prune();
    }
  }

  /**
   * Get the current size of the cache
   */
  public size(): number {
    return this.cache.size;
  }

  /**
   * Check if the cache contains an entry with the given key
   */
  public has(key: string): boolean {
    return this.cache.has(key);
  }

  /**
   * Get an entry from the cache
   */
  public get<T>(key: string): CacheEntry<T> | undefined {
    const entry = this.cache.get(key) as CacheEntry<T> | undefined;
    
    if (entry) {
      // Update hit count and last accessed time
      entry.hitCount += 1;
      entry.lastAccessed = Date.now();
      Logger.debug(MODULE_NAME, `Cache hit for key: ${key}, hit count: ${entry.hitCount}`);
    } else {
      Logger.debug(MODULE_NAME, `Cache miss for key: ${key}`);
    }
    
    return entry;
  }

  /**
   * Set an entry in the cache
   */
  public set<T>(key: string, data: T, ttl: number): void {
    const now = Date.now();
    const expiresAt = now + ttl;
    
    // Check if we need to make room in the cache
    if (!this.cache.has(key) && this.cache.size >= this.maxSize) {
      this.evictOne();
    }
    
    // Create or update the cache entry
    this.cache.set(key, {
      key,
      data,
      timestamp: now,
      expiresAt,
      ttl,
      hitCount: 0,
      lastAccessed: now
    });
    
    Logger.debug(MODULE_NAME, `Set cache entry for key: ${key}, expires at: ${new Date(expiresAt).toISOString()}`);
  }

  /**
   * Delete an entry from the cache
   */
  public delete(key: string): boolean {
    const result = this.cache.delete(key);
    Logger.debug(MODULE_NAME, `Deleted cache entry for key: ${key}, success: ${result}`);
    return result;
  }

  /**
   * Clear all entries from the cache
   */
  public clear(): void {
    this.cache.clear();
    Logger.debug(MODULE_NAME, 'Cleared all cache entries');
  }

  /**
   * Get all keys in the cache
   */
  public keys(): string[] {
    return Array.from(this.cache.keys());
  }

  /**
   * Get all entries in the cache
   */
  public entries<T>(): Array<[string, CacheEntry<T>]> {
    return Array.from(this.cache.entries()) as Array<[string, CacheEntry<T>]>;
  }

  /**
   * Delete all entries that match a pattern
   */
  public deleteByPattern(pattern: string): number {
    let count = 0;
    const regex = new RegExp(pattern);
    
    // Convert keys iterator to array before iterating
    const keys = Array.from(this.cache.keys());
    for (const key of keys) {
      if (regex.test(key)) {
        this.cache.delete(key);
        count++;
      }
    }
    
    Logger.debug(MODULE_NAME, `Deleted ${count} entries matching pattern: ${pattern}`);
    return count;
  }

  /**
   * Delete all expired entries
   */
  public deleteExpired(): number {
    let count = 0;
    const now = Date.now();
    
    // Convert entries iterator to array before iterating
    const entries = Array.from(this.cache.entries());
    for (const [key, entry] of entries) {
      if (entry.expiresAt <= now) {
        this.cache.delete(key);
        count++;
      }
    }
    
    Logger.debug(MODULE_NAME, `Deleted ${count} expired entries`);
    return count;
  }

  /**
   * Prune the cache to the maximum size
   */
  private prune(): void {
    if (this.cache.size <= this.maxSize) {
      return;
    }
    
    const entriesToRemove = this.cache.size - this.maxSize;
    Logger.debug(MODULE_NAME, `Pruning cache, removing ${entriesToRemove} entries`);
    
    // Sort entries by last accessed time (oldest first)
    const sortedEntries = Array.from(this.cache.entries())
      .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);
    
    // Remove the oldest entries
    for (let i = 0; i < entriesToRemove; i++) {
      this.cache.delete(sortedEntries[i][0]);
    }
  }

  /**
   * Evict one entry from the cache
   * Uses a combination of last accessed time and hit count to determine which entry to evict
   */
  private evictOne(): void {
    if (this.cache.size === 0) {
      return;
    }
    
    Logger.debug(MODULE_NAME, 'Evicting one entry from cache');
    
    // Sort entries by a score that combines last accessed time and hit count
    // Lower score = better candidate for eviction
    const now = Date.now();
    const sortedEntries = Array.from(this.cache.entries())
      .map(([key, entry]) => {
        // Calculate a score based on recency and popularity
        // More recent access and higher hit count = higher score = less likely to be evicted
        const recency = (now - entry.lastAccessed) / 1000; // seconds since last access
        const popularity = Math.log1p(entry.hitCount); // logarithmic scaling of hit count
        const score = popularity / recency; // higher hit count and more recent = higher score
        return { key, score };
      })
      .sort((a, b) => a.score - b.score); // sort by score (ascending)
    
    // Evict the entry with the lowest score
    const keyToEvict = sortedEntries[0].key;
    this.cache.delete(keyToEvict);
    Logger.debug(MODULE_NAME, `Evicted cache entry for key: ${keyToEvict}`);
  }
} 

================================================================================
File: src/services/ai/cache/PersistentCache.ts
================================================================================

import * as Logger from '../utils/logging';
import { CacheRepository } from '../database/repositories/CacheRepository';
import { CacheDbEntry } from '../types/common';
import { DatabaseManager } from '../database/DatabaseManager';

const MODULE_NAME = 'PersistentCache';

/**
 * Persistent cache implementation using SQLite
 * Provides durable storage for cache entries
 */
export class PersistentCache {
  private repository: CacheRepository;
  private initialized: boolean = false;

  constructor() {
    this.repository = new CacheRepository();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Initialize the persistent cache
   */
  private async ensureInitialized(): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      // Make sure the database is initialized - use initialize method
      const dbManager = DatabaseManager.getInstance();
      await dbManager.initialize();
      this.initialized = true;
      console.debug('[PersistentCache] Database initialized');
    } catch (error) {
      console.error('[PersistentCache] Failed to initialize database:', error);
      throw new Error('Cache database not initialized');
    }
  }

  /**
   * Store an entry in the persistent cache
   */
  public async set(key: string, data: any, ttl: number): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Storing cache entry with key: ${key}`);
      
      // Validate data before storing
      if (data === null || data === undefined) {
        Logger.error(MODULE_NAME, `Cannot store null or undefined data for key: ${key}`);
        throw new Error('Cannot store null or undefined data in cache');
      }
      
      const now = Date.now();
      const expiresAt = now + ttl;
      
      // Serialize data to JSON string
      let serializedData: string;
      try {
        serializedData = JSON.stringify(data);
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, `Failed to serialize data for key: ${key}`);
        throw new Error(`Failed to serialize data for cache key: ${key}`);
      }
      
      // Store in persistent cache
      await this.repository.storeResponse(key, serializedData, now, expiresAt, ttl);
      
      Logger.debug(MODULE_NAME, `Cache entry stored successfully: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Get an entry from the persistent cache
   */
  public async get<T>(key: string): Promise<T | null> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      const entry = await this.repository.getResponse(key);
      
      if (!entry) {
        Logger.debug(MODULE_NAME, `No cache entry found for key: ${key}`);
        return null;
      }
      
      // Check if the entry is expired
      if (entry.expires_at < Date.now()) {
        Logger.debug(MODULE_NAME, `Cache entry expired for key: ${key}`);
        await this.delete(key);
        return null;
      }
      
      // Update hit count and last accessed time
      await this.repository.updateStats(key, entry.hit_count + 1, Date.now());
      
      // Parse the serialized data
      try {
        const data = JSON.parse(entry.data) as T;
        Logger.debug(MODULE_NAME, `Cache hit for key: ${key}`);
        return data;
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, `Failed to parse data for key: ${key}`);
        await this.delete(key);
        return null;
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      return null;
    }
  }

  /**
   * Delete an entry from the persistent cache
   */
  public async delete(key: string): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      await this.repository.deleteEntry(key);
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Delete entries by pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      const count = await this.repository.deleteByPattern(pattern);
      Logger.debug(MODULE_NAME, `Deleted ${count} cache entries matching pattern: ${pattern}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      throw error;
    }
  }

  /**
   * Clear all entries from the persistent cache
   */
  public async clear(): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      await this.repository.clearAll();
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
      throw error;
    }
  }

  /**
   * Delete expired entries
   */
  public async deleteExpired(): Promise<number> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, 'Deleting expired cache entries');
      const count = await this.repository.deleteExpired();
      Logger.debug(MODULE_NAME, `Deleted ${count} expired cache entries`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to delete expired cache entries');
      throw error;
    }
  }

  /**
   * Get the most frequently used cache entries
   */
  public async getMostFrequentlyUsed(limit: number): Promise<CacheDbEntry[]> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting ${limit} most frequently used cache entries`);
      const entries = await this.repository.getMostFrequentlyUsed(limit);
      Logger.debug(MODULE_NAME, `Found ${entries.length} most frequently used cache entries`);
      return entries;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get most frequently used cache entries');
      throw error;
    }
  }

  /**
   * Get all keys for a specific user
   */
  public async getKeysForUser(userId: string): Promise<string[]> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting cache keys for user: ${userId}`);
      const keyEntries = await this.repository.getKeysForUser(userId);
      const keys = keyEntries.map(entry => entry.key);
      Logger.debug(MODULE_NAME, `Found ${keys.length} cache keys for user: ${userId}`);
      return keys;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache keys for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/feedback/FeedbackService.ts
================================================================================

import * as Logger from '../utils/logging';
import { FeedbackRepository } from '../database/repositories/FeedbackRepository';
import { UserFeedback, QualityScore, FeedbackPattern } from '../types/feedback';
import { AnthropicAPI } from '../api/AnthropicAPI';

const MODULE_NAME = 'FeedbackService';

/**
 * Feedback Service
 * Handles user feedback and response quality evaluation
 */
export class FeedbackService {
  private static instance: FeedbackService;
  private repository: FeedbackRepository;
  private api: AnthropicAPI;
  private initialized: boolean = false;

  private constructor() {
    this.repository = new FeedbackRepository();
    this.api = new AnthropicAPI();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of FeedbackService
   */
  public static getInstance(): FeedbackService {
    if (!FeedbackService.instance) {
      FeedbackService.instance = new FeedbackService();
    }
    return FeedbackService.instance;
  }

  /**
   * Initialize the feedback service
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing feedback service');
      this.initialized = true;
      Logger.info(MODULE_NAME, 'Feedback service initialized successfully');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback service');
      throw error;
    }
  }

  /**
   * Submit user feedback
   */
  public async submitFeedback(feedback: UserFeedback): Promise<string> {
    try {
      Logger.info(MODULE_NAME, `Submitting feedback for response: ${feedback.responseId}`);
      
      // Generate a unique ID for the feedback
      const feedbackId = `fb_${Date.now()}`;
      
      // Store the feedback
      await this.repository.storeFeedback(feedback, feedbackId);
      
      // Evaluate the response quality in the background
      this.evaluateResponseQuality(feedback.responseId, feedback.responseType)
        .catch(error => {
          Logger.logError(MODULE_NAME, error as Error, `Failed to evaluate response quality for: ${feedback.responseId}`);
        });
      
      // Extract feedback patterns in the background
      this.extractFeedbackPatterns(feedback)
        .catch(error => {
          Logger.logError(MODULE_NAME, error as Error, `Failed to extract feedback patterns for: ${feedback.responseId}`);
        });
      
      Logger.info(MODULE_NAME, `Feedback submitted successfully: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit feedback for response: ${feedback.responseId}`);
      throw error;
    }
  }

  /**
   * Evaluate the quality of a response
   */
  public async evaluateResponseQuality(
    responseId: string,
    responseType: 'recommendation' | 'chat',
    responseData?: any
  ): Promise<QualityScore> {
    try {
      Logger.info(MODULE_NAME, `Evaluating quality for response: ${responseId}`);
      
      // Generate a unique ID for the evaluation
      const evaluationId = `eval_${Date.now()}`;
      
      // If we have an API key and want to use the real API
      const useRealApi = false; // Set to true to use the real API
      
      if (useRealApi) {
        // Format the evaluation prompt
        const prompt = `
          You are an expert evaluator of AI responses for a cannabis recommendation app.
          Please evaluate the following ${responseType} response:
          
          ${JSON.stringify(responseData)}
          
          Provide a quality score on a scale of 0-100 for the following aspects:
          - Overall quality
          - Relevance to user needs
          - Accuracy of information
          - Comprehensiveness
          - Safety considerations
          
          Also list:
          - 3 strengths of the response
          - 3 weaknesses of the response
          - 3 suggestions for improvement
          
          Format your response as a JSON object with the following structure:
          {
            "overallScore": number,
            "relevanceScore": number,
            "accuracyScore": number,
            "comprehensivenessScore": number,
            "safetyScore": number,
            "strengths": string[],
            "weaknesses": string[],
            "improvementSuggestions": string[]
          }
        `;
        
        // Call the API
        const response = await this.api.sendMessage([
          { role: 'user', content: prompt }
        ], 2000, 0.3);
        
        // Parse the response
        const qualityScore = JSON.parse(response) as QualityScore;
        
        // Store the quality score
        await this.repository.storeQualityScore(evaluationId, responseId, qualityScore);
        
        Logger.info(MODULE_NAME, `Quality evaluation completed for response: ${responseId}`);
        return qualityScore;
      } else {
        // For testing or when API is not available, generate a mock quality score
        const mockQualityScore: QualityScore = {
          overallScore: 85,
          relevanceScore: 80,
          accuracyScore: 90,
          comprehensivenessScore: 85,
          safetyScore: 95,
          strengths: [
            'Provides detailed information about the recommended strains',
            'Includes safety considerations and dosage guidelines',
            'Explains the reasoning behind the recommendations'
          ],
          weaknesses: [
            'Could provide more context about potential side effects',
            'Limited information about alternative options',
            'Dosage recommendations could be more personalized'
          ],
          improvementSuggestions: [
            'Include more information about potential side effects',
            'Provide alternative recommendations for different scenarios',
            'Enhance personalization of dosage recommendations'
          ]
        };
        
        // Store the mock quality score
        await this.repository.storeQualityScore(evaluationId, responseId, mockQualityScore);
        
        Logger.info(MODULE_NAME, `Mock quality evaluation completed for response: ${responseId}`);
        return mockQualityScore;
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to evaluate quality for response: ${responseId}`);
      
      // Return a default quality score in case of error
      return {
        overallScore: 70,
        relevanceScore: 70,
        accuracyScore: 70,
        comprehensivenessScore: 70,
        safetyScore: 70,
        strengths: ['Not evaluated due to error'],
        weaknesses: ['Not evaluated due to error'],
        improvementSuggestions: ['Not evaluated due to error']
      };
    }
  }

  /**
   * Extract feedback patterns from user feedback
   */
  private async extractFeedbackPatterns(feedback: UserFeedback): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Extracting feedback patterns for response: ${feedback.responseId}`);
      
      // In a real implementation, this would analyze the feedback and extract patterns
      // For now, we'll just create a simple pattern based on the feedback
      
      // Create a pattern ID based on user profile and request factors
      const patternId = `pattern_${feedback.responseType}_${Date.now()}`;
      
      // Check if the pattern already exists
      const existingPattern = await this.repository.getPattern(patternId);
      
      if (existingPattern) {
        // Update the existing pattern
        const updatedPattern: FeedbackPattern = {
          patternId,
          responseType: feedback.responseType,
          userProfileFactors: { userId: feedback.userId },
          requestFactors: { responseId: feedback.responseId },
          positiveOutcomeRate: feedback.helpful ? 1 : 0,
          sampleSize: 1,
          lastUpdated: Date.now()
        };
        
        await this.repository.storePattern(updatedPattern);
      } else {
        // Create a new pattern
        const newPattern: FeedbackPattern = {
          patternId,
          responseType: feedback.responseType,
          userProfileFactors: { userId: feedback.userId },
          requestFactors: { responseId: feedback.responseId },
          positiveOutcomeRate: feedback.helpful ? 1 : 0,
          sampleSize: 1,
          lastUpdated: Date.now()
        };
        
        await this.repository.storePattern(newPattern);
      }
      
      Logger.debug(MODULE_NAME, `Feedback patterns extracted for response: ${feedback.responseId}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to extract feedback patterns for response: ${feedback.responseId}`);
    }
  }

  /**
   * Get all feedback for a user
   */
  public async getUserFeedback(userId: string): Promise<UserFeedback[]> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback for user: ${userId}`);
      const feedback = await this.repository.getUserFeedback(userId);
      Logger.debug(MODULE_NAME, `Found ${feedback.length} feedback entries for user: ${userId}`);
      return feedback;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get feedback statistics for a user
   */
  public async getUserFeedbackStats(userId: string): Promise<any> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback stats for user: ${userId}`);
      const stats = await this.repository.getUserFeedbackStats(userId);
      Logger.debug(MODULE_NAME, `Retrieved feedback stats for user: ${userId}`);
      return stats;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback stats for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get quality score statistics
   */
  public async getQualityScoreStats(): Promise<any> {
    try {
      Logger.debug(MODULE_NAME, 'Getting quality score statistics');
      const stats = await this.repository.getQualityScoreStats();
      Logger.debug(MODULE_NAME, 'Retrieved quality score statistics');
      return stats;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get quality score statistics');
      throw error;
    }
  }

  /**
   * Delete all feedback for a user
   */
  public async deleteUserFeedback(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting feedback for user: ${userId}`);
      const count = await this.repository.deleteUserFeedback(userId);
      Logger.debug(MODULE_NAME, `Deleted ${count} feedback entries for user: ${userId}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete feedback for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/feedback/index.ts
================================================================================

export { FeedbackService } from './FeedbackService'; 

================================================================================
File: src/services/ai/index.ts
================================================================================

export { AIService } from './AIService';

// Export sub-modules
export * from './api';
export * from './cache/index';
export * from './feedback';
export * from './types/common';
export * from './types/errors';
export * from './types/feedback';
export * from './types/requests';
export * from './types/responses'; 

================================================================================
File: src/services/ai/types/common.ts
================================================================================

// Constants
export const AI_USAGE_DB_NAME = "AIUsage";
export const RECOMMENDATION_FEEDBACK_DB_NAME = "RecommendationFeedback";
export const CACHE_DB_NAME = "AIResponseCache";

// Cache configuration
export const DEFAULT_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
export const MAX_CACHE_SIZE = 100; // Maximum number of cached responses

// Anthropic API constants
export const ANTHROPIC_API_URL = "https://api.anthropic.com/v1";
export const ANTHROPIC_API_VERSION = "2023-06-01";
// In a production app, you would use environment variables
// import { ANTHROPIC_API_KEY } from '@env';
// For now, we'll use a placeholder that you'll replace with your actual key
export const ANTHROPIC_API_KEY = "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"; // Replace this with your actual key

// Cache entry interface
export interface CacheEntry<T> {
  key: string;
  data: T;
  timestamp: number;
  expiresAt: number;
  ttl: number;
  hitCount: number;
  lastAccessed: number;
}

// Database entry interfaces
export interface CacheDbEntry {
  key: string;
  data: string;
  timestamp: number;
  expires_at: number;
  ttl: number;
  hit_count: number;
  last_accessed: number;
}

export interface KeyEntry {
  key: string;
}

export interface CountResult {
  count: number;
} 

================================================================================
File: src/services/ai/types/errors.ts
================================================================================

// Define error types for better error handling
export enum AIServiceErrorType {
  NETWORK = 'network_error',
  AUTHENTICATION = 'authentication_error',
  RATE_LIMIT = 'rate_limit_error',
  SERVER = 'server_error',
  PARSING = 'parsing_error',
  TIMEOUT = 'timeout_error',
  UNKNOWN = 'unknown_error'
}

export class AIServiceError extends Error {
  type: AIServiceErrorType;
  statusCode?: number;
  retryable: boolean;
  userMessage: string;

  constructor(
    message: string, 
    type: AIServiceErrorType = AIServiceErrorType.UNKNOWN, 
    statusCode?: number,
    retryable: boolean = false,
    userMessage: string = "An error occurred while processing your request."
  ) {
    super(message);
    this.name = 'AIServiceError';
    this.type = type;
    this.statusCode = statusCode;
    this.retryable = retryable;
    this.userMessage = userMessage;
  }
} 

================================================================================
File: src/services/ai/types/feedback.ts
================================================================================

// Feedback and evaluation types
export interface UserFeedback {
  userId: string;
  responseId: string;
  responseType: 'recommendation' | 'chat';
  helpful: boolean;
  accurate: boolean;
  relevance: number; // 1-5 scale
  comments?: string;
  timestamp: number;
}

export interface QualityScore {
  overallScore: number; // 0-100
  relevanceScore: number; // 0-100
  accuracyScore: number; // 0-100
  comprehensivenessScore: number; // 0-100
  safetyScore: number; // 0-100
  strengths: string[];
  weaknesses: string[];
  improvementSuggestions: string[];
}

export interface FeedbackPattern {
  patternId: string;
  responseType: 'recommendation' | 'chat';
  userProfileFactors: Record<string, any>;
  requestFactors: Record<string, any>;
  positiveOutcomeRate: number;
  sampleSize: number;
  lastUpdated: number;
}

// Database-specific interfaces for feedback
export interface PatternEntry {
  pattern_id: string;
  user_profile_factors: string;
  request_factors: string;
  positive_outcome_rate: number;
  sample_size: number;
}

export interface FeedbackStats {
  total: number;
  positive: number;
  relevance_sum: number;
}

export interface QualityStats {
  avg_overall: number;
  avg_relevance: number;
  avg_safety: number;
  total: number;
} 

================================================================================
File: src/services/ai/types/requests.ts
================================================================================

import { UserProfile, JournalEntry, ChatMessage } from '../../../types';

export interface RecommendationRequest {
  userProfile: UserProfile;
  journalEntries?: JournalEntry[];
  desiredEffects: string[];
  medicalNeeds?: string[];
  context?: 'recreational' | 'medical' | 'wellness';
  locationCode?: string; // For regulations
}

export interface ChatRequest {
  message: string;
  userProfile: UserProfile;
  locationCode?: string;
  previousMessages?: ChatMessage[];
} 

================================================================================
File: src/services/ai/types/responses.ts
================================================================================

import { DosageSuggestion, StrainRecommendation } from '../../../types';

export interface RecommendationResponse {
  recommendations: StrainRecommendation[];
  reasoning: string;
  confidenceScore: number;
  disclaimers: string[];
  dosageSuggestion?: DosageSuggestion;
  safetyNotes?: string[];
  error?: {
    message: string;
    type: string;
    recoverable: boolean;
  };
  // Adding responseId to fix the type issue in evaluateResponseQuality
  responseId?: string;
}

export interface ChatResponse {
  response: string;
  educationalLinks?: string[];
  disclaimers?: string[];
  regulatoryNotes?: string[];
  followUpSuggestions?: string[];
}

export interface JournalAnalysisResult {
  patterns: string[];
  insights: string[];
  recommendations: string[];
  safetyFlags?: string[];
}

export interface SafetyValidationResult {
  valid: boolean;
  reason?: string;
  modifications?: Partial<any>; // Changed from Partial<RecommendationRequest> to avoid circular dependency
  safetyFlags?: string[];
  warningLevel?: 'info' | 'warning' | 'critical';
}

export interface DrugInteractionResult {
  hasInteractions: boolean;
  details?: string[];
  severity?: 'mild' | 'moderate' | 'severe';
  recommendations?: string[];
}

export interface OveruseDetectionResult {
  detected: boolean;
  level?: 'mild' | 'moderate' | 'severe';
  details?: string;
  recommendedAction?: string;
  coolingOffPeriod?: number; // in days
} 

================================================================================
File: src/services/ai/utils/hash.ts
================================================================================

/**
 * A simple SHA-256 hash implementation for string inputs
 * This is a basic implementation for caching purposes
 * In a production environment, use a proper crypto library
 */
export function SHA256(input: string): string {
  // Simple hash function for demo purposes
  // In a real app, use a proper crypto library
  let hash = 0;
  
  if (input.length === 0) {
    return hash.toString(16);
  }
  
  // Generate a simple hash
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Convert to hex string and ensure it's 64 characters long (SHA-256 length)
  const hexHash = Math.abs(hash).toString(16).padStart(8, '0');
  
  // Repeat the hash to make it look like a SHA-256 hash (64 chars)
  return (hexHash.repeat(8)).substring(0, 64);
} 

================================================================================
File: src/services/ai/utils/logging.ts
================================================================================

/**
 * Logging utility for AI service
 * Provides consistent logging format and levels
 */

// Log levels
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

// Current log level - can be changed at runtime
let currentLogLevel: LogLevel = LogLevel.INFO;

// Set the current log level
export function setLogLevel(level: LogLevel): void {
  currentLogLevel = level;
}

// Get the current log level
export function getLogLevel(): LogLevel {
  return currentLogLevel;
}

// Format a log message with timestamp and module
function formatLogMessage(module: string, message: string): string {
  const timestamp = new Date().toISOString();
  return `[${timestamp}] [${module}] ${message}`;
}

// Debug level logging
export function debug(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.DEBUG) {
    console.debug(formatLogMessage(module, message), ...args);
  }
}

// Info level logging
export function info(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.INFO) {
    console.info(formatLogMessage(module, message), ...args);
  }
}

// Warning level logging
export function warn(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.WARN) {
    console.warn(formatLogMessage(module, message), ...args);
  }
}

// Error level logging
export function error(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.ERROR) {
    console.error(formatLogMessage(module, message), ...args);
  }
}

// Log an error object with stack trace
export function logError(module: string, error: Error, message?: string): void {
  if (currentLogLevel <= LogLevel.ERROR) {
    const errorMessage = message ? `${message}: ${error.message}` : error.message;
    console.error(formatLogMessage(module, errorMessage));
    if (error.stack) {
      console.error(error.stack);
    }
  }
} 

================================================================================
File: src/services/AppSetupService.ts
================================================================================

import { DatabaseManager } from '../DatabaseManager';
import { StorageService } from './StorageService';
import { StrainsRepository } from '../repositories/StrainsRepository';
import { AchievementsRepository } from '../repositories/AchievementsRepository';
import { BONG_HITS_DATABASE_NAME } from '../constants';

const FIRST_LAUNCH_KEY = 'hasLaunched';

/**
 * Service for handling app setup and first launch
 */
export class AppSetupService {
  private storageService: StorageService;
  private databaseManager: DatabaseManager;
  private strainsRepository: StrainsRepository;
  private achievementsRepository: AchievementsRepository | null = null;

  /**
   * Constructor
   * @param storageService Storage service for checking first launch
   * @param databaseManager Database manager for initialization
   * @param strainsRepository Repository for seeding initial data
   */
  constructor(
    storageService: StorageService,
    databaseManager: DatabaseManager,
    strainsRepository: StrainsRepository
  ) {
    this.storageService = storageService;
    this.databaseManager = databaseManager;
    this.strainsRepository = strainsRepository;
  }

  /**
   * Check if this is the first app launch
   */
  public async isFirstLaunch(): Promise<boolean> {
    try {
      return !(await this.storageService.hasKey(FIRST_LAUNCH_KEY));
    } catch (error) {
      console.error('[AppSetupService] Error checking first launch:', error);
      return false;
    }
  }

  /**
   * Initialize the app for first launch
   */
  public async initializeOnFirstLaunch(): Promise<void> {
    try {
      console.log('[AppSetupService] Initializing app for first launch...');
      
      // Initialize database (runs migrations)
      await this.databaseManager.initialize();
      
      // Seed initial strain data
      await this.strainsRepository.initializeData();
      
      // Create achievements repository and seed achievement data
      const db = await this.databaseManager.getDatabase(BONG_HITS_DATABASE_NAME);
      this.achievementsRepository = new AchievementsRepository(db);
      await this.achievementsRepository.initializeData();
      
      // Mark first launch as completed
      await this.storageService.setValue(FIRST_LAUNCH_KEY, true);
      
      console.log('[AppSetupService] First launch initialization completed.');
    } catch (error) {
      console.error('[AppSetupService] Error initializing app on first launch:', error);
      throw error;
    }
  }

  /**
   * Ensure achievements data is initialized regardless of first launch status
   */
  public async ensureAchievementsInitialized(): Promise<void> {
    try {
      if (!this.achievementsRepository) {
        const db = await this.databaseManager.getDatabase(BONG_HITS_DATABASE_NAME);
        this.achievementsRepository = new AchievementsRepository(db);
      }
      
      await this.achievementsRepository.initializeData();
    } catch (error) {
      console.error('[AppSetupService] Error ensuring achievements initialized:', error);
      throw error;
    }
  }

  /**
   * Ensure app is initialized regardless of whether it's first launch
   */
  public async ensureInitialized(): Promise<void> {
    try {
      // Check if this is first launch
      const isFirstLaunch = await this.isFirstLaunch();
      
      if (isFirstLaunch) {
        // If first launch, run full initialization
        await this.initializeOnFirstLaunch();
      } else {
        // Otherwise just ensure database is initialized
        await this.databaseManager.ensureInitialized();
        
        // Also ensure achievements are initialized
        await this.ensureAchievementsInitialized();
      }
    } catch (error) {
      console.error('[AppSetupService] Error ensuring app is initialized:', error);
      throw error;
    }
  }

  /**
   * Reset app to first launch state (for testing)
   */
  public async resetToFirstLaunch(): Promise<void> {
    try {
      // Remove first launch marker
      await this.storageService.removeValue(FIRST_LAUNCH_KEY);
      
      // Clean up database connections
      await this.databaseManager.cleanup();
      
      console.log('[AppSetupService] App reset to first launch state.');
    } catch (error) {
      console.error('[AppSetupService] Error resetting to first launch:', error);
      throw error;
    }
  }
} 

================================================================================
File: src/services/BluetoothService.ts
================================================================================

import { Alert, PermissionsAndroid, Platform } from "react-native";
import * as ExpoDevice from "expo-device";
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';
import base64 from "react-native-base64";
import { BluetoothHandler } from "../contexts/BluetoothContext";
import { DeviceService } from "./DeviceService";
import { BongHitsRepository } from "../repositories/BongHitsRepository";
import { parseRawTimestamp } from "../utils/functions";
import { dataChangeEmitter, dbEvents } from "../utils/EventEmitter";

/**
 * BluetoothService uses composition with BluetoothHandler and integrates with DeviceService
 * for saving connected devices and with BongHitsRepository for recording hits
 */
export class BluetoothService {
  private bluetoothHandler: BluetoothHandler;
  private deviceService: DeviceService;
  private bongHitsRepository: BongHitsRepository;

  /**
   * Constructor
   * @param deviceService Service for saving devices
   * @param bongHitsRepository Repository for recording bong hits
   * @param bluetoothHandler Optional BluetoothHandler instance (creates one if not provided)
   */
  constructor(
    deviceService: DeviceService, 
    bongHitsRepository: BongHitsRepository,
    bluetoothHandler?: BluetoothHandler
  ) {
    this.bluetoothHandler = bluetoothHandler || new BluetoothHandler();
    this.deviceService = deviceService;
    this.bongHitsRepository = bongHitsRepository;
    
    // Set up the callback to handle data from bluetooth
    this.bluetoothHandler.setOnDataCallback(this.handleReceivedData.bind(this));
    
    // Listen for app state changes to manage connections
    // platform-specific imports and setup would go here
  }

  /**
   * Handle data received from the Bluetooth device
   * @param rawTimestamp The original timestamp string from the device
   * @param timestamp ISO string timestamp (parsed)
   * @param duration Duration in milliseconds
   */
  private async handleReceivedData(rawTimestamp: string, timestamp: string, duration: number): Promise<void> {
    try {
      console.log(`[BluetoothService] Received data - Raw: ${rawTimestamp}, Parsed: ${timestamp}, Duration: ${duration}ms`);
      
      // Validate that the timestamp is in ISO format before proceeding
      if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/.test(timestamp)) {
        const errorMsg = `Invalid timestamp format: ${timestamp}`;
        console.error(`[BluetoothService] ${errorMsg}`);
        Alert.alert('Error', errorMsg);
        return;
      }
      
      // Validate duration is positive
      if (duration <= 0) {
        const errorMsg = `Invalid duration: ${duration}`;
        console.error(`[BluetoothService] ${errorMsg}`);
        Alert.alert('Error', errorMsg);
        return;
      }
      
      // Add the Alert call here, using parsed timestamp and duration
      Alert.alert(`Timestamp: ${timestamp}\n Duration: ${duration}ms`);
      
      // Record the bong hit using the validated timestamp
      await this.bongHitsRepository.recordBongHit(timestamp, duration);
      console.log(`[BluetoothService] Bong hit recorded successfully.`);
      
      // Emit an event to notify listeners that data has changed
      dataChangeEmitter.emit(dbEvents.DATA_CHANGED);
      console.log(`[BluetoothService] Emitted '${dbEvents.DATA_CHANGED}' event.`);
    } catch (error) {
      console.error('[BluetoothService] Error handling received data:', error);
      Alert.alert('Error', 'Failed to process or record received data');
    }
  }

  /**
   * Connect to a device by ID and save it to storage
   * @param deviceId ID of the device to connect to
   */
  public async connectToDevice(deviceId: string): Promise<void> {
    try {
      await this.bluetoothHandler.connectToDevice(deviceId);
      
      // Get the connected device
      const connectedDevice = this.bluetoothHandler.getConnectedDevice();
      if (connectedDevice) {
        // Save the device to persistent storage
        await this.deviceService.saveDevices([connectedDevice]);
        console.log(`[BluetoothService] Device ${deviceId} saved to storage`);
        
        // Set up the streaming on connected device
        // This will trigger the bluetoothHandler's handleBluetoothConnection internally
        await this.setupDeviceListeners();
      }
    } catch (error) {
      console.error('[BluetoothService] Error connecting to device:', error);
      throw error;
    }
  }
  
  /**
   * Set up listeners for the connected device
   */
  private async setupDeviceListeners(): Promise<void> {
    try {
      // Start streaming data from the device
      // This will use the internal handleBluetoothConnection in BluetoothHandler
      this.bluetoothHandler.streamOnConnectedDevice();
      
      // Additional setup could be done here
    } catch (error) {
      console.error('[BluetoothService] Error setting up device listeners:', error);
      throw error;
    }
  }

  /**
   * Scan for BLE devices
   * @param onDeviceFound Callback function for each device found
   * @param timeoutMs Optional scan timeout in milliseconds
   * @returns Promise that resolves when scan is complete
   */
  public async scanForDevices(
    onDeviceFound: (device: Device) => void,
    timeoutMs: number = 10000
  ): Promise<void> {
    try {
      // Get BLE manager from handler
      const manager = this.bluetoothHandler.getBLEManager();
      
      // Request permissions first
      const hasPermission = await this.requestPermissions();
      if (!hasPermission) {
        throw new Error('Bluetooth permissions not granted');
      }
      
      // Start scanning
      console.log('[BluetoothService] Starting device scan...');
      manager.startDeviceScan(null, null, (error, device) => {
        if (error) {
          console.error('[BluetoothService] Scan error:', error);
          return;
        }
        
        if (device && device.name) {
          // Call the callback with the found device
          onDeviceFound(device);
        }
      });
      
      // Set a timeout to stop scanning
      return new Promise((resolve) => {
        setTimeout(() => {
          manager.stopDeviceScan();
          console.log('[BluetoothService] Device scan complete');
          resolve();
        }, timeoutMs);
      });
    } catch (error) {
      console.error('[BluetoothService] Error scanning for devices:', error);
      throw error;
    }
  }

  /**
   * Disconnect from the current device
   */
  public disconnectFromCurrentDevice(): void {
    const device = this.bluetoothHandler.getConnectedDevice();
    if (device) {
      this.bluetoothHandler.disconnectFromDevice(device);
      console.log('[BluetoothService] Disconnected from device:', device.id);
    }
  }

  /**
   * Get the currently connected device
   */
  public getConnectedDevice(): Device | undefined {
    return this.bluetoothHandler.getConnectedDevice();
  }

  /**
   * Get a list of previously connected devices
   * @returns Promise that resolves with array of saved devices
   */
  public async getSavedDevices() {
    return this.deviceService.getSavedDevices();
  }

  /**
   * Request Bluetooth permissions based on platform and Android version
   */
  private async requestPermissions(): Promise<boolean> {
    if (Platform.OS === "android") {
      if ((ExpoDevice.platformApiLevel ?? -1) < 31) {
        // Android version below 31
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
          {
            title: "Location Permission",
            message: "Bluetooth Low Energy requires Location",
            buttonPositive: "OK",
          }
        );
        return granted === PermissionsAndroid.RESULTS.GRANTED;
      } else {
        // Android version 31 and above (Android 12+)
        return this.requestAndroid31Permissions();
      }
    } else {
      // iOS doesn't need permission in the same way
      return true;
    }
  }

  /**
   * Request the required permissions for Android 12+
   */
  private async requestAndroid31Permissions(): Promise<boolean> {
    const bluetoothScanPermission = await PermissionsAndroid.request(
      PermissionsAndroid.PERMISSIONS.BLUETOOTH_SCAN,
      {
        title: "Bluetooth Scan Permission",
        message: "App needs permission to scan for Bluetooth devices",
        buttonPositive: "OK",
      }
    );
    const bluetoothConnectPermission = await PermissionsAndroid.request(
      PermissionsAndroid.PERMISSIONS.BLUETOOTH_CONNECT,
      {
        title: "Bluetooth Connect Permission",
        message: "App needs permission to connect to Bluetooth devices",
        buttonPositive: "OK",
      }
    );
    const fineLocationPermission = await PermissionsAndroid.request(
      PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
      {
        title: "Location Permission",
        message: "Bluetooth scanning requires precise location",
        buttonPositive: "OK",
      }
    );

    return (
      bluetoothScanPermission === PermissionsAndroid.RESULTS.GRANTED &&
      bluetoothConnectPermission === PermissionsAndroid.RESULTS.GRANTED &&
      fineLocationPermission === PermissionsAndroid.RESULTS.GRANTED
    );
  }
} 

================================================================================
File: src/services/DeviceService.ts
================================================================================

import { Device } from 'react-native-ble-plx';
import { SavedDevice } from '../types';
import { StorageService } from './StorageService';

const SAVED_DEVICES_KEY = 'savedDevices';

/**
 * Service for managing saved devices
 */
export class DeviceService {
  private storageService: StorageService;

  /**
   * Constructor
   * @param storageService Injected storage service
   */
  constructor(storageService: StorageService) {
    this.storageService = storageService;
  }

  /**
   * Get all saved devices
   * @returns Array of saved devices
   */
  public async getSavedDevices(): Promise<SavedDevice[]> {
    try {
      const devices = await this.storageService.getValue<SavedDevice[]>(SAVED_DEVICES_KEY);
      return devices || [];
    } catch (error) {
      console.error('[DeviceService] Error getting saved devices:', error);
      return [];
    }
  }

  /**
   * Save devices to storage
   * @param devices Array of BLE devices to save
   */
  public async saveDevices(devices: Device[]): Promise<void> {
    try {
      // Get existing devices
      const existingDevices = await this.getSavedDevices();
      
      // Map new devices to SavedDevice format
      const newDevices: SavedDevice[] = devices.map(device => ({
        id: device.id,
        name: device.name || 'Unknown Device',
        lastConnected: Date.now()
      }));
      
      // Combine with existing, avoiding duplicates
      const combinedDevices = [...existingDevices];
      
      for (const newDevice of newDevices) {
        const existingIndex = combinedDevices.findIndex(d => d.id === newDevice.id);
        if (existingIndex !== -1) {
          // Update the existing device with a new lastConnected timestamp
          combinedDevices[existingIndex] = {
            ...combinedDevices[existingIndex],
            lastConnected: Date.now()
          };
        } else {
          // Add the new device
          combinedDevices.push(newDevice);
        }
      }
      
      // Save to storage
      await this.storageService.setValue(SAVED_DEVICES_KEY, combinedDevices);
      
      console.log(`[DeviceService] Saved ${newDevices.length} devices, total: ${combinedDevices.length}`);
    } catch (error) {
      console.error('[DeviceService] Error saving devices:', error);
      throw error;
    }
  }

  /**
   * Remove a device from saved devices
   * @param device Device or deviceId to remove
   */
  public async removeDevice(device: SavedDevice | string): Promise<void> {
    try {
      const devices = await this.getSavedDevices();
      const deviceId = typeof device === 'string' ? device : device.id;
      const filteredDevices = devices.filter(d => d.id !== deviceId);
      
      if (filteredDevices.length !== devices.length) {
        await this.storageService.setValue(SAVED_DEVICES_KEY, filteredDevices);
        console.log(`[DeviceService] Removed device: ${deviceId}`);
      }
    } catch (error) {
      console.error(`[DeviceService] Error removing device:`, error);
      throw error;
    }
  }

  /**
   * Clear all saved devices
   */
  public async clearDevices(): Promise<void> {
    try {
      await this.storageService.setValue(SAVED_DEVICES_KEY, []);
      console.log('[DeviceService] Cleared all saved devices');
    } catch (error) {
      console.error('[DeviceService] Error clearing devices:', error);
      throw error;
    }
  }
} 

================================================================================
File: src/services/StorageService.ts
================================================================================

import AsyncStorage from "@react-native-async-storage/async-storage";

/**
 * Service for managing AsyncStorage operations
 */
export class StorageService {
  /**
   * Store a value in AsyncStorage
   * @param key Storage key
   * @param value Value to store (will be JSON stringified)
   */
  public async setValue<T>(key: string, value: T): Promise<void> {
    try {
      const jsonValue = JSON.stringify(value);
      await AsyncStorage.setItem(key, jsonValue);
    } catch (error) {
      console.error(`[StorageService] Error setting value for key ${key}:`, error);
      throw error;
    }
  }

  /**
   * Get a value from AsyncStorage
   * @param key Storage key
   * @returns Retrieved value or null if not found
   */
  public async getValue<T>(key: string): Promise<T | null> {
    try {
      const jsonValue = await AsyncStorage.getItem(key);
      return jsonValue !== null ? JSON.parse(jsonValue) as T : null;
    } catch (error) {
      console.error(`[StorageService] Error getting value for key ${key}:`, error);
      return null;
    }
  }

  /**
   * Remove a value from AsyncStorage
   * @param key Storage key to remove
   */
  public async removeValue(key: string): Promise<void> {
    try {
      await AsyncStorage.removeItem(key);
    } catch (error) {
      console.error(`[StorageService] Error removing key ${key}:`, error);
      throw error;
    }
  }

  /**
   * Clear all values from AsyncStorage
   * Use with caution!
   */
  public async clearAll(): Promise<void> {
    try {
      await AsyncStorage.clear();
    } catch (error) {
      console.error('[StorageService] Error clearing AsyncStorage:', error);
      throw error;
    }
  }

  /**
   * Check if a key exists in AsyncStorage
   * @param key Storage key to check
   * @returns Boolean indicating if key exists
   */
  public async hasKey(key: string): Promise<boolean> {
    try {
      const value = await AsyncStorage.getItem(key);
      return value !== null;
    } catch (error) {
      console.error(`[StorageService] Error checking key ${key}:`, error);
      return false;
    }
  }

  /**
   * Get multiple values from AsyncStorage
   * @param keys Array of storage keys
   * @returns Object mapping keys to their values
   */
  public async getMultipleValues(keys: string[]): Promise<Record<string, any>> {
    try {
      const result: Record<string, any> = {};
      const keyValuePairs = await AsyncStorage.multiGet(keys);
      
      keyValuePairs.forEach(([key, value]) => {
        if (value !== null) {
          try {
            result[key] = JSON.parse(value);
          } catch {
            result[key] = value; // Use raw value if not valid JSON
          }
        }
      });
      
      return result;
    } catch (error) {
      console.error('[StorageService] Error getting multiple values:', error);
      return {};
    }
  }
} 

================================================================================
File: src/types.ts
================================================================================

// Core data types
export interface BongHit {
    id?: number;
    timestamp: string;
    duration_ms: number;
    intensity?: number;
    notes?: string;
}

export interface BongHitStats {
    averageDuration: number;
    longestHit: number;
    totalHits?: number;
}

export interface DailyStats {
    date: string;
    hitCount: number;
    averageDuration: number;
}

export interface AverageHourCount {
    count: number;
    hourOfDay: string;
}

export interface Datapoint {
    x: string | number;
    y: number;
}

// Chart-specific types
export interface ChartDataPoint {
    label: string;
    value: number;
}

export interface ChartDataset {
    data: number[];
    color: (opacity?: number) => string;
    strokeWidth: number;
}

export interface ChartData {
    labels: string[];
    datasets: ChartDataset[];
    legend?: string[];
}

// Database types
export interface DatabaseRow {
    timestamp?: string;
    duration_ms?: number;
    day?: string;
    month?: string;
    hour?: string;
    hit_count?: number;
    count?: number;
    avg_duration?: number;
    max_duration?: number;
    total_hits?: number;
    avg_hits_per_day?: number;
    avg_duration_per_day?: number;
    daily_hits?: number;
    days_with_data?: number;
    weekday_avg?: number;
    weekday_total?: number;
    weekend_avg?: number;
    weekend_total?: number;
    peak_day_hits?: number;
    lowest_day_hits?: number;
    most_active_hour?: number;
    least_active_hour?: number;
    total_duration?: number;
    avg_hits_per_hour?: number;
    hits_std_dev?: number;
    // Fields from time distribution query
    morning?: number;
    afternoon?: number;
    evening?: number;
    night?: number;
    // Fields from usage stats query
    average_hits_per_day?: number;
    shortest_hit?: number;
    longest_hit?: number;
    consistency?: number;
}

export interface UsageStats {
    // Hit counts
    averageHitsPerDay: number;
    totalHits: number;
    peakDayHits: number;
    lowestDayHits: number;
    
    // Duration stats
    averageDuration: number;  // in ms
    longestHit: number;      // in ms
    shortestHit: number;     // in ms
    
    // Time patterns
    mostActiveHour: number;  // 0-23
    leastActiveHour: number; // 0-23
    
    // Derived metrics
    totalDuration: number;   // total time in ms
    averageHitsPerHour: number;
    consistency: number;     // standard deviation of daily hits

    // Weekday vs Weekend stats
    weekdayStats: WeekdayStats;
}

// Add new interfaces for time distribution
export interface TimeDistribution {
    morning: number;
    afternoon: number;
    evening: number;
    night: number;
}

export interface WeekdayStats {
    weekday: { avg: number; total: number; };
    weekend: { avg: number; total: number; };
}

// Component Props interfaces
export interface WeeklyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface MonthlyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface NotificationProps {
    averageHits: number;
    percentageChange: number;
    onDismiss: () => void;
}

export interface DailyAverageCardProps {
    data: ChartDataPoint[];
    averageHits: number;
    onPress?: () => void;
}

export interface WeeklyUsageBannerProps {
    weeklyData: ChartDataPoint[];
    average: number;
    percentageChange: number;
    onPress?: () => void;
}

// API Response types
export interface DatabaseResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}

export interface UsageAnalytics {
    dailyAverage: number;
    weeklyAverage: number;
    percentageChange: number;
    lastUpdated: string;
}

export interface SavedDevice {
    id: string;
    name: string;
    lastConnected?: number; // Timestamp in milliseconds
}

// State management types
export interface DataState {
    weeklyData: ChartDataPoint[];
    monthlyData: ChartDataPoint[];
    usageStats: UsageStats;
    timeDistribution: TimeDistribution;
    isLoading: boolean;
    error: string | null;
}

export interface Strain {
  id?: number;
  name: string;
  overview: string;
  genetic_type: string;
  lineage: string;
  thc_range: string;
  cbd_level: string;
  dominant_terpenes: string;
  qualitative_insights: string;
  effects: string;
  negatives: string;
  uses: string;
  thc_rating: number;
  user_rating: number;
  combined_rating: number;
  created_at?: string;
}

/**
 * Filters for searching strains
 */
export interface StrainSearchFilters {
  geneticType?: 'Indica' | 'Sativa' | 'Hybrid';
  effects?: string[];
  sort?: 'name' | 'rating' | 'thc' | 'cbd';
  minTHC?: number;
  maxTHC?: number;
  minCBD?: number;
  maxCBD?: number;
  category?: string;
}

/**
 * Pagination parameters for search results
 */
export interface PaginationParams {
  page: number;
  limit: number;
}

/**
 * Strain search result
 */
export interface StrainSearchResult<T> {
  data: T[];
  total: number;
  currentPage: number;
  totalPages: number;
  hasMore: boolean;
}

// =========================================================
// Achievement types (moved from src/types/achievements.ts)
// =========================================================

export interface Achievement {
  id: number;
  category: string;
  name: string;
  unlockCondition: string;
  notes: string;
  icon: string; // MaterialCommunityIcons name
  complexity: number; // For achievement difficulty/value
}

export interface UserAchievement {
  userId: string;
  achievementId: number;
  progress: number; // 0-100%
  dateUnlocked: string | null;
  isUnlocked: boolean;
  isNew: boolean; // For notifications
  progressData?: any; // JSON data for specific tracking
}

// Extended UserAchievement with achievement details for UI
export interface UserAchievementWithDetails extends UserAchievement {
  id: number;
  category: string;
  name: string;
  unlockCondition: string;
  notes: string;
  icon: string;
  complexity: number;
}

// =========================================================
// AI-related types (moved from src/types/ai.ts)
// =========================================================

// AI recommendation system types
export interface UserProfile {
  id: string;
  experience_level: 'beginner' | 'intermediate' | 'experienced';
  preferred_effects: string[];
  medical_needs?: string[];
  avoid_effects?: string[];
  preferred_consumption_method?: string;
  thc_tolerance?: number; // Scale 1-10
  medications?: string[];
  created_at: string;
  updated_at: string;
}

export interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: string;
}

export interface JournalEntry {
  id: string;
  user_id: string;
  strain_id: number;
  strain_name: string;
  consumption_method: string;
  dosage: number;
  dosage_unit: string;
  effects_felt: string[];
  rating: number;
  effectiveness: number;
  notes?: string;
  mood_before?: string;
  mood_after?: string;
  medical_symptoms_relieved?: string[];
  negative_effects?: string[];
  duration_minutes?: number;
  created_at: string;
}

export interface RecommendationRequest {
  userProfile: UserProfile;
  journalEntries?: JournalEntry[];
  desiredEffects: string[];
  medicalNeeds?: string[];
  context?: 'recreational' | 'medical' | 'wellness';
  locationCode?: string; // For regulations
}

export interface StrainRecommendation {
  strainId: number;
  strainName: string;
  matchScore: number; // 0-100
  reasoningFactors: {
    factor: string;
    weight: number;
  }[];
  alternativeStrains?: {
    strainId: number;
    strainName: string;
    reason: string;
  }[];
}

export interface DosageSuggestion {
  minDosage: number;
  maxDosage: number;
  unit: string;
  gradualApproach: boolean;
  notes: string;
}

export interface RecommendationResponse {
  recommendations: StrainRecommendation[];
  reasoning: string;
  confidenceScore: number;
  disclaimers: string[];
  dosageSuggestion?: DosageSuggestion;
  safetyNotes?: string[];
  error?: {
    message: string;
    type: string;
    recoverable: boolean;
  };
}

export interface ChatRequest {
  message: string;
  userProfile: UserProfile;
  locationCode?: string;
  previousMessages?: {
    role: 'user' | 'assistant';
    content: string;
  }[];
}

export interface ChatResponse {
  response: string;
  educationalLinks?: string[];
  disclaimers?: string[];
  regulatoryNotes?: string[];
  followUpSuggestions?: string[];
}

export interface JournalAnalysisResult {
  patterns: string[];
  insights: string[];
  recommendations: string[];
  safetyFlags?: string[];
}

export interface SafetyValidationResult {
  valid: boolean;
  reason?: string;
  modifications?: Partial<RecommendationRequest>;
  safetyFlags?: string[];
  warningLevel?: 'info' | 'warning' | 'critical';
}

export interface DrugInteractionResult {
  hasInteractions: boolean;
  details?: string[];
  severity?: 'mild' | 'moderate' | 'severe';
  recommendations?: string[];
}

export interface OveruseDetectionResult {
  detected: boolean;
  level?: 'mild' | 'moderate' | 'severe';
  details?: string;
  recommendedAction?: string;
  coolingOffPeriod?: number; // in days
}

export interface SafetyRecord {
  id: string;
  user_id: string;
  concern_type: 'overuse' | 'negative_effects' | 'interactions';
  concern_details: string;
  resolution_suggestions: string[];
  cooling_off_until: number | null;
  created_at: string;
}


================================================================================
File: src/utils/animations.ts
================================================================================

import { useCallback } from 'react';
import { Platform } from 'react-native';
import {
  FadeIn,
  FadeInDown,
  FadeInUp,
  withSpring,
  withTiming,
  WithTimingConfig,
  Easing,
  useSharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

// Optimized spring configuration
export const SPRING_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100,
  restDisplacementThreshold: 0.01,
  restSpeedThreshold: 0.01,
} as const;

// Optimized timing configuration
export const TIMING_CONFIG: WithTimingConfig = {
  duration: 300,
  easing: Easing.bezier(0.25, 0.1, 0.25, 1),
} as const;

// Shared animation factory
export const createSharedAnimation = (delay: number = 0) => {
  return Platform.select({
    ios: FadeInDown.duration(300)
      .springify()
      .delay(delay)
      .damping(SPRING_CONFIG.damping)
      .mass(SPRING_CONFIG.mass),
    android: FadeIn.duration(250)
      .delay(delay)
  });
};

// Optimized press animation hook
export const useAnimatedPress = (scale: number = 0.98) => {
  const pressed = useSharedValue(false);
  
  const animatedStyle = useAnimatedStyle(() => {
    'worklet';
    return {
      transform: [{
        scale: withSpring(
          pressed.value ? scale : 1, 
          SPRING_CONFIG
        )
      }]
    };
  });

  return {
    animatedStyle,
    pressHandlers: {
      onPressIn: useCallback(() => {
        pressed.value = true;
      }, []),
      onPressOut: useCallback(() => {
        pressed.value = false;
      }, [])
    }
  };
};

// Gradient optimization utilities
export const GRADIENT_PROPS = Platform.select({
  ios: {
    shouldRasterizeIOS: true,
  },
  android: {
    renderToHardwareTextureAndroid: true,
  },
});

// Chart animation configuration
export const CHART_ANIMATION_CONFIG = {
  animationEnabled: true,
  animationDuration: 300,
  animationEasing: Easing.ease,
  propsForLabels: {
    fontSize: 10,
    fontWeight: '400'
  }
} as const;

// Optimized layout animation configuration
export const LAYOUT_ANIMATION_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100
} as const; 

================================================================================
File: src/utils/EventEmitter.ts
================================================================================

/**
 * Simple event emitter for communicating between services and hooks
 */
export class EventEmitter {
  private listeners: Record<string, Function[]> = {};

  /**
   * Add event listener
   * @param event Event name
   * @param callback Function to call when event is emitted
   */
  on(event: string, callback: Function) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  }

  /**
   * Remove event listener
   * @param event Event name
   * @param callback Function to remove
   */
  off(event: string, callback: Function) {
    if (!this.listeners[event]) return;
    this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
  }

  /**
   * Emit event to all listeners
   * @param event Event name
   * @param args Arguments to pass to listeners
   */
  emit(event: string, ...args: any[]) {
    if (!this.listeners[event]) return;
    this.listeners[event].forEach(callback => {
      try {
        callback(...args);
      } catch (error) {
        console.error(`[EventEmitter] Error in event listener for ${event}:`, error);
      }
    });
  }
}

// Create and export singleton instance
export const dataChangeEmitter = new EventEmitter();

// Define common event names
export const dbEvents = {
  DATA_CHANGED: 'dataChanged'
}; 

================================================================================
File: src/utils/filters.ts
================================================================================

import { StrainSearchFilters } from '../DatabaseManager';

export const hasActiveFilters = (filters: StrainSearchFilters): boolean => {
  return !!(
    filters.geneticType ||
    (filters.effects && filters.effects.length > 0) ||
    filters.minTHC ||
    filters.maxTHC ||
    (filters.sort && filters.sort !== 'rating')
  );
}; 

================================================================================
File: src/utils/functions.ts
================================================================================

const monthStringToInt: { [key: string]: string } = {
    "January": "01",
    "February": "02",
    "March": "03",
    "April": "04",
    "May": "05",
    "June": "06",
    "July": "07",
    "August": "08",
    "September": "09",
    "October": "10",
    "November": "11",
    "December": "12",
};

/**
 * Parses raw timestamp from device into a standard ISO format
 * @param rawTimestamp Raw timestamp string from device (e.g., "Thursday, March 27 2025 23:19:34")
 * @returns ISO 8601 formatted timestamp string (e.g., "2025-03-27T23:19:34.000Z")
 */
export function parseRawTimestamp(rawTimestamp: string): string {
    try {
        // Remove day, then separate by spaces
        const parts: string[] = rawTimestamp.split(',')[1].trim().split(' ');
        
        if (parts.length < 4) {
            console.error('Invalid timestamp format received:', rawTimestamp);
            throw new Error('Invalid timestamp parts');
        }
        
        const monthStr: string = parts[0];
        const day: string = parts[1].padStart(2, '0');
        const year: string = parts[2];
        const time: string = parts[3];
        
        // Get month number and pad with zero if needed
        const monthNum = monthStringToInt[monthStr];
        if (!monthNum) {
            console.error(`Unknown month: ${monthStr}`);
            throw new Error('Unknown month');
        }
        const month: string = monthNum;
        
        // Create a Date object from the local time
        // This correctly parses as local time, not UTC
        const localDate = new Date(`${year}-${month}-${day}T${time}`);
        
        // Check if the date is valid
        if (isNaN(localDate.getTime())) {
            console.error('Created invalid date:', localDate);
            throw new Error('Invalid resulting date');
        }
        
        // Convert to UTC ISO string - this will apply the proper timezone offset
        const utcTimestamp = localDate.toISOString();
        console.log(`[parseRawTimestamp] Local timestamp: ${localDate.toString()}, UTC: ${utcTimestamp}`);
        
        return utcTimestamp;
    } catch (error) {
        console.error('Error parsing timestamp:', error);
        // Fallback - create a current timestamp in ISO format
        return new Date().toISOString();
    }
}

================================================================================
File: src/utils/QueryBuilder.ts
================================================================================

/**
 * QueryBuilder - A simple SQL query builder for SQLite
 * 
 * This class provides a fluent interface for building SQL queries
 * without having to write raw SQL strings.
 */
export class QueryBuilder {
  private selectCols: string[] = [];
  private fromTableName: string = '';
  private whereConditions: string[] = [];
  private orderByClauses: string[] = [];
  private groupByClauses: string[] = [];
  private limitValue: number | null = null;
  private offsetValue: number | null = null;
  private paramValues: any[] = [];
  
  /**
   * Select columns to include in the query
   * @param columns Column names to select
   * @returns this instance for chaining
   */
  selectColumns(columns: string | string[]): QueryBuilder {
    if (Array.isArray(columns)) {
      this.selectCols.push(...columns);
    } else {
      this.selectCols.push(columns);
    }
    return this;
  }
  
  /**
   * Set the table to query from
   * @param table Table name
   * @returns this instance for chaining
   */
  from(table: string): QueryBuilder {
    this.fromTableName = table;
    return this;
  }
  
  /**
   * Add a WHERE condition with parameters
   * @param condition SQL condition as string
   * @param params Parameters to bind to the condition
   * @returns this instance for chaining
   */
  whereClause(condition: string, ...params: any[]): QueryBuilder {
    this.whereConditions.push(condition);
    this.paramValues.push(...params);
    return this;
  }

  /**
   * Add an ORDER BY clause
   * @param column Column to order by
   * @param direction Sort direction (ASC or DESC)
   * @returns this instance for chaining
   */
  orderByColumn(column: string, direction: 'ASC' | 'DESC' = 'ASC'): QueryBuilder {
    this.orderByClauses.push(`${column} ${direction}`);
    return this;
  }

  /**
   * Add a GROUP BY clause
   * @param columns Columns to group by
   * @returns this instance for chaining
   */
  groupByColumns(columns: string | string[]): QueryBuilder {
    if (Array.isArray(columns)) {
      this.groupByClauses.push(...columns);
    } else {
      this.groupByClauses.push(columns);
    }
    return this;
  }

  /**
   * Set LIMIT clause
   * @param limit Maximum number of rows to return
   * @returns this instance for chaining
   */
  limitTo(limit: number): QueryBuilder {
    this.limitValue = limit;
    return this;
  }

  /**
   * Set OFFSET clause
   * @param offset Number of rows to skip
   * @returns this instance for chaining
   */
  offsetBy(offset: number): QueryBuilder {
    this.offsetValue = offset;
    return this;
  }
  
  /**
   * Build the final SQL query and parameters
   * @returns Object containing the query string and parameters array
   */
  build(): { query: string, params: any[] } {
    const parts: string[] = [];
    
    // SELECT clause
    parts.push(`SELECT ${this.selectCols.length > 0 ? this.selectCols.join(', ') : '*'}`);
    
    // FROM clause
    parts.push(`FROM ${this.fromTableName}`);
    
    // WHERE clause
    if (this.whereConditions.length > 0) {
      parts.push(`WHERE ${this.whereConditions.join(' AND ')}`);
    }
    
    // GROUP BY clause
    if (this.groupByClauses.length > 0) {
      parts.push(`GROUP BY ${this.groupByClauses.join(', ')}`);
    }
    
    // ORDER BY clause
    if (this.orderByClauses.length > 0) {
      parts.push(`ORDER BY ${this.orderByClauses.join(', ')}`);
    }
    
    // LIMIT clause
    if (this.limitValue !== null) {
      parts.push(`LIMIT ${this.limitValue}`);
    }
    
    // OFFSET clause
    if (this.offsetValue !== null) {
      parts.push(`OFFSET ${this.offsetValue}`);
    }
    
    return {
      query: parts.join(' '),
      params: this.paramValues
    };
  }
} 

================================================================================
File: src/utils/SqlTemplates.ts
================================================================================

/**
 * SQL Templates
 * 
 * This file contains template functions for commonly used SQL queries.
 * It helps to keep the SQL queries organized, maintainable, and separated
 * from the database logic.
 */

/**
 * Get the query for usage statistics
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getUsageStatsQuery(tableName: string): string {
  // Date filter clause will be added externally
  return `
    WITH FilteredData AS (
      SELECT timestamp, duration_ms
      FROM ${tableName}
      -- DATE FILTER ADDED EXTERNALLY
    ),
    DailyStats AS (
      SELECT
        strftime('%Y-%m-%d', timestamp, 'utc') as day,
        strftime('%w', timestamp, 'utc') as weekday,
        COUNT(*) as daily_hits,
        AVG(duration_ms) as avg_duration_per_day,
        MIN(duration_ms) as min_duration,
        MAX(duration_ms) as max_duration,
        SUM(duration_ms) as total_duration_per_day
      FROM FilteredData
      GROUP BY day
    ),
    TotalStats AS (
      SELECT
        COUNT(*) as total_hits,
        COUNT(DISTINCT strftime('%Y-%m-%d', timestamp, 'utc')) as active_days,
        AVG(duration_ms) as overall_avg_duration,
        SUM(duration_ms) as total_duration
      FROM FilteredData
    ),
    DayOfWeekStats AS (
      SELECT
        weekday,
        COUNT(*) as total_hits,
        AVG(daily_hits) as avg_hits_per_day
      FROM DailyStats
      GROUP BY weekday
    ),
    HourlyStats AS (
       SELECT
         CAST(strftime('%H', timestamp, 'utc') AS INTEGER) as hour,
         COUNT(*) as hits
       FROM FilteredData
       GROUP BY hour
    )
    SELECT
      COALESCE((SELECT total_hits FROM TotalStats), 0) as total_hits,
      COALESCE((SELECT active_days FROM TotalStats), 0) as active_days,
      CASE WHEN COALESCE((SELECT active_days FROM TotalStats), 0) > 0
           THEN CAST(COALESCE((SELECT total_hits FROM TotalStats), 0) AS REAL) / (SELECT active_days FROM TotalStats)
           ELSE 0
      END as avg_hits_per_active_day,
      COALESCE((SELECT overall_avg_duration FROM TotalStats), 0) as avg_duration_ms,
      COALESCE((SELECT total_duration FROM TotalStats), 0) as total_duration_ms,
      COALESCE((SELECT MAX(daily_hits) FROM DailyStats), 0) as max_hits_in_day,
      COALESCE((SELECT MIN(daily_hits) FROM DailyStats WHERE daily_hits > 0), 0) as min_hits_in_day,
      COALESCE((SELECT MAX(max_duration) FROM DailyStats), 0) as longest_hit,
      COALESCE((SELECT MIN(min_duration) FROM DailyStats WHERE min_duration > 0), 0) as shortest_hit,
      COALESCE((SELECT hour FROM HourlyStats ORDER BY hits DESC LIMIT 1), -1) as most_active_hour,
      COALESCE((SELECT hour FROM HourlyStats ORDER BY hits ASC LIMIT 1), -1) as least_active_hour
  `;
}

/**
 * Get the query for time distribution of usage
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getTimeDistributionQuery(tableName: string): string {
  // Date filter clause will be added externally
  return `
    WITH HourlyHits AS (
      SELECT
        CAST(strftime('%H', timestamp, 'utc') AS INTEGER) as hour,
        COUNT(*) as hits
      FROM ${tableName}
      -- DATE FILTER ADDED EXTERNALLY
      GROUP BY hour
    ),
    TotalHits AS (
      -- Use COALESCE to ensure total is not NULL if HourlyHits is empty
      SELECT COALESCE(SUM(hits), 0) as total FROM HourlyHits
    )
    SELECT
      -- Use MAX(1, ...) to prevent division by zero
      CAST(COALESCE((SELECT SUM(hits) FROM HourlyHits WHERE hour >= 5 AND hour < 12), 0) AS REAL) / MAX(1, (SELECT total FROM TotalHits)) as morning,
      CAST(COALESCE((SELECT SUM(hits) FROM HourlyHits WHERE hour >= 12 AND hour < 17), 0) AS REAL) / MAX(1, (SELECT total FROM TotalHits)) as afternoon,
      CAST(COALESCE((SELECT SUM(hits) FROM HourlyHits WHERE hour >= 17 AND hour < 22), 0) AS REAL) / MAX(1, (SELECT total FROM TotalHits)) as evening,
      CAST(COALESCE((SELECT SUM(hits) FROM HourlyHits WHERE hour >= 22 OR hour < 5), 0) AS REAL) / MAX(1, (SELECT total FROM TotalHits)) as night
  `;
}

/**
 * Get the query for weekly stats
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getWeeklyStatsQuery(tableName: string): string {
  // Date filter clause will be added externally
  return `
    SELECT
      strftime('%w', timestamp, 'utc') as day_of_week,
      COUNT(*) as count,
      AVG(duration_ms) as avg_duration
    FROM ${tableName}
    -- DATE FILTER ADDED EXTERNALLY
    GROUP BY day_of_week
    ORDER BY day_of_week ASC
  `;
}

/**
 * Get the query for monthly stats
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getMonthlyStatsQuery(tableName: string): string {
  // Date filter clause will be added externally
  return `
    SELECT
      strftime('%m', timestamp, 'utc') as month,
      COUNT(*) as count
    FROM ${tableName}
    -- DATE FILTER ADDED EXTERNALLY
    GROUP BY month
    ORDER BY month ASC
  `;
}

/**
 * Get query for finding strains with filter conditions
 * @param filters Filter conditions 
 * @returns SQL query parts (where clause, params)
 */
export function buildStrainFilterQuery(
  query: string,
  filters: {
    genetic_type?: string;
    effects?: string[];
    minThc?: number;
    maxThc?: number;
  }
): { whereClause: string, params: any[] } {
  const whereClauses = [];
  const params: any[] = [];

  // Search by name if query is provided
  if (query && query.trim() !== '') {
    whereClauses.push('(name LIKE ? OR genetic_type LIKE ? OR effects LIKE ?)');
    const searchTerm = `%${query}%`;
    params.push(searchTerm, searchTerm, searchTerm);
  }

  // Filter by genetic type
  if (filters.genetic_type) {
    whereClauses.push('genetic_type = ?');
    params.push(filters.genetic_type);
  }

  // Filter by effects
  if (filters.effects && filters.effects.length > 0) {
    const effectClauses = filters.effects.map(() => 'effects LIKE ?');
    whereClauses.push(`(${effectClauses.join(' OR ')})`);
    filters.effects.forEach(effect => params.push(`%${effect}%`));
  }

  // Filter by THC range
  if (filters.minThc !== undefined) {
    whereClauses.push('thc_rating >= ?');
    params.push(filters.minThc);
  }

  if (filters.maxThc !== undefined) {
    whereClauses.push('thc_rating <= ?');
    params.push(filters.maxThc);
  }

  return {
    whereClause: whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '',
    params
  };
}

// Helper function to create WHERE clause for date filtering using ISO strings
export function getDateRangeFilter(startDate?: string, endDate?: string): { clause: string, params: string[] } {
  if (!startDate && !endDate) {
    // No date range specified, return empty clause and params
    return { clause: '', params: [] };
  }

  const conditions: string[] = [];
  const params: string[] = [];

  if (startDate) {
    console.log(`[SqlTemplates] Adding start date condition: timestamp >= ${startDate}`);
    conditions.push(`timestamp >= ?`);
    params.push(startDate); // Pass the ISO string as a parameter
  }

  if (endDate) {
    console.log(`[SqlTemplates] Adding end date condition: timestamp <= ${endDate}`);
    conditions.push(`timestamp <= ?`);
    params.push(endDate); // Pass the ISO string as a parameter
  }

  // Combine conditions with AND
  const clause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  return { clause, params };
} 

================================================================================
File: src/utils/timeUtils.ts
================================================================================

/**
 * Utility functions for calculating date ranges in the local timezone.
 */

/**
 * Gets the start and end of the current day in the local timezone.
 * @returns { startDate: Date, endDate: Date }
 */
export function getTodayRangeLocal(): { startDate: Date, endDate: Date } {
  const now = new Date();
  const startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0); // Start of today (local)
  const endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999); // End of today (local)
  console.log(`[timeUtils] Today Range (Local): ${startDate.toISOString()} to ${endDate.toISOString()}`);
  return { startDate, endDate };
}

/**
 * Gets the start of the current week (Sunday) and the end of the current day in the local timezone.
 * @param weekStartsOnSunday If true, week starts Sunday(0). If false, starts Monday(1). Default true.
 * @returns { startDate: Date, endDate: Date }
 */
export function getCurrentWeekProgressRangeLocal(weekStartsOnSunday: boolean = true): { startDate: Date, endDate: Date } {
  const now = new Date();
  const currentDayOfWeek = now.getDay(); // 0 = Sunday, 6 = Saturday

  const startDate = new Date(now);
  const dayOffset = weekStartsOnSunday ? currentDayOfWeek : (currentDayOfWeek === 0 ? 6 : currentDayOfWeek - 1);
  startDate.setDate(now.getDate() - dayOffset);
  startDate.setHours(0, 0, 0, 0); // Start of the first day of the week (local)

  const endDate = new Date(); // End of today (local)
  endDate.setHours(23, 59, 59, 999);

  console.log(`[timeUtils] Current Week Progress Range (Local): ${startDate.toISOString()} to ${endDate.toISOString()}`);
  return { startDate, endDate };
}

/**
 * Gets the start and end of the current full week (e.g., Sun-Sat) in the local timezone.
 * @param weekStartsOnSunday If true, week starts Sunday(0). If false, starts Monday(1). Default true.
 * @returns { startDate: Date, endDate: Date }
 */
export function getCurrentFullWeekRangeLocal(weekStartsOnSunday: boolean = true): { startDate: Date, endDate: Date } {
  const { startDate: startOfWeek } = getCurrentWeekProgressRangeLocal(weekStartsOnSunday);
  const endDate = new Date(startOfWeek);
  endDate.setDate(startOfWeek.getDate() + 6); // Go to the end of the week (Saturday or Sunday)
  endDate.setHours(23, 59, 59, 999);

  console.log(`[timeUtils] Current Full Week Range (Local): ${startOfWeek.toISOString()} to ${endDate.toISOString()}`);
  return { startDate: startOfWeek, endDate };
}

/**
 * Gets the start and end for the last N days, ending today.
 * @param days Number of days to look back.
 * @returns { startDate: Date, endDate: Date }
 */
export function getLastNDaysRangeLocal(days: number): { startDate: Date, endDate: Date } {
  const endDate = new Date(); // End of today
  endDate.setHours(23, 59, 59, 999);

  const startDate = new Date();
  startDate.setDate(endDate.getDate() - (days - 1)); // Go back N-1 days to include today
  startDate.setHours(0, 0, 0, 0); // Start of the first day

  console.log(`[timeUtils] Last ${days} Days Range (Local): ${startDate.toISOString()} to ${endDate.toISOString()}`);
  return { startDate, endDate };
} 

================================================================================
File: src/utils/validators.ts
================================================================================

import { BongHit, Strain, JournalEntry, SafetyRecord } from '../types';

/**
 * Validators utility
 * 
 * Contains domain-specific validation functions for various data types
 * used throughout the application.
 */

/**
 * Validate a BongHit object
 * @param hit The BongHit to validate
 * @returns Error message if invalid, null if valid
 */
export function validateBongHit(hit: BongHit): string | null {
  if (!hit) return 'Bong hit data is required';
  if (!hit.timestamp) return 'Timestamp is required';
  if (!isValidISOTimestamp(hit.timestamp)) return 'Invalid timestamp format';
  if (typeof hit.duration_ms !== 'number') return 'Duration must be a number';
  if (hit.duration_ms <= 0) return 'Duration must be positive';
  return null; // Valid
}

/**
 * Validate a Strain object
 * @param strain The Strain to validate
 * @returns Error message if invalid, null if valid
 */
export function validateStrain(strain: Strain): string | null {
  if (!strain) return 'Strain data is required';
  if (!strain.name || strain.name.trim() === '') return 'Strain name is required';
  if (!strain.genetic_type) return 'Genetic type is required';
  if (strain.thc_rating != null && (typeof strain.thc_rating !== 'number' || strain.thc_rating < 0 || strain.thc_rating > 100)) {
    return 'THC rating must be a number between 0 and 100';
  }
  return null; // Valid
}

/**
 * Validate a SafetyRecord object
 * @param record The SafetyRecord to validate
 * @returns Error message if invalid, null if valid
 */
export function validateSafetyRecord(record: SafetyRecord): string | null {
  if (!record) return 'Safety record is required';
  if (!record.id) return 'Safety record ID is required';
  if (!record.user_id) return 'User ID is required';
  if (!record.concern_type) return 'Concern type is required';
  if (!record.concern_details || record.concern_details.trim() === '') return 'Concern details are required';
  if (!record.created_at) return 'Created timestamp is required';
  return null; // Valid
}

/**
 * Validate a JournalEntry object
 * @param entry The JournalEntry to validate
 * @returns Error message if invalid, null if valid
 */
export function validateJournalEntry(entry: JournalEntry): string | null {
  if (!entry) return 'Journal entry is required';
  if (!entry.id) return 'Entry ID is required';
  if (!entry.user_id) return 'User ID is required';
  if (!entry.created_at) return 'Created timestamp is required';
  if (!isValidISOTimestamp(entry.created_at)) return 'Invalid timestamp format';
  return null; // Valid
}

/**
 * Check if a string is a valid ISO timestamp
 * @param timestamp The timestamp string to validate
 * @returns Whether the string is a valid ISO timestamp
 */
export function isValidISOTimestamp(timestamp: string): boolean {
  try {
    if (typeof timestamp !== 'string') {
      console.error(`[Validators] Invalid timestamp type: ${typeof timestamp}`);
      return false;
    }
    
    // Check for ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ)
    // This regex checks for the basic pattern but isn't exhaustive
    if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/.test(timestamp)) {
      console.error(`[Validators] Timestamp doesn't match ISO format: ${timestamp}`);
      return false;
    }
    
    const date = new Date(timestamp);
    const isValid = !isNaN(date.getTime());
    
    // Extra validation: Check that the timestamp is truly ISO format by ensuring
    // toISOString() produces the exact same string
    const roundTrip = isValid && date.toISOString() === timestamp;
    
    if (!isValid) {
      console.error(`[Validators] Invalid date from timestamp: ${timestamp}`);
    } else if (!roundTrip) {
      console.error(`[Validators] Timestamp not in canonical ISO format. Original: ${timestamp}, Parsed: ${date.toISOString()}`);
    }
    
    return isValid && roundTrip;
  } catch (error) {
    console.error(`[Validators] Error validating timestamp: ${error}`);
    return false;
  }
}

/**
 * Validate that a value is not empty (null, undefined, or empty string)
 * @param value The value to validate
 * @param fieldName The name of the field for the error message
 * @throws Error if the value is empty
 */
export function validateNotEmpty(value: any, fieldName: string): void {
  if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
    throw new Error(`${fieldName} is required and cannot be empty`);
  }
}

/**
 * Create a validation error result
 * @param code Error code
 * @param message Error message
 * @param data Optional data related to the error
 * @returns Validation error result object
 */
export function createValidationError<T>(code: string, message: string, data?: any): { 
  success: false, 
  error: string, 
  code: string, 
  data?: any 
} {
  return {
    success: false,
    error: message,
    code,
    data
  };
}

/**
 * Create a successful validation result
 * @param data The validated data
 * @returns Successful validation result object
 */
export function createValidationSuccess<T>(data: T): {
  success: true,
  data: T
} {
  return {
    success: true,
    data
  };
}

/**
 * Validation result type
 */
export type ValidationResult<T> = 
  | { success: true, data: T }
  | { success: false, error: string, code: string, data?: any }; 

================================================================================
File: tsconfig.json
================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}