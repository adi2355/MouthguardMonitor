

================================================================================
File: app.json
================================================================================

{
  "expo": {
    "name": "CanovaReactNativeApp",
    "slug": "CanovaReactNativeApp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/canovafavicon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.anonymous.CanovaReactNativeApp",
      "infoPlist": {
        "NSBluetoothAlwaysUsageDescription": "This app requires Bluetooth access to connect to devices.",
        "NSBluetoothPeripheralUsageDescription": "This app requires Bluetooth access to communicate with nearby devices."
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/canovafavicon.png",
        "backgroundColor": "#ffffff"
      },
      "permissions": [
        "android.permission.BLUETOOTH",
        "android.permission.BLUETOOTH_ADMIN",
        "android.permission.BLUETOOTH_CONNECT",
        "android.permission.BLUETOOTH",
        "android.permission.BLUETOOTH_ADMIN",
        "android.permission.BLUETOOTH_CONNECT"
      ],
      "package": "com.anonymous.CanovaReactNativeApp"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/canovafavicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ],
      "expo-sqlite",
      [
        "react-native-ble-plx",
        {
          "isBackgroundEnabled": true,
          "modes": [
            "peripheral",
            "central"
          ],
          "bluetoothAlwaysPermission": "Allow $(PRODUCT_NAME) to connect to bluetooth devices"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}


================================================================================
File: app/_layout.tsx
================================================================================

import { Stack } from "expo-router";
import { useState, useEffect } from "react";
import { BluetoothContext, BluetoothHandler } from "@/src/contexts/BluetoothContext";
import { useColorScheme } from 'react-native';

export default function RootLayout() {
  const colorScheme = useColorScheme();

  const [bluetoothHandler] = useState<BluetoothHandler>(new BluetoothHandler());

  return (
    <BluetoothContext.Provider value={bluetoothHandler}>
      <Stack>
        <Stack.Screen 
          name="(tabs)" 
          options={{ headerShown: false }} 
        />
        <Stack.Screen 
          name="dataOverviews/strains/strainDetails" 
          options={{ 
            headerShown: false,
            presentation: 'modal',
            animation: 'slide_from_bottom',
          }} 
        />
        <Stack.Screen name="+not-found" />
      </Stack>  
    </BluetoothContext.Provider>
  );
}


================================================================================
File: app/(tabs)/_layout.tsx
================================================================================

import { Tabs } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarStyle: {
          backgroundColor: COLORS.background,
          borderTopColor: 'rgba(255, 255, 255, 0.1)',
        },
        tabBarActiveTintColor: COLORS.primary,
        tabBarInactiveTintColor: 'rgba(255, 255, 255, 0.5)',
        headerShown: false,
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          href: null,
        }}
      />
      <Tabs.Screen
        name="mydata"
        options={{
          title: 'My Data',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="chart-box" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="devices"
        options={{
          title: 'Devices',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="devices" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="journal"
        options={{
          title: 'Journal',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="notebook" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="trending"
        options={{
          title: 'Trending',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="trending-up" size={24} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

================================================================================
File: app/(tabs)/devices.tsx
================================================================================

import { BluetoothContext } from '@/src/contexts/BluetoothContext';
import AntDesign from '@expo/vector-icons/AntDesign';
import React, { useState, useEffect, useRef, useContext } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Alert
} from 'react-native';
import base64 from 'react-native-base64';
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';

export default function Devices() {

  const [savedDevices, setSavedDevice] = useState<Device[]>([]);
  const [devices, setDevices] = useState<Device[]>([]);
  const [scanning, setScanning] = useState<boolean>(false);

  //Track devices to avoid duplicate keys when scanning
  const undiscoveredDeviceSet = useRef(new Set<string>());

  const bluetoothHandler = useContext(BluetoothContext)!;

  useEffect(() => {
    setSavedDevice(bluetoothHandler.getSavedDevices());
  }, []);

  // THIS WILL decode BONG HIT DATA
  function onDataUpdate(error: BleError | null, characteristic: Characteristic | null) {
    if (error) {
      console.log(error);
      return -1;
    } else if (!characteristic?.value) {
      console.log("No Data was recieved");
      return -1;
    }
    const rawData = base64.decode(characteristic.value);
    Alert.alert(`Raw Data: ${rawData}`);
  }

  function scanDevices(): void {
    const manager: BleManager = bluetoothHandler.getBLEManager();
    setScanning(true);
    setDevices([]);

    manager.startDeviceScan(null, null, (error, device) => {
      if (error) {
        console.error('Error scanning devices:', error.message);
        setScanning(false);
        return;
      }

      if (device && device.name && !undiscoveredDeviceSet.current.has(device.id)) {
        undiscoveredDeviceSet.current.add(device.id); // Add device ID to the Set
        setDevices((prevDevices) => [...prevDevices, device]);
      }
    });

    // Stop scanning after 10 seconds
    setTimeout(() => {
      manager.stopDeviceScan();
      setScanning(false);
    }, 10000);
  };

  // Renders device
  const renderDevice = ({ item }: { item: Device }): JSX.Element => (
    <TouchableOpacity style={styles.deviceItem} onPress={() => bluetoothHandler.connectToDevice(item)}>
      <AntDesign name="hdd" size={24} color="black" />
      <View style={styles.deviceInfo}>
        <Text style={styles.deviceName}>{item.name}</Text>
      </View>
      {item.id === bluetoothHandler.getConnectedDevice()?.id ? <Text>Connected</Text> : <Text>Not Connected</Text>}
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      <View style={styles.devicesFlatMapContainer}>
        <View style={styles.header}>
          <Text style={styles.headerText}>My Devices</Text>
        </View>
        <FlatList
          data={savedDevices}
          keyExtractor={(item) => item.id}
          renderItem={renderDevice}
          contentContainerStyle={styles.list}
        />
      </View>
      <View style={styles.devicesFlatMapContainer}>
        <View style={styles.header}>
          <Text style={styles.headerText}>Other Devices</Text>
        </View>
        <TouchableOpacity style={styles.scanButton} onPress={scanDevices} disabled={scanning}>
          <Text style={styles.scanButtonText}>
            {scanning ? 'Scanning...' : 'Scan for Devices'}
          </Text>
        </TouchableOpacity>
        {scanning && <ActivityIndicator style={styles.loader} size="large" color="#007AFF" />}
        <FlatList
          data={devices}
          keyExtractor={(item) => item.id}
          renderItem={renderDevice}
          contentContainerStyle={styles.list}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  devicesFlatMapContainer: {
    marginBottom: 20
  },
  header: {
    backgroundColor: '#ffffff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e6e6e6'
  },
  headerText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#000',
  },
  scanButton: {
    backgroundColor: '#12a35f',
    padding: 12,
    margin: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  scanButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loader: {
    marginTop: 10,
  },
  list: {
    padding: 16,
  },
  deviceItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e6e6e6',
    borderRadius: 6,
    marginVertical: 4,
  },
  deviceInfo: {
    marginLeft: 12,
    flex: 1,
  },
  deviceName: {
    fontSize: 16,
    fontWeight: '500',
  },
  deviceId: {
    color: '#8e8e93',
    fontSize: 12,
  },
});


================================================================================
File: app/(tabs)/index.tsx
================================================================================

import { Redirect } from 'expo-router';

export default function Index() {
  return <Redirect href="/mydata" />;
}

================================================================================
File: app/(tabs)/journal.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, Modal, TextInput, Button, StyleSheet } from 'react-native';
import { Calendar } from 'react-native-calendars';

export default function JournalCalendar() {
  const [selectedDate, setSelectedDate] = useState('');
  const [modalVisible, setModalVisible] = useState(false);
  const [entries, setEntries] = useState({});
  const [currentEntry, setCurrentEntry] = useState('');

  const handleDayPress = (day) => {
    const date = day.dateString;
    setSelectedDate(date);
    setCurrentEntry(entries[date] || '');
    setModalVisible(true);
  };

  const saveEntry = () => {
    setEntries({ ...entries, [selectedDate]: currentEntry });
    setModalVisible(false);
  };

  return (
    <View style={styles.container}>
      {/* Calendar */}
      <Calendar
        onDayPress={handleDayPress}
        markedDates={{
          ...Object.keys(entries).reduce((acc, date) => {
            acc[date] = { marked: true };
            return acc;
          }, {}),
          [selectedDate]: { selected: true, selectedColor: '#12a35f' },
        }}
      />

      {/* Modal for journal entry */}
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              Journal Entry for {selectedDate}
            </Text>
            <TextInput
              style={styles.input}
              multiline
              placeholder="Write your journal entry here..."
              value={currentEntry}
              onChangeText={setCurrentEntry}
            />
            <View style={styles.modalButtons}>
              <Button title="Save" onPress={saveEntry} />
              <Button title="Cancel" onPress={() => setModalVisible(false)} />
            </View>
          </View>
        </View>
      </Modal>

      {/* Display Saved Entries */}
      <View style={styles.entriesContainer}>
        <Text style={styles.entriesTitle}>Saved Journal Entries:</Text>
        {Object.keys(entries).length > 0 ? (
          Object.entries(entries).map(([date, entry]) => (
            <View key={date} style={styles.entry}>
              <Text style={styles.entryDate}>{date}</Text>
              <Text style={styles.entryText}>{entry}</Text>
            </View>
          ))
        ) : (
          <Text>No journal entries yet.</Text>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '80%',
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 20,
    alignItems: 'center',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  input: {
    width: '100%',
    height: 100,
    borderColor: '#ddd',
    borderWidth: 1,
    borderRadius: 5,
    padding: 10,
    textAlignVertical: 'top',
    marginBottom: 20,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  entriesContainer: {
    marginTop: 20,
  },
  entriesTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  entry: {
    marginBottom: 10,
  },
  entryDate: {
    fontWeight: 'bold',
  },
  entryText: {
    fontSize: 14,
  },
});


================================================================================
File: app/(tabs)/mydata.tsx
================================================================================

import React, { memo, useCallback, useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { COLORS } from '../../src/constants';
import { useDataService } from '../../src/hooks/useDataService';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LinearGradient } from 'expo-linear-gradient';
import { Text } from 'react-native';
import MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';

// Import components from their new structure
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';
import Header from '../components/mydata/Header';
import Section from '../components/mydata/Section';
import NotificationBanner from '../components/mydata/NotificationBanner';
import MedicalCard from '../components/mydata/MedicalCard';
import DailyAverageCard from '../components/mydata/DailyAverageCard';
import WeeklyUsageBanner from '../components/mydata/WeeklyUsageBanner';
import WeeklyOverviewChart from '../components/charts/WeeklyOverviewChart';
import MonthlyOverviewChart from '../components/charts/MonthlyOverviewChart';
import StatsOverviewCard from '../components/StatsOverviewCard';
import TimeDistributionCard from '../components/TimeDistributionCard';

// Import new components
import GoalTrackingCard from '../components/mydata/GoalTrackingCard';
import SetGoalModal from '../components/mydata/SetGoalModal';
import StrainUsageCard from '../components/mydata/StrainUsageCard';

const ROUTES = {
  DAILY_AVERAGE: "/dataOverviews/dailyAverageOverview",
  WEEKLY_AVERAGE: "/dataOverviews/weeklyAverage",
  WEEKLY_OVERVIEW: "/dataOverviews/weeklyOverview",
  MONTHLY_OVERVIEW: "/dataOverviews/monthlyOverview",
  STRAIN_USAGE: "/dataOverviews/strainUsage",
} as const;

export default memo(function MyData() {
  const router = useRouter();
  const [showNotification, setShowNotification] = useState(true);
  const [goalModalVisible, setGoalModalVisible] = useState(false);
  const [dailyGoal, setDailyGoal] = useState(10); // Default goal
  
  const { 
    weeklyData, 
    monthlyData, 
    usageStats, 
    timeDistribution,
    isLoading, 
    error 
  } = useDataService();

  const handleNavigation = useCallback((route: keyof typeof ROUTES) => {
    router.push(ROUTES[route] as any);
  }, [router]);

  const handleNavigateToAI = () => {
    router.push('/ai/recommendations' as any);
  };

  // Sample strain data - in a real app, this would come from your database
  const mockStrainData = [
    {
      strainId: 1,
      strainName: "Blue Dream",
      strainType: "Hybrid",
      usageCount: 42,
      percentageOfTotal: 35.6
    },
    {
      strainId: 2,
      strainName: "OG Kush",
      strainType: "Indica",
      usageCount: 28,
      percentageOfTotal: 23.7
    },
    {
      strainId: 3,
      strainName: "Sour Diesel",
      strainType: "Sativa",
      usageCount: 18,
      percentageOfTotal: 15.3
    }
  ];

  if (isLoading) return <LoadingView />;
  if (error) return <ErrorView error={error} />;

  const weekdayAvg = usageStats.weekdayStats?.weekday.avg || 0;
  const weekendAvg = usageStats.weekdayStats?.weekend.avg || 0;
  const percentageChange = weekdayAvg > 0 ? ((weekendAvg - weekdayAvg) / weekdayAvg) * 100 : 0;

  return (
    <SafeAreaProvider>
      <Animated.ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
        entering={FadeIn.duration(200)}
        scrollEventThrottle={16}
        removeClippedSubviews={true}
      >
        <Header />

        <View style={styles.mainContent}>
          {/* Goals Section */}
          <Section title="Goals & Tracking">
            <GoalTrackingCard
              currentUsage={usageStats.averageHitsPerDay}
              goalUsage={dailyGoal}
              onEditGoal={() => setGoalModalVisible(true)}
            />
          </Section>

          <Section title="Notifications & Medical">
            {showNotification && (
              <NotificationBanner
                averageHits={usageStats.averageHitsPerDay}
                percentageChange={percentageChange}
                onDismiss={() => setShowNotification(false)}
              />
            )}
            <MedicalCard />
          </Section>

          <Section title="Usage Overview">
            <DailyAverageCard
              data={weeklyData}
              averageHits={usageStats.averageHitsPerDay}
              onPress={() => handleNavigation("DAILY_AVERAGE")}
            />
            <WeeklyUsageBanner
              weeklyData={weeklyData}
              average={usageStats.averageHitsPerDay}
              onPress={() => handleNavigation("WEEKLY_AVERAGE")}
            />
          </Section>

          <Section title="Analytics">
            <StrainUsageCard
              strainData={mockStrainData}
              totalHits={usageStats.totalHits || 100}
              onViewAll={() => handleNavigation("STRAIN_USAGE")}
            />
          </Section>

          <Section title="Usage Charts">
            <WeeklyOverviewChart 
              data={weeklyData}
              onPress={() => handleNavigation("WEEKLY_OVERVIEW")}
            />
            <MonthlyOverviewChart 
              data={monthlyData}
              onPress={() => handleNavigation("MONTHLY_OVERVIEW")}
            />
          </Section>

          <Section title="Detailed Statistics">
            <StatsOverviewCard stats={usageStats} />
            <TimeDistributionCard timeData={timeDistribution} />
          </Section>

          <TouchableOpacity 
            style={styles.aiFeatureCard}
            onPress={handleNavigateToAI}
          >
            <LinearGradient
              colors={['#4a7c59', '#2c4c36']}
              style={styles.aiCardGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.aiCardContent}>
                <View style={styles.aiCardIcon}>
                  <MaterialCommunityIcons name="brain" size={32} color="#fff" />
                </View>
                <View style={styles.aiCardTextContainer}>
                  <Text style={styles.aiCardTitle}>AI Recommendations</Text>
                  <Text style={styles.aiCardDescription}>
                    Get personalized strain recommendations and insights based on your usage patterns
                  </Text>
                </View>
                <MaterialCommunityIcons name="chevron-right" size={24} color="#fff" />
              </View>
            </LinearGradient>
          </TouchableOpacity>
            </View>
      </Animated.ScrollView>

      {/* Goal Setting Modal */}
      <SetGoalModal
        visible={goalModalVisible}
        onClose={() => setGoalModalVisible(false)}
        onSave={(goal) => setDailyGoal(goal)}
        currentGoal={dailyGoal}
      />
    </SafeAreaProvider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  mainContent: {
    paddingHorizontal: 20,
  },
  aiFeatureCard: {
    marginBottom: 20,
    borderRadius: 12,
    overflow: 'hidden',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  aiCardGradient: {
    width: '100%',
  },
  aiCardContent: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
  },
  aiCardIcon: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  aiCardTextContainer: {
    flex: 1,
  },
  aiCardTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 4,
  },
  aiCardDescription: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.8)',
    lineHeight: 20,
  },
});

================================================================================
File: app/(tabs)/trending.tsx
================================================================================

// app/(tabs)/trending.tsx
import React, { useState, useCallback, useEffect, memo, useMemo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { useRouter } from 'expo-router';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useStrains } from '../../src/hooks/useStrains';
import { COLORS } from '../../src/constants';
import { StrainSearchFilters } from '../../src/services/StrainService';
import { Strain } from '../../src/dbManager';
import { LinearGradient } from 'expo-linear-gradient';
import LoadingView from '../components/shared/LoadingView';
import Header from '../components/trending/Header';
import StrainsList from '../components/trending/StrainsList';
import CompareBar from '../components/trending/CompareBar';
import SearchFilters from '../components/trending/SearchFilters';
import { hasActiveFilters } from '../../src/utils/filters';
import Animated, { FadeIn } from 'react-native-reanimated';

const TrendingScreen = memo(() => {
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState('');
  const [showFilters, setShowFilters] = useState(false);
  const [compareList, setCompareList] = useState<Strain[]>([]);
  const [filters, setFilters] = useState<StrainSearchFilters>({
    geneticType: undefined,
    effects: [],
    sort: 'rating'
  });

  const { 
    strains,
    popularStrains,
    categories,
    isLoading,
    error,
    searchStrains,
    clearSearch,
    loadMore,
    toggleFavorite,
    isFavorite,
    pagination
  } = useStrains();

  useEffect(() => {
    const delaySearch = setTimeout(() => {
      if (searchQuery.trim() || hasActiveFilters(filters)) {
        searchStrains(searchQuery, filters);
      } else {
        clearSearch();
      }
    }, 300);

    return () => clearTimeout(delaySearch);
  }, [searchQuery, filters, searchStrains, clearSearch]);

  const handleFilterChange = useCallback((newFilters: StrainSearchFilters) => {
    setFilters(newFilters);
  }, []);

  const handleApplyFilters = useCallback(() => {
    setShowFilters(false);
  }, []);

  const handleClearSearch = useCallback(() => {
    setSearchQuery('');
    setFilters({
      geneticType: undefined,
      effects: [],
      sort: 'rating'
    });
    clearSearch();
  }, [clearSearch]);

  const handleCompareToggle = useCallback((strain: Strain) => {
    setCompareList(prev => {
      if (prev.some(s => s.id === strain.id)) {
        return prev.filter(s => s.id !== strain.id);
      }
      if (prev.length >= 3) return prev;
      return [...prev, strain];
    });
  }, []);

  const handleCompare = useCallback(() => {
    if (compareList.length >= 2) {
      router.push({
        pathname: "/dataOverviews/compare",
        params: { ids: compareList.map(s => s.id).join(',') }
      } as any);
    }
  }, [compareList, router]);

  // Memoize the displayed strains to prevent unnecessary re-renders
  const displayedStrains = useMemo(() => 
    searchQuery.trim() || hasActiveFilters(filters) ? strains : popularStrains,
    [searchQuery, filters, strains, popularStrains]
  );

  // Memoize the section title
  const sectionTitle = useMemo(() => 
    searchQuery.trim() || hasActiveFilters(filters) 
      ? `Search Results (${pagination.total})`
      : "Popular Strains",
    [searchQuery, filters, pagination.total]
  );

  if (isLoading && !strains.length && !popularStrains.length) {
    return <LoadingView />;
  }

  return (
    <SafeAreaProvider>
      <View style={styles.container}>
        {/* Black background */}
        <View style={StyleSheet.absoluteFillObject} />
        
        {/* Header with glow effect */}
        <LinearGradient
          colors={['rgba(0, 230, 118, 0.15)', 'transparent']}
          style={styles.headerGradient}
          start={{ x: 0.5, y: 0 }}
          end={{ x: 0.5, y: 0.3 }}
        />
        
        <Header 
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          showFilters={showFilters}
          setShowFilters={setShowFilters}
          filters={filters}
          handleClearSearch={handleClearSearch}
        />

        {showFilters && (
          <Animated.View 
            entering={FadeIn.duration(300)}
            style={styles.filtersContainer}
          >
            <SearchFilters
              filters={filters}
              onFilterChange={handleFilterChange}
              onApplyFilters={handleApplyFilters}
              categories={categories}
            />
          </Animated.View>
        )}

        <View style={styles.mainContent}>
          <View style={styles.sectionHeaderContainer}>
            <LinearGradient
              colors={['rgba(0, 230, 118, 0.12)', 'transparent']}
              style={styles.sectionHeaderGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
            <Text style={styles.sectionTitle}>{sectionTitle}</Text>
          </View>
          
          {/* Don't wrap this in a ScrollView since StrainsList is already virtualized */}
          <View style={styles.listWrapper}>
            <StrainsList
              strains={displayedStrains}
              onCompareToggle={handleCompareToggle}
              onFavoriteToggle={toggleFavorite}
              compareList={compareList}
              isFavorite={isFavorite}
              isLoading={isLoading}
              onEndReached={loadMore}
            />
          </View>
        </View>

        {compareList.length > 0 && (
          <CompareBar
            compareList={compareList}
            onCompareToggle={handleCompareToggle}
            onCompare={handleCompare}
          />
        )}
      </View>
    </SafeAreaProvider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000000', // Jet black background
  },
  headerGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 150,
    zIndex: 0,
  },
  filtersContainer: {
    paddingHorizontal: 20,
    paddingBottom: 16,
    marginTop: 8,
    zIndex: 1,
  },
  mainContent: {
    flex: 1,
    paddingHorizontal: 20,
  },
  sectionHeaderContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    paddingVertical: 10,
    position: 'relative',
  },
  sectionHeaderGradient: {
    position: 'absolute',
    left: -20,
    right: -20,
    top: 0,
    bottom: 0,
    height: '100%',
    borderRadius: 8,
  },
  sectionTitle: {
    fontSize: 22,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
    textShadowColor: 'rgba(0, 230, 118, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  listWrapper: {
    flex: 1,
  }
});

export default TrendingScreen;

================================================================================
File: app/ai/_layout.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { Tabs, useRouter, usePathname } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { View, ActivityIndicator, Text } from 'react-native';

export default function AILayout() {
  const router = useRouter();
  const pathname = usePathname();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    // Check if the user has completed onboarding
    const checkOnboardingStatus = async () => {
      try {
        // Add a small delay to prevent UI jittering
        await new Promise(resolve => setTimeout(resolve, 300));
        
        const hasCompletedOnboarding = await AsyncStorage.getItem('ai_onboarding_completed');
        
        if (hasCompletedOnboarding !== 'true') {
          // Only redirect if we're not already on the onboarding screen
          if (!pathname.includes('/ai/onboarding')) {
            router.replace('/ai/onboarding');
          }
        }
      } catch (error) {
        console.error('Error checking onboarding status:', error);
        setError('Failed to check onboarding status');
      } finally {
        setIsLoading(false);
      }
    };
    
    checkOnboardingStatus();
  }, [router, pathname]);
  
  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#121212' }}>
        <ActivityIndicator size="large" color="#4CAF50" />
      </View>
    );
  }
  
  if (error) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#121212', padding: 20 }}>
        <Text style={{ color: '#ff6b6b', fontSize: 16, textAlign: 'center', marginBottom: 16 }}>
          {error}
        </Text>
        <Text style={{ color: '#ffffff', fontSize: 14, textAlign: 'center' }}>
          Please restart the app or try again later.
        </Text>
      </View>
    );
  }
  
  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: '#4a7c59',
        tabBarInactiveTintColor: '#888',
        tabBarStyle: {
          backgroundColor: '#121212',
          borderTopColor: '#333',
        },
        tabBarLabelStyle: {
          fontSize: 12,
        },
        headerStyle: {
          backgroundColor: '#121212',
        },
        headerTintColor: '#fff',
      }}
    >
      <Tabs.Screen
        name="recommendations"
        options={{
          title: 'Recommendations',
          tabBarLabel: 'Recommendations',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="leaf" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="chat"
        options={{
          title: 'AI Assistant',
          tabBarLabel: 'Chat',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="chat-processing" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="journal-insights"
        options={{
          title: 'Journal Insights',
          tabBarLabel: 'Insights',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="chart-line" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="onboarding"
        options={{
          href: null, // Hide from tab bar
          headerShown: false,
        }}
      />
    </Tabs>
  );
} 

================================================================================
File: app/ai/chat.tsx
================================================================================

import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity, 
  FlatList,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator
} from 'react-native';
import { Stack } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { ChatMessage, UserProfile } from '../../src/types/ai';

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

// Initial welcome message
const WELCOME_MESSAGE: ChatMessage = {
  id: 'welcome',
  content: "Hi there! I'm your cannabis assistant. I can help you find strains, answer questions about cannabis, or provide guidance on usage. What would you like to know?",
  role: 'assistant',
  timestamp: new Date().toISOString()
};

export default function ChatScreen() {
  const { loading, error, chatHistory, getChatResponse, clearChatHistory } = useAIRecommendations();
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<ChatMessage[]>([WELCOME_MESSAGE]);
  const flatListRef = useRef<FlatList>(null);
  
  // Initialize chat history
  useEffect(() => {
    if (chatHistory.length > 0) {
      setMessages([WELCOME_MESSAGE, ...chatHistory]);
    }
  }, [chatHistory]);
  
  // Scroll to bottom when messages change
  useEffect(() => {
    if (flatListRef.current && messages.length > 0) {
      setTimeout(() => {
        flatListRef.current?.scrollToEnd({ animated: true });
      }, 100);
    }
  }, [messages]);
  
  // Handle sending a message
  const handleSendMessage = async () => {
    if (!message.trim()) return;
    
    const userMessage = message.trim();
    setMessage('');
    
    // Add user message to local state immediately for better UX
    const newUserMessage: ChatMessage = {
      id: `user_${Date.now()}`,
      content: userMessage,
      role: 'user',
      timestamp: new Date().toISOString()
    };
    
    setMessages(prev => [...prev, newUserMessage]);
    
    // Get AI response
    const response = await getChatResponse(userMessage, mockUserProfile);
    
    if (response) {
      setMessages(prev => [...prev, response]);
    } else if (error) {
      // Add error message if request failed
      const errorMessage: ChatMessage = {
        id: `error_${Date.now()}`,
        content: "Sorry, I'm having trouble responding right now. Please try again later.",
        role: 'assistant',
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, errorMessage]);
    }
  };
  
  // Clear chat history
  const handleClearChat = () => {
    clearChatHistory();
    setMessages([WELCOME_MESSAGE]);
  };
  
  // Render a chat message
  const renderMessage = ({ item }: { item: ChatMessage }) => {
    const isUser = item.role === 'user';
    
    return (
      <View style={[
        styles.messageContainer,
        isUser ? styles.userMessageContainer : styles.assistantMessageContainer
      ]}>
        {!isUser && (
          <View style={styles.avatarContainer}>
            <MaterialCommunityIcons name="robot" size={24} color="#fff" />
          </View>
        )}
        
        <View style={[
          styles.messageBubble,
          isUser ? styles.userMessageBubble : styles.assistantMessageBubble
        ]}>
          <Text style={styles.messageText}>{item.content}</Text>
        </View>
        
        {isUser && (
          <View style={styles.avatarContainer}>
            <MaterialCommunityIcons name="account" size={24} color="#fff" />
          </View>
        )}
      </View>
    );
  };
  
  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
    >
      <Stack.Screen 
        options={{
          title: 'AI Assistant',
          headerRight: () => (
            <TouchableOpacity onPress={handleClearChat} style={styles.clearButton}>
              <MaterialCommunityIcons name="delete-outline" size={24} color="#fff" />
            </TouchableOpacity>
          ),
        }} 
      />
      
      <FlatList
        ref={flatListRef}
        data={messages}
        renderItem={renderMessage}
        keyExtractor={item => item.id}
        contentContainerStyle={styles.messagesContainer}
      />
      
      {error && (
        <View style={styles.errorContainer}>
          <MaterialCommunityIcons name="alert-circle" size={20} color="#ff6b6b" />
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}
      
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.input}
          placeholder="Type a message..."
          placeholderTextColor="#888"
          value={message}
          onChangeText={setMessage}
          multiline
          maxLength={500}
          onSubmitEditing={handleSendMessage}
        />
        
        <TouchableOpacity 
          style={[
            styles.sendButton,
            (!message.trim() || loading) && styles.disabledSendButton
          ]}
          onPress={handleSendMessage}
          disabled={!message.trim() || loading}
        >
          {loading ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <MaterialCommunityIcons name="send" size={24} color="#fff" />
          )}
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  messagesContainer: {
    padding: 16,
    paddingBottom: 24,
  },
  messageContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    alignItems: 'flex-end',
  },
  userMessageContainer: {
    justifyContent: 'flex-end',
  },
  assistantMessageContainer: {
    justifyContent: 'flex-start',
  },
  avatarContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#333',
    justifyContent: 'center',
    alignItems: 'center',
    marginHorizontal: 8,
  },
  messageBubble: {
    maxWidth: '70%',
    padding: 12,
    borderRadius: 16,
  },
  userMessageBubble: {
    backgroundColor: '#4a7c59',
    borderBottomRightRadius: 4,
  },
  assistantMessageBubble: {
    backgroundColor: '#2c2c2c',
    borderBottomLeftRadius: 4,
  },
  messageText: {
    color: '#fff',
    fontSize: 16,
    lineHeight: 22,
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: '#333',
    backgroundColor: '#1a1a1a',
    alignItems: 'center',
  },
  input: {
    flex: 1,
    backgroundColor: '#2c2c2c',
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 10,
    color: '#fff',
    fontSize: 16,
    maxHeight: 120,
  },
  sendButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: '#4a7c59',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 12,
  },
  disabledSendButton: {
    backgroundColor: '#333',
  },
  clearButton: {
    padding: 8,
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    padding: 12,
    borderRadius: 8,
    margin: 12,
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
}); 

================================================================================
File: app/ai/index.tsx
================================================================================

import { useEffect } from 'react';
import { Redirect } from 'expo-router';

export default function AIIndex() {
  // Redirect to the recommendations screen by default
  return <Redirect href={'/ai/recommendations' as any} />;
} 

================================================================================
File: app/ai/journal-insights.tsx
================================================================================

import React, { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity, 
  ActivityIndicator 
} from 'react-native';
import { Stack } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { UserProfile } from '../../src/types/ai';

// Mock journal entries for demo purposes
const mockJournalEntries = [
  {
    id: "j1",
    user_id: "user123",
    strain_id: 1,
    strain_name: "Blue Dream",
    consumption_method: "vaporize",
    dosage: 15,
    dosage_unit: "mg",
    effects_felt: ["Relaxed", "Happy", "Creative"],
    rating: 4,
    effectiveness: 4,
    notes: "Good for evening relaxation, helped with creativity",
    mood_before: "Stressed",
    mood_after: "Calm",
    medical_symptoms_relieved: ["Anxiety"],
    negative_effects: ["Dry mouth"],
    duration_minutes: 180,
    created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
  },
  {
    id: "j2",
    user_id: "user123",
    strain_id: 2,
    strain_name: "OG Kush",
    consumption_method: "edible",
    dosage: 10,
    dosage_unit: "mg",
    effects_felt: ["Sleepy", "Relaxed", "Hungry"],
    rating: 3,
    effectiveness: 4,
    notes: "Helped with sleep, but made me too hungry",
    mood_before: "Tired",
    mood_after: "Sleepy",
    medical_symptoms_relieved: ["Insomnia"],
    negative_effects: ["Groggy morning"],
    duration_minutes: 240,
    created_at: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
  },
  {
    id: "j3",
    user_id: "user123",
    strain_id: 3,
    strain_name: "Sour Diesel",
    consumption_method: "flower",
    dosage: 0.5,
    dosage_unit: "g",
    effects_felt: ["Energetic", "Focused", "Creative"],
    rating: 5,
    effectiveness: 5,
    notes: "Perfect for morning use, helped with productivity",
    mood_before: "Groggy",
    mood_after: "Energized",
    medical_symptoms_relieved: ["Fatigue"],
    negative_effects: [],
    duration_minutes: 150,
    created_at: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()
  }
];

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

export default function JournalInsightsScreen() {
  const { loading, error, analyzeJournalPatterns } = useAIRecommendations();
  const [insights, setInsights] = useState<any>(null);
  
  // Handle analyzing journal entries
  const handleAnalyzeJournal = async () => {
    const analysis = await analyzeJournalPatterns(mockJournalEntries, mockUserProfile);
    if (analysis) {
      setInsights(analysis);
    }
  };
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          title: 'Journal Insights',
        }} 
      />
      
      <ScrollView style={styles.scrollView}>
        <View style={styles.headerContainer}>
          <Text style={styles.headerTitle}>AI Journal Analysis</Text>
          <Text style={styles.headerSubtitle}>
            Get personalized insights based on your journal entries
          </Text>
        </View>
        
        <View style={styles.journalSummaryContainer}>
          <Text style={styles.sectionTitle}>Journal Summary</Text>
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{mockJournalEntries.length}</Text>
              <Text style={styles.statLabel}>Entries</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>
                {mockJournalEntries.reduce((sum, entry) => sum + entry.rating, 0) / mockJournalEntries.length}
              </Text>
              <Text style={styles.statLabel}>Avg Rating</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>
                {[...new Set(mockJournalEntries.map(entry => entry.strain_name))].length}
              </Text>
              <Text style={styles.statLabel}>Strains</Text>
            </View>
          </View>
        </View>
        
        <TouchableOpacity 
          style={styles.analyzeButton}
          onPress={handleAnalyzeJournal}
          disabled={loading}
        >
          <Text style={styles.analyzeButtonText}>
            {loading ? 'Analyzing...' : 'Analyze My Journal'}
          </Text>
          {loading && (
            <ActivityIndicator 
              size="small" 
              color="#fff" 
              style={styles.loadingIndicator} 
            />
          )}
        </TouchableOpacity>
        
        {error && (
          <View style={styles.errorContainer}>
            <MaterialCommunityIcons name="alert-circle" size={24} color="#ff6b6b" />
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}
        
        {insights && (
          <View style={styles.insightsContainer}>
            <Text style={styles.insightsTitle}>Your Personalized Insights</Text>
            
            {/* Pattern Insights */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="chart-line" size={24} color="#4a7c59" />
                <Text style={styles.insightHeaderText}>Usage Patterns</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.patterns?.summary || "You tend to use cannabis in the evening for relaxation. Your highest rated strains are typically Sativa dominant."}
              </Text>
            </View>
            
            {/* Effectiveness Insights */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="check-circle" size={24} color="#4a7c59" />
                <Text style={styles.insightHeaderText}>Effectiveness</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.effectiveness?.summary || "Based on your ratings, strains with high myrcene content seem to be most effective for your needs."}
              </Text>
              <View style={styles.effectiveStrains}>
                {(insights.effectiveness?.topStrains || ["Sour Diesel", "Blue Dream"]).map((strain: string, index: number) => (
                  <View key={`strain-${index}`} style={styles.effectiveStrain}>
                    <Text style={styles.effectiveStrainText}>{strain}</Text>
                  </View>
                ))}
              </View>
            </View>
            
            {/* Recommendations */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="lightbulb" size={24} color="#4a7c59" />
                <Text style={styles.insightHeaderText}>Recommendations</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.recommendations?.summary || "Consider trying lower doses in the evening to improve sleep quality without morning grogginess."}
              </Text>
              <View style={styles.recommendationsList}>
                {(insights.recommendations?.tips || [
                  "Try vaporizing at a lower temperature",
                  "Consider CBD-rich strains for anxiety",
                  "Journal more consistently for better insights"
                ]).map((tip: string, index: number) => (
                  <View key={`tip-${index}`} style={styles.recommendationItem}>
                    <MaterialCommunityIcons name="arrow-right" size={16} color="#4a7c59" />
                    <Text style={styles.recommendationText}>{tip}</Text>
                  </View>
                ))}
              </View>
            </View>
          </View>
        )}
        
        {!insights && !loading && (
          <View style={styles.placeholderContainer}>
            <MaterialCommunityIcons name="book-open-page-variant" size={64} color="#333" />
            <Text style={styles.placeholderText}>
              Tap "Analyze My Journal" to get personalized insights based on your usage patterns
            </Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  headerContainer: {
    marginBottom: 24,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 8,
  },
  headerSubtitle: {
    fontSize: 16,
    color: '#aaa',
    lineHeight: 22,
  },
  journalSummaryContainer: {
    backgroundColor: '#1a1a1a',
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#4a7c59',
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 14,
    color: '#aaa',
  },
  analyzeButton: {
    backgroundColor: '#4a7c59',
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    marginBottom: 24,
    flexDirection: 'row',
    justifyContent: 'center',
  },
  analyzeButtonText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  loadingIndicator: {
    marginLeft: 10,
  },
  errorContainer: {
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    borderRadius: 8,
    padding: 16,
    marginBottom: 24,
    flexDirection: 'row',
    alignItems: 'center',
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
  insightsContainer: {
    marginBottom: 24,
  },
  insightsTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 16,
  },
  insightCard: {
    backgroundColor: '#1a1a1a',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
  },
  insightHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  insightHeaderText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#fff',
    marginLeft: 8,
  },
  insightText: {
    fontSize: 16,
    color: '#ddd',
    lineHeight: 22,
    marginBottom: 16,
  },
  effectiveStrains: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  effectiveStrain: {
    backgroundColor: 'rgba(74, 124, 89, 0.2)',
    borderRadius: 16,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  effectiveStrainText: {
    color: '#4a7c59',
    fontWeight: '500',
  },
  recommendationsList: {
    marginTop: 8,
  },
  recommendationItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  recommendationText: {
    fontSize: 16,
    color: '#ddd',
    marginLeft: 8,
    flex: 1,
  },
  placeholderContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
    marginTop: 24,
  },
  placeholderText: {
    fontSize: 16,
    color: '#888',
    textAlign: 'center',
    marginTop: 16,
    lineHeight: 24,
  },
}); 

================================================================================
File: app/ai/onboarding.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, Image, ActivityIndicator } from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { LinearGradient } from 'expo-linear-gradient';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { MaterialCommunityIcons } from '@expo/vector-icons';

// Define the step type with proper icon names
type OnboardingStep = {
  title: string;
  description: string;
  icon: React.ComponentProps<typeof MaterialCommunityIcons>['name'];
  color: string;
};

const ONBOARDING_STEPS: OnboardingStep[] = [
  {
    title: "Personalized Recommendations",
    description: "Our AI analyzes your preferences and usage patterns to suggest strains tailored to your needs.",
    icon: "leaf",
    color: "#4CAF50"
  },
  {
    title: "Smart Safety Checks",
    description: "We automatically check for potential interactions and usage patterns to keep you informed and safe.",
    icon: "shield-check",
    color: "#2196F3"
  },
  {
    title: "Journal Insights",
    description: "Get personalized insights from your journal entries to better understand what works for you.",
    icon: "notebook",
    color: "#9C27B0"
  },
  {
    title: "AI Assistant",
    description: "Chat with our AI assistant to get answers about cannabis, effects, dosing, and more.",
    icon: "robot",
    color: "#FF9800"
  }
];

export default function AIOnboarding() {
  const router = useRouter();
  const [currentStep, setCurrentStep] = useState(0);
  const [isCompleting, setIsCompleting] = useState(false);
  const [hasChecked, setHasChecked] = useState(false);
  
  // Check if onboarding is already completed
  useEffect(() => {
    const checkOnboardingStatus = async () => {
      try {
        const hasCompletedOnboarding = await AsyncStorage.getItem('ai_onboarding_completed');
        if (hasCompletedOnboarding === 'true') {
          router.replace('/ai/recommendations');
        }
      } catch (error) {
        console.error('Error checking onboarding status:', error);
      } finally {
        setHasChecked(true);
      }
    };
    
    checkOnboardingStatus();
  }, [router]);
  
  const handleNext = () => {
    if (currentStep < ONBOARDING_STEPS.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      completeOnboarding();
    }
  };
  
  const completeOnboarding = async () => {
    try {
      setIsCompleting(true);
      await AsyncStorage.setItem('ai_onboarding_completed', 'true');
      
      // Add a small delay to ensure the AsyncStorage value is set
      await new Promise(resolve => setTimeout(resolve, 300));
      
      router.replace('/ai/recommendations');
    } catch (error) {
      console.error('Error saving onboarding status:', error);
      setIsCompleting(false);
    }
  };
  
  // Show loading screen while checking onboarding status
  if (!hasChecked) {
    return (
      <View style={[styles.container, styles.loadingContainer]}>
        <ActivityIndicator size="large" color="#4CAF50" />
      </View>
    );
  }
  
  const step = ONBOARDING_STEPS[currentStep];
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          headerShown: false
        }} 
      />
      
      <LinearGradient
        colors={['#000000', '#121212']}
        style={StyleSheet.absoluteFill}
      />
      
      <View style={styles.content}>
        <View style={styles.stepIndicators}>
          {ONBOARDING_STEPS.map((_, index) => (
            <View 
              key={index} 
              style={[
                styles.stepDot,
                currentStep === index && styles.activeStepDot
              ]} 
            />
          ))}
        </View>
        
        <View style={styles.iconContainer}>
          <LinearGradient
            colors={[step.color, `${step.color}80`]}
            style={styles.iconGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons 
              name={step.icon} 
              size={60} 
              color="#FFFFFF" 
            />
          </LinearGradient>
        </View>
        
        <Text style={styles.title}>{step.title}</Text>
        <Text style={styles.description}>{step.description}</Text>
        
        <View style={styles.buttonContainer}>
          <TouchableOpacity 
            style={styles.skipButton}
            onPress={completeOnboarding}
            disabled={isCompleting}
          >
            <Text style={styles.skipButtonText}>Skip</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={styles.nextButton}
            onPress={handleNext}
            disabled={isCompleting}
          >
            {isCompleting ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <>
                <Text style={styles.nextButtonText}>
                  {currentStep < ONBOARDING_STEPS.length - 1 ? 'Next' : 'Get Started'}
                </Text>
                <MaterialCommunityIcons 
                  name="arrow-right" 
                  size={20} 
                  color="#FFFFFF" 
                />
              </>
            )}
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000000',
  },
  loadingContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  stepIndicators: {
    flexDirection: 'row',
    marginBottom: 60,
  },
  stepDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    marginHorizontal: 6,
  },
  activeStepDot: {
    backgroundColor: '#FFFFFF',
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  iconContainer: {
    marginBottom: 40,
  },
  iconGradient: {
    width: 120,
    height: 120,
    borderRadius: 60,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 16,
    textAlign: 'center',
  },
  description: {
    fontSize: 16,
    color: 'rgba(255, 255, 255, 0.8)',
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 60,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  skipButton: {
    padding: 16,
  },
  skipButtonText: {
    color: 'rgba(255, 255, 255, 0.6)',
    fontSize: 16,
  },
  nextButton: {
    backgroundColor: '#4CAF50',
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 30,
    flexDirection: 'row',
    alignItems: 'center',
    minWidth: 120,
    justifyContent: 'center',
  },
  nextButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginRight: 8,
  },
}); 

================================================================================
File: app/ai/recommendations.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity, 
  ActivityIndicator,
  Alert,
  TextInput
} from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { RecommendationRequest, StrainRecommendation, UserProfile } from '../../src/types/ai';
import { COLORS } from '../../src/constants';

// Extended StrainRecommendation for UI purposes
interface UIStrainRecommendation extends StrainRecommendation {
  name: string;
  type: string;
  effects: string[];
  reason: string;
}

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

// Mock strain types for UI
const mockStrainTypes: Record<number, string> = {
  1: 'indica',
  2: 'sativa',
  3: 'hybrid'
};

// Mock effects for UI
const mockEffects: Record<number, string[]> = {
  1: ['Relaxed', 'Sleepy', 'Hungry'],
  2: ['Energetic', 'Creative', 'Focused'],
  3: ['Balanced', 'Happy', 'Euphoric']
};

export default function RecommendationsScreen() {
  const router = useRouter();
  const { 
    loading, 
    error, 
    recommendations, 
    safetyValidation,
    getRecommendations 
  } = useAIRecommendations();
  
  const [desiredEffects, setDesiredEffects] = useState<string[]>(['relaxed', 'creative']);
  const [context, setContext] = useState<'recreational' | 'medical'>('recreational');
  const [customEffect, setCustomEffect] = useState('');
  
  // Fetch recommendations on initial load
  useEffect(() => {
    fetchRecommendations();
  }, []);
  
  // Handle fetching recommendations
  const fetchRecommendations = async () => {
    const request: RecommendationRequest = {
      userProfile: mockUserProfile,
      desiredEffects,
      context,
      medicalNeeds: context === 'medical' ? mockUserProfile.medical_needs : []
    };
    
    await getRecommendations(request);
  };
  
  // Add custom effect
  const handleAddEffect = () => {
    if (customEffect.trim() && !desiredEffects.includes(customEffect.trim().toLowerCase())) {
      setDesiredEffects([...desiredEffects, customEffect.trim().toLowerCase()]);
      setCustomEffect('');
    }
  };
  
  // Remove effect
  const handleRemoveEffect = (effect: string) => {
    setDesiredEffects(desiredEffects.filter(e => e !== effect));
  };
  
  // Toggle context
  const toggleContext = () => {
    setContext(context === 'recreational' ? 'medical' : 'recreational');
  };
  
  // Transform StrainRecommendation to UIStrainRecommendation
  const enhanceRecommendation = (recommendation: StrainRecommendation): UIStrainRecommendation => {
    const strainId = recommendation.strainId;
    
    // Extract genetic type from the reasoning factors if available
    let type = 'hybrid'; // Default to hybrid
    let thcContent = '';
    
    if (recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors)) {
      // Look for the genetic type in the reasoning factors
      const typeFactors = recommendation.reasoningFactors.filter(factor => 
        factor.factor.includes('Indica') || 
        factor.factor.includes('Sativa') || 
        factor.factor.includes('Hybrid') ||
        factor.factor.includes('THC content')
      );
      
      if (typeFactors.length > 0) {
        const typeFactor = typeFactors[0].factor.toLowerCase();
        
        if (typeFactor.includes('indica')) {
          type = 'indica';
        } else if (typeFactor.includes('sativa')) {
          type = 'sativa';
        } else if (typeFactor.includes('hybrid')) {
          type = 'hybrid';
        }
        
        // Extract THC content if available
        const thcMatch = typeFactors[0].factor.match(/(\d+(?:\.\d+)?-\d+(?:\.\d+)?)%/);
        if (thcMatch) {
          thcContent = thcMatch[1];
        }
      }
    }
    
    // Extract effects from the reasoning factors
    let effects = ['Relaxed', 'Happy']; // Default effects
    
    if (recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors)) {
      const effectsFactor = recommendation.reasoningFactors.find(factor => 
        factor.factor.includes('Matches') && factor.factor.includes('effects')
      );
      
      if (effectsFactor) {
        // Try to extract the effects from the factor text
        effects = effectsFactor.factor
          .replace('Matches', '')
          .replace('of your desired effects', '')
          .trim()
          .split(',')
          .map(e => e.trim())
          .filter(e => e.length > 0);
        
        // If we couldn't extract effects, use the desired effects from the request
        if (effects.length === 0 || (effects.length === 1 && !isNaN(parseInt(effects[0])))) {
          effects = desiredEffects.map(e => e.charAt(0).toUpperCase() + e.slice(1));
        }
      }
    }
    
    return {
      ...recommendation,
      name: recommendation.strainName,
      type: type,
      effects: effects,
      reason: recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors) 
        ? recommendation.reasoningFactors.map(f => f.factor).join('. ')
        : 'Recommended based on your preferences'
    };
  };
  
  // Render recommendation card
  const renderRecommendationCard = (recommendation: StrainRecommendation, index: number) => {
    const enhancedRecommendation = enhanceRecommendation(recommendation);
    
    return (
      <TouchableOpacity 
        key={`recommendation-${index}`}
        style={styles.recommendationCard}
        onPress={() => Alert.alert('Strain Details', `View detailed information about ${enhancedRecommendation.name}`)}
      >
        <LinearGradient
          colors={getStrainTypeGradient(enhancedRecommendation.type)}
          style={styles.strainTypeIndicator}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        />
        <View style={styles.recommendationContent}>
          <Text style={styles.strainName}>{enhancedRecommendation.name}</Text>
          <Text style={styles.strainType}>{enhancedRecommendation.type}</Text>
          <Text style={styles.matchScore}>
            {enhancedRecommendation.matchScore}% Match
          </Text>
          <Text style={styles.reasonText}>{enhancedRecommendation.reason}</Text>
          
          <View style={styles.effectsContainer}>
            {enhancedRecommendation.effects.slice(0, 3).map((effect, i) => (
              <View key={`effect-${i}`} style={styles.effectTag}>
                <Text style={styles.effectText}>{effect}</Text>
              </View>
            ))}
          </View>
        </View>
      </TouchableOpacity>
    );
  };
  
  // Get gradient colors based on strain type
  const getStrainTypeGradient = (type: string): readonly [string, string] => {
    switch(type.toLowerCase()) {
      case 'indica':
        return ['#3949ab', '#1a237e'] as const; // Indigo colors
      case 'sativa':
        return ['#43a047', '#1b5e20'] as const; // Green colors
      case 'hybrid':
        return ['#7b1fa2', '#4a148c'] as const; // Purple colors
      default:
        return ['#757575', '#424242'] as const; // Gray colors
    }
  };
  
  // Render safety warnings if any
  const renderSafetyWarnings = () => {
    if (!safetyValidation || !safetyValidation.safetyFlags) return null;
    
    return (
      <View style={styles.safetyWarningsContainer}>
        <View style={styles.safetyHeader}>
          <MaterialCommunityIcons 
            name="alert-circle-outline" 
            size={20} 
            color={
              safetyValidation.warningLevel === 'warning' 
                ? '#ffb300' // Amber color
                : '#2196f3' // Blue color
            } 
          />
          <Text style={styles.safetyHeaderText}>Safety Information</Text>
        </View>
        
        {safetyValidation.safetyFlags.map((flag, index) => (
          <Text key={`flag-${index}`} style={styles.safetyFlag}>
             {flag}
          </Text>
        ))}
      </View>
    );
  };
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          title: 'AI Strain Recommendations',
          headerStyle: {
            backgroundColor: '#1a1a1a', // Dark background
          },
          headerTintColor: '#fff',
        }} 
      />
      
      <ScrollView style={styles.scrollView}>
        {/* Context Selector */}
        <View style={styles.contextSelector}>
          <Text style={styles.sectionTitle}>Purpose</Text>
          <View style={styles.contextButtons}>
            <TouchableOpacity
              style={[
                styles.contextButton,
                context === 'recreational' && styles.activeContextButton
              ]}
              onPress={() => setContext('recreational')}
            >
              <Text style={[
                styles.contextButtonText,
                context === 'recreational' && styles.activeContextButtonText
              ]}>
                Recreational
              </Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={[
                styles.contextButton,
                context === 'medical' && styles.activeContextButton
              ]}
              onPress={() => setContext('medical')}
            >
              <Text style={[
                styles.contextButtonText,
                context === 'medical' && styles.activeContextButtonText
              ]}>
                Medical
              </Text>
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Desired Effects */}
        <View style={styles.effectsSection}>
          <Text style={styles.sectionTitle}>Desired Effects</Text>
          
          <View style={styles.selectedEffectsContainer}>
            {desiredEffects.map((effect, index) => (
              <View key={`selected-${index}`} style={styles.selectedEffect}>
                <Text style={styles.selectedEffectText}>{effect}</Text>
                <TouchableOpacity onPress={() => handleRemoveEffect(effect)}>
                  <MaterialCommunityIcons name="close-circle" size={16} color="#fff" />
                </TouchableOpacity>
              </View>
            ))}
          </View>
          
          <View style={styles.addEffectContainer}>
            <TextInput
              style={styles.effectInput}
              placeholder="Add desired effect..."
              placeholderTextColor="#9e9e9e" // Gray color
              value={customEffect}
              onChangeText={setCustomEffect}
              onSubmitEditing={handleAddEffect}
            />
            <TouchableOpacity 
              style={styles.addEffectButton}
              onPress={handleAddEffect}
            >
              <MaterialCommunityIcons name="plus" size={20} color="#fff" />
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Get Recommendations Button */}
        <TouchableOpacity 
          style={styles.getRecommendationsButton}
          onPress={fetchRecommendations}
          disabled={loading}
        >
          <Text style={styles.getRecommendationsText}>
            {loading ? 'Finding Matches...' : 'Get Recommendations'}
          </Text>
          {loading && (
            <ActivityIndicator 
              size="small" 
              color="#fff" 
              style={styles.loadingIndicator} 
            />
          )}
        </TouchableOpacity>
        
        {/* Safety Warnings */}
        {renderSafetyWarnings()}
        
        {/* Error Message */}
        {error && (
          <View style={styles.errorContainer}>
            <MaterialCommunityIcons name="alert-circle" size={24} color="#f44336" /> {/* Red color */}
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}
        
        {/* Recommendations */}
        {recommendations && recommendations.recommendations && Array.isArray(recommendations.recommendations) && recommendations.recommendations.length > 0 ? (
          <View style={styles.recommendationsContainer}>
            <Text style={styles.recommendationsTitle}>
              Your Personalized Recommendations
            </Text>
            
            {recommendations.recommendations.map((recommendation, index) => 
              renderRecommendationCard(recommendation, index)
            )}
            
            {/* Disclaimers */}
            {recommendations.disclaimers && Array.isArray(recommendations.disclaimers) && recommendations.disclaimers.length > 0 && (
              <View style={styles.disclaimersContainer}>
                <Text style={styles.disclaimersTitle}>Important Information</Text>
                {recommendations.disclaimers.map((disclaimer, index) => (
                  <Text key={`disclaimer-${index}`} style={styles.disclaimerText}>
                     {disclaimer}
                  </Text>
                ))}
              </View>
            )}
          </View>
        ) : (
          <View style={styles.noRecommendationsContainer}>
            <Text style={styles.noRecommendationsText}>
              No recommendations available. Try adjusting your preferences or try again later.
            </Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000000', // Black background
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  contextSelector: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 12,
  },
  contextButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  contextButton: {
    flex: 1,
    backgroundColor: '#424242', // Dark gray
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginHorizontal: 4,
  },
  activeContextButton: {
    backgroundColor: '#4a7c59', // Green
  },
  contextButtonText: {
    color: '#bdbdbd', // Light gray
    fontWeight: '600',
  },
  activeContextButtonText: {
    color: '#fff',
  },
  effectsSection: {
    marginBottom: 20,
  },
  selectedEffectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
  },
  selectedEffect: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#4a7c59', // Green
    borderRadius: 16,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  selectedEffectText: {
    color: '#fff',
    marginRight: 6,
  },
  addEffectContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  effectInput: {
    flex: 1,
    backgroundColor: '#424242', // Dark gray
    borderRadius: 8,
    padding: 12,
    color: '#fff',
    marginRight: 8,
  },
  addEffectButton: {
    backgroundColor: '#4a7c59', // Green
    borderRadius: 8,
    padding: 12,
  },
  getRecommendationsButton: {
    backgroundColor: '#4caf50', // Green
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    marginBottom: 20,
    flexDirection: 'row',
    justifyContent: 'center',
  },
  getRecommendationsText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  loadingIndicator: {
    marginLeft: 10,
  },
  safetyWarningsContainer: {
    backgroundColor: '#1a1a1a', // Dark background
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
    borderLeftWidth: 4,
    borderLeftColor: '#2196f3', // Blue
  },
  safetyHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  safetyHeaderText: {
    color: '#fff',
    fontWeight: 'bold',
    marginLeft: 8,
    fontSize: 16,
  },
  safetyFlag: {
    color: '#bdbdbd', // Light gray
    marginBottom: 4,
    lineHeight: 20,
  },
  errorContainer: {
    backgroundColor: '#1a1a1a', // Dark background
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
    borderLeftWidth: 4,
    borderLeftColor: '#f44336', // Red
    flexDirection: 'row',
    alignItems: 'center',
  },
  errorText: {
    color: '#ef9a9a', // Light red
    marginLeft: 8,
    flex: 1,
  },
  recommendationsContainer: {
    marginBottom: 20,
  },
  recommendationsTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 16,
  },
  recommendationCard: {
    backgroundColor: '#1a1a1a', // Dark background
    borderRadius: 12,
    marginBottom: 16,
    overflow: 'hidden',
    flexDirection: 'row',
  },
  strainTypeIndicator: {
    width: 8,
    height: '100%',
  },
  recommendationContent: {
    padding: 16,
    flex: 1,
  },
  strainName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 4,
  },
  strainType: {
    fontSize: 14,
    color: '#9e9e9e', // Gray
    marginBottom: 8,
  },
  matchScore: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#66bb6a', // Green
    marginBottom: 8,
  },
  reasonText: {
    fontSize: 14,
    color: '#bdbdbd', // Light gray
    marginBottom: 12,
    lineHeight: 20,
  },
  effectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  effectTag: {
    backgroundColor: '#424242', // Dark gray
    borderRadius: 16,
    paddingVertical: 4,
    paddingHorizontal: 10,
    marginRight: 8,
    marginBottom: 4,
  },
  effectText: {
    color: '#bdbdbd', // Light gray
    fontSize: 12,
  },
  disclaimersContainer: {
    backgroundColor: '#1a1a1a', // Dark background
    borderRadius: 8,
    padding: 16,
    marginTop: 8,
  },
  disclaimersTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 8,
  },
  disclaimerText: {
    color: '#bdbdbd', // Light gray
    marginBottom: 4,
    lineHeight: 20,
  },
  noRecommendationsContainer: {
    backgroundColor: '#1a1a1a', // Dark background
    borderRadius: 8,
    padding: 16,
    marginTop: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  noRecommendationsText: {
    color: '#bdbdbd', // Light gray
    fontSize: 16,
    textAlign: 'center',
    lineHeight: 22,
  },
}); 

================================================================================
File: app/components/ai/RecommendationFeedback.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, TextInput, ActivityIndicator } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { AIService } from '../../../src/services/ai';

interface RecommendationFeedbackProps {
  userId: string;
  recommendationId: string;
  onClose: () => void;
}

export default function RecommendationFeedback({ 
  userId, 
  recommendationId, 
  onClose 
}: RecommendationFeedbackProps) {
  const [helpful, setHelpful] = useState<boolean | null>(null);
  const [accurateEffects, setAccurateEffects] = useState<boolean | null>(null);
  const [wouldTryAgain, setWouldTryAgain] = useState<boolean | null>(null);
  const [comments, setComments] = useState('');
  const [submitting, setSubmitting] = useState(false);
  
  // Get AIService instance
  const aiService = AIService.getInstance();
  
  const handleSubmit = async () => {
    if (helpful === null) return;
    
    setSubmitting(true);
    
    try {
      // Calculate relevance score (1-5) based on user feedback
      const relevance = calculateRelevanceScore(helpful, accurateEffects, wouldTryAgain);
      
      await aiService.submitRecommendationFeedback(
        userId,
        recommendationId,
        helpful,
        accurateEffects || false,
        relevance,
        comments
      );
      
      onClose();
    } catch (error) {
      console.error('Error submitting feedback:', error);
    } finally {
      setSubmitting(false);
    }
  };
  
  // Calculate a relevance score (1-5) based on user feedback
  const calculateRelevanceScore = (
    helpful: boolean, 
    accurateEffects: boolean | null, 
    wouldTryAgain: boolean | null
  ): number => {
    if (!helpful) return 1; // Not helpful at all
    
    // Base score for helpful
    let score = 3;
    
    // Add points for accurate effects
    if (accurateEffects) score += 1;
    
    // Add points for would try again
    if (wouldTryAgain) score += 1;
    
    return Math.min(score, 5); // Cap at 5
  };
  
  return (
    <View style={styles.container}>
      <Text style={styles.title}>How was this recommendation?</Text>
      
      <View style={styles.questionContainer}>
        <Text style={styles.questionText}>Was this recommendation helpful?</Text>
        <View style={styles.buttonGroup}>
          <TouchableOpacity 
            style={[
              styles.optionButton,
              helpful === true && styles.selectedButton
            ]}
            onPress={() => setHelpful(true)}
          >
            <MaterialCommunityIcons 
              name="thumb-up" 
              size={20} 
              color={helpful === true ? '#FFFFFF' : '#AAAAAA'} 
            />
            <Text style={[
              styles.optionText,
              helpful === true && styles.selectedOptionText
            ]}>Yes</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[
              styles.optionButton,
              helpful === false && styles.selectedButton
            ]}
            onPress={() => setHelpful(false)}
          >
            <MaterialCommunityIcons 
              name="thumb-down" 
              size={20} 
              color={helpful === false ? '#FFFFFF' : '#AAAAAA'} 
            />
            <Text style={[
              styles.optionText,
              helpful === false && styles.selectedOptionText
            ]}>No</Text>
          </TouchableOpacity>
        </View>
      </View>
      
      {helpful !== null && (
        <>
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>Were the effects as described?</Text>
            <View style={styles.buttonGroup}>
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  accurateEffects === true && styles.selectedButton
                ]}
                onPress={() => setAccurateEffects(true)}
              >
                <Text style={[
                  styles.optionText,
                  accurateEffects === true && styles.selectedOptionText
                ]}>Yes</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  accurateEffects === false && styles.selectedButton
                ]}
                onPress={() => setAccurateEffects(false)}
              >
                <Text style={[
                  styles.optionText,
                  accurateEffects === false && styles.selectedOptionText
                ]}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>Would you try this strain again?</Text>
            <View style={styles.buttonGroup}>
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  wouldTryAgain === true && styles.selectedButton
                ]}
                onPress={() => setWouldTryAgain(true)}
              >
                <Text style={[
                  styles.optionText,
                  wouldTryAgain === true && styles.selectedOptionText
                ]}>Yes</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  wouldTryAgain === false && styles.selectedButton
                ]}
                onPress={() => setWouldTryAgain(false)}
              >
                <Text style={[
                  styles.optionText,
                  wouldTryAgain === false && styles.selectedOptionText
                ]}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          <View style={styles.commentsContainer}>
            <Text style={styles.questionText}>Additional comments (optional)</Text>
            <TextInput
              style={styles.commentsInput}
              placeholder="Share your experience..."
              placeholderTextColor="#888888"
              value={comments}
              onChangeText={setComments}
              multiline
              maxLength={500}
            />
          </View>
          
          <TouchableOpacity 
            style={styles.submitButton}
            onPress={handleSubmit}
            disabled={submitting}
          >
            {submitting ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <Text style={styles.submitButtonText}>Submit Feedback</Text>
            )}
          </TouchableOpacity>
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#1A1A1A',
    borderRadius: 16,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 20,
    textAlign: 'center',
  },
  questionContainer: {
    marginBottom: 20,
  },
  questionText: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 12,
  },
  buttonGroup: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  optionButton: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginHorizontal: 6,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  selectedButton: {
    backgroundColor: '#4CAF50',
  },
  optionText: {
    color: '#AAAAAA',
    fontSize: 16,
    marginLeft: 8,
  },
  selectedOptionText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  commentsContainer: {
    marginBottom: 20,
  },
  commentsInput: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 8,
    padding: 12,
    color: '#FFFFFF',
    height: 100,
    textAlignVertical: 'top',
  },
  submitButton: {
    backgroundColor: '#4CAF50',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
  },
  submitButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
}); 

================================================================================
File: app/components/charts/BarChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';

interface BarChartProps {
  data: number[];
  labels: string[];
  maxValue?: number;
  barColor?: string;
}

const BarChart: React.FC<BarChartProps> = ({ 
  data, 
  labels, 
  maxValue: propMaxValue, 
  barColor = COLORS.primary
}) => {
  // Calculate maxValue if not provided
  const maxValue = propMaxValue || Math.max(...data) * 1.2; // Add 20% padding
  const chartHeight = 220;
  const divisions = 5; // Number of horizontal lines

  // Generate y-axis labels
  const yAxisLabels = Array.from({ length: divisions + 1 }, (_, i) => {
    const value = (maxValue / divisions) * (divisions - i);
    return Math.round(value).toString();
  });

  return (
    <View style={styles.container}>
      {/* Y-axis labels */}
      <View style={styles.yAxis}>
        {yAxisLabels.map((label, index) => (
          <Text key={index} style={styles.yAxisLabel}>
            {label}
          </Text>
        ))}
      </View>

      {/* Chart area */}
      <View style={styles.chartArea}>
        {/* Horizontal grid lines */}
        {yAxisLabels.map((_, index) => (
          <View 
            key={index} 
            style={[
              styles.gridLine,
              { top: (chartHeight / divisions) * index }
            ]} 
          />
        ))}

        {/* Bars */}
        <View style={styles.barsContainer}>
          {data.map((value, index) => {
            const barHeight = (value / maxValue) * chartHeight;
            
            return (
              <View key={index} style={styles.barWrapper}>
                <View style={styles.barLabelContainer}>
                  <Text style={styles.barValue}>{value}</Text>
                </View>
                <View style={[styles.barBackground, { height: barHeight }]}>
                  <LinearGradient
                    colors={[
                      `${barColor}CC`, // 80% opacity
                      `${barColor}66`, // 40% opacity
                    ]}
                    style={[styles.bar, { height: '100%' }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 0, y: 1 }}
                  />
                </View>
                <Text style={styles.xAxisLabel}>{labels[index]}</Text>
              </View>
            );
          })}
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    height: 280, // Include space for labels
    paddingRight: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 12,
    padding: 16,
  },
  yAxis: {
    width: 50,
    justifyContent: 'space-between',
    marginRight: 10,
  },
  yAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    textAlign: 'right',
  },
  chartArea: {
    flex: 1,
    height: 220,
    position: 'relative',
  },
  gridLine: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  barsContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    height: '100%',
  },
  barWrapper: {
    flex: 1,
    alignItems: 'center',
    height: '100%',
    justifyContent: 'flex-end',
  },
  barLabelContainer: {
    position: 'absolute',
    top: -20,
    width: '100%',
    alignItems: 'center',
  },
  barValue: {
    color: COLORS.text.primary,
    fontSize: 12,
    fontWeight: '600',
  },
  barBackground: {
    width: '60%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
    overflow: 'hidden',
  },
  bar: {
    width: '100%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
  },
  xAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    marginTop: 8,
  },
});

export default BarChart; 

================================================================================
File: app/components/charts/ChartStyles.ts
================================================================================

import { StyleSheet } from 'react-native';
import { COLORS } from '../../../src/constants';

const chartStyles = StyleSheet.create({
  card: {
    backgroundColor: COLORS.cardBackground,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 20,
    padding: 20,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 15,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.08)',
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12,
  },
  headerIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: 0.38,
  },
  description: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 20,
    letterSpacing: -0.24,
    lineHeight: 20,
  },
  chartWrapper: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
  },
  chartContainer: {
    borderRadius: 16,
    overflow: 'hidden',
  },
});

export default chartStyles; 

================================================================================
File: app/components/charts/LineChart.tsx
================================================================================

import React from 'react';
import { View, StyleSheet, Dimensions } from 'react-native';
import { LineChart as RNLineChart } from 'react-native-chart-kit';
import { COLORS } from '../../../src/constants';

interface LineChartProps {
  data: number[];
  labels: string[];
  color?: string;
  width?: number;
  height?: number;
}

const screenWidth = Dimensions.get('window').width;

const LineChart: React.FC<LineChartProps> = ({
  data,
  labels,
  color = COLORS.primary,
  width = screenWidth - 64,
  height = 220
}) => {
  const chartConfig = {
    backgroundColor: 'transparent',
    backgroundGradientFrom: 'transparent',
    backgroundGradientTo: 'transparent',
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
    labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity * 0.7})`,
    style: {
      borderRadius: 16
    },
    propsForDots: {
      r: '5',
      strokeWidth: '2',
      stroke: color
    },
    propsForBackgroundLines: {
      strokeDasharray: '5, 5',
      stroke: 'rgba(255, 255, 255, 0.1)',
      strokeWidth: 1
    },
    propsForLabels: {
      fontSize: 10
    }
  };

  return (
    <View style={styles.container}>
      <RNLineChart
        data={{
          labels,
          datasets: [
            {
              data,
              color: (opacity = 1) => color ? `${color}${Math.round(opacity * 255).toString(16).padStart(2, '0')}` : `rgba(0, 230, 118, ${opacity})`,
              strokeWidth: 2
            }
          ]
        }}
        width={width}
        height={height}
        chartConfig={chartConfig}
        bezier
        style={styles.chart}
        withInnerLines={true}
        withOuterLines={false}
        withHorizontalLabels={true}
        withVerticalLabels={true}
        withDots={true}
        segments={5}
        fromZero={true}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  chart: {
    borderRadius: 16,
    paddingRight: 16,
  }
});

export default LineChart; 

================================================================================
File: app/components/charts/MonthlyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '../../../src/types';

interface MonthlyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const MonthlyOverviewChart: React.FC<MonthlyOverviewChartProps> = ({ data, onPress }) => {
  const chartData = {
    labels: data.map(item => item.label),
    datasets: [{
      data: data.map(item => item.value)
    }]
  };

  // Calculate monthly stats
  const totalHits = data.reduce((sum, month) => sum + month.value, 0);
  const avgHits = totalHits / data.length;
  const maxHits = Math.max(...data.map(month => month.value));
  const maxMonth = data.find(month => month.value === maxHits)?.label || '';
  const monthlyGrowth = data.length > 1 
    ? ((data[data.length - 1].value - data[0].value) / data[0].value * 100).toFixed(1)
    : '0';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Monthly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/month average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-areaspline" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Month</Text>
              <Text style={styles.statValue}>{maxMonth}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Growth</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={Number(monthlyGrowth) >= 0 ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(Number(monthlyGrowth))}%
                </Text>
              </View>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Monthly Analysis</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 18,
    fontWeight: '600',
    marginLeft: 4,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default MonthlyOverviewChart; 

================================================================================
File: app/components/charts/WeeklyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '../../../src/types';

interface WeeklyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const WeeklyOverviewChart: React.FC<WeeklyOverviewChartProps> = ({ data, onPress }) => {
  const chartData = {
    labels: data.map(item => item.label),
    datasets: [{
      data: data.map(item => item.value)
    }]
  };

  // Calculate weekly stats
  const totalHits = data.reduce((sum, day) => sum + day.value, 0);
  const avgHits = totalHits / 7;
  const maxHits = Math.max(...data.map(day => day.value));
  const maxDay = data.find(day => day.value === maxHits)?.label || '';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Weekly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/day average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-line-variant" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Day</Text>
              <Text style={styles.statValue}>{maxDay}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Max Hits</Text>
              <Text style={styles.statValue}>{maxHits}</Text>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Details</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default WeeklyOverviewChart; 

================================================================================
File: app/components/Header.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { COLORS } from '@/src/constants';

interface HeaderProps {
  title: string;
}

export default function Header({ title }: HeaderProps) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: COLORS.background,
  },
  title: {
    fontSize: 28,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
}); 

================================================================================
File: app/components/mydata/DailyAverageCard.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { ChartDataPoint } from '../../../src/types';

interface DailyAverageCardProps {
  data: ChartDataPoint[];
  averageHits: number;
  onPress: () => void;
}

const DailyAverageCard: React.FC<DailyAverageCardProps> = ({ data, averageHits, onPress }) => {
  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Daily Average</Text>
              <Text style={styles.subtitle}>
                {averageHits.toFixed(1)} hits per day
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-bell-curve" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Details</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
    minHeight: 120,
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 20,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  buttonContainer: {
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default DailyAverageCard;

================================================================================
File: app/components/mydata/GoalTrackingCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';

interface GoalTrackingCardProps {
  currentUsage: number;
  goalUsage: number;
  onEditGoal: () => void;
}

const GoalTrackingCard = ({ currentUsage, goalUsage, onEditGoal }: GoalTrackingCardProps) => {
  // Calculate percentage of goal reached
  const goalPercentage = Math.min(Math.round((currentUsage / goalUsage) * 100), 100);
  const isExceeded = currentUsage > goalUsage;

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <View style={styles.content}>
        {/* Header with icon */}
        <View style={styles.headerRow}>
          <View style={styles.iconCircle}>
            <MaterialCommunityIcons 
              name="target" 
              size={20} 
              color={COLORS.primary} 
            />
          </View>
          <View style={styles.headerTextContainer}>
            <Text style={styles.title}>Daily Goal Tracking</Text>
            <Text style={styles.subtitle}>
              {isExceeded ? 'Goal exceeded today' : `${goalPercentage}% of daily goal reached`}
            </Text>
          </View>
          <TouchableOpacity onPress={onEditGoal} style={styles.closeButton}>
            <MaterialCommunityIcons 
              name="pencil" 
              size={16} 
              color={COLORS.primary}
            />
          </TouchableOpacity>
        </View>

        {/* Stats Container */}
        <View style={styles.statsContainer}>
          {/* Progress Bar */}
          <View style={styles.progressContainer}>
            <View style={styles.progressBackground}>
              <View 
                style={[
                  styles.progressFill, 
                  { 
                    width: `${Math.min(goalPercentage, 100)}%`,
                    backgroundColor: isExceeded ? '#FF5252' : COLORS.primary
                  }
                ]} 
              />
            </View>
          </View>
          
          {/* Labels */}
          <View style={styles.progressLabels}>
            <Text style={styles.progressText}>{currentUsage.toFixed(2)} hits</Text>
            <Text style={styles.goalText}>Goal: {goalUsage} hits</Text>
          </View>
        </View>

        {/* Button */}
        <TouchableOpacity 
          onPress={onEditGoal}
          style={styles.editButton}
        >
          <Text style={styles.editButtonText}>Edit Goal</Text>
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: '#0C140E',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    marginBottom: 12,
  },
  content: {
    padding: 16,
  },
  headerRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  iconCircle: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 230, 118, 0.15)',
    marginRight: 12,
  },
  headerTextContainer: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
    marginBottom: 2,
  },
  subtitle: {
    fontSize: 13,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  closeButton: {
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  statsContainer: {
    padding: 12,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 8,
    marginBottom: 16,
  },
  progressContainer: {
    marginBottom: 8,
  },
  progressBackground: {
    height: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 4,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    borderRadius: 4,
  },
  progressLabels: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  progressText: {
    fontSize: 13,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  goalText: {
    fontSize: 13,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  editButton: {
    alignSelf: 'center',
    backgroundColor: COLORS.primary,
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 20,
  },
  editButtonText: {
    fontSize: 14,
    color: '#000000',
    fontWeight: '600',
  },
});

export default GoalTrackingCard;

================================================================================
File: app/components/mydata/Header.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';

// Gradient configurations
const gradients = {
  header: ['rgba(0,230,118,0.15)', 'rgba(0,230,118,0.05)', 'transparent'] as const,
};

const Header = memo(() => (
  <View style={styles.headerSection}>
    <LinearGradient
      colors={gradients.header}
      style={styles.headerGradient}
      start={{ x: 0, y: 0 }}
      end={{ x: 0, y: 1 }}
    />
    <View style={styles.headerContent}>
      <Text style={styles.headerTitle}>Summary</Text>
      <View style={styles.profileContainer}>
        <MaterialCommunityIcons 
          name="account" 
          size={24} 
          color={COLORS.primary}
        />
      </View>
    </View>
  </View>
));

const styles = StyleSheet.create({
  headerSection: {
    height: 120,
    position: 'relative',
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    marginBottom: 24,
  },
  headerGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  headerContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 34,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  profileContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0,230,118,0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.2)',
  },
});

export default Header;

================================================================================
File: app/components/mydata/MedicalCard.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from "expo-linear-gradient";
import { COLORS } from "../../../src/constants";

export default function MedicalCard() {
  return (
    <View style={styles.medicalCard}>
      <LinearGradient
        colors={[
          'rgba(0,230,118,0.15)',
          'rgba(0,230,118,0.05)',
          'transparent'
        ]}
        style={styles.cardGradient}
      />
      
      <View style={styles.cardHeader}>
        <MaterialCommunityIcons 
          name="medical-bag" 
          size={24} 
          color={COLORS.primary}
        />
        <Text style={styles.cardHeaderText}>Medical Info</Text>
      </View>

      <View style={styles.medicalStats}>
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>Strain Type</Text>
          <Text style={styles.statValue}>Hybrid</Text>
        </View>
        <View style={styles.statDivider} />
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>THC Content</Text>
          <Text style={styles.statValue}>18-24%</Text>
        </View>
        <View style={styles.statDivider} />
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>CBD Content</Text>
          <Text style={styles.statValue}>0.1%</Text>
        </View>
      </View>

      <TouchableOpacity style={styles.moreDetailsButton}>
        <Text style={styles.moreDetailsText}>View Medical Details</Text>
        <MaterialCommunityIcons 
          name="chevron-right" 
          size={20} 
          color={COLORS.primary}
        />
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  medicalCard: {
    backgroundColor: COLORS.cardBackground,
    width: '100%',
    marginHorizontal: 2,
    marginVertical: 8,
    borderRadius: 16,
    padding: 16,
    overflow: 'hidden',
    position: 'relative',
    
  },
  cardGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  cardHeaderText: {
    fontSize: 17,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 8,
  },
  medicalStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statLabel: {
    fontSize: 13,
    color: COLORS.text.secondary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 17,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  statDivider: {
    width: 1,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginHorizontal: 8,
  },
  moreDetailsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  moreDetailsText: {
    fontSize: 15,
    color: COLORS.primary,
  },
});

================================================================================
File: app/components/mydata/NotificationBanner.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from "../../../src/constants";
import Animated, { 
  FadeIn, 
  FadeInDown, 
  FadeOutUp,
  withTiming,
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  Layout
} from 'react-native-reanimated';

interface NotificationProps {
  averageHits: number;
  percentageChange: number;
  onDismiss: () => void;
}

const NotificationBanner: React.FC<NotificationProps> = ({ 
  averageHits, 
  percentageChange, 
  onDismiss 
}) => {
  const isIncrease = percentageChange > 0;
  const statusColor = isIncrease ? '#FF5252' : COLORS.primary;

  // Format percentage to 1 decimal place and handle edge cases
  const formattedPercentage = Math.abs(Number(percentageChange.toFixed(1)));

  // Enhanced gradient combinations with type assertions
  const gradientBase = isIncrease 
    ? ['rgba(255,82,82,0.2)', 'rgba(255,82,82,0.08)', 'transparent'] as const
    : ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.08)', 'transparent'] as const;

  const accentGradient = isIncrease
    ? ['rgba(255,82,82,0.3)', 'rgba(255,82,82,0.15)'] as const
    : ['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.15)'] as const;

  return (
    <Animated.View 
      entering={FadeInDown.springify()}
      exiting={FadeOutUp.springify()}
      layout={Layout.springify()}
      style={styles.container}
    >
      {/* Enhanced Background Gradient */}
      <LinearGradient
        colors={gradientBase}
        style={styles.backgroundGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      {/* Shimmer Effect Layer */}
      <LinearGradient
        colors={['transparent', 'rgba(255,255,255,0.05)', 'transparent'] as const}
        style={styles.shimmerEffect}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      <View style={styles.content}>
        {/* Enhanced Header */}
        <View style={styles.header}>
          <View style={styles.titleRow}>
            <LinearGradient
              colors={accentGradient}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="bell-outline" 
                size={22} 
                color={statusColor}
              />
            </LinearGradient>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Daily Summary</Text>
              <Text style={styles.subtitle}>Last 24 hours</Text>
            </View>
          </View>
          
          <TouchableOpacity 
            onPress={onDismiss}
            style={styles.dismissButton}
          >
            <LinearGradient
              colors={['rgba(255,255,255,0.1)', 'rgba(255,255,255,0.05)'] as const}
              style={styles.dismissGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="close" 
                size={18} 
                color={COLORS.text.secondary}
              />
            </LinearGradient>
          </TouchableOpacity>
        </View>

        {/* Enhanced Stats Container */}
        <View style={styles.statsContainer}>
          <LinearGradient
            colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
            style={styles.statsGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Daily Average</Text>
              <Text style={styles.statValue}>{averageHits.toFixed(1)}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Change</Text>
              <Text style={[styles.statValue, { color: statusColor }]}>
                {isIncrease ? '+' : '-'}{formattedPercentage}%
              </Text>
            </View>
          </LinearGradient>
        </View>

        {/* Status Message */}
        <View style={styles.messageContainer}>
          <LinearGradient
            colors={accentGradient}
            style={styles.statusIcon}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons
              name={isIncrease ? "trending-up" : "trending-down"}
              size={24}
              color={statusColor}
            />
          </LinearGradient>

          <Text style={styles.messageText}>
            {isIncrease 
              ? 'Your daily average has increased compared to last week'
              : 'Your daily average has decreased compared to last week'
            }
          </Text>
        </View>

        {/* Action Button */}
        <TouchableOpacity style={styles.actionButton}>
          <LinearGradient
            colors={[statusColor, `${statusColor}CC`] as const}
            style={styles.actionGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
          >
            <Text style={styles.actionText}>View Details</Text>
            <MaterialCommunityIcons 
              name="chevron-right" 
              size={18} 
              color="#FFF"
            />
          </LinearGradient>
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: COLORS.cardBackground,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    marginBottom: 16,
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 12,
      },
      android: {
        elevation: 8,
      },
    }),
  },
  backgroundGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  shimmerEffect: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.4,
  },
  content: {
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  titleContainer: {
    marginLeft: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 13,
    color: COLORS.text.secondary,
  },
  dismissButton: {
    borderRadius: 15,
    overflow: 'hidden',
  },
  dismissGradient: {
    width: 30,
    height: 30,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 15,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  statsContainer: {
    borderRadius: 16,
    overflow: 'hidden',
    marginBottom: 20,
  },
  statsGradient: {
    flexDirection: 'row',
    padding: 16,
    alignItems: 'center',
    justifyContent: 'space-around',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statLabel: {
    fontSize: 13,
    color: COLORS.text.secondary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  statDivider: {
    width: 1,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginHorizontal: 16,
  },
  messageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.03)',
    padding: 12,
    borderRadius: 12,
  },
  statusIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  messageText: {
    flex: 1,
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
  },
  actionButton: {
    borderRadius: 20,
    overflow: 'hidden',
  },
  actionGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 20,
  },
  actionText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#FFF',
    marginRight: 4,
  },
});

export default NotificationBanner;

================================================================================
File: app/components/mydata/Section.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '@/src/constants';

// Gradient configurations
const gradients = {
  section: ['rgba(0,230,118,0.1)', 'rgba(0,230,118,0.02)', 'transparent'] as const,
  divider: ['rgba(0,230,118,0.1)', 'transparent'] as const,
};

interface SectionProps {
  title: string;
  children: React.ReactNode;
}

const Section = memo(({ title, children }: SectionProps) => (
  <View style={styles.sectionWrapper}>
    <LinearGradient
      colors={gradients.divider}
      style={styles.sectionDivider}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 0 }}
    />
    <View style={styles.section}>
      <LinearGradient
        colors={gradients.section}
        style={styles.sectionGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionTitle}>{title}</Text>
      </View>
      <View style={styles.sectionContent}>
        {children}
      </View>
    </View>
  </View>
));

const styles = StyleSheet.create({
  sectionWrapper: {
    marginBottom: 32,
    position: 'relative',
  },
  sectionDivider: {
    height: 1,
    width: '100%',
    marginBottom: 16,
  },
  section: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(26, 26, 26, 0.85)',
  },
  sectionGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  sectionHeader: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 230, 118, 0.1)',
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  sectionContent: {
    padding: 12,
    gap: 12,
  },
});

export default Section;

================================================================================
File: app/components/mydata/SetGoalModal.tsx
================================================================================

import React, { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  Modal, 
  TouchableOpacity, 
  TextInput,
  TouchableWithoutFeedback,
  Keyboard 
} from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';

interface SetGoalModalProps {
  visible: boolean;
  onClose: () => void;
  onSave: (goal: number) => void;
  currentGoal: number;
}

const SetGoalModal = ({ visible, onClose, onSave, currentGoal }: SetGoalModalProps) => {
  const [goalValue, setGoalValue] = useState(currentGoal.toString());

  const handleSave = () => {
    const numValue = parseInt(goalValue, 10);
    if (!isNaN(numValue) && numValue > 0) {
      onSave(numValue);
    }
    onClose();
  };

  return (
    <Modal
      visible={visible}
      transparent={true}
      animationType="fade"
      onRequestClose={onClose}
    >
      <TouchableWithoutFeedback onPress={() => {
        Keyboard.dismiss();
        onClose();
      }}>
        <View style={styles.modalOverlay}>
          <TouchableWithoutFeedback onPress={(e) => e.stopPropagation()}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Set Daily Goal</Text>
                <TouchableOpacity onPress={onClose} style={styles.closeButton}>
                  <MaterialCommunityIcons 
                    name="close" 
                    size={20} 
                    color="#FFFFFF" 
                  />
                </TouchableOpacity>
              </View>
              
              <Text style={styles.label}>Number of hits per day</Text>
              <TextInput
                style={styles.input}
                value={goalValue}
                onChangeText={setGoalValue}
                keyboardType="numeric"
                placeholder="Enter your goal"
                placeholderTextColor="rgba(255, 255, 255, 0.4)"
              />
              
              <View style={styles.buttonRow}>
                <TouchableOpacity 
                  onPress={onClose}
                  style={styles.cancelButton}
                >
                  <Text style={styles.cancelButtonText}>Cancel</Text>
                </TouchableOpacity>
                
                <TouchableOpacity 
                  onPress={handleSave}
                  style={styles.saveButton}
                >
                  <Text style={styles.saveButtonText}>Save Goal</Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '85%',
    backgroundColor: '#0B1B0F', // Darker green background to match screenshot
    borderRadius: 16,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.15)',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 24,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  closeButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  label: {
    fontSize: 15,
    color: 'rgba(255, 255, 255, 0.7)',
    marginBottom: 12,
  },
  input: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 8,
    padding: 14,
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 24,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.2)',
  },
  buttonRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  cancelButton: {
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
  },
  cancelButtonText: {
    fontSize: 16,
    color: '#FFFFFF',
  },
  saveButton: {
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    backgroundColor: '#00E676', // Bright green to match your app's theme
  },
  saveButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#000000', // Black text on green button
  },
});

export default SetGoalModal;

================================================================================
File: app/components/mydata/StrainUsageCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';

interface StrainUsage {
  strainId: number;
  strainName: string;
  strainType: string;
  usageCount: number;
  percentageOfTotal: number;
}

interface StrainUsageCardProps {
  strainData: StrainUsage[];
  totalHits: number;
  onViewAll: () => void;
}

const StrainUsageCard = ({ strainData, totalHits, onViewAll }: StrainUsageCardProps) => {
  // Just show the top 3 strains
  const topStrains = strainData.slice(0, 3);
  
  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <View style={styles.content}>
        {/* Header with icon */}
        <View style={styles.headerRow}>
          <View style={styles.iconCircle}>
            <MaterialCommunityIcons 
              name="cannabis" 
              size={20} 
              color={COLORS.primary}
            />
          </View>
          <View style={styles.headerTextContainer}>
            <Text style={styles.title}>Most Used Strains</Text>
            <Text style={styles.subtitle}>
              Based on your last {totalHits} hits
            </Text>
          </View>
        </View>

        {/* Strains List */}
        <View style={styles.strainsList}>
          {topStrains.map((strain, index) => (
            <View key={strain.strainId} style={styles.strainItem}>
              <View style={styles.strainInfo}>
                <Text style={styles.strainName}>{strain.strainName}</Text>
                <Text style={styles.strainType}>{strain.strainType}</Text>
              </View>
              
              <View style={styles.strainStats}>
                <Text style={styles.usageCount}>{strain.usageCount} hits</Text>
                <View style={styles.percentageContainer}>
                  <View 
                    style={[
                      styles.percentageFill, 
                      { width: `${strain.percentageOfTotal}%` }
                    ]} 
                  />
                </View>
                <Text style={styles.percentageText}>
                  {strain.percentageOfTotal.toFixed(1)}%
                </Text>
              </View>
            </View>
          ))}
        </View>

        {/* View All Button */}
        <TouchableOpacity 
          onPress={onViewAll}
          style={styles.viewDetailsButton}
        >
          <Text style={styles.viewDetailsText}>View Details</Text>
          <MaterialCommunityIcons 
            name="chevron-right" 
            size={16} 
            color="#FFFFFF"
          />
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: '#0C140E',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    marginBottom: 12,
  },
  content: {
    padding: 16,
  },
  headerRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  iconCircle: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 230, 118, 0.15)',
    marginRight: 12,
  },
  headerTextContainer: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
    marginBottom: 2,
  },
  subtitle: {
    fontSize: 13,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  strainsList: {
    gap: 8,
    marginBottom: 16,
  },
  strainItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 8,
  },
  strainInfo: {
    flex: 1,
  },
  strainName: {
    fontSize: 15,
    fontWeight: '500',
    color: '#FFFFFF',
    marginBottom: 2,
  },
  strainType: {
    fontSize: 13,
    color: COLORS.primary,
  },
  strainStats: {
    flex: 2,
    alignItems: 'flex-end',
  },
  usageCount: {
    fontSize: 13,
    color: 'rgba(255, 255, 255, 0.7)',
    marginBottom: 4,
  },
  percentageContainer: {
    height: 6,
    width: '100%',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 3,
    marginBottom: 4,
  },
  percentageFill: {
    height: '100%',
    backgroundColor: COLORS.primary,
    borderRadius: 3,
  },
  percentageText: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  viewDetailsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: COLORS.primary,
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 20,
    alignSelf: 'center',
  },
  viewDetailsText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#000000',
    marginRight: 4,
  },
});

export default StrainUsageCard;

================================================================================
File: app/components/mydata/WeeklyUsageBanner.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { ChartDataPoint } from '../../../src/types';

interface WeeklyUsageBannerProps {
  weeklyData: ChartDataPoint[];
  average: number;
  onPress: () => void;
}

const WeeklyUsageBanner: React.FC<WeeklyUsageBannerProps> = ({ weeklyData, average, onPress }) => {
  // Calculate the percentage change from last week
  const currentWeekTotal = weeklyData.reduce((sum, day) => sum + day.value, 0);
  const weeklyAverage = currentWeekTotal / 7;
  const percentageChange = ((weeklyAverage - average) / average) * 100;
  
  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Weekly Usage</Text>
              <Text style={styles.subtitle}>
                {weeklyAverage.toFixed(1)} average hits per day
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-timeline-variant" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{currentWeekTotal}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>vs Last Week</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={percentageChange >= 0 ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={percentageChange >= 0 ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: percentageChange >= 0 ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(percentageChange).toFixed(1)}%
                </Text>
              </View>
            </View>
          </View>

          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Weekly Analysis</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
    minHeight: 160,
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 20,
    paddingTop: 8,
  },
  statItem: {
    flex: 1,
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 20,
    fontWeight: '600',
    marginLeft: 4,
  },
  buttonContainer: {
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default WeeklyUsageBanner;

================================================================================
File: app/components/shared/Card.tsx
================================================================================

import React, { forwardRef } from "react";
import { View, StyleSheet, StyleProp, ViewStyle } from "react-native";
import { COLORS } from '../../../src/constants';

interface CardProps {
    children: React.ReactNode;
    style?: StyleProp<ViewStyle>;
}

export const Card = forwardRef<View, CardProps>(({ children, style }, ref) => {
    return <View ref={ref} style={[styles.card, style]}>{children}</View>;
});

const styles = StyleSheet.create({
    card: {
        backgroundColor: COLORS.cardBackground,
        borderRadius: 16,
        elevation: 6,
        shadowColor: COLORS.primary,
        shadowOffset: {
            width: 0,
            height: 2,
        },
        shadowOpacity: 0.15,
        shadowRadius: 8,
        padding: 16,
        borderWidth: 1,
        borderColor: 'rgba(0, 230, 118, 0.1)',
    }
});

================================================================================
File: app/components/shared/ErrorView.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '@/src/constants';

interface ErrorViewProps {
  error: string;
}

export default function ErrorView({ error }: ErrorViewProps) {
  return (
    <View style={styles.container}>
      <MaterialCommunityIcons 
        name="alert-circle-outline" 
        size={48} 
        color={COLORS.error} 
      />
      <Text style={styles.title}>Error</Text>
      <Text style={styles.message}>{error}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    marginTop: 16,
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  message: {
    marginTop: 8,
    fontSize: 16,
    color: COLORS.text.secondary,
    textAlign: 'center',
  },
});

================================================================================
File: app/components/shared/LoadingView.tsx
================================================================================

import React, { useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '../../../src/constants';
import Animated, { 
  withRepeat, 
  withTiming,
  useAnimatedStyle, 
  useSharedValue,
  FadeIn
} from 'react-native-reanimated';
import { TIMING_CONFIG } from '@/src/utils/animations';

export default function LoadingView() {
  const rotation = useSharedValue(0);

  useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        ...TIMING_CONFIG,
        duration: 1500 // Slightly slower for smoother rotation
      }),
      -1
    );
  }, []);

  const spinStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }]
  }));

  return (
    <View style={styles.container}>
      <Animated.View 
        entering={FadeIn.duration(300)}
        style={styles.content}
      >
        <Animated.View style={spinStyle}>
          <MaterialCommunityIcons 
            name="cannabis" 
            size={32} 
            color={COLORS.primary} 
          />
        </Animated.View>
        <Text style={styles.text}>Loading...</Text>
      </Animated.View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    alignItems: 'center',
    gap: 12,
  },
  text: {
    fontSize: 16,
    color: COLORS.text.secondary,
  },
});

================================================================================
File: app/components/StatsOverviewCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { Card } from "./shared/Card";
import { COLORS } from "../../src/constants";
import { UsageStats } from "../../src/types";
import Animated, { FadeIn } from 'react-native-reanimated';

interface StatsOverviewCardProps {
  stats: UsageStats;
}

function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

const StatsOverviewCard: React.FC<StatsOverviewCardProps> = ({ stats }) => {
  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <LinearGradient
        colors={[
          'rgba(0,230,118,0.15)',
          'rgba(0,230,118,0.05)',
          'transparent'
        ]}
        style={StyleSheet.absoluteFill}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      
      <View style={styles.content}>
        {/* Header */}
        <View style={styles.headerRow}>
          <View style={styles.titleContainer}>
            <Text style={styles.title}>Usage Statistics</Text>
            <Text style={styles.subtitle}>
              Detailed overview of your usage patterns
            </Text>
          </View>
          
          <LinearGradient
            colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
            style={styles.iconContainer}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons 
              name="chart-box-outline" 
              size={24} 
              color={COLORS.primary}
            />
          </LinearGradient>
        </View>

        {/* Hit Counts Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Hit Counts</Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Daily Average</Text>
              <Text style={styles.statValue}>{stats.averageHitsPerDay.toFixed(1)}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Day</Text>
              <Text style={styles.statValue}>{stats.peakDayHits}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{stats.totalHits}</Text>
            </View>
          </View>
        </View>

        {/* Duration Stats Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Duration</Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Average</Text>
              <Text style={styles.statValue}>{formatDuration(stats.averageDuration)}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Longest</Text>
              <Text style={styles.statValue}>{formatDuration(stats.longestHit)}</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Shortest</Text>
              <Text style={styles.statValue}>{formatDuration(stats.shortestHit)}</Text>
            </View>
          </View>
        </View>

        {/* Time Patterns Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Activity Patterns</Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Hours</Text>
              <Text style={styles.statValue}>{stats.mostActiveHour}:00</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Quiet Hours</Text>
              <Text style={styles.statValue}>{stats.leastActiveHour}:00</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Consistency</Text>
              <Text style={styles.statValue}>{stats.consistency.toFixed(1)}</Text>
            </View>
          </View>
        </View>

        {/* Weekday vs Weekend */}
        <View style={[styles.section, styles.lastSection]}>
          <Text style={styles.sectionTitle}>Weekly Distribution</Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Weekday Avg</Text>
              <Text style={styles.statValue}>
                {stats.weekdayStats.weekday.avg.toFixed(1)}
              </Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Weekend Avg</Text>
              <Text style={styles.statValue}>
                {stats.weekdayStats.weekend.avg.toFixed(1)}
              </Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Difference</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={stats.weekdayStats.weekend.avg >= stats.weekdayStats.weekday.avg ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={stats.weekdayStats.weekend.avg >= stats.weekdayStats.weekday.avg ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: stats.weekdayStats.weekend.avg >= stats.weekdayStats.weekday.avg ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(((stats.weekdayStats.weekend.avg - stats.weekdayStats.weekday.avg) / stats.weekdayStats.weekday.avg) * 100).toFixed(1)}%
                </Text>
              </View>
            </View>
          </View>
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 24,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  section: {
    marginBottom: 24,
  },
  lastSection: {
    marginBottom: 0,
  },
  sectionTitle: {
    fontSize: 17,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 16,
    letterSpacing: -0.41,
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    flex: 1,
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 18,
    fontWeight: '600',
    marginLeft: 4,
  },
});

export default StatsOverviewCard; 

================================================================================
File: app/components/TimeDistributionCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from "../../src/constants";
import { TimeDistribution } from "../../src/types";
import Animated, { FadeIn } from 'react-native-reanimated';

interface TimeDistributionCardProps {
  timeData: TimeDistribution;
}

type TimeSlot = 'morning' | 'afternoon' | 'evening' | 'night';

const COLORS_MAP: Record<TimeSlot, string> = {
  morning: '#FFB74D',
  afternoon: '#4FC3F7',
  evening: '#7986CB',
  night: '#9575CD',
};

const ICONS_MAP: Record<TimeSlot, keyof typeof MaterialCommunityIcons.glyphMap> = {
  morning: 'weather-sunny',
  afternoon: 'weather-partly-cloudy',
  evening: 'weather-sunset',
  night: 'weather-night',
};

const TimeDistributionCard = ({ timeData }: TimeDistributionCardProps) => {
  const total = Object.values(timeData).reduce((sum, val) => sum + val, 0);

  const TimeSlotComponent = ({ type, value }: { type: TimeSlot; value: number }) => {
    const percentage = total === 0 ? 0 : (value / total) * 100;
    const barWidth = Math.max(0, Math.min(100, percentage));

    return (
      <Animated.View 
        entering={FadeIn.delay(type === 'morning' ? 200 : type === 'afternoon' ? 400 : type === 'evening' ? 600 : 800)}
        style={styles.timeSlot}
      >
        <View style={styles.timeSlotContent}>
          <View style={styles.timeSlotHeader}>
            <LinearGradient
              colors={[`${COLORS_MAP[type]}40`, `${COLORS_MAP[type]}20`]}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name={ICONS_MAP[type]} 
                size={18} 
                color={COLORS_MAP[type]} 
              />
            </LinearGradient>
            <Text style={styles.timeSlotText}>
              {type.charAt(0).toUpperCase() + type.slice(1)}
            </Text>
            <Text style={styles.percentageText}>
              {percentage.toFixed(0)}%
            </Text>
          </View>
          <View style={styles.barContainer}>
            <LinearGradient
              colors={[`${COLORS_MAP[type]}`, `${COLORS_MAP[type]}80`]}
              style={[styles.bar, { width: `${barWidth}%` }]}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
          </View>
        </View>
      </Animated.View>
    );
  };

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <LinearGradient
        colors={[
          'rgba(0,230,118,0.15)',
          'rgba(0,230,118,0.05)',
          'transparent'
        ]}
        style={StyleSheet.absoluteFill}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      
      <View style={styles.content}>
        <View style={styles.headerRow}>
          <View style={styles.titleContainer}>
            <Text style={styles.title}>Time Distribution</Text>
            <Text style={styles.subtitle}>
              Activity patterns throughout the day
            </Text>
          </View>
          
          <LinearGradient
            colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
            style={styles.headerIconContainer}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons 
              name="clock-outline" 
              size={24} 
              color={COLORS.primary}
            />
          </LinearGradient>
        </View>

        <View style={styles.distributionContent}>
          <TimeSlotComponent type="morning" value={timeData.morning} />
          <TimeSlotComponent type="afternoon" value={timeData.afternoon} />
          <TimeSlotComponent type="evening" value={timeData.evening} />
          <TimeSlotComponent type="night" value={timeData.night} />
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 24,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  headerIconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  distributionContent: {
    gap: 16,
  },
  timeSlot: {
    marginBottom: 4,
  },
  timeSlotContent: {
    gap: 8,
  },
  timeSlotHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  timeSlotText: {
    flex: 1,
    fontSize: 15,
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: -0.24,
  },
  percentageText: {
    fontSize: 15,
    fontWeight: '600',
    color: COLORS.text.primary,
    width: 40,
    textAlign: 'right',
    letterSpacing: -0.24,
  },
  barContainer: {
    height: 6,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 3,
    overflow: 'hidden',
    marginTop: 4,
  },
  bar: {
    height: '100%',
    borderRadius: 3,
  },
});

export default TimeDistributionCard; 

================================================================================
File: app/components/trending/CompareBar.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, FlatList } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import { Strain } from '../../../src/dbManager';
import Animated, { FadeIn } from 'react-native-reanimated';

interface CompareBarProps {
  compareList: Strain[];
  onCompareToggle: (strain: Strain) => void;
  onCompare: () => void;
}

const CompareBar = memo(({
  compareList,
  onCompareToggle,
  onCompare
}: CompareBarProps) => (
  <Animated.View 
    entering={FadeIn}
    style={styles.compareBar}
  >
    <FlatList
      horizontal
      data={compareList}
      keyExtractor={item => item.id!.toString()}
      renderItem={({ item }) => (
        <View style={styles.compareItem}>
          <Text style={styles.compareItemText}>{item.name}</Text>
          <TouchableOpacity 
            onPress={() => onCompareToggle(item)}
            style={styles.compareItemRemove}
          >
            <MaterialCommunityIcons 
              name="close" 
              size={20} 
              color={COLORS.text.secondary} 
            />
          </TouchableOpacity>
        </View>
      )}
    />
    <TouchableOpacity 
      style={[
        styles.compareButton,
        compareList.length < 2 && styles.compareButtonDisabled
      ]}
      onPress={onCompare}
      disabled={compareList.length < 2}
    >
      <Text style={styles.compareButtonText}>
        Compare ({compareList.length})
      </Text>
    </TouchableOpacity>
  </Animated.View>
));

const styles = StyleSheet.create({
  compareBar: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'rgba(26, 26, 26, 0.95)',
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 230, 118, 0.1)',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    gap: 12,
  },
  compareItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderRadius: 8,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    gap: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  compareItemText: {
    color: COLORS.text.primary,
    fontSize: 14,
    maxWidth: 120,
    letterSpacing: 0.2,
  },
  compareItemRemove: {
    padding: 2,
  },
  compareButton: {
    backgroundColor: COLORS.primary,
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
    opacity: 1,
  },
  compareButtonDisabled: {
    opacity: 0.5,
  },
  compareButtonText: {
    color: COLORS.background,
    fontWeight: '600',
    fontSize: 14,
    letterSpacing: 0.2,
  },
});

export default CompareBar; 

================================================================================
File: app/components/trending/Header.tsx
================================================================================

// components/trending/Header.tsx
import React from 'react';
import { View, Text, StyleSheet, TextInput, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';
import { StrainSearchFilters } from '../../../src/services/StrainService';
import { hasActiveFilters } from '../../../src/utils/filters';

interface HeaderProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  filters: StrainSearchFilters;
  handleClearSearch: () => void;
}

const Header = ({ 
  searchQuery, 
  setSearchQuery, 
  showFilters, 
  setShowFilters,
  filters,
  handleClearSearch
}: HeaderProps) => {
  const insets = useSafeAreaInsets();
  const hasFilters = hasActiveFilters(filters);
  const hasSearchOrFilters = searchQuery.trim() || hasFilters;

  return (
    <View style={[styles.container, { paddingTop: insets.top + 10 }]}>
      <LinearGradient
        colors={['rgba(0, 230, 118, 0.15)', 'transparent']}
        style={[styles.headerGradient, { top: 0 }]}
        start={{ x: 0.5, y: 0 }}
        end={{ x: 0.5, y: 1 }}
      />
      
      <Text style={styles.title}>Trending</Text>
      
      <View style={styles.searchContainer}>
        <View style={styles.searchInputContainer}>
          <Ionicons name="search" size={20} color={COLORS.text.secondary} style={styles.searchIcon} />
          <TextInput
            style={styles.searchInput}
            placeholder="Search strains..."
            placeholderTextColor={COLORS.text.placeholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            returnKeyType="search"
          />
          {searchQuery.length > 0 && (
            <TouchableOpacity onPress={() => setSearchQuery('')} style={styles.clearButton}>
              <Ionicons name="close-circle" size={18} color={COLORS.text.secondary} />
            </TouchableOpacity>
          )}
        </View>
        
        <TouchableOpacity 
          style={[
            styles.filterButton, 
            hasFilters && styles.activeFilterButton
          ]} 
          onPress={() => setShowFilters(!showFilters)}
        >
          <Ionicons 
            name="options-outline" 
            size={20} 
            color={hasFilters ? COLORS.accent : COLORS.text.secondary} 
          />
        </TouchableOpacity>
      </View>
      
      {hasSearchOrFilters && (
        <View style={styles.clearSearchContainer}>
          <TouchableOpacity 
            style={styles.clearSearchButton}
            onPress={handleClearSearch}
          >
            <Text style={styles.clearSearchText}>Clear All</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 20,
    paddingBottom: 16,
    position: 'relative',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.05)',
  },
  headerGradient: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 150,
  },
  title: {
    fontSize: 34,
    fontWeight: '700',
    color: 'white',
    marginBottom: 20,
    letterSpacing: 0.5,
    textShadowColor: 'rgba(0, 230, 118, 0.6)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  searchInputContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.06)',
    borderRadius: 12,
    paddingHorizontal: 12,
    height: 46,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.08)',
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 46,
    color: COLORS.text.primary,
    fontSize: 16,
  },
  clearButton: {
    padding: 6,
  },
  filterButton: {
    width: 46,
    height: 46,
    borderRadius: 12,
    backgroundColor: 'rgba(255, 255, 255, 0.06)',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.08)',
  },
  activeFilterButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    borderColor: 'rgba(0, 230, 118, 0.3)',
  },
  clearSearchContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginBottom: 4,
  },
  clearSearchButton: {
    paddingVertical: 6,
    paddingHorizontal: 10,
  },
  clearSearchText: {
    color: COLORS.accent,
    fontSize: 14,
    fontWeight: '500',
  },
});

export default Header;

================================================================================
File: app/components/trending/SearchBar.tsx
================================================================================

// app/components/trending/SearchBar.tsx
import React, { memo } from 'react';
import { View, TextInput, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import { LinearGradient } from 'expo-linear-gradient';
import { StrainSearchFilters } from '../../../src/services/StrainService';
import { hasActiveFilters } from '../../../src/utils/filters';
import Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';

interface SearchBarProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  filters: StrainSearchFilters;
  onClear: () => void;
}

const SearchBar = memo(({
  searchQuery,
  setSearchQuery,
  showFilters,
  setShowFilters,
  filters,
  onClear
}: SearchBarProps) => {
  // Determine if we need the clear button
  const showClearButton = searchQuery.trim() || hasActiveFilters(filters);
  
  // Define filter button states
  const hasFilters = hasActiveFilters(filters);
  const isFilterActive = showFilters || hasFilters;
  
  return (
    <View style={styles.searchContainer}>
      {/* Main search input with enhanced styling */}
      <View style={styles.searchBar}>
        <LinearGradient
          colors={['rgba(0,0,0,0.2)', 'rgba(0,0,0,0.1)']}
          style={StyleSheet.absoluteFillObject}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <MaterialCommunityIcons 
          name="magnify" 
          size={22} 
          color={COLORS.text.secondary} 
          style={styles.searchIcon}
        />
        
        <TextInput
          style={styles.searchInput}
          placeholder="Search strains..."
          placeholderTextColor="rgba(255,255,255,0.4)"
          value={searchQuery}
          onChangeText={setSearchQuery}
          returnKeyType="search"
          autoCapitalize="none"
          autoCorrect={false}
          clearButtonMode="while-editing"
        />
        
        {Platform.OS === 'android' && showClearButton && (
          <TouchableOpacity 
            onPress={onClear}
            style={styles.clearButton}
          >
            <MaterialCommunityIcons 
              name="close-circle" 
              size={18} 
              color={COLORS.text.secondary} 
            />
          </TouchableOpacity>
        )}
      </View>

      {/* Enhanced filter button with states */}
      <TouchableOpacity 
        style={[styles.filterButton, isFilterActive && styles.filterButtonActive]}
        onPress={() => setShowFilters(!showFilters)}
        activeOpacity={0.7}
      >
        <LinearGradient
          colors={
            isFilterActive 
              ? ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']
              : ['rgba(0,0,0,0.2)', 'rgba(0,0,0,0.1)']
          }
          style={StyleSheet.absoluteFillObject}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <MaterialCommunityIcons 
          name="filter-variant" 
          size={22} 
          color={isFilterActive ? COLORS.primary : COLORS.text.secondary} 
        />
        
        {/* Badge indicator if filters are active */}
        {hasFilters && (
          <View style={styles.filterBadge}>
            <LinearGradient
              colors={['#00E676', '#00C853']}
              style={StyleSheet.absoluteFillObject}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            />
          </View>
        )}
      </TouchableOpacity>
    </View>
  );
});

const styles = StyleSheet.create({
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  searchBar: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.25)',
    borderRadius: 12,
    height: 44,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.12)',
    overflow: 'hidden',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  searchIcon: {
    marginLeft: 12,
    marginRight: 4,
  },
  searchInput: {
    flex: 1,
    color: '#000000',
    fontSize: 16,
    fontWeight: '400',
    paddingVertical: 10,
    paddingHorizontal: 8,
  },
  clearButton: {
    padding: 8,
    marginRight: 4,
  },
  filterButton: {
    width: 44,
    height: 44,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.25)',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.12)',
    overflow: 'hidden',
    position: 'relative',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  filterButtonActive: {
    borderColor: 'rgba(0, 230, 118, 0.3)',
  },
  filterBadge: {
    position: 'absolute',
    top: 10,
    right: 10,
    width: 8,
    height: 8,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.3)',
    overflow: 'hidden',
  },
});

export default SearchBar;

================================================================================
File: app/components/trending/SearchFilters.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import { StrainSearchFilters } from '../../../src/services/StrainService';
import { LinearGradient } from 'expo-linear-gradient';

interface SearchFiltersProps {
  filters: StrainSearchFilters;
  onFilterChange: (filters: StrainSearchFilters) => void;
  onApplyFilters: () => void;
  categories: { [key: string]: number };
}

const SORT_OPTIONS = [
  { key: 'rating', label: 'Rating', icon: 'star' },
  { key: 'name', label: 'Name', icon: 'sort-alphabetical-ascending' },
  { key: 'thc', label: 'THC', icon: 'percent' },
] as const;

const COMMON_EFFECTS = [
  'Relaxed',
  'Energetic',
  'Creative',
  'Focused',
  'Euphoric',
  'Sleepy',
  'Happy',
  'Uplifted'
];

export default function SearchFilters({ 
  filters, 
  onFilterChange, 
  onApplyFilters,
  categories 
}: SearchFiltersProps) {
  const [localFilters, setLocalFilters] = useState<StrainSearchFilters>(filters);

  const handleSortChange = (sort: StrainSearchFilters['sort']) => {
    setLocalFilters(prev => ({ ...prev, sort }));
  };

  const handleEffectToggle = (effect: string) => {
    const currentEffects = localFilters.effects || [];
    const newEffects = currentEffects.includes(effect)
      ? currentEffects.filter(e => e !== effect)
      : [...currentEffects, effect];
    setLocalFilters(prev => ({ ...prev, effects: newEffects }));
  };

  const handleGeneticTypeChange = (geneticType: string | undefined) => {
    setLocalFilters(prev => ({ ...prev, geneticType }));
  };

  const handleApply = () => {
    onFilterChange(localFilters);
    onApplyFilters();
  };

  return (
    <View style={styles.container}>
      {/* Sort Options */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Sort By</Text>
        <View style={styles.sortOptions}>
          {SORT_OPTIONS.map(({ key, label, icon }) => (
            <TouchableOpacity
              key={key}
              style={[
                styles.sortOption,
                localFilters.sort === key && styles.sortOptionActive
              ]}
              onPress={() => handleSortChange(key)}
            >
              <MaterialCommunityIcons
                name={icon}
                size={18}
                color={localFilters.sort === key ? COLORS.primary : COLORS.text.secondary}
              />
              <Text style={[
                styles.sortOptionText,
                localFilters.sort === key && styles.sortOptionTextActive
              ]}>
                {label}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Genetic Types */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Genetic Type</Text>
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          style={styles.geneticTypes}
        >
          <TouchableOpacity
            style={[
              styles.typeChip,
              !localFilters.geneticType && styles.typeChipActive
            ]}
            onPress={() => handleGeneticTypeChange(undefined)}
          >
            <Text style={[
              styles.typeChipText,
              !localFilters.geneticType && styles.typeChipTextActive
            ]}>
              All
            </Text>
          </TouchableOpacity>
          {Object.entries(categories).map(([type, count]) => (
            <TouchableOpacity
              key={type}
              style={[
                styles.typeChip,
                localFilters.geneticType === type && styles.typeChipActive
              ]}
              onPress={() => handleGeneticTypeChange(type)}
            >
              <Text style={[
                styles.typeChipText,
                localFilters.geneticType === type && styles.typeChipTextActive
              ]}>
                {type} ({count})
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>

      {/* Effects */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Effects</Text>
        <View style={styles.effectsGrid}>
          {COMMON_EFFECTS.map(effect => (
            <TouchableOpacity
              key={effect}
              style={[
                styles.effectChip,
                (localFilters.effects || []).includes(effect) && styles.effectChipActive
              ]}
              onPress={() => handleEffectToggle(effect)}
            >
              <Text style={[
                styles.effectChipText,
                (localFilters.effects || []).includes(effect) && styles.effectChipTextActive
              ]}>
                {effect}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Apply Button */}
      <TouchableOpacity 
        style={styles.applyButton}
        onPress={handleApply}
      >
        <LinearGradient
          colors={[COLORS.primary, COLORS.primaryDark]}
          style={styles.applyButtonGradient}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          <Text style={styles.applyButtonText}>Apply Filters</Text>
          <MaterialCommunityIcons 
            name="check" 
            size={20} 
            color="#FFF" 
          />
        </LinearGradient>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 12,
    padding: 16,
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  sortOptions: {
    flexDirection: 'row',
    gap: 12,
  },
  sortOption: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    gap: 6,
  },
  sortOptionActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  sortOptionText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  sortOptionTextActive: {
    color: COLORS.primary,
  },
  geneticTypes: {
    flexDirection: 'row',
  },
  typeChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    marginRight: 8,
  },
  typeChipActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  typeChipText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  typeChipTextActive: {
    color: COLORS.primary,
  },
  effectsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  effectChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  effectChipActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  effectChipText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  effectChipTextActive: {
    color: COLORS.primary,
  },
  applyButton: {
    marginTop: 20,
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  applyButtonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 8,
    width: '100%',
  },
  applyButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFF',
    marginRight: 8,
  },
});

================================================================================
File: app/components/trending/Section.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';

interface SectionProps {
  title: string;
  children: React.ReactNode;
}

const Section = memo(({ title, children }: SectionProps) => (
  <View style={styles.sectionWrapper}>
    <LinearGradient
      colors={['rgba(0,230,118,0.1)', 'transparent']}
      style={styles.sectionDivider}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 0 }}
    />
    <View style={styles.section}>
      <LinearGradient
        colors={['rgba(0,230,118,0.1)', 'rgba(0,230,118,0.02)', 'transparent']}
        style={styles.sectionGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionTitle}>{title}</Text>
      </View>
      <View style={styles.sectionContent}>
        {children}
      </View>
    </View>
  </View>
));

const styles = StyleSheet.create({
  sectionWrapper: {
    marginBottom: 32,
    position: 'relative',
  },
  sectionDivider: {
    height: 1,
    width: '100%',
    marginBottom: 16,
  },
  section: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.75)',
      android: 'rgba(26, 26, 26, 0.9)',
    }),
  },
  sectionGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  sectionHeader: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 230, 118, 0.1)',
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  sectionContent: {
    padding: 12,
    gap: 12,
  },
});

export default Section; 

================================================================================
File: app/components/trending/StrainsList.tsx
================================================================================

// app/components/trending/StrainsList.tsx
import React, { memo, useCallback } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  FlatList, 
  Platform
} from 'react-native';
import { useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';
import { Strain } from '../../../src/dbManager';
import Animated, { FadeIn } from 'react-native-reanimated';

interface StrainsListProps {
  strains: Strain[];
  onCompareToggle: (strain: Strain) => void;
  onFavoriteToggle: (strainId: number) => void;
  compareList: Strain[];
  isFavorite: (strainId: number) => boolean;
  isLoading: boolean;
  onEndReached: () => void;
}

// Rating badge component for cleaner code
const RatingBadge = ({ rating }: { rating: number }) => (
  <LinearGradient
    colors={[
      rating >= 9 ? '#00E676' : rating >= 8 ? '#1DE9B6' : '#26C6DA', 
      rating >= 9 ? '#00C853' : rating >= 8 ? '#00BFA5' : '#00ACC1'
    ]}
    style={styles.ratingBadge}
    start={{ x: 0, y: 0 }}
    end={{ x: 1, y: 1 }}
  >
    <Text style={styles.ratingText}>{rating.toFixed(1)}</Text>
  </LinearGradient>
);

// Strain type badge
const TypeBadge = ({ type }: { type: string }) => {
  let gradientColors;
  
  // Different colors for different strain types
  switch(type.toLowerCase()) {
    case 'sativa':
    case 'sativa-dominant':
    case 'sativa-dominant hybrid':
      gradientColors = ['rgba(255, 160, 0, 0.2)', 'rgba(255, 160, 0, 0.1)'];
      break;
    case 'indica':
    case 'indica-dominant':
    case 'indica-dominant hybrid':
      gradientColors = ['rgba(123, 31, 162, 0.2)', 'rgba(123, 31, 162, 0.1)'];
      break;
    case 'hybrid':
      gradientColors = ['rgba(0, 176, 255, 0.2)', 'rgba(0, 176, 255, 0.1)'];
      break;
    default:
      gradientColors = ['rgba(120, 144, 156, 0.2)', 'rgba(120, 144, 156, 0.1)'];
  }
  
  return (
    <LinearGradient
      colors={gradientColors}
      style={styles.typeBadge}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 1 }}
    >
      <Text style={styles.typeBadgeText}>{type}</Text>
    </LinearGradient>
  );
};

export const StrainsList = memo(({
  strains,
  onCompareToggle,
  onFavoriteToggle,
  compareList,
  isFavorite,
  isLoading,
  onEndReached,
}: StrainsListProps) => {
  const router = useRouter();

  // Optimize with useCallback
  const renderStrainItem = useCallback(({ item: strain, index }: { item: Strain, index: number }) => (
    <Animated.View 
    entering={FadeIn.duration(150)} // Much shorter duration, no delay
    style={styles.strainItemContainer}
  >
      <TouchableOpacity
        onPress={() => router.push({
          pathname: "/strains/details",
          params: { id: strain.id }
        } as any)}
        style={styles.strainItem}
        activeOpacity={0.8}
      >
        <LinearGradient
          colors={['rgba(0, 230, 118, 0.1)', 'rgba(0, 230, 118, 0.05)', 'rgba(0, 230, 118, 0)']}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        />
        
        {/* Left content */}
        <View style={styles.strainContent}>
          <View style={styles.strainHeader}>
            <Text style={styles.strainName}>{strain.name}</Text>
            <RatingBadge rating={strain.combined_rating} />
          </View>

          <TypeBadge type={strain.genetic_type} />
          
          <Text 
            numberOfLines={2} 
            style={styles.strainDescription}
          >
            {strain.overview}
          </Text>

          {strain.effects && (
            <View style={styles.effectsContainer}>
              {strain.effects.split(',').slice(0, 3).map((effect, idx) => (
                <View key={idx} style={styles.effectBadge}>
                  <Text style={styles.effectText}>{effect.trim()}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        {/* Action buttons */}
        <View style={styles.actionButtons}>
          <TouchableOpacity 
            onPress={() => onFavoriteToggle(strain.id!)}
            style={[
              styles.actionButton,
              isFavorite(strain.id!) && styles.favoriteButton
            ]}
          >
            <MaterialCommunityIcons 
              name={isFavorite(strain.id!) ? "heart" : "heart-outline"} 
              size={22} 
              color={isFavorite(strain.id!) ? '#FFFFFF' : COLORS.text.secondary} 
            />
          </TouchableOpacity>
          
          <TouchableOpacity 
            onPress={() => onCompareToggle(strain)}
            style={[
              styles.actionButton,
              compareList.some(s => s.id === strain.id) && styles.compareButton
            ]}
            disabled={compareList.length >= 3 && !compareList.some(s => s.id === strain.id)}
          >
            <MaterialCommunityIcons 
              name={compareList.some(s => s.id === strain.id) ? "compare" : "compare-horizontal"} 
              size={22} 
              color={compareList.some(s => s.id === strain.id) ? '#FFFFFF' : COLORS.text.secondary} 
            />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    </Animated.View>
  ), [onCompareToggle, onFavoriteToggle, compareList, isFavorite, router]);

  const keyExtractor = useCallback((item: Strain, index: number) => {
    // Use unique combination of id and index if id exists, otherwise use index-based fallback
    return item.id ? `strain-${item.id}-${index}` : `strain-index-${index}`;
  }, []);
  

  if (!strains.length && !isLoading) {
    return (
      <View style={styles.emptyContainer}>
        <MaterialCommunityIcons 
          name="cannabis" 
          size={48} 
          color={COLORS.primary}
          style={{ opacity: 0.5 }}
        />
        <Text style={styles.emptyText}>
          No strains found matching your criteria
        </Text>
      </View>
    );
  }

  return (
    <FlatList
      data={strains}
      renderItem={renderStrainItem}
      keyExtractor={keyExtractor}
      contentContainerStyle={styles.content}
      onEndReached={onEndReached}
      onEndReachedThreshold={0.5}
      showsVerticalScrollIndicator={false}
      // Performance optimizations
      removeClippedSubviews={Platform.OS === 'android'}
      windowSize={5}
      maxToRenderPerBatch={5}
      initialNumToRender={8}  // Limit initial render batch
      updateCellsBatchingPeriod={50}  // Group cell updates to optimize performance
      // Add key tracking for debugging
      maintainVisibleContentPosition={{
        minIndexForVisible: 0,
      }}
    />
  );
  
});

const styles = StyleSheet.create({
  content: {
    paddingBottom: 80, // Space for the compare bar
  },
  strainItemContainer: {
    marginBottom: 16,
    borderRadius: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
  },
  strainItem: {
    backgroundColor: 'rgba(26, 32, 28, 0.95)',
    borderRadius: 16,
    overflow: 'hidden',
    flexDirection: 'row',
    padding: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.15)',
  },
  strainContent: {
    flex: 1,
  },
  strainHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  strainName: {
    fontSize: 18,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
    flex: 1,
    marginRight: 8,
  },
  ratingBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  ratingText: {
    color: '#FFFFFF',
    fontWeight: '700',
    fontSize: 16,
  },
  typeBadge: {
    alignSelf: 'flex-start',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 8,
    marginBottom: 10,
  },
  typeBadgeText: {
    fontSize: 13,
    color: COLORS.text.primary,
    fontWeight: '500',
  },
  strainDescription: {
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
    marginBottom: 12,
  },
  effectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  effectBadge: {
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
  },
  effectText: {
    fontSize: 12,
    color: COLORS.text.secondary,
  },
  actionButtons: {
    marginLeft: 16,
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  actionButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    marginVertical: 6,
  },
  favoriteButton: {
    backgroundColor: 'rgba(255, 82, 82, 0.8)',
  },
  compareButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.8)',
  },
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(26, 32, 28, 0.5)',
    padding: 40,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    marginVertical: 30,
  },
  emptyText: {
    fontSize: 16,
    color: COLORS.text.primary,
    textAlign: 'center',
    marginTop: 16,
    opacity: 0.8,
  },
});

export default StrainsList;

================================================================================
File: app/mydata/_layout.tsx
================================================================================

import { Stack } from 'expo-router';

export default function MyDataLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="daily-average" 
        options={{ 
          title: "Daily Average",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="weekly-average" 
        options={{ 
          title: "Weekly Average",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="weekly-overview" 
        options={{ 
          title: "Weekly Overview",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="monthly-overview" 
        options={{ 
          title: "Monthly Overview",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
    </Stack>
  );
}

================================================================================
File: app/mydata/daily-average.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { COLORS } from '../../src/constants';

export default function DailyAverageOverview() {
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Daily Average Overview
      </Text>
    </View>
  );
}

================================================================================
File: app/mydata/monthly-overview.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { COLORS } from '../../src/constants';

export default function MonthlyOverview() {
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Monthly Overview
      </Text>
    </View>
  );
}

================================================================================
File: app/mydata/weekly-average.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { COLORS } from '../../src/constants';

export default function WeeklyAverage() {
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Weekly Average
      </Text>
    </View>
  );
}

================================================================================
File: app/mydata/weekly-overview.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { COLORS } from '../../src/constants';
import { useDataService } from '../../src/hooks/useDataService';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';
import BarChart from '../components/charts/BarChart';

export default function WeeklyOverview() {
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Weekly Overview
      </Text>
    </View>
  );
}

================================================================================
File: app/strains/_layout.tsx
================================================================================

import { Stack } from 'expo-router';

export default function StrainsLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="popular" 
        options={{ 
          title: "Popular Strains",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="details" 
        options={{ 
          title: "Strain Details",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="compare" 
        options={{ 
          title: "Compare Strains",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
    </Stack>
  );
}

================================================================================
File: app/strains/compare.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../src/constants';
import { Strain } from '../../src/dbManager';
import StrainService from '../../src/services/StrainService';

export default function CompareStrains() {
  const { ids } = useLocalSearchParams();
  const strainIds = typeof ids === 'string' ? ids.split(',') : [];
  
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Compare Strains
      </Text>
      <Text style={{ color: COLORS.text.secondary, marginTop: 8 }}>
        Comparing IDs: {strainIds.join(', ')}
      </Text>
    </View>
  );
}

================================================================================
File: app/strains/details.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { Redirect, useLocalSearchParams } from 'expo-router';
import { COLORS } from '@/src/constants';

export default function StrainDetailsRedirect() {
  const { id } = useLocalSearchParams();
  return <Redirect href={`/dataOverviews/strains/strainDetails?id=${id}`} />;
}

================================================================================
File: app/strains/popular.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList,
  TouchableOpacity,
  Platform 
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { COLORS } from '../../src/constants';
import { Strain } from '../../src/dbManager';
import StrainService from '../../src/services/StrainService';

// Define strain type
interface Strain {
  id: string;
  name: string;
  description: string;
  thcContent?: string;
  type: 'sativa' | 'indica' | 'hybrid';
}

// Sample data
const strains: Strain[] = [
  { 
    id: '1', 
    name: 'Blue Dream', 
    description: 'Hybrid strain with sweet berry aroma',
    thcContent: '18-24%',
    type: 'hybrid'
  },
  { 
    id: '2', 
    name: 'OG Kush', 
    description: 'Classic strain with earthy pine scent',
    thcContent: '20-25%',
    type: 'hybrid'
  },
  { 
    id: '3', 
    name: 'Gorilla Glue', 
    description: 'Powerful hybrid with diesel notes',
    thcContent: '25-28%',
    type: 'hybrid'
  },
  { 
    id: '4', 
    name: 'Gelato', 
    description: 'Sweet and creamy hybrid strain',
    thcContent: '17-22%',
    type: 'hybrid'
  },
  { 
    id: '5', 
    name: 'Sour Diesel', 
    description: 'Energetic sativa with diesel aroma',
    thcContent: '19-25%',
    type: 'sativa'
  }
];

const PopularStrains = () => {
  const router = useRouter();

  const renderItem = ({ item }: { item: Strain }) => (
    <TouchableOpacity 
      style={styles.strainItem}
      onPress={() => router.push(`/strains/${item.id}`)}
    >
      <View style={styles.iconContainer}>
        <MaterialCommunityIcons name="cannabis" size={24} color="#fff" />
      </View>
      <View style={styles.textContainer}>
        <Text style={styles.strainName}>{item.name}</Text>
        <Text style={styles.strainDescription}>{item.description}</Text>
        {item.thcContent && (
          <Text style={styles.thcContent}>THC: {item.thcContent}</Text>
        )}
      </View>
      <MaterialCommunityIcons 
        name="chevron-right" 
        size={24} 
        color={colors.label.secondary} 
      />
    </TouchableOpacity>
  );

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <MaterialCommunityIcons 
            name="chevron-left" 
            size={28} 
            color={colors.label.primary} 
          />
        </TouchableOpacity>
        <Text style={styles.headerText}>Popular Strains</Text>
      </View>
      <FlatList
        data={strains}
        renderItem={renderItem}
        keyExtractor={item => item.id}
        contentContainerStyle={styles.listContainer}
        showsVerticalScrollIndicator={false}
      />
    </SafeAreaView>
  );
};

const colors = {
  label: {
    primary: "#FFFFFF",
    secondary: "#8E8E93",
    tertiary: "#636366",
  },
  background: {
    primary: "#000000",
    secondary: "#1C1C1E",
    tertiary: "#2C2C2E",
  }
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background.primary,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    paddingTop: 8,
    borderBottomWidth: 1,
    borderBottomColor: colors.background.secondary,
  },
  backButton: {
    marginRight: 8,
    padding: 4,
  },
  headerText: {
    fontSize: 24,
    fontWeight: Platform.select({ ios: '600', android: 'bold' }),
    color: colors.label.primary,
  },
  listContainer: {
    padding: 16,
  },
  strainItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    backgroundColor: colors.background.secondary,
    borderRadius: 12,
    marginBottom: 12,
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: colors.background.tertiary,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  textContainer: {
    flex: 1,
  },
  strainName: {
    fontSize: 17,
    fontWeight: Platform.select({ ios: '600', android: 'bold' }),
    color: colors.label.primary,
    marginBottom: 4,
  },
  strainDescription: {
    fontSize: 14,
    color: colors.label.secondary,
    marginBottom: 4,
  },
  thcContent: {
    fontSize: 12,
    color: colors.label.tertiary,
    fontWeight: '500',
  },
});

export default PopularStrains; 

================================================================================
File: components/charts/WeeklyOverviewChart.tsx
================================================================================

import { Card } from "@/components/Card";
import { StyleSheet, View, Text, Dimensions } from "react-native";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { BarChart } from "react-native-chart-kit";
import { LinearGradient } from "expo-linear-gradient";
import { Datapoint } from "@/src/types";
import { useMemo } from "react";

// Keep COLORS here for now, we'll move it to constants later
const COLORS = {
  background: '#000000',
  cardBackground: '#1A1A1A',
  primary: '#00E676',       // Neon green 
  primaryLight: '#69F0AE',  // Light neon green
  primaryDark: '#00C853',   // Darker green
  text: {
    primary: '#FFFFFF',
    secondary: '#FFFFFFCC',  // 80% white
    tertiary: '#FFFFFF99',   // 60% white
  },
  chart: {
    primary: '#00E676',
    secondary: '#69F0AE',
    background: '#1A1A1A',
  },
  gradientColors: {
    start: 'rgba(0,230,118,0.4)',
    middle: 'rgba(105,240,174,0.2)',
    end: 'rgba(0,0,0,0)',
  }
};

const windowWidth = Dimensions.get("window").width;

interface WeeklyOverviewChartProps {
  data: Datapoint[];
  onPress?: () => void;
}

export function WeeklyOverviewChart({ data }: WeeklyOverviewChartProps) {
  // Memoize the chart width calculation
  const chartWidth = useMemo(() => Math.max(windowWidth - 64, 200), [windowWidth]);

  // Base chart config with optimizations
  const baseChartConfig = useMemo(() => ({
    backgroundColor: COLORS.chart.background,
    backgroundGradientFrom: COLORS.chart.background,
    backgroundGradientTo: COLORS.chart.background,
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
    labelColor: (opacity = 0.8) => `rgba(255, 255, 255, ${opacity})`,
    barPercentage: 0.7,
    useShadowColorFromDataset: false,
    withInnerLines: false,
    withVerticalLabels: true,
    withHorizontalLabels: true,
    withVerticalLines: false,
    withHorizontalLines: true,
    propsForBackgroundLines: {
      stroke: COLORS.text.tertiary,
      strokeWidth: 1,
    },
    propsForDots: {
      r: "4",
      strokeWidth: "2",
      stroke: COLORS.primaryLight,
    },
    style: {
      borderRadius: 16,
    },
    formatYLabel: (value: string) => Math.round(Number(value)).toString(),
    formatXLabel: (label: string) => label.substring(0, 3),
    segments: 4,
  }), []);

  // Memoize the data transformation
  const chartData = useMemo(() => ({
    labels: data.map((d) => d.label),
    datasets: [{ 
      data: data.map((d) => d.value),
      color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
      strokeWidth: 2,
    }]
  }), [data]);

  if (!data?.length) {
    return (
      <Card style={styles.card}>
        <View style={styles.cardHeader}>
          <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
          <Text style={styles.cardTitle}>Weekly Overview</Text>
        </View>
        <View style={styles.chartContainer}>
          <Text style={styles.noDataText}>No data available</Text>
        </View>
      </Card>
    );
  }

  return (
    <Card style={styles.card}>
      <View style={styles.cardHeader}>
        <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
        <Text style={styles.cardTitle}>Weekly Overview</Text>
      </View>
      <Text style={styles.cardDescription}>Compare your usage across different days</Text>
      <View style={styles.chartContainer}>
        <LinearGradient
          colors={[
            COLORS.gradientColors.start,
            COLORS.gradientColors.middle,
            COLORS.gradientColors.end
          ]}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
          style={styles.chartGradient}
        />
        <BarChart
          data={chartData}
          width={chartWidth}
          height={180}
          chartConfig={baseChartConfig}
          style={styles.chart}
          showValuesOnTopOfBars
          fromZero
          segments={4}
          flatColor={true}
          withCustomBarColorFromData={true}
        />
      </View>
    </Card>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#1A1A1A',
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 16,
    padding: 16,
    shadowColor: '#00E676',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  cardTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 10,
  },
  cardDescription: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 16,
    lineHeight: 20,
  },
  chartContainer: {
    marginTop: 16,
    alignItems: "center",
    paddingHorizontal: 8,
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 4,
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
    backgroundColor: COLORS.cardBackground,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 6,
  },
  chartGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 16,
  },
  noDataText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    padding: 20,
  }
}); 

================================================================================
File: components/Leaderboard.tsx
================================================================================

import React from 'react';
import { View, Text, FlatList, StyleSheet } from 'react-native';

interface LeaderboardEntry {
  id: string;
  name: string;
  score: number;
}

interface LeaderboardProps {
  data: LeaderboardEntry[];
  title: string;
}

const Leaderboard: React.FC<LeaderboardProps> = ({ title, data }) => {
  const renderItem = ({ item, index }: { item: LeaderboardEntry; index: number }) => (
    <View style={[styles.row, index === 0 ? styles.topRank : {}]}>
      <Text style={styles.rank}>{index + 1}</Text>
      <Text style={styles.name}>{item.name}</Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
      <FlatList
        data={data.sort((a, b) => b.score - a.score)} // Sort by score in descending order
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        ListEmptyComponent={<Text style={styles.empty}>No entries yet!</Text>}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 16,
    color: '#333',
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    marginVertical: 4,
    backgroundColor: '#fff',
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  topRank: {
    backgroundColor: '#ffd700', // Gold for top rank
  },
  rank: {
    fontSize: 18,
    fontWeight: 'bold',
    width: 40,
    textAlign: 'center',
  },
  name: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginLeft: 8,
  },
  score: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#12a35f',
  },
  empty: {
    textAlign: 'center',
    fontSize: 16,
    color: '#aaa',
    marginTop: 20,
  },
});

export default Leaderboard;

================================================================================
File: package.json
================================================================================

{
  "name": "canovareactnativeapp",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.37.0",
    "@expo/vector-icons": "^14.0.4",
    "@react-native-async-storage/async-storage": "^1.23.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "expo": "~52.0.23",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.3",
    "expo-dev-client": "~5.0.8",
    "expo-device": "^7.0.2",
    "expo-font": "~13.0.2",
    "expo-haptics": "~14.0.0",
    "expo-linear-gradient": "~14.0.2",
    "expo-linking": "~7.0.3",
    "expo-router": "~4.0.15",
    "expo-splash-screen": "^0.29.22",
    "expo-sqlite": "~15.1.2",
    "expo-status-bar": "~2.0.0",
    "expo-symbols": "~0.2.0",
    "expo-system-ui": "~4.0.6",
    "expo-web-browser": "~14.0.1",
    "install": "^0.13.0",
    "lucide-react": "^0.475.0",
    "papaparse": "^5.5.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-native": "^0.76.5",
    "react-native-base64": "^0.2.1",
    "react-native-ble-plx": "^3.5.0",
    "react-native-calendars": "^1.1310.0",
    "react-native-chart-kit": "^6.12.0",
    "react-native-dotenv": "^3.4.11",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "^15.11.2",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5"
  },
  "devDependencies": {
    "@babel/core": "^7.26.9",
    "@react-native-community/cli": "^15.1.3",
    "@types/jest": "^29.5.14",
    "@types/react": "~18.3.12",
    "@types/react-native-base64": "^0.2.2",
    "@types/react-test-renderer": "^18.3.1",
    "jest": "^29.7.0",
    "jest-expo": "~52.0.2",
    "react-test-renderer": "^18.3.1",
    "typescript": "^5.7.3"
  },
  "private": true
}


================================================================================
File: src/constants.ts
================================================================================

export const BONG_HITS_DATABASE_NAME: string = "BongHits";
export const SAVED_DEVICES_DATABASE_NAME: string = "SavedDevices";
export const STRAINS_DATABASE_NAME: string = "Strains";

export const dayLookUpTable = new Map<number, string>()
dayLookUpTable.set(0, "Sun");
dayLookUpTable.set(1, "Mon");
dayLookUpTable.set(2, "Tue");
dayLookUpTable.set(3, "Wed");
dayLookUpTable.set(4, "Thu");
dayLookUpTable.set(5, "Fri");
dayLookUpTable.set(6, "Sat");

// Function to generate strain insert statements
export function getStrainInsertStatements(): string {
  return '';  // Empty implementation for now
}

export const COLORS = {
  background: '#000000',
  cardBackground: '#1A1A1A',
  primary: '#00E676',       // Neon green 
  primaryLight: '#69F0AE',  // Light neon green
  primaryDark: '#00C853',   // Darker green
  text: {
    primary: '#FFFFFF',
    secondary: '#FFFFFFCC',  // 80% white
    tertiary: '#FFFFFF99',   // 60% white
  },
  chart: {
    primary: '#00E676',
    secondary: '#69F0AE',
    background: '#1A1A1A',
  },
  gradientColors: {
    start: 'rgba(0,230,118,0.4)',
    middle: 'rgba(105,240,174,0.2)',
    end: 'rgba(0,0,0,0)',
  }
};

/**
 * Stupid goofy hardcoded function for testing
 * https://www.mockaroo.com/
 * @returns 
 */
export function getInsertStatements(): string {
    return(`
insert into BongHits (timestamp, duration_ms) values ('2024-12-26 18:28:33', 27050);
insert into BongHits (timestamp, duration_ms) values ('2025-01-03 03:31:57', 12228);
insert into BongHits (timestamp, duration_ms) values ('2024-12-30 23:51:43', 13319);
insert into BongHits (timestamp, duration_ms) values ('2024-12-28 17:23:17', 18857);

insert into BongHits (timestamp, duration_ms) values ('2024-12-28 15:13:36', 10003);
`)
}




export const SAMPLE_STRAINS = [
  
  {
    name: "Jillybean",
    overview: "Hybrid strain known for its fruity, floral flavor and uplifting, creative effects.",
    genetic_type: "Hybrid",
    lineage: "Unknown (landrace blend)",
    thc_range: "15-20%",
    cbd_level: "Low",
    dominant_terpenes: "Limonene, Caryophyllene",
    qualitative_insights: "Fruity, floral aroma with a sweet finish; light buds",
    effects: "Uplifted, Euphoric, Creative",
    negatives: "dry mouth, dry eyes",
    uses: "Great for daytime use and creative inspiration",
    thc_rating: 6.25,
    user_rating: 6,
    combined_rating: 6.13
  },
  {
    name: "Strawberry Banana",
    overview: "Hybrid strain combining sweet strawberry and banana flavors with a balanced high.",
    genetic_type: "Hybrid",
    lineage: "Unknown (blend)",
    thc_range: "18-26%",
    cbd_level: "Low",
    dominant_terpenes: "Limonene, Myrcene",
    qualitative_insights: "Sweet, tropical aroma with a creamy finish; resinous buds",
    effects: "Happy, Relaxed, Euphoric",
    negatives: "dry mouth, dizziness",
    uses: "Ideal for mood elevation and relaxation",
    thc_rating: 8.5,
    user_rating: 8.25,
    combined_rating: 8.38
  },
  {
    name: "Tropicana Cookies",
    overview: "Sativa-dominant hybrid delivering a burst of citrus and cookie flavors with an energetic high.",
    genetic_type: "Sativa-dominant Hybrid",
    lineage: "Cookie genetics x Tangie",
    thc_range: "20-28%",
    cbd_level: "Low",
    dominant_terpenes: "Limonene, Caryophyllene",
    qualitative_insights: "Zesty citrus aroma with a sweet, baked undertone; frosty buds",
    effects: "Energized, Uplifted, Creative",
    negatives: "dry mouth, dry eyes",
    uses: "Perfect for daytime creativity and social events",
    thc_rating: 9.5,
    user_rating: 9,
    combined_rating: 9.25
  },
  {
    name: "UK Cheese",
    overview: "Indica-dominant variant of Cheese known for its pungent aroma and relaxing, euphoric effects.",
    genetic_type: "Indica-dominant Hybrid",
    lineage: "UK Landrace",
    thc_range: "15-20%",
    cbd_level: "Low",
    dominant_terpenes: "Caryophyllene, Myrcene",
    qualitative_insights: "Strong cheesy odor with herbal undertones; sticky buds",
    effects: "Relaxed, Euphoric, Happy",
    negatives: "dry mouth, dry eyes",
    uses: "Great for stress relief and relaxation",
    thc_rating: 6.25,
    user_rating: 6,
    combined_rating: 6.13
  },
  
];

================================================================================
File: src/contexts/BluetoothContext.ts
================================================================================

import { createContext, useContext } from "react";
import { PermissionsAndroid, Platform } from "react-native";
import * as ExpoDevice from "expo-device";
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';

type ConnectedDevice = {
    device: Device;
    serviceUUID: string;
    characteristicUUID: string
}

export class BluetoothHandler {
    private manager: BleManager;
    private connectedDevice: ConnectedDevice | null;

    constructor() {
        this.manager = new BleManager();
        this.connectedDevice = null;
    }

    public async connectToDevice(device: Device) {
        if (this.connectedDevice !== null) {
            // TODO: decide how to handle new connection when device is already connected
            return;
        }
        try {
            const deviceConnection: Device = await this.manager.connectToDevice(device.id);
            await deviceConnection.discoverAllServicesAndCharacteristics();
            const services = await deviceConnection.services();
            if (services.length !== 1) {
                throw Error("Bad number of services");
            }

            const service = services[0];
            const characteristics = await service.characteristics();
            if (characteristics.length !== 1) {
                throw Error("Bad number of characteristics");
            }
            const characteristic = characteristics[0];
            this.connectedDevice = {
                device: deviceConnection,
                serviceUUID: service.uuid,
                characteristicUUID: characteristic.uuid
            }

        } catch (error) {
            console.error('Error discovering services/characteristics:', error);
        } finally {
            this.manager.stopDeviceScan();
        }
    }

    public disconnectFromDevice(connectedDevice: Device) {
        if (connectedDevice) {
            this.manager.cancelDeviceConnection(connectedDevice.id);
          }
    }

    public streamOnConnectedDevice(streamListener: (error: BleError | null, characteristic: Characteristic | null) => void) {
        if (this.connectedDevice === null) {
            throw Error("Tried to stream with no device connected");
        } 
        this.connectedDevice.device.monitorCharacteristicForService(
            this.connectedDevice.serviceUUID,
            this.connectedDevice.characteristicUUID,
            streamListener
          );
    }

    public getBLEManager(): BleManager {
        return this.manager;
    }

    public getConnectedDevice(): Device | undefined {
        return this.connectedDevice?.device;
    }

    public getSavedDevices(): Device[] {
        // TODO query database
        return [];
    }

    /*
     * Requests bluetooth permissions, accounting for platform differences
     */
    private async requestPermissions() {
        if (Platform.OS === "android") {
            if ((ExpoDevice.platformApiLevel ?? -1) < 31) {
                // Android version below 31
                const granted = await PermissionsAndroid.request(
                    PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
                    {
                        title: "Location Permission",
                        message: "Bluetooth Low Energy requires Location",
                        buttonPositive: "OK",
                    }
                );
                return granted === PermissionsAndroid.RESULTS.GRANTED;
            } else {
                // Android version above 31
                const isAndroid31PermissionsGranted = await this.requestAndroid31Permissions();

                return isAndroid31PermissionsGranted;
            }
        } else {
            //ios
            return true;
        }
    }

    private async requestAndroid31Permissions() {
        const bluetoothScanPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_SCAN,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );
        const bluetoothConnectPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_CONNECT,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );
        const fineLocationPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );

        return (
            bluetoothScanPermission === "granted" &&
            bluetoothConnectPermission === "granted" &&
            fineLocationPermission === "granted"
        );
    }
}

export const BluetoothContext = createContext<BluetoothHandler | undefined>(undefined);


================================================================================
File: src/dbManager.ts
================================================================================

// File: src/dbManager.ts

import AsyncStorage from "@react-native-async-storage/async-storage";
import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import {
  BONG_HITS_DATABASE_NAME,
  SAVED_DEVICES_DATABASE_NAME,
  STRAINS_DATABASE_NAME,
  getInsertStatements,
  getStrainInsertStatements,
  SAMPLE_STRAINS
} from "./constants";
import { BongHitStats, Datapoint, AverageHourCount } from "./types";

const FIRST_LAUNCH_KEY = "hasLaunched";

export interface Strain {
  id?: number;
  name: string;
  overview: string;
  genetic_type: string;
  lineage: string;
  thc_range: string;
  cbd_level: string;
  dominant_terpenes: string;
  qualitative_insights: string;
  effects: string;
  negatives: string;
  uses: string;
  thc_rating: number;
  user_rating: number;
  combined_rating: number;
  created_at?: string;
}

/**
 * Checks if the application is launching for the first time.
 */
export async function isFirstLaunch(): Promise<boolean> {
  try {
    return (await AsyncStorage.getItem(FIRST_LAUNCH_KEY)) === null;
  } catch (error) {
    console.error('[dbManager] Error checking first launch:', error);
    return false;
  }
}

/**
 * Called on first launch to run any initial setup (e.g. DB creation).
 */
export async function initializeAppOnFirstLaunch() {
  try {
    await AsyncStorage.setItem(FIRST_LAUNCH_KEY, "true");
    await initializeDatabase();
  } catch (error) {
    console.error('[dbManager] Error initializing app:', error);
    throw error;
  }
}

/**
 * Initializes all databases and tables with initial data.
 */
async function initializeDatabase(): Promise<void> {
  try {
    console.log('[dbManager] Starting database initialization...');

    // Initialize BongHits database
    const bongHitsDb = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    await bongHitsDb.execAsync(
      'PRAGMA journal_mode = WAL;' +
      `CREATE TABLE IF NOT EXISTS ${BONG_HITS_DATABASE_NAME} (
        timestamp TIMESTAMP PRIMARY KEY NOT NULL,
        duration_ms INTEGER NOT NULL
      );` +
      `CREATE INDEX IF NOT EXISTS idx_timestamp 
      ON ${BONG_HITS_DATABASE_NAME}(timestamp);` +
      getInsertStatements()
    );
    console.log('[dbManager] BongHits database initialized');

    // Initialize SavedDevices database
    const savedDevicesDb = await openDatabaseAsync(SAVED_DEVICES_DATABASE_NAME);
    await savedDevicesDb.execAsync(
      'PRAGMA journal_mode = WAL;' +
      `CREATE TABLE IF NOT EXISTS ${SAVED_DEVICES_DATABASE_NAME} (
        uuid TEXT PRIMARY KEY NOT NULL,
        name TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );` +
      `CREATE INDEX IF NOT EXISTS idx_device_name 
      ON ${SAVED_DEVICES_DATABASE_NAME}(name);`
    );
    console.log('[dbManager] SavedDevices database initialized');

    // Initialize Strains database
    const strainsDb = await openDatabaseAsync(STRAINS_DATABASE_NAME);
    await strainsDb.execAsync(
      'PRAGMA journal_mode = WAL;' +
      `CREATE TABLE IF NOT EXISTS ${STRAINS_DATABASE_NAME} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        overview TEXT,
        genetic_type TEXT,
        lineage TEXT,
        thc_range TEXT,
        cbd_level TEXT,
        dominant_terpenes TEXT,
        qualitative_insights TEXT,
        effects TEXT,
        negatives TEXT,
        uses TEXT,
        thc_rating REAL,
        user_rating REAL,
        combined_rating REAL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );` +
      `CREATE INDEX IF NOT EXISTS idx_strain_name 
      ON ${STRAINS_DATABASE_NAME}(name);` +
      `CREATE INDEX IF NOT EXISTS idx_strain_genetic_type 
      ON ${STRAINS_DATABASE_NAME}(genetic_type);` +
      `CREATE INDEX IF NOT EXISTS idx_strain_effects 
      ON ${STRAINS_DATABASE_NAME}(effects);` +
      `CREATE INDEX IF NOT EXISTS idx_strain_rating 
      ON ${STRAINS_DATABASE_NAME}(combined_rating DESC);`
    );

    // Insert sample strain data
    await insertStrainData(strainsDb);
    console.log('[dbManager] Strains database initialized');

    console.log('[dbManager] All databases initialized successfully');
  } catch (error) {
    console.error('[dbManager] Error initializing databases:', error);
    throw error;
  }
}

/**
 * Inserts sample strain data into the database
 */
async function insertStrainData(db: SQLiteDatabase): Promise<void> {
  try {
    console.log('[dbManager] Starting strain data insertion...');
    
    // Insert strains in batches for better performance
    const batchSize = 50;
    for (let i = 0; i < SAMPLE_STRAINS.length; i += batchSize) {
      const batch = SAMPLE_STRAINS.slice(i, i + batchSize);
      
      const placeholders = batch.map(() => 
        '(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
      ).join(',');

      const values = batch.flatMap((strain: Strain) => [
        strain.name,
        strain.overview,
        strain.genetic_type,
        strain.lineage,
        strain.thc_range,
        strain.cbd_level,
        strain.dominant_terpenes,
        strain.qualitative_insights,
        strain.effects,
        strain.negatives,
        strain.uses,
        strain.thc_rating,
        strain.user_rating,
        strain.combined_rating
      ]);

      await db.execAsync(
        `INSERT OR IGNORE INTO ${STRAINS_DATABASE_NAME} (
          name, overview, genetic_type, lineage, thc_range,
          cbd_level, dominant_terpenes, qualitative_insights,
          effects, negatives, uses, thc_rating,
          user_rating, combined_rating
        ) VALUES ${placeholders}`,
        values
      );
    }

    console.log('[dbManager] Strain data insertion completed');
  } catch (error) {
    console.error('[dbManager] Error inserting strain data:', error);
    throw error;
  }
}

/* ------------------------------------------------------------------
   Helpers to validate results before returning them
 ------------------------------------------------------------------ */

const validateBongHitStats = (stats: BongHitStats): BongHitStats => ({
  averageDuration: Math.max(0, Number(stats.averageDuration) || 0),
  longestHit: Math.max(0, Number(stats.longestHit) || 0),
});

const validateDatapoint = (point: Datapoint): Datapoint => ({
  label: String(point.label || ""),
  value: Math.max(0, Number(point.value) || 0),
});

const validateAverageHourCount = (count: AverageHourCount): AverageHourCount => ({
  hourOfDay: String(count.hourOfDay || "00"),
  count: Math.max(0, Number(count.count) || 0),
});

/* ------------------------------------------------------------------
   Data-Fetching / Query Functions
   (Now using execAsync, parse the result sets)
 ------------------------------------------------------------------ */

/**
 * Retrieves average and max duration over the past 7 days.
 */
export async function getBongHitStatsFromPastWeek(): Promise<BongHitStats> {
  try {
    const db: SQLiteDatabase = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    const results = await db.execAsync(`
      SELECT
        AVG(duration_ms) AS avg_duration,
        MAX(duration_ms) AS max_duration
      FROM ${BONG_HITS_DATABASE_NAME}
      WHERE timestamp >= DATETIME('now', '-7 days')
    `);

    // execAsync returns an array of result sets; we only have one query
    const row = results[0]?.rows?._array[0];
    if (!row) {
      // Fallback if no data
      return validateBongHitStats({ averageDuration: 0, longestHit: 0 });
    }

    return validateBongHitStats({
      averageDuration: row.avg_duration,
      longestHit: row.max_duration,
    });
  } catch (error) {
    console.error("Error in getBongHitStatsFromPastWeek:", error);
    throw error;
  }
}

/**
 * Counts hits per day over the past week (filling day indices 0..6).
 */
export async function queryNumberOfHitsFromPastWeek(): Promise<Datapoint[]> {
  try {
    const db: SQLiteDatabase = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    const results = await db.execAsync(`
      SELECT 
        strftime('%w', timestamp) AS day,
        COUNT(*) AS hit_count
      FROM ${BONG_HITS_DATABASE_NAME}
      WHERE timestamp >= '2024-12-24'
      GROUP BY day
      ORDER BY day;
    `);

    const rows = results[0]?.rows?._array || [];
    console.log("Weekly query results:", rows);

    // Prepare an array for Sunday..Saturday
    const weekData: Datapoint[] = Array.from({ length: 7 }, (_, i) => ({
      label: dayLookUpTable.get(i) || "",
      value: 0,
    }));

    rows.forEach((row: any) => {
      const dayIndex = parseInt(row.day, 10);
      if (dayIndex >= 0 && dayIndex < 7) {
        weekData[dayIndex] = validateDatapoint({
          label: dayLookUpTable.get(dayIndex) || "",
          value: row.hit_count,
        });
      }
    });

    return weekData;
  } catch (error) {
    console.error("Error in queryNumberOfHitsFromPastWeek:", error);
    throw error;
  }
}

/**
 * Returns a list of (hourOfDay -> # of hits) since 2024-12-24,
 * filling missing hours with 0.
 */
export async function getDailyAverageDatapoints(): Promise<AverageHourCount[]> {
  try {
    const db: SQLiteDatabase = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    const results = await db.execAsync(`
      SELECT 
        strftime('%H', timestamp) AS hourOfDay,
        COUNT(*) AS count
      FROM ${BONG_HITS_DATABASE_NAME}
      WHERE timestamp >= '2024-12-24'
      GROUP BY hourOfDay
      ORDER BY hourOfDay
    `);

    const rows = results[0]?.rows?._array || [];
    // Hours "00" through "23"
    const allHours = Array.from({ length: 24 }, (_, i) => i.toString().padStart(2, "0"));
    const dataMap = new Map<string, number>(
      rows.map((item: any) => [item.hourOfDay, item.count])
    );

    return allHours.map((hour) =>
      validateAverageHourCount({
        hourOfDay: hour,
        count: dataMap.get(hour) || 0,
      })
    );
  } catch (error) {
    console.error("Error in getDailyAverageDatapoints:", error);
    throw error;
  }
}

/**
 * Generic function to get data based on a time range (D=Day, W=Week, M=Month).
 * Returns both chartData and some aggregated stats.
 */
export async function getDailyStats(timeRange: string) {
  let query = "";

  switch (timeRange) {
    case "D":
      query = `
        SELECT strftime('%H', timestamp) as label,
               COUNT(*) as value,
               AVG(duration_ms) as avg_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE date(timestamp) = date('now')
        GROUP BY label
        ORDER BY label
      `;
      break;
    case "W":
      query = `
        SELECT strftime('%w', timestamp) as label,
               COUNT(*) as value,
               AVG(duration_ms) as avg_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= date('now', '-7 days')
        GROUP BY label
        ORDER BY label
      `;
      break;
    case "M":
      query = `
        SELECT strftime('%d', timestamp) as label,
               COUNT(*) as value,
               AVG(duration_ms) as avg_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= date('now', '-30 days')
        GROUP BY label
        ORDER BY label
      `;
      break;
    default:
      // fallback same as 'D'
      query = `
        SELECT strftime('%H', timestamp) as label,
               COUNT(*) as value,
               AVG(duration_ms) as avg_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE date(timestamp) = date('now')
        GROUP BY label
        ORDER BY label
      `;
  }

  try {
    const db: SQLiteDatabase = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);
    const results = await db.execAsync(query);
    const rows = results[0]?.rows?._array || [];

    // Build chart data
    const chartData = {
      labels: rows.map((r: any) => `${r.label}h`),
      datasets: [
        {
          data: rows.map((r: any) => r.value),
          color: (opacity = 1) => `rgba(0, 122, 255, ${opacity})`,
          strokeWidth: 2,
        },
      ],
      legend: ["Hits"],
    };

    // Build aggregated stats
    // If no rows, handle safely
    if (!rows.length) {
      return {
        chartData,
        stats: {
          avgDuration: 0,
          totalHits: 0,
          peakHour: null,
        },
      };
    }

    const avgDuration =
      rows.reduce((acc: number, curr: any) => acc + curr.avg_duration, 0) /
      rows.length;
    const totalHits = rows.reduce((acc: number, curr: any) => acc + curr.value, 0);
    const peak = rows.reduce((a: any, b: any) => (a.value > b.value ? a : b));
    const peakHour = peak.label;

    return {
      chartData,
      stats: {
        avgDuration,
        totalHits,
        peakHour,
      },
    };
  } catch (error) {
    console.error("Error in getDailyStats:", error);
    throw error;
  }
}

// Export query functions


================================================================================
File: src/hooks/useAIRecommendations.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { AIService } from '../services/ai';
import { ChatRequest } from '../services/ai/types/requests';
import SafetyService from '../services/SafetyService';
import { 
  RecommendationRequest, 
  RecommendationResponse, 
  ChatMessage, 
  UserProfile,
  JournalEntry,
  SafetyValidationResult
} from '../types/ai';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Cache keys
const RECOMMENDATIONS_CACHE_KEY = 'ai_recommendations_cache';
const RECOMMENDATIONS_CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

export const useAIRecommendations = () => {
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [recommendations, setRecommendations] = useState<RecommendationResponse | null>(null);
  const [safetyValidation, setSafetyValidation] = useState<SafetyValidationResult | null>(null);
  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  
  // Get AIService instance
  const aiService = AIService.getInstance();
  
  // Initialize services
  useEffect(() => {
    const initServices = async () => {
      try {
        await aiService.initialize();
        await SafetyService.initialize();
      } catch (err) {
        console.error('Error initializing AI or Safety services:', err);
        setError('Failed to initialize recommendation services');
      }
    };
    
    initServices();
    
    // Load cached recommendations if available
    loadCachedRecommendations();
    
    return () => {
      // Cleanup
      SafetyService.cleanup();
    };
  }, []);
  
  // Load cached recommendations
  const loadCachedRecommendations = async () => {
    try {
      const cachedData = await AsyncStorage.getItem(RECOMMENDATIONS_CACHE_KEY);
      
      if (cachedData) {
        const { recommendations: cachedRecommendations, timestamp } = JSON.parse(cachedData);
        
        // Check if cache is still valid
        if (Date.now() - timestamp < RECOMMENDATIONS_CACHE_EXPIRY) {
          setRecommendations(cachedRecommendations);
        }
      }
    } catch (err) {
      console.warn('Error loading cached recommendations:', err);
      // Non-critical error, don't set error state
    }
  };
  
  // Cache recommendations
  const cacheRecommendations = async (recommendations: RecommendationResponse) => {
    try {
      await AsyncStorage.setItem(
        RECOMMENDATIONS_CACHE_KEY,
        JSON.stringify({
          recommendations,
          timestamp: Date.now()
        })
      );
    } catch (err) {
      console.warn('Error caching recommendations:', err);
      // Non-critical error, don't set error state
    }
  };
  
  // Get strain recommendations with safety checks
  const getRecommendations = useCallback(async (
    request: RecommendationRequest,
    recentEntries: JournalEntry[] = []
  ): Promise<RecommendationResponse | null> => {
    setLoading(true);
    setError(null);
    
    try {
      // Validate request for safety concerns
      const validationResult = await SafetyService.validateRecommendationRequest(request);
      setSafetyValidation(validationResult);
      
      // If request is invalid due to safety concerns, return early
      if (!validationResult.valid) {
        setError(validationResult.reason || 'Request failed safety validation');
        setLoading(false);
        return null;
      }
      
      // Apply any safety modifications to the request
      const safeRequest = validationResult.modifications 
        ? { ...request, ...validationResult.modifications }
        : request;
      
      // Get recommendations from AI service
      const rawRecommendations = await aiService.getRecommendations(safeRequest);
      
      // Process recommendations through safety service
      const safeRecommendations = await SafetyService.processRecommendationResponse(
        rawRecommendations,
        request.userProfile,
        recentEntries
      );
      
      // Update state and cache
      setRecommendations(safeRecommendations);
      cacheRecommendations(safeRecommendations);
      
      setLoading(false);
      return safeRecommendations;
      
    } catch (err) {
      console.error('Error getting recommendations:', err);
      setError('Failed to get recommendations. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [aiService]);
  
  // Get chat response
  const getChatResponse = useCallback(async (
    message: string,
    userProfile: UserProfile
  ): Promise<ChatMessage | null> => {
    setLoading(true);
    setError(null);
    
    try {
      // Add user message to history
      const userMessage: ChatMessage = {
        id: `user_${Date.now()}`,
        content: message,
        role: 'user',
        timestamp: new Date().toISOString()
      };
      
      setChatHistory(prev => [...prev, userMessage]);
      
      // Create chat request - convert ChatMessage to the simplified format expected by AIService
      const chatRequest: ChatRequest = {
        message,
        userProfile,
        // Only include the role and content properties that AIService needs
        previousMessages: chatHistory.length > 0 
          ? chatHistory.map(msg => ({ 
              role: msg.role, 
              content: msg.content 
            })) as any // Use type assertion to bypass the type check
          : undefined
      };
      
      // Get AI response
      const aiResponseData = await aiService.getChatResponse(chatRequest);
      
      // Create chat message from response
      const aiResponseMessage: ChatMessage = {
        id: `assistant_${Date.now()}`,
        content: aiResponseData.response,
        role: 'assistant',
        timestamp: new Date().toISOString()
      };
      
      // Add AI response to history
      setChatHistory(prev => [...prev, aiResponseMessage]);
      
      setLoading(false);
      return aiResponseMessage;
      
    } catch (err) {
      console.error('Error getting chat response:', err);
      setError('Failed to get response. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [chatHistory, aiService]);
  
  // Analyze journal patterns
  const analyzeJournalPatterns = useCallback(async (
    entries: JournalEntry[],
    userProfile: UserProfile
  ) => {
    setLoading(true);
    setError(null);
    
    try {
      const analysis = await aiService.analyzeJournalEntries(userProfile.id, entries);
      setLoading(false);
      return analysis;
      
    } catch (err) {
      console.error('Error analyzing journal patterns:', err);
      setError('Failed to analyze journal entries. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [aiService]);
  
  // Clear chat history
  const clearChatHistory = useCallback(() => {
    setChatHistory([]);
  }, []);
  
  // Get safety history
  const getSafetyHistory = useCallback(async (userId: string) => {
    try {
      return await SafetyService.getSafetyHistory(userId);
    } catch (err) {
      console.error('Error getting safety history:', err);
      return [];
    }
  }, []);
  
  return {
    loading,
    error,
    recommendations,
    safetyValidation,
    chatHistory,
    getRecommendations,
    getChatResponse,
    analyzeJournalPatterns,
    clearChatHistory,
    getSafetyHistory
  };
};

export default useAIRecommendations; 

================================================================================
File: src/hooks/useDataService.ts
================================================================================

import { useState, useEffect } from 'react';
import { DataService } from '@/src/services/DataService';
import { DataState, ChartDataPoint, UsageStats, WeekdayStats } from '@/src/types';

const DEFAULT_STATE: DataState = {
  weeklyData: [],
  monthlyData: [],
  usageStats: {
    averageHitsPerDay: 0,
    totalHits: 0,
    peakDayHits: 0,
    lowestDayHits: 0,
    averageDuration: 0,
    longestHit: 0,
    shortestHit: 0,
    mostActiveHour: 0,
    leastActiveHour: 0,
    totalDuration: 0,
    averageHitsPerHour: 0,
    consistency: 0,
    weekdayStats: {
      weekday: { avg: 0, total: 0 },
      weekend: { avg: 0, total: 0 }
    }
  },
  timeDistribution: {
    morning: 0,
    afternoon: 0,
    evening: 0,
    night: 0
  },
  isLoading: true,
  error: null
};

export function useDataService() {
  const [state, setState] = useState<DataState>(DEFAULT_STATE);

  useEffect(() => {
    let isMounted = true;
    const service = DataService.getInstance();

    const loadData = async () => {
      try {
        // Log for debugging
        console.log('[useDataService] Starting data fetch...');

        // Set initial loading state
        if (!isMounted) return;
        setState(prev => ({ ...prev, isLoading: true, error: null }));

        // Fetch data sequentially to avoid race conditions
        console.log('[useDataService] Fetching weekly stats...');
        const weeklyStats = await service.getWeeklyStats();
        if (!isMounted) return;
        console.log('[useDataService] Weekly stats:', weeklyStats);

        console.log('[useDataService] Fetching monthly stats...');
        const monthlyStats = await service.getMonthlyStats();
        if (!isMounted) return;
        console.log('[useDataService] Monthly stats:', monthlyStats);

        console.log('[useDataService] Fetching usage stats...');
        const usageStats = await service.getUsageStats();
        if (!isMounted) return;
        console.log('[useDataService] Usage stats:', usageStats);

        console.log('[useDataService] Fetching time distribution...');
        const timeDistribution = await service.getTimeDistribution();
        if (!isMounted) return;
        console.log('[useDataService] Time distribution:', timeDistribution);

        // Collect any errors from the responses
        const errors: string[] = [];
        if (!weeklyStats.success) errors.push(`Weekly stats: ${weeklyStats.error}`);
        if (!monthlyStats.success) errors.push(`Monthly stats: ${monthlyStats.error}`);
        if (!usageStats.success) errors.push(`Usage stats: ${usageStats.error}`);
        if (!timeDistribution.success) errors.push(`Time distribution: ${timeDistribution.error}`);

        if (errors.length > 0) {
          const errorMessage = errors.join('; ');
          console.error('[useDataService] Data fetch errors:', errorMessage);
          if (isMounted) {
            setState(prev => ({
              ...prev,
              isLoading: false,
              error: errorMessage
            }));
          }
          return;
        }

        // Update state only if all requests succeeded and component is mounted
        console.log('[useDataService] All data fetched successfully, updating state...');
        if (isMounted) {
          setState({
            ...DEFAULT_STATE,
            weeklyData: weeklyStats.data!,
            monthlyData: monthlyStats.data!,
            usageStats: {
              ...DEFAULT_STATE.usageStats,
              ...usageStats.data!
            },
            timeDistribution: timeDistribution.data!,
            isLoading: false,
            error: null
          });
        }
      } catch (error) {
        console.error('[useDataService] Unexpected error in loadData:', error);
        if (isMounted) {
          setState(prev => ({
            ...prev,
            isLoading: false,
            error: error instanceof Error ? error.message : 'An unexpected error occurred while fetching data'
          }));
        }
      }
    };

    loadData();

    return () => {
      console.log('[useDataService] Cleaning up...');
      isMounted = false;
      service.cleanup().catch(error => {
        console.error('[useDataService] Error during cleanup:', error);
      });
    };
  }, []); // Empty dependency array as we only want to run this once

  return state;
} 

================================================================================
File: src/hooks/useStrains.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import StrainService, { StrainSearchFilters } from '../services/StrainService';
import { Strain } from '../dbManager';

export interface UseStrainState {
  strains: Strain[];
  popularStrains: Strain[];
  categories: { [key: string]: number };
  isLoading: boolean;
  error: string | null;
  pagination: {
    total: number;
    currentPage: number;
    totalPages: number;
    hasMore: boolean;
  };
}

export interface UseStrainActions {
  searchStrains: (query: string, filters: StrainSearchFilters) => Promise<void>;
  loadMore: () => void;
  toggleFavorite: (strainId: number) => Promise<void>;
  isFavorite: (strainId: number) => boolean;
  clearSearch: () => void;
  getStrainDetails: (id: number) => Promise<Strain | null>;
  getRelatedStrains: (strain: Strain) => Promise<Strain[]>;
}

const INITIAL_STATE: UseStrainState = {
  strains: [],
  popularStrains: [],
  categories: {},
  isLoading: false,
  error: null,
  pagination: {
    total: 0,
    currentPage: 1,
    totalPages: 1,
    hasMore: false
  }
};

export function useStrains(): UseStrainState & UseStrainActions {
  const [state, setState] = useState<UseStrainState>(INITIAL_STATE);
  const [filters, setFilters] = useState<StrainSearchFilters>({});
  const [favoriteStrains, setFavoriteStrains] = useState<number[]>([]);

  // Load initial data
  useEffect(() => {
    loadInitialData();
  }, []);

  const loadInitialData = async () => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      
      const [popularStrains, categories] = await Promise.all([
        StrainService.getPopularStrains(),
        StrainService.getStrainCategories()
      ]);

      setState(prev => ({
        ...prev,
        popularStrains,
        categories,
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Failed to load initial data',
        isLoading: false
      }));
    }
  };

  const searchStrains = useCallback(async (
    query: string,
    newFilters: StrainSearchFilters = {},
    page: number = 1
  ) => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      setFilters(newFilters);

      const result = await StrainService.searchStrains(query, newFilters, { page, limit: 10 });

      setState(prev => ({
        ...prev,
        strains: page === 1 ? result.data : [...prev.strains, ...result.data],
        pagination: {
          total: result.total,
          currentPage: result.currentPage,
          totalPages: result.totalPages,
          hasMore: result.hasMore
        },
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Search failed',
        isLoading: false
      }));
    }
  }, []);

  const loadMore = useCallback(() => {
    if (state.pagination.hasMore && !state.isLoading) {
      const nextPage = state.pagination.currentPage + 1;
      searchStrains('', filters, nextPage);
    }
  }, [state.pagination, state.isLoading, filters, searchStrains]);

  const toggleFavorite = useCallback(async (strainId: number) => {
    setFavoriteStrains(prev => {
      const isFavorited = prev.includes(strainId);
      return isFavorited 
        ? prev.filter(id => id !== strainId)
        : [...prev, strainId];
    });
  }, []);

  const isFavorite = useCallback((strainId: number) => {
    return favoriteStrains.includes(strainId);
  }, [favoriteStrains]);

  const clearSearch = useCallback(() => {
    setState(prev => ({
      ...prev,
      strains: [],
      pagination: {
        total: 0,
        currentPage: 1,
        totalPages: 1,
        hasMore: false
      }
    }));
  }, []);

  const getStrainDetails = useCallback(async (id: number): Promise<Strain | null> => {
    try {
      return await StrainService.getStrainById(id);
    } catch (error) {
      console.error('[useStrains] Error getting strain details:', error);
      return null;
    }
  }, []);

  const getRelatedStrains = useCallback(async (strain: Strain): Promise<Strain[]> => {
    try {
      return await StrainService.getRelatedStrains(strain);
    } catch (error) {
      console.error('[useStrains] Error getting related strains:', error);
      return [];
    }
  }, []);

  return {
    ...state,
    searchStrains,
    loadMore,
    toggleFavorite,
    isFavorite,
    clearSearch,
    getStrainDetails,
    getRelatedStrains
  };
} 

================================================================================
File: src/hooks/useTimeRangeData.ts
================================================================================

import { useState, useCallback, useEffect } from 'react';
import { useDataService } from './useDataService';

export type TimeRange = 'D' | 'W' | 'M' | 'Y';

interface TimeRangeData {
  chartData: number[];
  chartLabels: string[];
  averageValue: number;
  maxValue: number;
  minValue: number;
  weekdayAvg?: number;
  weekendAvg?: number;
}

export function useTimeRangeData(initialRange: TimeRange = 'W') {
  const { weeklyData, monthlyData, usageStats, isLoading: isDataLoading, error: dataError } = useDataService();
  const [timeRange, setTimeRange] = useState<TimeRange>(initialRange);
  const [data, setData] = useState<TimeRangeData>({
    chartData: [],
    chartLabels: [],
    averageValue: 0,
    maxValue: 0,
    minValue: 0,
    weekdayAvg: 0,
    weekendAvg: 0
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Function to fetch data based on time range
  const fetchDataByTimeRange = useCallback(async (range: TimeRange) => {
    if (isDataLoading || dataError) return;
    const averageValue = usageStats.averageHitsPerDay;
    const maxValue = usageStats.peakDayHits; // Use the peak day value
    const minValue = usageStats.lowestDayHits > 0 ? usageStats.lowestDayHits : 0;
    setIsLoading(true);
    setError(null);
    
    try {
      // In a real implementation, this would call your data service
      // For now, we'll use the existing data and simulate different time ranges
      let chartData: number[] = [];
      let chartLabels: string[] = [];
      
      switch(range) {
        case 'D': // Daily (hours)
          // Simulate hourly data for today
          chartData = Array.from({ length: 24 }, () => Math.floor(Math.random() * 10));
          chartLabels = Array.from({ length: 24 }, (_, i) => `${i}:00`);
          break;
        case 'W': // Weekly (days)
          // Use the existing weekly data
          chartData = weeklyData.map(d => d.value);
          chartLabels = weeklyData.map(d => d.label);
          break;
        case 'M': // Monthly (days)
          // Simulate daily data for a month
          chartData = Array.from({ length: 30 }, () => Math.floor(Math.random() * 20));
          chartLabels = Array.from({ length: 30 }, (_, i) => `${i+1}`);
          break;
        case 'Y': // Yearly (months)
          // Use the existing monthly data
          chartData = monthlyData.map(d => d.value);
          chartLabels = monthlyData.map(d => d.label);
          break;
      }

      let weekdayAvg = usageStats.weekdayStats?.weekday.avg || 0;
      let weekendAvg = usageStats.weekdayStats?.weekend.avg || 0;
      
      if (range !== 'W') {
        // Simulate different stats for other time ranges
        weekdayAvg = averageValue * 0.9; // Slightly lower for weekdays
        weekendAvg = averageValue * 1.2; // Slightly higher for weekends
      }
      
      setData({
        chartData,
        chartLabels,
        averageValue,
        maxValue,
        minValue,
        weekdayAvg,
        weekendAvg
      });
    } catch (err) {
      console.error("Error fetching time range data:", err);
      setError(err instanceof Error ? err.message : "An unknown error occurred");
    } finally {
      setIsLoading(false);
    }
  }, [weeklyData, monthlyData, usageStats, isDataLoading, dataError]);

  // Update data when time range changes
  useEffect(() => {
    fetchDataByTimeRange(timeRange);
  }, [timeRange, fetchDataByTimeRange]);

  return {
    timeRange,
    setTimeRange,
    data,
    isLoading: isLoading || isDataLoading,
    error: error || dataError,
    fetchDataByTimeRange
  };
} 

================================================================================
File: src/services/ai/AIService.ts
================================================================================

import * as Logger from './utils/logging';
import { DatabaseManager } from './database/DatabaseManager';
import { CacheManager } from './cache/CacheManager';
import { FeedbackService } from './feedback/FeedbackService';
import { AnthropicAPI } from './api/AnthropicAPI';
import { AIServiceError, AIServiceErrorType } from './types/errors';
import { 
  RecommendationRequest, 
  ChatRequest 
} from './types/requests';
import { 
  RecommendationResponse, 
  ChatResponse,
  JournalAnalysisResult,
  SafetyValidationResult,
  DrugInteractionResult,
  OveruseDetectionResult
} from './types/responses';
import { UserFeedback, QualityScore } from './types/feedback';
import { DEFAULT_CACHE_TTL } from './types/common';
// Import types from the main app types
import { 
  UserProfile, 
  JournalEntry, 
  StrainRecommendation, 
  DosageSuggestion,
  ChatMessage
} from '../../types/ai';
import { MemoryCache } from './cache/MemoryCache';
import { PersistentCache } from './cache/PersistentCache';
import { StrainService } from '../StrainService';
import { Strain } from '../../dbManager';

const MODULE_NAME = 'AIService';

/**
 * AI Service
 * Main service for AI-powered features in the Canova app
 */
export class AIService {
  private static instance: AIService;
  private databaseManager: DatabaseManager;
  private cacheManager: CacheManager;
  private feedbackService: FeedbackService;
  private api: AnthropicAPI;
  private strainService: StrainService;
  private initialized: boolean = false;
  private useMockResponses: boolean = false;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {
    this.databaseManager = DatabaseManager.getInstance();
    this.cacheManager = CacheManager.getInstance();
    this.feedbackService = FeedbackService.getInstance();
    this.api = new AnthropicAPI();
    this.strainService = StrainService.getInstance();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of AIService
   */
  public static getInstance(): AIService {
    if (!AIService.instance) {
      AIService.instance = new AIService();
    }
    return AIService.instance;
  }

  /**
   * Initialize the AI service and its dependencies
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing AI service');
      
      // Initialize dependencies
      try {
        await this.databaseManager.initialize();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database manager, continuing with limited functionality');
      }
      
      try {
        await this.cacheManager.initialize();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize cache manager, continuing with limited functionality');
      }
      
      try {
        await this.feedbackService.initialize();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback service, continuing with limited functionality');
      }
      
      this.initialized = true;
      Logger.info(MODULE_NAME, 'AI service initialized successfully');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize AI service');
      // Set initialized to true anyway to prevent repeated initialization attempts
      this.initialized = true;
    }
  }

  /**
   * Configure the AI service
   */
  public configure(options: {
    useMockResponses?: boolean;
    cacheEnabled?: boolean;
    cacheTtl?: number;
    cacheMaxSize?: number;
  }): void {
    if (options.useMockResponses !== undefined) {
      this.useMockResponses = options.useMockResponses;
      Logger.info(MODULE_NAME, `Mock responses ${this.useMockResponses ? 'enabled' : 'disabled'}`);
    }
    
    // Configure cache if options provided
    if (options.cacheEnabled !== undefined || options.cacheTtl !== undefined || options.cacheMaxSize !== undefined) {
      try {
        this.cacheManager.configure(
          options.cacheEnabled ?? true,
          options.cacheTtl ?? DEFAULT_CACHE_TTL,
          options.cacheMaxSize ?? 100
        );
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to configure cache manager');
      }
    }
  }

  /**
   * Check if the service is initialized
   */
  private checkInitialized(): void {
    if (!this.initialized) {
      // Auto-initialize instead of throwing an error
      Logger.warn(MODULE_NAME, 'AI service not initialized, initializing now...');
      this.initialize().catch(error => {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to auto-initialize AI service');
      });
    }
  }

  /**
   * Get real strain recommendations from the database based on user preferences
   */
  private async getRealStrainRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    try {
      Logger.info(MODULE_NAME, 'Getting real strain recommendations from database');
      
      // Extract desired effects from the request
      const { desiredEffects, context, medicalNeeds } = request;
      Logger.info(MODULE_NAME, `Desired effects: ${desiredEffects.join(', ')}`);
      
      // Get all strains from the database
      const allStrainsResult = await this.strainService.searchStrains('', {}, { page: 1, limit: 100 });
      Logger.info(MODULE_NAME, `All strains search result: Found ${allStrainsResult.data?.length || 0} strains`);
      
      if (!allStrainsResult.data || allStrainsResult.data.length === 0) {
        Logger.warn(MODULE_NAME, 'No strains found in database at all');
        return this.getMockRecommendations(request); // Fallback to mock data if no results
      }
      
      // Log some sample effects from the database to understand what's available
      const sampleEffects = allStrainsResult.data.slice(0, 5).map((strain: Strain) => {
        return `${strain.name}: ${strain.effects}`;
      });
      Logger.info(MODULE_NAME, `Sample effects in database: ${sampleEffects.join(' | ')}`);
      
      // Use the AI to interpret the natural language query and match it to strain effects
      const matchedStrains = await this.matchStrainsWithAI(desiredEffects, allStrainsResult.data, context, medicalNeeds);
      
      // If we don't have any recommendations, use mock data
      if (!matchedStrains || matchedStrains.length === 0) {
        Logger.warn(MODULE_NAME, 'No matching strains found after AI matching');
        return this.getMockRecommendations(request);
      }
      
      // Log the top 5 scored strains
      const topScores = matchedStrains.slice(0, 5).map(s => `${s.strain.name}: ${s.matchScore}%`);
      Logger.info(MODULE_NAME, `Top scored strains: ${topScores.join(', ')}`);
      
      // Take top 5 recommendations
      const topRecommendations = matchedStrains
        .slice(0, 5)
        .map(s => ({
          strainId: s.strain.id || 0,
          strainName: s.strain.name,
          matchScore: s.matchScore,
          reasoningFactors: s.reasoningFactors,
          alternativeStrains: [] // Could be populated with similar strains
        }));
      
      Logger.info(MODULE_NAME, `Returning ${topRecommendations.length} recommendations`);
      
      return {
        recommendations: topRecommendations,
        reasoning: `Based on your request for "${desiredEffects.join(', ')}", I've found strains that are likely to match your preferences.`,
        confidenceScore: 90,
        disclaimers: [
          'Individual experiences may vary',
          'Start with a low dose and gradually increase as needed',
          'Consult with a healthcare professional before use, especially if you have medical conditions or take medications'
        ],
        dosageSuggestion: {
          minDosage: 5,
          maxDosage: 10,
          unit: 'mg THC',
          gradualApproach: true,
          notes: 'Start low and go slow. Wait at least 2 hours before consuming more edibles.'
        },
        safetyNotes: [
          'Do not drive or operate heavy machinery after use',
          'Keep out of reach of children and pets',
          'Store in a cool, dry place away from direct sunlight'
        ]
      };
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get real strain recommendations');
      // Fallback to mock data if there's an error
      return this.getMockRecommendations(request);
    }
  }

  /**
   * Use AI to match strains with natural language queries
   */
  private async matchStrainsWithAI(
    desiredEffects: string[], 
    strains: Strain[], 
    context?: string,
    medicalNeeds?: string[]
  ): Promise<Array<{
    strain: Strain;
    matchScore: number;
    reasoningFactors: Array<{ factor: string; weight: number }>;
  }>> {
    try {
      // If we're not using the real API, use a simpler matching approach
      if (this.useMockResponses) {
        return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
      }
      
      // Create a prompt for the AI to match strains
      const prompt = `
        You are an expert cannabis strain matcher. I need you to match the following user's desired effects with the most appropriate strains from our database.
        
        User's desired effects: "${desiredEffects.join(', ')}"
        ${context ? `Context: ${context}` : ''}
        ${medicalNeeds && medicalNeeds.length > 0 ? `Medical needs: ${medicalNeeds.join(', ')}` : ''}
        
        Here are the available strains with their effects:
        ${strains.slice(0, 50).map(strain => 
          `- ${strain.name} (${strain.genetic_type}, THC: ${strain.thc_range}): ${strain.effects}${strain.uses ? ` | Uses: ${strain.uses}` : ''}`
        ).join('\n')}
        
        Please analyze the user's request and match it with the most appropriate strains. For each matched strain, provide:
        1. The strain name
        2. A match score (0-100)
        3. 2-3 specific reasoning factors explaining why this strain matches the user's request
        
        Return your response as a JSON array with the following structure:
        [
          {
            "strainName": "Strain Name",
            "matchScore": 85,
            "reasoningFactors": [
              {"factor": "Specific reason this strain matches", "weight": 0.5},
              {"factor": "Another specific reason", "weight": 0.3},
              {"factor": "Additional information about the strain", "weight": 0.2}
            ]
          }
        ]
        
        Only include strains with a match score above 50. Limit your response to the top 10 matches.
      `;
      
      // Call the AI API
      const response = await this.api.sendMessage([
        { role: 'user', content: prompt }
      ], 2000, 0.7);
      
      // Parse the response
      try {
        // Extract JSON from the response (it might be wrapped in markdown code blocks)
        const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)\s*```/) || 
                          response.match(/\[\s*\{\s*"strainName"/);
        
        const jsonStr = jsonMatch ? jsonMatch[1] || response : response;
        const matches = JSON.parse(jsonStr);
        
        if (!Array.isArray(matches)) {
          throw new Error('Response is not an array');
        }
        
        // Map the AI matches to our strain objects
        const matchedStrains = matches.map(match => {
          // Find the corresponding strain object
          const strain = strains.find(s => s.name === match.strainName);
          
          if (!strain) {
            Logger.warn(MODULE_NAME, `Strain not found: ${match.strainName}`);
            return null;
          }
          
          return {
            strain,
            matchScore: match.matchScore,
            reasoningFactors: match.reasoningFactors
          };
        }).filter((match): match is { 
          strain: Strain; 
          matchScore: number; 
          reasoningFactors: Array<{ factor: string; weight: number }> 
        } => match !== null);
        
        Logger.info(MODULE_NAME, `AI matched ${matchedStrains.length} strains`);
        
        return matchedStrains;
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to parse AI strain matching response');
        // Fallback to simple matching
        return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to match strains with AI');
      // Fallback to simple matching
      return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
    }
  }
  
  /**
   * Simple strain matching algorithm as a fallback
   */
  private matchStrainsSimple(
    desiredEffects: string[], 
    strains: Strain[], 
    context?: string,
    medicalNeeds?: string[]
  ): Array<{
    strain: Strain;
    matchScore: number;
    reasoningFactors: Array<{ factor: string; weight: number }>;
  }> {
    // Common cannabis effects for basic matching
    const commonEffects = {
      'happy': ['euphoric', 'uplifted', 'joyful', 'cheerful', 'blissful'],
      'relaxed': ['calm', 'peaceful', 'tranquil', 'mellow', 'soothing'],
      'creative': ['inspired', 'imaginative', 'artistic', 'focused'],
      'energetic': ['active', 'lively', 'stimulating', 'invigorating'],
      'sleepy': ['sedated', 'drowsy', 'restful', 'sleep', 'tired'],
      'hungry': ['appetite', 'munchies', 'food'],
      'pain relief': ['analgesic', 'pain', 'ache', 'sore'],
      'stress relief': ['stress', 'anxiety', 'tension', 'worry']
    };
    
    // Score each strain
    const scoredStrains = strains.map(strain => {
      // Parse effects into an array
      const strainEffects = strain.effects.split(',').map(e => e.trim().toLowerCase());
      
      // Calculate a basic match score
      let matchScore = 0;
      const matchedEffects: string[] = [];
      
      // Check each desired effect against strain effects
      desiredEffects.forEach(desiredEffect => {
        const desiredLower = desiredEffect.toLowerCase();
        
        // Direct match
        const directMatch = strainEffects.some(effect => 
          effect.includes(desiredLower) || desiredLower.includes(effect)
        );
        
        if (directMatch) {
          matchScore += 25;
          matchedEffects.push(desiredEffect);
          return;
        }
        
        // Check against common effects
        for (const [effect, synonyms] of Object.entries(commonEffects)) {
          // If desired effect contains this effect or synonyms
          if (desiredLower.includes(effect) || synonyms.some(s => desiredLower.includes(s))) {
            // Check if strain has this effect
            const hasEffect = strainEffects.some(strainEffect => 
              strainEffect.includes(effect) || synonyms.some(s => strainEffect.includes(s))
            );
            
            if (hasEffect) {
              matchScore += 20;
              matchedEffects.push(effect);
              return;
            }
          }
        }
        
        // Check for partial word matches
        const desiredWords = desiredLower.split(/\s+/).filter(w => w.length > 3);
        const hasPartialMatch = strainEffects.some(effect => 
          desiredWords.some(word => effect.includes(word))
        );
        
        if (hasPartialMatch) {
          matchScore += 10;
        }
      });
      
      // Boost score for context matches
      if (context === 'medical' && strain.uses && 
          (strain.uses.toLowerCase().includes('medical') || 
           (medicalNeeds && medicalNeeds.some(need => strain.uses.toLowerCase().includes(need.toLowerCase()))))) {
        matchScore += 15;
      } else if (context === 'recreational' && strainEffects.some(e => e.includes('euphoric'))) {
        matchScore += 15;
      }
      
      // Cap score at 100
      matchScore = Math.min(matchScore, 100);
      
      // Create reasoning factors
      const reasoningFactors = [];
      
      if (matchedEffects.length > 0) {
        reasoningFactors.push({
          factor: `Matches your desired effects: ${matchedEffects.join(', ')}`,
          weight: 0.5
        });
      }
      
      if (context === 'medical' && strain.uses) {
        reasoningFactors.push({
          factor: `Good for medical use: ${strain.uses}`,
          weight: 0.3
        });
      }
      
      reasoningFactors.push({
        factor: `${strain.genetic_type} with ${strain.thc_range} THC content`,
        weight: 0.2
      });
      
      return {
        strain,
        matchScore,
        reasoningFactors
      };
    });
    
    // Sort by match score (highest first) and filter out low scores
    return scoredStrains
      .filter(s => s.matchScore > 0)
      .sort((a, b) => b.matchScore - a.matchScore);
  }

  /**
   * Get strain recommendations based on user profile and preferences
   */
  public async getRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Getting strain recommendations');
      
      // Generate a unique response ID
      const responseId = `rec_${Date.now()}`;
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey(request);
      const cachedResponse = await this.cacheManager.get<RecommendationResponse>(cacheKey);
      
      if (cachedResponse) {
        Logger.info(MODULE_NAME, 'Returning cached recommendations');
        // Add the responseId to the cached response
        return { ...cachedResponse, responseId };
      }
      
      // If using mock responses, return a mock response
      if (this.useMockResponses) {
        const mockResponse = this.getMockRecommendations(request);
        
        // Cache the response
        await this.cacheManager.set(cacheKey, mockResponse);
        
        Logger.info(MODULE_NAME, 'Returning mock recommendations');
        return { ...mockResponse, responseId };
      }
      
      // Get real recommendations from the database
      const realRecommendations = await this.getRealStrainRecommendations(request);
      
      // Add the responseId
      const result: RecommendationResponse = {
        ...realRecommendations,
        responseId
      };
      
      // Cache the response
      await this.cacheManager.set(cacheKey, result);
      
      Logger.info(MODULE_NAME, 'Recommendations generated successfully');
      return result;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get recommendations');
      throw error;
    }
  }

  /**
   * Format a recommendation prompt for the AI
   */
  private formatRecommendationPrompt(request: RecommendationRequest): string {
    // Create a detailed prompt for the AI
    return `
      You are an AI assistant for a cannabis recommendation app called Canova.
      Please provide personalized cannabis strain recommendations based on the following user profile and preferences:
      
      User Profile:
      ${JSON.stringify(request.userProfile, null, 2)}
      
      Desired Effects:
      ${request.desiredEffects.join(', ')}
      
      ${request.medicalNeeds ? `Medical Needs: ${request.medicalNeeds.join(', ')}` : ''}
      ${request.context ? `Context: ${request.context}` : ''}
      ${request.locationCode ? `Location Code: ${request.locationCode}` : ''}
      
      ${request.journalEntries ? `Recent Journal Entries:
      ${JSON.stringify(request.journalEntries, null, 2)}` : ''}
      
      Please provide:
      1. A list of 3-5 strain recommendations with detailed information about each
      2. A brief explanation of why each strain was recommended
      3. Suggested dosage guidelines
      4. Any safety considerations or warnings
      
      Format your response as a JSON object with the following structure:
      {
        "recommendations": [
          {
            "name": "Strain Name",
            "type": "Indica/Sativa/Hybrid",
            "thcContent": "THC percentage range",
            "cbdContent": "CBD percentage range",
            "effects": ["effect1", "effect2", ...],
            "medicalBenefits": ["benefit1", "benefit2", ...],
            "flavors": ["flavor1", "flavor2", ...],
            "description": "Detailed description"
          }
        ],
        "reasoning": "Explanation of recommendations",
        "confidenceScore": 0-100,
        "disclaimers": ["disclaimer1", "disclaimer2", ...],
        "dosageSuggestion": {
          "beginner": "Beginner dosage",
          "intermediate": "Intermediate dosage",
          "experienced": "Experienced dosage",
          "notes": "Additional notes"
        },
        "safetyNotes": ["note1", "note2", ...]
      }
    `;
  }

  /**
   * Parse the AI response into a structured recommendation
   */
  private parseRecommendationResponse(response: string): RecommendationResponse {
    try {
      // Try to parse the response as JSON
      const parsedResponse = JSON.parse(response) as RecommendationResponse;
      
      // Validate the response structure
      if (!parsedResponse.recommendations || !Array.isArray(parsedResponse.recommendations)) {
        throw new Error('Invalid response structure: recommendations array missing');
      }
      
      return parsedResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to parse recommendation response');
      
      // If parsing fails, try to extract information from the text response
      // This is a fallback mechanism for when the AI doesn't return valid JSON
      
      // For now, return a simple error response
      return {
        recommendations: [],
        reasoning: 'Failed to parse AI response',
        confidenceScore: 0,
        disclaimers: ['The AI response could not be properly parsed'],
        error: {
          message: 'Failed to parse AI response',
          type: 'parsing_error',
          recoverable: false
        }
      };
    }
  }

  /**
   * Generate mock recommendations for testing
   */
  private getMockRecommendations(request: RecommendationRequest): RecommendationResponse {
    return {
      recommendations: [
        {
          strainId: 1,
          strainName: 'Blue Dream',
          matchScore: 95,
          reasoningFactors: [
            { factor: 'Matches desired effects', weight: 0.5 },
            { factor: 'Good for stress relief', weight: 0.3 },
            { factor: 'Balanced hybrid', weight: 0.2 }
          ],
          alternativeStrains: [
            { strainId: 4, strainName: 'Harlequin', reason: 'Higher CBD content' }
          ]
        },
        {
          strainId: 2,
          strainName: 'OG Kush',
          matchScore: 90,
          reasoningFactors: [
            { factor: 'Strong pain relief', weight: 0.6 },
            { factor: 'Matches user experience level', weight: 0.4 }
          ],
          alternativeStrains: [
            { strainId: 5, strainName: 'Bubba Kush', reason: 'Similar effects with more sedation' }
          ]
        },
        {
          strainId: 3,
          strainName: 'Granddaddy Purple',
          matchScore: 85,
          reasoningFactors: [
            { factor: 'Good for sleep', weight: 0.7 },
            { factor: 'Matches flavor preferences', weight: 0.3 }
          ],
          alternativeStrains: [
            { strainId: 6, strainName: 'Northern Lights', reason: 'Similar relaxation effects' }
          ]
        }
      ],
      reasoning: `Based on the user's profile and preferences, I've recommended strains that align with their desired effects and medical needs. Blue Dream offers a balanced experience, OG Kush provides potent relief, and Granddaddy Purple is excellent for relaxation and sleep.`,
      confidenceScore: 85,
      disclaimers: [
        'Individual experiences may vary',
        'Start with a low dose and gradually increase as needed',
        'Consult with a healthcare professional before use, especially if you have medical conditions or take medications'
      ],
      dosageSuggestion: {
        minDosage: 5,
        maxDosage: 10,
        unit: 'mg THC',
        gradualApproach: true,
        notes: 'Start low and go slow. Wait at least 2 hours before consuming more edibles.'
      },
      safetyNotes: [
        'Do not drive or operate heavy machinery after use',
        'Keep out of reach of children and pets',
        'Store in a cool, dry place away from direct sunlight'
      ]
    };
  }

  /**
   * Submit user feedback for a recommendation
   */
  public async submitRecommendationFeedback(
    userId: string,
    responseId: string,
    helpful: boolean,
    accurate: boolean,
    relevance: number,
    comments?: string
  ): Promise<string> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Submitting recommendation feedback for response: ${responseId}`);
      
      const feedback: UserFeedback = {
        userId,
        responseId,
        responseType: 'recommendation',
        helpful,
        accurate,
        relevance,
        comments,
        timestamp: Date.now()
      };
      
      // Submit the feedback using the feedback service
      const feedbackId = await this.feedbackService.submitFeedback(feedback);
      
      Logger.info(MODULE_NAME, `Recommendation feedback submitted: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit recommendation feedback for response: ${responseId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to submit recommendation feedback',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while submitting your feedback. Please try again later.'
      );
    }
  }

  /**
   * Get a response to a user's chat message
   */
  public async getChatResponse(request: ChatRequest): Promise<ChatResponse> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Getting chat response');
      
      // Generate a unique response ID
      const responseId = `chat_${Date.now()}`;
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey(request);
      const cachedResponse = await this.cacheManager.get<ChatResponse>(cacheKey);
      
      if (cachedResponse) {
        Logger.info(MODULE_NAME, 'Returning cached chat response');
        return cachedResponse;
      }
      
      // If using mock responses, return a mock response
      if (this.useMockResponses) {
        const mockResponse = this.getMockChatResponse(request);
        
        // Cache the response
        await this.cacheManager.set(cacheKey, mockResponse);
        
        Logger.info(MODULE_NAME, 'Returning mock chat response');
        return mockResponse;
      }
      
      // Format messages for the API
      const messages = this.formatChatMessages(request);
      
      // Call the API
      const response = await this.api.sendMessage(messages, 2000, 0.7);
      
      // Parse the response
      const chatResponse = this.parseChatResponse(response);
      
      // Cache the response
      await this.cacheManager.set(cacheKey, chatResponse);
      
      Logger.info(MODULE_NAME, 'Chat response generated successfully');
      return chatResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get chat response');
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to get chat response',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while generating a response. Please try again later.'
      );
    }
  }

  /**
   * Format chat messages for the API
   */
  private formatChatMessages(request: ChatRequest): Array<{ role: 'user' | 'assistant'; content: string }> {
    const messages: Array<{ role: 'user' | 'assistant'; content: string }> = [];
    
    // Add system message with context
    messages.push({
      role: 'user',
      content: `You are an AI assistant for a cannabis app called Canova. You provide helpful, accurate, and educational information about cannabis. 
      
      User Profile:
      ${JSON.stringify(request.userProfile, null, 2)}
      
      ${request.locationCode ? `Location Code: ${request.locationCode}` : ''}
      
      Please provide informative, educational responses. Include relevant scientific information when appropriate. Always prioritize safety and responsible use. If you don't know something, say so rather than providing incorrect information.`
    });
    
    // Add previous messages if available
    if (request.previousMessages && request.previousMessages.length > 0) {
      request.previousMessages.forEach(msg => {
        messages.push({
          role: msg.role as 'user' | 'assistant',
          content: msg.content
        });
      });
    }
    
    // Add the current message
    messages.push({
      role: 'user',
      content: request.message
    });
    
    return messages;
  }

  /**
   * Parse the AI response into a structured chat response
   */
  private parseChatResponse(response: string): ChatResponse {
    // For chat, we can use the response text directly
    const chatResponse: ChatResponse = {
      response: response,
      // Extract educational links if present
      educationalLinks: this.extractLinks(response),
      // Add disclaimers
      disclaimers: [
        'This information is for educational purposes only and not medical advice.',
        'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
      ]
    };
    
    return chatResponse;
  }

  /**
   * Extract links from a text response
   */
  private extractLinks(text: string): string[] {
    const links: string[] = [];
    const linkRegex = /https?:\/\/[^\s]+/g;
    const matches = text.match(linkRegex);
    
    if (matches) {
      matches.forEach(link => {
        links.push(link);
      });
    }
    
    return links;
  }

  /**
   * Generate a mock chat response for testing
   */
  private getMockChatResponse(request: ChatRequest): ChatResponse {
    // Simple mock response based on the request message
    const message = request.message.toLowerCase();
    
    if (message.includes('strain') || message.includes('recommend')) {
      return {
        response: `Based on your profile, I'd recommend considering strains like Blue Dream, OG Kush, or Granddaddy Purple. Blue Dream is a balanced hybrid that provides relaxation without sedation, OG Kush offers potent relief from stress and pain, and Granddaddy Purple is excellent for sleep and deep relaxation. Always start with a low dose, especially if you're new to cannabis.`,
        educationalLinks: ['https://www.leafly.com/strains/blue-dream', 'https://www.leafly.com/strains/og-kush'],
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    } else if (message.includes('cbd') || message.includes('thc')) {
      return {
        response: `THC (tetrahydrocannabinol) and CBD (cannabidiol) are the two most well-known cannabinoids in cannabis. THC is primarily responsible for the psychoactive effects or "high," while CBD is non-intoxicating and associated with various potential therapeutic benefits. The ratio of THC to CBD in a strain can significantly influence its effects. High-THC strains tend to be more intoxicating, while high-CBD strains are often used for their potential therapeutic properties without strong psychoactive effects.`,
        educationalLinks: ['https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5345356/'],
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    } else {
      return {
        response: `Thank you for your question about cannabis. I'm here to provide educational information and guidance based on scientific research. If you have specific questions about strains, effects, consumption methods, or safety considerations, feel free to ask. Remember that individual experiences with cannabis can vary significantly based on factors like body chemistry, tolerance, and the specific product used.`,
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    }
  }

  /**
   * Submit user feedback for a chat response
   */
  public async submitChatFeedback(
    userId: string,
    responseId: string,
    helpful: boolean,
    accurate: boolean,
    relevance: number,
    comments?: string
  ): Promise<string> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Submitting chat feedback for response: ${responseId}`);
      
      const feedback: UserFeedback = {
        userId,
        responseId,
        responseType: 'chat',
        helpful,
        accurate,
        relevance,
        comments,
        timestamp: Date.now()
      };
      
      // Submit the feedback using the feedback service
      const feedbackId = await this.feedbackService.submitFeedback(feedback);
      
      Logger.info(MODULE_NAME, `Chat feedback submitted: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit chat feedback for response: ${responseId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to submit chat feedback',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while submitting your feedback. Please try again later.'
      );
    }
  }

  /**
   * Analyze journal entries for patterns and insights
   */
  public async analyzeJournalEntries(
    userId: string,
    journalEntries: JournalEntry[]
  ): Promise<JournalAnalysisResult> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Analyzing journal entries for user: ${userId}`);
      
      // If no entries, return empty analysis
      if (!journalEntries || journalEntries.length === 0) {
        Logger.info(MODULE_NAME, 'No journal entries to analyze');
        return {
          patterns: [],
          insights: [],
          recommendations: []
        };
      }
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey({
        userId,
        journalEntries: journalEntries.map(entry => ({
          id: entry.id,
          created_at: entry.created_at
        }))
      });
      
      const cachedAnalysis = await this.cacheManager.get<JournalAnalysisResult>(cacheKey);
      
      if (cachedAnalysis) {
        Logger.info(MODULE_NAME, 'Returning cached journal analysis');
        return cachedAnalysis;
      }
      
      // If using mock responses, return a mock analysis
      if (this.useMockResponses) {
        const mockAnalysis = this.getMockJournalAnalysis(journalEntries);
        
        // Cache the analysis
        await this.cacheManager.set(cacheKey, mockAnalysis);
        
        Logger.info(MODULE_NAME, 'Returning mock journal analysis');
        return mockAnalysis;
      }
      
      // Format the prompt for the AI
      const prompt = this.formatJournalAnalysisPrompt(journalEntries);
      
      // Call the API
      const response = await this.api.sendMessage([
        { role: 'user', content: prompt }
      ], 2000, 0.7);
      
      // Parse the response
      const analysis = this.parseJournalAnalysisResponse(response);
      
      // Cache the analysis
      await this.cacheManager.set(cacheKey, analysis);
      
      Logger.info(MODULE_NAME, 'Journal analysis completed successfully');
      return analysis;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to analyze journal entries for user: ${userId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to analyze journal entries',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while analyzing your journal entries. Please try again later.'
      );
    }
  }

  /**
   * Format a journal analysis prompt for the AI
   */
  private formatJournalAnalysisPrompt(journalEntries: JournalEntry[]): string {
    return `
      You are an AI assistant for a cannabis app called Canova.
      Please analyze the following journal entries to identify patterns, insights, and potential recommendations:
      
      Journal Entries:
      ${JSON.stringify(journalEntries, null, 2)}
      
      For each entry, consider:
      - Strain used
      - Dosage
      - Consumption method
      - Effects experienced
      - Time of day
      - User's mood before and after
      - Any side effects
      
      Please provide:
      1. Patterns you've identified across entries
      2. Insights about what works well and what doesn't for this user
      3. Recommendations for strains, dosages, or consumption methods based on the data
      4. Any safety flags or concerns that should be addressed
      
      Format your response as a JSON object with the following structure:
      {
        "patterns": ["pattern1", "pattern2", ...],
        "insights": ["insight1", "insight2", ...],
        "recommendations": ["recommendation1", "recommendation2", ...],
        "safetyFlags": ["flag1", "flag2", ...] // Optional, include only if relevant
      }
    `;
  }

  /**
   * Parse the AI response into a structured journal analysis
   */
  private parseJournalAnalysisResponse(response: string): JournalAnalysisResult {
    try {
      // Try to parse the response as JSON
      const parsedResponse = JSON.parse(response) as JournalAnalysisResult;
      
      // Validate the response structure
      if (!parsedResponse.patterns || !parsedResponse.insights || !parsedResponse.recommendations) {
        throw new Error('Invalid response structure: required fields missing');
      }
      
      return parsedResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to parse journal analysis response');
      
      // Return a simple error response
      return {
        patterns: ['Could not identify patterns due to parsing error'],
        insights: ['Could not generate insights due to parsing error'],
        recommendations: ['Please try again later or contact support']
      };
    }
  }

  /**
   * Generate mock journal analysis for testing
   */
  private getMockJournalAnalysis(journalEntries: JournalEntry[]): JournalAnalysisResult {
    // Simple mock analysis based on the number of entries
    if (journalEntries.length >= 5) {
      return {
        patterns: [
          'Higher satisfaction with indica strains in the evening',
          'Edibles tend to cause more anxiety than vaping',
          'Morning use of low-THC strains improves focus without impairment'
        ],
        insights: [
          'You respond well to balanced THC:CBD ratios for pain management',
          'Strains high in limonene terpenes seem to elevate your mood consistently',
          'Consumption 2-3 hours before bedtime improves sleep quality'
        ],
        recommendations: [
          'Try Granddaddy Purple for evening relaxation',
          'Consider microdosing with a 1:1 THC:CBD tincture for daytime pain relief',
          'Experiment with lower temperatures when vaping to reduce throat irritation'
        ]
      };
    } else {
      return {
        patterns: [
          'Not enough entries to identify reliable patterns yet',
          'Initial preference for hybrid strains noted'
        ],
        insights: [
          'More journal entries needed for meaningful insights',
          'Consider recording more details about effects and context'
        ],
        recommendations: [
          'Continue journaling consistently to build more data',
          'Try varying your consumption methods to compare effects',
          'Record your experience with different terpene profiles'
        ]
      };
    }
  }

  /**
   * Validate the safety of a recommendation request
   */
  public async validateRecommendationSafety(
    request: RecommendationRequest
  ): Promise<SafetyValidationResult> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Validating recommendation request safety');
      
      // Check for basic safety issues
      const basicSafetyCheck = this.performBasicSafetyCheck(request);
      if (!basicSafetyCheck.valid) {
        Logger.info(MODULE_NAME, `Safety validation failed: ${basicSafetyCheck.reason}`);
        return basicSafetyCheck;
      }
      
      // Check for potential drug interactions
      const interactionResult = await this.checkDrugInteractions(request);
      if (interactionResult.hasInteractions && interactionResult.severity === 'severe') {
        Logger.info(MODULE_NAME, 'Safety validation failed: Severe drug interactions detected');
        return {
          valid: false,
          reason: 'Potential severe drug interactions detected',
          safetyFlags: interactionResult.details,
          warningLevel: 'critical'
        };
      }
      
      // Check for potential overuse
      const overuseResult = await this.detectOveruse(request.userProfile.id);
      if (overuseResult.detected && overuseResult.level === 'severe') {
        Logger.info(MODULE_NAME, 'Safety validation failed: Severe overuse pattern detected');
        return {
          valid: false,
          reason: 'Potential overuse pattern detected',
          safetyFlags: [overuseResult.details || 'Frequent high-dose usage pattern detected'],
          warningLevel: 'critical'
        };
      }
      
      // If there are moderate concerns, return valid but with warnings
      if (
        (interactionResult.hasInteractions && interactionResult.severity === 'moderate') ||
        (overuseResult.detected && overuseResult.level === 'moderate')
      ) {
        const safetyFlags = [
          ...(interactionResult.hasInteractions ? interactionResult.details || [] : []),
          ...(overuseResult.detected && overuseResult.details ? [overuseResult.details] : [])
        ];
        
        Logger.info(MODULE_NAME, 'Safety validation passed with warnings');
        return {
          valid: true,
          safetyFlags,
          warningLevel: 'warning'
        };
      }
      
      // If there are mild concerns, return valid but with info
      if (
        (interactionResult.hasInteractions && interactionResult.severity === 'mild') ||
        (overuseResult.detected && overuseResult.level === 'mild')
      ) {
        const safetyFlags = [
          ...(interactionResult.hasInteractions ? interactionResult.details || [] : []),
          ...(overuseResult.detected && overuseResult.details ? [overuseResult.details] : [])
        ];
        
        Logger.info(MODULE_NAME, 'Safety validation passed with information');
        return {
          valid: true,
          safetyFlags,
          warningLevel: 'info'
        };
      }
      
      // All checks passed
      Logger.info(MODULE_NAME, 'Safety validation passed');
      return {
        valid: true
      };
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to validate recommendation safety');
      
      // Return a conservative result in case of error
      return {
        valid: true,
        reason: 'Safety validation could not be completed',
        safetyFlags: ['Safety validation encountered an error, proceed with caution'],
        warningLevel: 'warning'
      };
    }
  }

  /**
   * Perform basic safety checks on a recommendation request
   */
  private performBasicSafetyCheck(request: RecommendationRequest): SafetyValidationResult {
    // Check for underage users based on experience level
    if (request.userProfile.experience_level === 'beginner') {
      // For beginners, we'll add extra caution
      return {
        valid: true,
        safetyFlags: ['User is a beginner, recommend starting with low doses'],
        warningLevel: 'info'
      };
    }
    
    // Check for pregnancy or other medical conditions
    if (request.userProfile.medical_needs && 
        request.userProfile.medical_needs.some((condition: string) => 
          condition.toLowerCase().includes('pregnant') || 
          condition.toLowerCase().includes('pregnancy')
        )) {
      return {
        valid: false,
        reason: 'Cannabis use is not recommended during pregnancy',
        warningLevel: 'critical'
      };
    }
    
    // Check for severe mental health conditions
    const severeConditions = ['schizophrenia', 'psychosis', 'severe depression', 'bipolar disorder'];
    if (request.userProfile.medical_needs && 
        request.userProfile.medical_needs.some((condition: string) => 
          severeConditions.some(severe => condition.toLowerCase().includes(severe))
        )) {
      return {
        valid: false,
        reason: 'Cannabis use may exacerbate certain mental health conditions',
        warningLevel: 'critical'
      };
    }
    
    // All basic checks passed
    return {
      valid: true
    };
  }

  /**
   * Check for potential drug interactions
   */
  private async checkDrugInteractions(request: RecommendationRequest): Promise<DrugInteractionResult> {
    // In a real implementation, this would check against a database of known drug interactions
    // For now, we'll just check for some common medications that have known interactions
    
    const highRiskMedications = [
      'warfarin', 'clopidogrel', 'amiodarone', 'tacrolimus', 'cyclosporine',
      'sedative', 'benzodiazepine', 'opioid', 'alcohol'
    ];
    
    const moderateRiskMedications = [
      'antidepressant', 'ssri', 'antipsychotic', 'stimulant', 'adhd medication',
      'blood pressure', 'hypertension', 'beta blocker'
    ];
    
    if (!request.userProfile.medications || request.userProfile.medications.length === 0) {
      return {
        hasInteractions: false
      };
    }
    
    const highRiskFound = request.userProfile.medications.some((med: string) => 
      highRiskMedications.some(risk => med.toLowerCase().includes(risk))
    );
    
    if (highRiskFound) {
      return {
        hasInteractions: true,
        severity: 'severe',
        details: [
          'Potential severe interaction with one or more medications',
          'Cannabis may increase or decrease the effects of certain medications',
          'Consult with a healthcare provider before using cannabis'
        ],
        recommendations: [
          'Consult with a healthcare provider before using cannabis',
          'Consider alternative treatments',
          'If approved by a healthcare provider, start with very low doses and monitor closely'
        ]
      };
    }
    
    const moderateRiskFound = request.userProfile.medications.some((med: string) => 
      moderateRiskMedications.some(risk => med.toLowerCase().includes(risk))
    );
    
    if (moderateRiskFound) {
      return {
        hasInteractions: true,
        severity: 'moderate',
        details: [
          'Potential moderate interaction with one or more medications',
          'Cannabis may affect how your medications work'
        ],
        recommendations: [
          'Consult with a healthcare provider before using cannabis',
          'Start with low doses and monitor for any adverse effects',
          'Keep a journal of effects to share with your healthcare provider'
        ]
      };
    }
    
    // No known interactions found
    return {
      hasInteractions: false
    };
  }

  /**
   * Detect potential overuse patterns
   */
  private async detectOveruse(userId: string): Promise<OveruseDetectionResult> {
    // In a real implementation, this would analyze usage patterns from the user's history
    // For now, we'll just return a mock result
    
    // Simulate a 10% chance of detecting mild overuse
    const randomValue = Math.random();
    
    if (randomValue < 0.01) {
      // 1% chance of severe overuse
      return {
        detected: true,
        level: 'severe',
        details: 'Frequent high-dose usage pattern detected',
        recommendedAction: 'Consider taking a tolerance break and consulting with a healthcare provider',
        coolingOffPeriod: 14 // 14 days
      };
    } else if (randomValue < 0.05) {
      // 4% chance of moderate overuse
      return {
        detected: true,
        level: 'moderate',
        details: 'Increasing frequency of use detected',
        recommendedAction: 'Consider moderating use and monitoring effects more closely',
        coolingOffPeriod: 7 // 7 days
      };
    } else if (randomValue < 0.10) {
      // 5% chance of mild overuse
      return {
        detected: true,
        level: 'mild',
        details: 'Slight increase in usage frequency noted',
        recommendedAction: 'Be mindful of consumption patterns and consider occasional breaks',
        coolingOffPeriod: 2 // 2 days
      };
    }
    
    // No overuse detected
    return {
      detected: false
    };
  }
} 

================================================================================
File: src/services/ai/api/AnthropicAPI.ts
================================================================================

import * as Logger from '../utils/logging';
import { AIServiceError, AIServiceErrorType } from '../types/errors';
import { ANTHROPIC_API_URL, ANTHROPIC_API_VERSION, ANTHROPIC_API_KEY } from '../types/common';

const MODULE_NAME = 'AnthropicAPI';

/**
 * Anthropic API client
 * Handles communication with the Claude API
 */
export class AnthropicAPI {
  private apiKey: string;
  private apiUrl: string;
  private apiVersion: string;

  constructor(
    apiKey: string = "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",
    apiUrl: string = "https://api.anthropic.com/v1",
    apiVersion: string = "2023-06-01",
  ) {
    this.apiKey = apiKey;
    this.apiUrl = apiUrl;
    this.apiVersion = apiVersion;
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Send a message to the Claude API
   */
  public async sendMessage(
    messages: Array<{ role: 'user' | 'assistant'; content: string }>,
    maxTokens: number = 1000,
    temperature: number = 0.7,
    model: string = 'claude-3-sonnet-20240229'
  ): Promise<string> {
    try {
      Logger.debug(MODULE_NAME, `Sending message to Claude API, model: ${model}`);

      const response = await fetch(`${this.apiUrl}/messages`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': this.apiVersion,
        },
        body: JSON.stringify({
          model,
          messages,
          max_tokens: maxTokens,
          temperature,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        Logger.error(
          MODULE_NAME,
          `API error: ${response.status} ${response.statusText}`,
          errorData
        );

        let errorType = AIServiceErrorType.UNKNOWN;
        let retryable = false;
        let userMessage = 'An error occurred while processing your request.';

        // Determine error type based on status code
        if (response.status === 401 || response.status === 403) {
          errorType = AIServiceErrorType.AUTHENTICATION;
          userMessage = 'Authentication error. Please check your API key.';
        } else if (response.status === 429) {
          errorType = AIServiceErrorType.RATE_LIMIT;
          retryable = true;
          userMessage = 'Rate limit exceeded. Please try again later.';
        } else if (response.status >= 500) {
          errorType = AIServiceErrorType.SERVER;
          retryable = true;
          userMessage = 'Server error. Please try again later.';
        }

        throw new AIServiceError(
          `API error: ${response.status} ${response.statusText}`,
          errorType,
          response.status,
          retryable,
          userMessage
        );
      }

      const data = await response.json();
      Logger.debug(MODULE_NAME, 'Received response from Claude API');

      return data.content[0].text;
    } catch (error) {
      if (error instanceof AIServiceError) {
        throw error;
      }

      Logger.logError(MODULE_NAME, error as Error, 'Failed to send message to Claude API');
      throw new AIServiceError(
        'Failed to send message to Claude API',
        AIServiceErrorType.NETWORK,
        undefined,
        true,
        'Network error. Please check your internet connection and try again.'
      );
    }
  }

  /**
   * Send a completion request to the Claude API
   * @deprecated Use sendMessage instead
   */
  public async sendCompletion(
    prompt: string,
    maxTokens: number = 1000,
    temperature: number = 0.7,
    model: string = 'claude-3-sonnet-20240229'
  ): Promise<string> {
    try {
      Logger.debug(MODULE_NAME, `Sending completion to Claude API, model: ${model}`);

      const response = await fetch(`${this.apiUrl}/complete`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': this.apiVersion,
        },
        body: JSON.stringify({
          model,
          prompt,
          max_tokens_to_sample: maxTokens,
          temperature,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        Logger.error(
          MODULE_NAME,
          `API error: ${response.status} ${response.statusText}`,
          errorData
        );

        let errorType = AIServiceErrorType.UNKNOWN;
        let retryable = false;
        let userMessage = 'An error occurred while processing your request.';

        // Determine error type based on status code
        if (response.status === 401 || response.status === 403) {
          errorType = AIServiceErrorType.AUTHENTICATION;
          userMessage = 'Authentication error. Please check your API key.';
        } else if (response.status === 429) {
          errorType = AIServiceErrorType.RATE_LIMIT;
          retryable = true;
          userMessage = 'Rate limit exceeded. Please try again later.';
        } else if (response.status >= 500) {
          errorType = AIServiceErrorType.SERVER;
          retryable = true;
          userMessage = 'Server error. Please try again later.';
        }

        throw new AIServiceError(
          `API error: ${response.status} ${response.statusText}`,
          errorType,
          response.status,
          retryable,
          userMessage
        );
      }

      const data = await response.json();
      Logger.debug(MODULE_NAME, 'Received response from Claude API');

      return data.completion;
    } catch (error) {
      if (error instanceof AIServiceError) {
        throw error;
      }

      Logger.logError(MODULE_NAME, error as Error, 'Failed to send completion to Claude API');
      throw new AIServiceError(
        'Failed to send completion to Claude API',
        AIServiceErrorType.NETWORK,
        undefined,
        true,
        'Network error. Please check your internet connection and try again.'
      );
    }
  }
} 

================================================================================
File: src/services/ai/api/index.ts
================================================================================

export { AnthropicAPI } from './AnthropicAPI'; 

================================================================================
File: src/services/ai/cache/CacheManager.ts
================================================================================

import * as Logger from '../utils/logging';
import { MemoryCache } from './MemoryCache';
import { PersistentCache } from './PersistentCache';
import { SHA256 } from '../utils/hash';
import { DEFAULT_CACHE_TTL, MAX_CACHE_SIZE, CacheDbEntry } from '../types/common';

const MODULE_NAME = 'CacheManager';

/**
 * Cache Manager
 * Orchestrates both memory and persistent caches
 */
export class CacheManager {
  private static instance: CacheManager;
  private memoryCache: MemoryCache;
  private persistentCache: PersistentCache;
  private enabled: boolean = true;
  private defaultTtl: number = DEFAULT_CACHE_TTL;
  private initialized: boolean = false;

  private constructor() {
    this.memoryCache = new MemoryCache(MAX_CACHE_SIZE);
    this.persistentCache = new PersistentCache();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of CacheManager
   */
  public static getInstance(): CacheManager {
    if (!CacheManager.instance) {
      CacheManager.instance = new CacheManager();
    }
    return CacheManager.instance;
  }

  /**
   * Initialize the cache manager
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing cache manager');
      
      // Load frequently accessed entries into memory cache
      await this.loadFrequentEntries();
      
      // Delete expired entries
      await this.pruneCache();
      
      this.initialized = true;
      Logger.info(MODULE_NAME, 'Cache manager initialized successfully');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize cache manager');
      throw error;
    }
  }

  /**
   * Configure the cache
   */
  public configure(enabled: boolean, ttlMs: number = DEFAULT_CACHE_TTL, maxSize: number = MAX_CACHE_SIZE): void {
    this.enabled = enabled;
    this.defaultTtl = ttlMs;
    this.memoryCache.setMaxSize(maxSize);
    
    Logger.info(MODULE_NAME, `Cache configured: enabled=${enabled}, ttl=${ttlMs}ms, maxSize=${maxSize}`);
  }

  /**
   * Generate a cache key from request data
   */
  public generateKey(requestData: any): string {
    try {
      // Create a stable representation of the request data
      const stableRepresentation = this.createStableRepresentation(requestData);
      
      // Generate a hash of the stable representation
      const hash = SHA256(stableRepresentation);
      
      // Extract user ID if available for easier cache invalidation
      let userId = '';
      if (requestData.userProfile && requestData.userProfile.id) {
        userId = requestData.userProfile.id;
      } else if (requestData.userId) {
        userId = requestData.userId;
      }
      
      // Create a key with user ID prefix for easier user-specific cache invalidation
      const key = userId ? `user:${userId}:${hash}` : hash;
      
      Logger.debug(MODULE_NAME, `Generated cache key: ${key}`);
      return key;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to generate cache key');
      // Return a timestamp-based key as fallback
      return `fallback:${Date.now()}`;
    }
  }

  /**
   * Create a stable representation of an object
   * Ensures that the same object always produces the same string
   * regardless of property order
   */
  private createStableRepresentation(obj: any): string {
    if (obj === null || obj === undefined) {
      return '';
    }
    
    if (typeof obj !== 'object') {
      return String(obj);
    }
    
    if (Array.isArray(obj)) {
      return '[' + obj.map(item => this.createStableRepresentation(item)).join(',') + ']';
    }
    
    // Sort keys to ensure stable order
    const sortedKeys = Object.keys(obj).sort();
    
    return '{' + sortedKeys.map(key => {
      // Skip functions and undefined values
      if (typeof obj[key] === 'function' || obj[key] === undefined) {
        return '';
      }
      return `"${key}":${this.createStableRepresentation(obj[key])}`;
    }).filter(Boolean).join(',') + '}';
  }

  /**
   * Get a value from the cache
   */
  public async get<T>(key: string): Promise<T | null> {
    if (!this.enabled) {
      Logger.debug(MODULE_NAME, 'Cache is disabled, skipping get');
      return null;
    }
    
    try {
      // Check if initialized
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Cache not initialized, initializing now...');
        await this.initialize();
      }
      
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      // Try memory cache first
      const memoryEntry = this.memoryCache.get<T>(key);
      if (memoryEntry) {
        // Check if the entry is expired
        if (memoryEntry.expiresAt < Date.now()) {
          Logger.debug(MODULE_NAME, `Memory cache entry expired for key: ${key}`);
          this.memoryCache.delete(key);
          return null;
        }
        
        Logger.debug(MODULE_NAME, `Memory cache hit for key: ${key}`);
        return memoryEntry.data;
      }
      
      // Try persistent cache
      const persistentData = await this.persistentCache.get<T>(key);
      if (persistentData) {
        // Store in memory cache for faster access next time
        this.memoryCache.set(key, persistentData, this.defaultTtl);
        
        Logger.debug(MODULE_NAME, `Persistent cache hit for key: ${key}`);
        return persistentData;
      }
      
      Logger.debug(MODULE_NAME, `Cache miss for key: ${key}`);
      return null;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      return null;
    }
  }

  /**
   * Set a value in the cache
   */
  public async set<T>(key: string, data: T, ttl: number = this.defaultTtl): Promise<void> {
    if (!this.enabled) {
      Logger.debug(MODULE_NAME, 'Cache is disabled, skipping set');
      return;
    }
    
    if (data === null || data === undefined) {
      Logger.error(MODULE_NAME, `Cannot cache null or undefined data for key: ${key}`);
      return;
    }
    
    try {
      // Check if initialized
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Cache not initialized, initializing now...');
        await this.initialize();
      }
      
      Logger.debug(MODULE_NAME, `Setting cache entry with key: ${key}`);
      
      // Store in memory cache
      this.memoryCache.set(key, data, ttl);
      
      // Store in persistent cache
      await this.persistentCache.set(key, data, ttl);
      
      Logger.debug(MODULE_NAME, `Cache entry set for key: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to set cache entry: ${key}`);
      // If persistent cache fails, delete from memory cache to maintain consistency
      this.memoryCache.delete(key);
    }
  }

  /**
   * Delete a value from the cache
   */
  public async delete(key: string): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      
      // Delete from memory cache
      this.memoryCache.delete(key);
      
      // Delete from persistent cache
      await this.persistentCache.delete(key);
      
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
    }
  }

  /**
   * Delete all cache entries that match a pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      
      // Delete from memory cache
      const memoryCount = this.memoryCache.deleteByPattern(pattern);
      
      // Delete from persistent cache
      const persistentCount = await this.persistentCache.deleteByPattern(pattern);
      
      Logger.debug(MODULE_NAME, `Deleted ${memoryCount} memory cache entries and ${persistentCount} persistent cache entries matching pattern: ${pattern}`);
      return Math.max(memoryCount, persistentCount);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      return 0;
    }
  }

  /**
   * Clear all cache entries
   */
  public async clear(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      
      // Clear memory cache
      this.memoryCache.clear();
      
      // Clear persistent cache
      await this.persistentCache.clear();
      
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
    }
  }

  /**
   * Delete all cache entries for a specific user
   */
  public async deleteForUser(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entries for user: ${userId}`);
      
      // Delete from memory cache
      const memoryCount = this.memoryCache.deleteByPattern(`user:${userId}`);
      
      // Get all keys for the user from persistent cache
      const keys = await this.persistentCache.getKeysForUser(userId);
      
      // Delete each key from persistent cache
      for (const key of keys) {
        await this.persistentCache.delete(key);
      }
      
      Logger.debug(MODULE_NAME, `Deleted ${memoryCount} memory cache entries and ${keys.length} persistent cache entries for user: ${userId}`);
      return keys.length;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries for user: ${userId}`);
      return 0;
    }
  }

  /**
   * Prune the cache by removing expired entries
   */
  public async pruneCache(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Pruning cache');
      
      // Delete expired entries from memory cache
      const memoryCount = this.memoryCache.deleteExpired();
      
      // Delete expired entries from persistent cache
      const persistentCount = await this.persistentCache.deleteExpired();
      
      Logger.debug(MODULE_NAME, `Pruned ${memoryCount} memory cache entries and ${persistentCount} persistent cache entries`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to prune cache');
    }
  }

  /**
   * Load frequently accessed entries into memory cache
   */
  private async loadFrequentEntries(limit: number = 20): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Loading ${limit} most frequently accessed cache entries into memory`);
      
      // Get most frequently used entries from persistent cache
      const entries = await this.persistentCache.getMostFrequentlyUsed(limit);
      
      // Load each entry into memory cache
      for (const entry of entries) {
        try {
          const data = JSON.parse(entry.data);
          const ttl = entry.expires_at - Date.now();
          
          // Only load if not expired
          if (ttl > 0) {
            this.memoryCache.set(entry.key, data, ttl);
          }
        } catch (error) {
          Logger.logError(MODULE_NAME, error as Error, `Failed to parse data for key: ${entry.key}`);
        }
      }
      
      Logger.debug(MODULE_NAME, `Loaded ${entries.length} cache entries into memory`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to load frequent cache entries');
    }
  }
} 

================================================================================
File: src/services/ai/cache/index.ts
================================================================================

export { CacheManager } from './CacheManager';
export { MemoryCache } from './MemoryCache';
export { PersistentCache } from './PersistentCache'; 

================================================================================
File: src/services/ai/cache/MemoryCache.ts
================================================================================

import * as Logger from '../utils/logging';
import { CacheEntry, MAX_CACHE_SIZE } from '../types/common';

const MODULE_NAME = 'MemoryCache';

/**
 * In-memory cache implementation
 * Provides fast access to frequently used cache entries
 */
export class MemoryCache {
  private cache: Map<string, CacheEntry<any>> = new Map();
  private maxSize: number;

  constructor(maxSize: number = MAX_CACHE_SIZE) {
    this.maxSize = maxSize;
    Logger.debug(MODULE_NAME, `Initialized with max size: ${maxSize}`);
  }

  /**
   * Set the maximum size of the cache
   */
  public setMaxSize(size: number): void {
    this.maxSize = size;
    Logger.debug(MODULE_NAME, `Max size updated to: ${size}`);
    
    // If the current size exceeds the new max size, prune the cache
    if (this.cache.size > this.maxSize) {
      this.prune();
    }
  }

  /**
   * Get the current size of the cache
   */
  public size(): number {
    return this.cache.size;
  }

  /**
   * Check if the cache contains an entry with the given key
   */
  public has(key: string): boolean {
    return this.cache.has(key);
  }

  /**
   * Get an entry from the cache
   */
  public get<T>(key: string): CacheEntry<T> | undefined {
    const entry = this.cache.get(key) as CacheEntry<T> | undefined;
    
    if (entry) {
      // Update hit count and last accessed time
      entry.hitCount += 1;
      entry.lastAccessed = Date.now();
      Logger.debug(MODULE_NAME, `Cache hit for key: ${key}, hit count: ${entry.hitCount}`);
    } else {
      Logger.debug(MODULE_NAME, `Cache miss for key: ${key}`);
    }
    
    return entry;
  }

  /**
   * Set an entry in the cache
   */
  public set<T>(key: string, data: T, ttl: number): void {
    const now = Date.now();
    const expiresAt = now + ttl;
    
    // Check if we need to make room in the cache
    if (!this.cache.has(key) && this.cache.size >= this.maxSize) {
      this.evictOne();
    }
    
    // Create or update the cache entry
    this.cache.set(key, {
      key,
      data,
      timestamp: now,
      expiresAt,
      ttl,
      hitCount: 0,
      lastAccessed: now
    });
    
    Logger.debug(MODULE_NAME, `Set cache entry for key: ${key}, expires at: ${new Date(expiresAt).toISOString()}`);
  }

  /**
   * Delete an entry from the cache
   */
  public delete(key: string): boolean {
    const result = this.cache.delete(key);
    Logger.debug(MODULE_NAME, `Deleted cache entry for key: ${key}, success: ${result}`);
    return result;
  }

  /**
   * Clear all entries from the cache
   */
  public clear(): void {
    this.cache.clear();
    Logger.debug(MODULE_NAME, 'Cleared all cache entries');
  }

  /**
   * Get all keys in the cache
   */
  public keys(): string[] {
    return Array.from(this.cache.keys());
  }

  /**
   * Get all entries in the cache
   */
  public entries<T>(): Array<[string, CacheEntry<T>]> {
    return Array.from(this.cache.entries()) as Array<[string, CacheEntry<T>]>;
  }

  /**
   * Delete all entries that match a pattern
   */
  public deleteByPattern(pattern: string): number {
    let count = 0;
    const regex = new RegExp(pattern);
    
    // Convert keys iterator to array before iterating
    const keys = Array.from(this.cache.keys());
    for (const key of keys) {
      if (regex.test(key)) {
        this.cache.delete(key);
        count++;
      }
    }
    
    Logger.debug(MODULE_NAME, `Deleted ${count} entries matching pattern: ${pattern}`);
    return count;
  }

  /**
   * Delete all expired entries
   */
  public deleteExpired(): number {
    let count = 0;
    const now = Date.now();
    
    // Convert entries iterator to array before iterating
    const entries = Array.from(this.cache.entries());
    for (const [key, entry] of entries) {
      if (entry.expiresAt <= now) {
        this.cache.delete(key);
        count++;
      }
    }
    
    Logger.debug(MODULE_NAME, `Deleted ${count} expired entries`);
    return count;
  }

  /**
   * Prune the cache to the maximum size
   */
  private prune(): void {
    if (this.cache.size <= this.maxSize) {
      return;
    }
    
    const entriesToRemove = this.cache.size - this.maxSize;
    Logger.debug(MODULE_NAME, `Pruning cache, removing ${entriesToRemove} entries`);
    
    // Sort entries by last accessed time (oldest first)
    const sortedEntries = Array.from(this.cache.entries())
      .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);
    
    // Remove the oldest entries
    for (let i = 0; i < entriesToRemove; i++) {
      this.cache.delete(sortedEntries[i][0]);
    }
  }

  /**
   * Evict one entry from the cache
   * Uses a combination of last accessed time and hit count to determine which entry to evict
   */
  private evictOne(): void {
    if (this.cache.size === 0) {
      return;
    }
    
    Logger.debug(MODULE_NAME, 'Evicting one entry from cache');
    
    // Sort entries by a score that combines last accessed time and hit count
    // Lower score = better candidate for eviction
    const now = Date.now();
    const sortedEntries = Array.from(this.cache.entries())
      .map(([key, entry]) => {
        // Calculate a score based on recency and popularity
        // More recent access and higher hit count = higher score = less likely to be evicted
        const recency = (now - entry.lastAccessed) / 1000; // seconds since last access
        const popularity = Math.log1p(entry.hitCount); // logarithmic scaling of hit count
        const score = popularity / recency; // higher hit count and more recent = higher score
        return { key, score };
      })
      .sort((a, b) => a.score - b.score); // sort by score (ascending)
    
    // Evict the entry with the lowest score
    const keyToEvict = sortedEntries[0].key;
    this.cache.delete(keyToEvict);
    Logger.debug(MODULE_NAME, `Evicted cache entry for key: ${keyToEvict}`);
  }
} 

================================================================================
File: src/services/ai/cache/PersistentCache.ts
================================================================================

import * as Logger from '../utils/logging';
import { CacheRepository } from '../database/repositories/CacheRepository';
import { CacheDbEntry } from '../types/common';
import { DatabaseManager } from '../database/DatabaseManager';

const MODULE_NAME = 'PersistentCache';

/**
 * Persistent cache implementation using SQLite
 * Provides durable storage for cache entries
 */
export class PersistentCache {
  private repository: CacheRepository;
  private initialized: boolean = false;

  constructor() {
    this.repository = new CacheRepository();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Initialize the persistent cache
   */
  private async ensureInitialized(): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      // Make sure the database is initialized
      await DatabaseManager.getInstance().initialize();
      this.initialized = true;
      Logger.debug(MODULE_NAME, 'Database initialized');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database');
      throw new Error('Cache database not initialized');
    }
  }

  /**
   * Store an entry in the persistent cache
   */
  public async set(key: string, data: any, ttl: number): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Storing cache entry with key: ${key}`);
      
      // Validate data before storing
      if (data === null || data === undefined) {
        Logger.error(MODULE_NAME, `Cannot store null or undefined data for key: ${key}`);
        throw new Error('Cannot store null or undefined data in cache');
      }
      
      const now = Date.now();
      const expiresAt = now + ttl;
      
      // Serialize data to JSON string
      let serializedData: string;
      try {
        serializedData = JSON.stringify(data);
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, `Failed to serialize data for key: ${key}`);
        throw new Error(`Failed to serialize data for cache key: ${key}`);
      }
      
      // Store in persistent cache
      await this.repository.storeResponse(key, serializedData, now, expiresAt, ttl);
      
      Logger.debug(MODULE_NAME, `Cache entry stored successfully: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Get an entry from the persistent cache
   */
  public async get<T>(key: string): Promise<T | null> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      const entry = await this.repository.getResponse(key);
      
      if (!entry) {
        Logger.debug(MODULE_NAME, `No cache entry found for key: ${key}`);
        return null;
      }
      
      // Check if the entry is expired
      if (entry.expires_at < Date.now()) {
        Logger.debug(MODULE_NAME, `Cache entry expired for key: ${key}`);
        await this.delete(key);
        return null;
      }
      
      // Update hit count and last accessed time
      await this.repository.updateStats(key, entry.hit_count + 1, Date.now());
      
      // Parse the serialized data
      try {
        const data = JSON.parse(entry.data) as T;
        Logger.debug(MODULE_NAME, `Cache hit for key: ${key}`);
        return data;
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, `Failed to parse data for key: ${key}`);
        await this.delete(key);
        return null;
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      return null;
    }
  }

  /**
   * Delete an entry from the persistent cache
   */
  public async delete(key: string): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      await this.repository.deleteEntry(key);
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Delete entries by pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      const count = await this.repository.deleteByPattern(pattern);
      Logger.debug(MODULE_NAME, `Deleted ${count} cache entries matching pattern: ${pattern}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      throw error;
    }
  }

  /**
   * Clear all entries from the persistent cache
   */
  public async clear(): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      await this.repository.clearAll();
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
      throw error;
    }
  }

  /**
   * Delete expired entries
   */
  public async deleteExpired(): Promise<number> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, 'Deleting expired cache entries');
      const count = await this.repository.deleteExpired();
      Logger.debug(MODULE_NAME, `Deleted ${count} expired cache entries`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to delete expired cache entries');
      throw error;
    }
  }

  /**
   * Get the most frequently used cache entries
   */
  public async getMostFrequentlyUsed(limit: number): Promise<CacheDbEntry[]> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting ${limit} most frequently used cache entries`);
      const entries = await this.repository.getMostFrequentlyUsed(limit);
      Logger.debug(MODULE_NAME, `Found ${entries.length} most frequently used cache entries`);
      return entries;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get most frequently used cache entries');
      throw error;
    }
  }

  /**
   * Get all keys for a specific user
   */
  public async getKeysForUser(userId: string): Promise<string[]> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting cache keys for user: ${userId}`);
      const keyEntries = await this.repository.getKeysForUser(userId);
      const keys = keyEntries.map(entry => entry.key);
      Logger.debug(MODULE_NAME, `Found ${keys.length} cache keys for user: ${userId}`);
      return keys;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache keys for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/database/DatabaseManager.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import * as FileSystem from 'expo-file-system';
import * as Logger from '../utils/logging';

// Import constants
import { 
  AI_USAGE_DB_NAME, 
  RECOMMENDATION_FEEDBACK_DB_NAME, 
  CACHE_DB_NAME 
} from '../types/common';

const MODULE_NAME = 'DatabaseManager';

/**
 * Database Manager class
 * Handles database connections and initialization
 */
export class DatabaseManager {
  private static instance: DatabaseManager;
  private usageDb: SQLiteDatabase | null = null;
  private feedbackDb: SQLiteDatabase | null = null;
  private cacheDb: SQLiteDatabase | null = null;
  private initialized: boolean = false;

  private constructor() {
    // Private constructor to enforce singleton pattern
  }

  /**
   * Get the singleton instance of DatabaseManager
   */
  public static getInstance(): DatabaseManager {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new DatabaseManager();
    }
    return DatabaseManager.instance;
  }

  /**
   * Initialize all databases
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Databases already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing databases...');
      
      // Initialize usage database
      try {
        this.usageDb = await this.openDatabase(AI_USAGE_DB_NAME);
        await this.initializeUsageDb();
        Logger.info(MODULE_NAME, 'Usage database initialized successfully');
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize usage database');
      }
      
      // Initialize feedback database
      try {
        this.feedbackDb = await this.openDatabase(RECOMMENDATION_FEEDBACK_DB_NAME);
        await this.initializeFeedbackDb();
        Logger.info(MODULE_NAME, 'Feedback database initialized successfully');
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback database');
      }
      
      // Initialize cache database
      try {
        this.cacheDb = await this.openDatabase(CACHE_DB_NAME);
        await this.initializeCacheDb();
        Logger.info(MODULE_NAME, 'Cache database initialized successfully');
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize cache database');
      }
      
      // Mark as initialized if at least one database was successfully initialized
      if (this.usageDb || this.feedbackDb || this.cacheDb) {
        this.initialized = true;
        Logger.info(MODULE_NAME, 'Database initialization completed with some databases available');
      } else {
        Logger.error(MODULE_NAME, 'Failed to initialize any databases');
        throw new Error('Failed to initialize any databases');
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize databases');
      throw error;
    }
  }

  /**
   * Get the usage database instance
   */
  public getUsageDb(): SQLiteDatabase {
    if (!this.usageDb) {
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Database not initialized, attempting to initialize now');
        this.initialize().catch(error => {
          Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database on demand');
        });
      }
      throw new Error('Usage database not initialized');
    }
    return this.usageDb;
  }

  /**
   * Get the feedback database instance
   */
  public getFeedbackDb(): SQLiteDatabase {
    if (!this.feedbackDb) {
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Database not initialized, attempting to initialize now');
        this.initialize().catch(error => {
          Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database on demand');
        });
      }
      throw new Error('Feedback database not initialized');
    }
    return this.feedbackDb;
  }

  /**
   * Get the cache database instance
   */
  public getCacheDb(): SQLiteDatabase {
    if (!this.cacheDb) {
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Database not initialized, attempting to initialize now');
        this.initialize().catch(error => {
          Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize database on demand');
        });
      }
      throw new Error('Cache database not initialized');
    }
    return this.cacheDb;
  }

  /**
   * Open a database with the given name
   */
  private async openDatabase(dbName: string): Promise<SQLiteDatabase> {
    try {
      Logger.debug(MODULE_NAME, `Opening database: ${dbName}`);
      return await openDatabaseAsync(dbName);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to open database: ${dbName}`);
      throw error;
    }
  }

  /**
   * Initialize the usage database schema
   */
  private async initializeUsageDb(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Initializing usage database schema');
      await this.usageDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS ai_usage (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id TEXT NOT NULL,
          request_type TEXT NOT NULL,
          tokens_used INTEGER NOT NULL,
          timestamp INTEGER NOT NULL
        );
      `);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize usage database schema');
      throw error;
    }
  }

  /**
   * Initialize the feedback database schema
   */
  private async initializeFeedbackDb(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Initializing feedback database schema');
      
      // Create user feedback table
      await this.feedbackDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS user_feedback (
          id TEXT PRIMARY KEY,
          user_id TEXT NOT NULL,
          response_id TEXT NOT NULL,
          response_type TEXT NOT NULL,
          helpful INTEGER NOT NULL,
          accurate INTEGER NOT NULL,
          relevance INTEGER NOT NULL,
          comments TEXT,
          timestamp INTEGER NOT NULL
        );
      `);
      
      // Create response quality scores table
      await this.feedbackDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS response_quality_scores (
          id TEXT PRIMARY KEY,
          response_id TEXT NOT NULL,
          overall_score REAL NOT NULL,
          relevance_score REAL NOT NULL,
          accuracy_score REAL NOT NULL,
          comprehensiveness_score REAL NOT NULL,
          safety_score REAL NOT NULL,
          strengths TEXT NOT NULL,
          weaknesses TEXT NOT NULL,
          improvement_suggestions TEXT NOT NULL,
          timestamp INTEGER NOT NULL
        );
      `);
      
      // Create feedback patterns table
      await this.feedbackDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS feedback_patterns (
          pattern_id TEXT PRIMARY KEY,
          response_type TEXT NOT NULL,
          user_profile_factors TEXT NOT NULL,
          request_factors TEXT NOT NULL,
          positive_outcome_rate REAL NOT NULL,
          sample_size INTEGER NOT NULL,
          last_updated INTEGER NOT NULL
        );
      `);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback database schema');
      throw error;
    }
  }

  /**
   * Initialize the cache database schema
   */
  private async initializeCacheDb(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Initializing cache database schema');
      await this.cacheDb?.execAsync(`
        CREATE TABLE IF NOT EXISTS ai_response_cache (
          key TEXT PRIMARY KEY,
          data TEXT NOT NULL,
          timestamp INTEGER NOT NULL,
          expires_at INTEGER NOT NULL,
          ttl INTEGER NOT NULL,
          hit_count INTEGER NOT NULL DEFAULT 0,
          last_accessed INTEGER NOT NULL
        );
      `);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize cache database schema');
      throw error;
    }
  }

  /**
   * Close all database connections
   */
  public async closeAll(): Promise<void> {
    try {
      Logger.info(MODULE_NAME, 'Closing all database connections');
      
      if (this.usageDb) {
        await this.usageDb.closeAsync();
        this.usageDb = null;
      }
      
      if (this.feedbackDb) {
        await this.feedbackDb.closeAsync();
        this.feedbackDb = null;
      }
      
      if (this.cacheDb) {
        await this.cacheDb.closeAsync();
        this.cacheDb = null;
      }
      
      this.initialized = false;
      Logger.info(MODULE_NAME, 'All database connections closed');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to close database connections');
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/database/repositories/CacheRepository.ts
================================================================================

import { SQLiteDatabase } from "expo-sqlite";
import { DatabaseManager } from "../DatabaseManager";
import * as Logger from '../../utils/logging';
import { CacheDbEntry, KeyEntry, CountResult } from '../../types/common';

const MODULE_NAME = 'CacheRepository';

/**
 * Repository for cache database operations
 */
export class CacheRepository {
  private db: SQLiteDatabase | null = null;

  constructor() {
    try {
      this.db = DatabaseManager.getInstance().getCacheDb();
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get cache database');
    }
  }

  /**
   * Ensure database is available
   */
  private ensureDatabase(): SQLiteDatabase {
    if (!this.db) {
      try {
        this.db = DatabaseManager.getInstance().getCacheDb();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to get cache database');
        throw new Error('Cache database not initialized');
      }
    }
    return this.db;
  }

  /**
   * Store a response in the cache
   */
  public async storeResponse(
    key: string, 
    data: string, 
    timestamp: number, 
    expiresAt: number, 
    ttl: number
  ): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Storing cache entry with key: ${key}`);
      
      // Validate data before storing
      if (!data) {
        Logger.error(MODULE_NAME, `Cannot store null or empty data for key: ${key}`);
        throw new Error('Cannot store null or empty data in cache');
      }
      
      const now = Date.now();
      
      await db.getAllAsync(`
        INSERT OR REPLACE INTO ai_response_cache (
          key, 
          data, 
          timestamp, 
          expires_at, 
          ttl, 
          hit_count, 
          last_accessed
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `, [key, data, timestamp, expiresAt, ttl, 0, now]);
      
      Logger.debug(MODULE_NAME, `Cache entry stored successfully: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Get a response from the cache by key
   */
  public async getResponse(key: string): Promise<CacheDbEntry | null> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      const results = await db.getAllAsync<CacheDbEntry>(`
        SELECT * FROM ai_response_cache WHERE key = ?
      `, [key]);
      
      if (results.length === 0) {
        Logger.debug(MODULE_NAME, `No cache entry found for key: ${key}`);
        return null;
      }
      
      Logger.debug(MODULE_NAME, `Cache entry found for key: ${key}`);
      return results[0];
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Update cache entry statistics
   */
  public async updateStats(key: string, hitCount: number, lastAccessed: number): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Updating stats for cache entry: ${key}`);
      
      await db.getAllAsync(`
        UPDATE ai_response_cache 
        SET hit_count = ?, last_accessed = ? 
        WHERE key = ?
      `, [hitCount, lastAccessed, key]);
      
      Logger.debug(MODULE_NAME, `Stats updated for cache entry: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to update stats for cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Delete a cache entry by key
   */
  public async deleteEntry(key: string): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      
      await db.getAllAsync(`
        DELETE FROM ai_response_cache WHERE key = ?
      `, [key]);
      
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Delete cache entries by pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      
      // First get the keys that match the pattern
      const keys = await db.getAllAsync<KeyEntry>(`
        SELECT key FROM ai_response_cache WHERE key LIKE ?
      `, [`%${pattern}%`]);
      
      if (keys.length === 0) {
        Logger.debug(MODULE_NAME, `No cache entries found matching pattern: ${pattern}`);
        return 0;
      }
      
      // Delete the entries
      await db.getAllAsync(`
        DELETE FROM ai_response_cache WHERE key LIKE ?
      `, [`%${pattern}%`]);
      
      Logger.debug(MODULE_NAME, `Deleted ${keys.length} cache entries matching pattern: ${pattern}`);
      return keys.length;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      throw error;
    }
  }

  /**
   * Clear all cache entries
   */
  public async clearAll(): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      
      await db.getAllAsync(`DELETE FROM ai_response_cache`);
      
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
      throw error;
    }
  }

  /**
   * Get the total number of cache entries
   */
  public async getCount(): Promise<number> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, 'Getting cache entry count');
      
      const result = await db.getAllAsync<CountResult>(`
        SELECT COUNT(*) as count FROM ai_response_cache
      `);
      
      Logger.debug(MODULE_NAME, `Cache entry count: ${result[0].count}`);
      return result[0].count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get cache entry count');
      throw error;
    }
  }

  /**
   * Delete expired cache entries
   */
  public async deleteExpired(): Promise<number> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, 'Deleting expired cache entries');
      
      const now = Date.now();
      
      // First get the keys that are expired
      const keys = await db.getAllAsync<KeyEntry>(`
        SELECT key FROM ai_response_cache WHERE expires_at < ?
      `, [now]);
      
      if (keys.length === 0) {
        Logger.debug(MODULE_NAME, 'No expired cache entries found');
        return 0;
      }
      
      // Delete the expired entries
      await db.getAllAsync(`
        DELETE FROM ai_response_cache WHERE expires_at < ?
      `, [now]);
      
      Logger.debug(MODULE_NAME, `Deleted ${keys.length} expired cache entries`);
      return keys.length;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to delete expired cache entries');
      throw error;
    }
  }

  /**
   * Get the least recently used cache entries
   */
  public async getLeastRecentlyUsed(limit: number): Promise<KeyEntry[]> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Getting ${limit} least recently used cache entries`);
      
      const keys = await db.getAllAsync<KeyEntry>(`
        SELECT key FROM ai_response_cache 
        ORDER BY last_accessed ASC 
        LIMIT ?
      `, [limit]);
      
      Logger.debug(MODULE_NAME, `Found ${keys.length} least recently used cache entries`);
      return keys;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get least recently used cache entries');
      throw error;
    }
  }

  /**
   * Get the most frequently used cache entries
   */
  public async getMostFrequentlyUsed(limit: number): Promise<CacheDbEntry[]> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Getting ${limit} most frequently used cache entries`);
      
      const entries = await db.getAllAsync<CacheDbEntry>(`
        SELECT * FROM ai_response_cache 
        ORDER BY hit_count DESC 
        LIMIT ?
      `, [limit]);
      
      Logger.debug(MODULE_NAME, `Found ${entries.length} most frequently used cache entries`);
      return entries;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get most frequently used cache entries');
      throw error;
    }
  }

  /**
   * Get all keys for a specific user
   */
  public async getKeysForUser(userId: string): Promise<KeyEntry[]> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Getting cache keys for user: ${userId}`);
      
      const keys = await db.getAllAsync<KeyEntry>(`
        SELECT key FROM ai_response_cache 
        WHERE key LIKE ?
      `, [`%user:${userId}%`]);
      
      Logger.debug(MODULE_NAME, `Found ${keys.length} cache keys for user: ${userId}`);
      return keys;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache keys for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/database/repositories/FeedbackRepository.ts
================================================================================

import { SQLiteDatabase } from "expo-sqlite";
import { DatabaseManager } from "../DatabaseManager";
import * as Logger from '../../utils/logging';
import { UserFeedback, QualityScore, FeedbackPattern } from '../../types/feedback';
import { FeedbackStats, PatternEntry, QualityStats } from '../../types/feedback';

const MODULE_NAME = 'FeedbackRepository';

/**
 * Repository for feedback database operations
 */
export class FeedbackRepository {
  private db: SQLiteDatabase | null = null;

  constructor() {
    try {
      this.db = DatabaseManager.getInstance().getFeedbackDb();
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get feedback database');
    }
  }

  /**
   * Ensure database is available
   */
  private ensureDatabase(): SQLiteDatabase {
    if (!this.db) {
      try {
        this.db = DatabaseManager.getInstance().getFeedbackDb();
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to get feedback database');
        throw new Error('Feedback database not initialized');
      }
    }
    return this.db;
  }

  /**
   * Store user feedback
   */
  public async storeFeedback(feedback: UserFeedback, feedbackId: string = `fb_${Date.now()}`): Promise<string> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Storing feedback for response: ${feedback.responseId}`);
      
      await db.getAllAsync(`
        INSERT OR REPLACE INTO user_feedback (
          id,
          user_id,
          response_id,
          response_type,
          helpful,
          accurate,
          relevance,
          comments,
          timestamp
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        feedbackId,
        feedback.userId,
        feedback.responseId,
        feedback.responseType,
        feedback.helpful ? 1 : 0,
        feedback.accurate ? 1 : 0,
        feedback.relevance,
        feedback.comments || null,
        feedback.timestamp
      ]);
      
      Logger.debug(MODULE_NAME, `Feedback stored with ID: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store feedback for response: ${feedback.responseId}`);
      throw error;
    }
  }

  /**
   * Store quality score
   */
  public async storeQualityScore(
    evaluationId: string,
    responseId: string,
    qualityScore: QualityScore
  ): Promise<void> {
    try {
      const db = this.ensureDatabase();
      Logger.debug(MODULE_NAME, `Storing quality score for response: ${responseId}`);
      
      await db.getAllAsync(`
        INSERT OR REPLACE INTO response_quality_scores (
          id,
          response_id,
          overall_score,
          relevance_score,
          accuracy_score,
          comprehensiveness_score,
          safety_score,
          strengths,
          weaknesses,
          improvement_suggestions,
          timestamp
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        evaluationId,
        responseId,
        qualityScore.overallScore,
        qualityScore.relevanceScore,
        qualityScore.accuracyScore,
        qualityScore.comprehensivenessScore,
        qualityScore.safetyScore,
        JSON.stringify(qualityScore.strengths),
        JSON.stringify(qualityScore.weaknesses),
        JSON.stringify(qualityScore.improvementSuggestions),
        Date.now()
      ]);
      
      Logger.debug(MODULE_NAME, `Quality score stored for response: ${responseId}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store quality score for response: ${responseId}`);
      throw error;
    }
  }

  /**
   * Store or update feedback pattern
   */
  public async storePattern(pattern: FeedbackPattern): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Storing feedback pattern: ${pattern.patternId}`);
      
      await this.db.getAllAsync(`
        INSERT OR REPLACE INTO feedback_patterns (
          pattern_id,
          response_type,
          user_profile_factors,
          request_factors,
          positive_outcome_rate,
          sample_size,
          last_updated
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `, [
        pattern.patternId,
        pattern.responseType,
        JSON.stringify(pattern.userProfileFactors),
        JSON.stringify(pattern.requestFactors),
        pattern.positiveOutcomeRate,
        pattern.sampleSize,
        pattern.lastUpdated
      ]);
      
      Logger.debug(MODULE_NAME, `Feedback pattern stored: ${pattern.patternId}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store feedback pattern: ${pattern.patternId}`);
      throw error;
    }
  }

  /**
   * Get feedback pattern by ID
   */
  public async getPattern(patternId: string): Promise<PatternEntry | null> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback pattern: ${patternId}`);
      
      const results = await this.db.getAllAsync<PatternEntry>(`
        SELECT 
          pattern_id,
          user_profile_factors,
          request_factors,
          positive_outcome_rate,
          sample_size
        FROM feedback_patterns 
        WHERE pattern_id = ?
      `, [patternId]);
      
      if (results.length === 0) {
        Logger.debug(MODULE_NAME, `No feedback pattern found for ID: ${patternId}`);
        return null;
      }
      
      Logger.debug(MODULE_NAME, `Feedback pattern found: ${patternId}`);
      return results[0];
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback pattern: ${patternId}`);
      throw error;
    }
  }

  /**
   * Get all feedback for a user
   */
  public async getUserFeedback(userId: string): Promise<UserFeedback[]> {
    try {
      Logger.debug(MODULE_NAME, `Getting all feedback for user: ${userId}`);
      
      // Define the interface for the raw database results
      interface RawFeedbackRow {
        userId: string;
        responseId: string;
        responseType: 'recommendation' | 'chat';
        helpful: number;
        accurate: number;
        relevance: number;
        comments?: string;
        timestamp: number;
      }
      
      const results = await this.db.getAllAsync<RawFeedbackRow>(`
        SELECT 
          user_id as userId,
          response_id as responseId,
          response_type as responseType,
          helpful,
          accurate,
          relevance,
          comments,
          timestamp
        FROM user_feedback 
        WHERE user_id = ?
        ORDER BY timestamp DESC
      `, [userId]);
      
      // Convert boolean fields from SQLite integers
      const feedback: UserFeedback[] = results.map(row => ({
        userId: row.userId,
        responseId: row.responseId,
        responseType: row.responseType,
        helpful: row.helpful === 1,
        accurate: row.accurate === 1,
        relevance: row.relevance,
        comments: row.comments,
        timestamp: row.timestamp
      }));
      
      Logger.debug(MODULE_NAME, `Found ${feedback.length} feedback entries for user: ${userId}`);
      return feedback;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get feedback statistics for a user
   */
  public async getUserFeedbackStats(userId: string): Promise<FeedbackStats> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback stats for user: ${userId}`);
      
      const results = await this.db.getAllAsync<FeedbackStats>(`
        SELECT 
          COUNT(*) as total,
          SUM(CASE WHEN helpful = 1 THEN 1 ELSE 0 END) as positive,
          SUM(relevance) as relevance_sum
        FROM user_feedback 
        WHERE user_id = ?
      `, [userId]);
      
      Logger.debug(MODULE_NAME, `Retrieved feedback stats for user: ${userId}`);
      return results[0];
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback stats for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get quality score statistics
   */
  public async getQualityScoreStats(): Promise<QualityStats> {
    try {
      Logger.debug(MODULE_NAME, 'Getting quality score statistics');
      
      const results = await this.db.getAllAsync<QualityStats>(`
        SELECT 
          AVG(overall_score) as avg_overall,
          AVG(relevance_score) as avg_relevance,
          AVG(safety_score) as avg_safety,
          COUNT(*) as total
        FROM response_quality_scores
      `);
      
      Logger.debug(MODULE_NAME, 'Retrieved quality score statistics');
      return results[0];
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get quality score statistics');
      throw error;
    }
  }

  /**
   * Get all patterns for a response type
   */
  public async getPatternsByType(responseType: string): Promise<PatternEntry[]> {
    try {
      Logger.debug(MODULE_NAME, `Getting patterns for response type: ${responseType}`);
      
      const results = await this.db.getAllAsync<PatternEntry>(`
        SELECT 
          pattern_id,
          user_profile_factors,
          request_factors,
          positive_outcome_rate,
          sample_size
        FROM feedback_patterns 
        WHERE response_type = ?
        ORDER BY positive_outcome_rate DESC
      `, [responseType]);
      
      Logger.debug(MODULE_NAME, `Found ${results.length} patterns for response type: ${responseType}`);
      return results;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get patterns for response type: ${responseType}`);
      throw error;
    }
  }

  /**
   * Delete all feedback for a user
   */
  public async deleteUserFeedback(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting all feedback for user: ${userId}`);
      
      // First count how many entries will be deleted
      const countResult = await this.db.getAllAsync<{ count: number }>(`
        SELECT COUNT(*) as count FROM user_feedback WHERE user_id = ?
      `, [userId]);
      
      const count = countResult[0].count;
      
      // Delete the entries
      await this.db.getAllAsync(`
        DELETE FROM user_feedback WHERE user_id = ?
      `, [userId]);
      
      Logger.debug(MODULE_NAME, `Deleted ${count} feedback entries for user: ${userId}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete feedback for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/feedback/FeedbackService.ts
================================================================================

import * as Logger from '../utils/logging';
import { FeedbackRepository } from '../database/repositories/FeedbackRepository';
import { UserFeedback, QualityScore, FeedbackPattern } from '../types/feedback';
import { AnthropicAPI } from '../api/AnthropicAPI';

const MODULE_NAME = 'FeedbackService';

/**
 * Feedback Service
 * Handles user feedback and response quality evaluation
 */
export class FeedbackService {
  private static instance: FeedbackService;
  private repository: FeedbackRepository;
  private api: AnthropicAPI;
  private initialized: boolean = false;

  private constructor() {
    this.repository = new FeedbackRepository();
    this.api = new AnthropicAPI();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of FeedbackService
   */
  public static getInstance(): FeedbackService {
    if (!FeedbackService.instance) {
      FeedbackService.instance = new FeedbackService();
    }
    return FeedbackService.instance;
  }

  /**
   * Initialize the feedback service
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing feedback service');
      this.initialized = true;
      Logger.info(MODULE_NAME, 'Feedback service initialized successfully');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback service');
      throw error;
    }
  }

  /**
   * Submit user feedback
   */
  public async submitFeedback(feedback: UserFeedback): Promise<string> {
    try {
      Logger.info(MODULE_NAME, `Submitting feedback for response: ${feedback.responseId}`);
      
      // Generate a unique ID for the feedback
      const feedbackId = `fb_${Date.now()}`;
      
      // Store the feedback
      await this.repository.storeFeedback(feedback, feedbackId);
      
      // Evaluate the response quality in the background
      this.evaluateResponseQuality(feedback.responseId, feedback.responseType)
        .catch(error => {
          Logger.logError(MODULE_NAME, error as Error, `Failed to evaluate response quality for: ${feedback.responseId}`);
        });
      
      // Extract feedback patterns in the background
      this.extractFeedbackPatterns(feedback)
        .catch(error => {
          Logger.logError(MODULE_NAME, error as Error, `Failed to extract feedback patterns for: ${feedback.responseId}`);
        });
      
      Logger.info(MODULE_NAME, `Feedback submitted successfully: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit feedback for response: ${feedback.responseId}`);
      throw error;
    }
  }

  /**
   * Evaluate the quality of a response
   */
  public async evaluateResponseQuality(
    responseId: string,
    responseType: 'recommendation' | 'chat',
    responseData?: any
  ): Promise<QualityScore> {
    try {
      Logger.info(MODULE_NAME, `Evaluating quality for response: ${responseId}`);
      
      // Generate a unique ID for the evaluation
      const evaluationId = `eval_${Date.now()}`;
      
      // If we have an API key and want to use the real API
      const useRealApi = false; // Set to true to use the real API
      
      if (useRealApi) {
        // Format the evaluation prompt
        const prompt = `
          You are an expert evaluator of AI responses for a cannabis recommendation app.
          Please evaluate the following ${responseType} response:
          
          ${JSON.stringify(responseData)}
          
          Provide a quality score on a scale of 0-100 for the following aspects:
          - Overall quality
          - Relevance to user needs
          - Accuracy of information
          - Comprehensiveness
          - Safety considerations
          
          Also list:
          - 3 strengths of the response
          - 3 weaknesses of the response
          - 3 suggestions for improvement
          
          Format your response as a JSON object with the following structure:
          {
            "overallScore": number,
            "relevanceScore": number,
            "accuracyScore": number,
            "comprehensivenessScore": number,
            "safetyScore": number,
            "strengths": string[],
            "weaknesses": string[],
            "improvementSuggestions": string[]
          }
        `;
        
        // Call the API
        const response = await this.api.sendMessage([
          { role: 'user', content: prompt }
        ], 2000, 0.3);
        
        // Parse the response
        const qualityScore = JSON.parse(response) as QualityScore;
        
        // Store the quality score
        await this.repository.storeQualityScore(evaluationId, responseId, qualityScore);
        
        Logger.info(MODULE_NAME, `Quality evaluation completed for response: ${responseId}`);
        return qualityScore;
      } else {
        // For testing or when API is not available, generate a mock quality score
        const mockQualityScore: QualityScore = {
          overallScore: 85,
          relevanceScore: 80,
          accuracyScore: 90,
          comprehensivenessScore: 85,
          safetyScore: 95,
          strengths: [
            'Provides detailed information about the recommended strains',
            'Includes safety considerations and dosage guidelines',
            'Explains the reasoning behind the recommendations'
          ],
          weaknesses: [
            'Could provide more context about potential side effects',
            'Limited information about alternative options',
            'Dosage recommendations could be more personalized'
          ],
          improvementSuggestions: [
            'Include more information about potential side effects',
            'Provide alternative recommendations for different scenarios',
            'Enhance personalization of dosage recommendations'
          ]
        };
        
        // Store the mock quality score
        await this.repository.storeQualityScore(evaluationId, responseId, mockQualityScore);
        
        Logger.info(MODULE_NAME, `Mock quality evaluation completed for response: ${responseId}`);
        return mockQualityScore;
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to evaluate quality for response: ${responseId}`);
      
      // Return a default quality score in case of error
      return {
        overallScore: 70,
        relevanceScore: 70,
        accuracyScore: 70,
        comprehensivenessScore: 70,
        safetyScore: 70,
        strengths: ['Not evaluated due to error'],
        weaknesses: ['Not evaluated due to error'],
        improvementSuggestions: ['Not evaluated due to error']
      };
    }
  }

  /**
   * Extract feedback patterns from user feedback
   */
  private async extractFeedbackPatterns(feedback: UserFeedback): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Extracting feedback patterns for response: ${feedback.responseId}`);
      
      // In a real implementation, this would analyze the feedback and extract patterns
      // For now, we'll just create a simple pattern based on the feedback
      
      // Create a pattern ID based on user profile and request factors
      const patternId = `pattern_${feedback.responseType}_${Date.now()}`;
      
      // Check if the pattern already exists
      const existingPattern = await this.repository.getPattern(patternId);
      
      if (existingPattern) {
        // Update the existing pattern
        const updatedPattern: FeedbackPattern = {
          patternId,
          responseType: feedback.responseType,
          userProfileFactors: { userId: feedback.userId },
          requestFactors: { responseId: feedback.responseId },
          positiveOutcomeRate: feedback.helpful ? 1 : 0,
          sampleSize: 1,
          lastUpdated: Date.now()
        };
        
        await this.repository.storePattern(updatedPattern);
      } else {
        // Create a new pattern
        const newPattern: FeedbackPattern = {
          patternId,
          responseType: feedback.responseType,
          userProfileFactors: { userId: feedback.userId },
          requestFactors: { responseId: feedback.responseId },
          positiveOutcomeRate: feedback.helpful ? 1 : 0,
          sampleSize: 1,
          lastUpdated: Date.now()
        };
        
        await this.repository.storePattern(newPattern);
      }
      
      Logger.debug(MODULE_NAME, `Feedback patterns extracted for response: ${feedback.responseId}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to extract feedback patterns for response: ${feedback.responseId}`);
    }
  }

  /**
   * Get all feedback for a user
   */
  public async getUserFeedback(userId: string): Promise<UserFeedback[]> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback for user: ${userId}`);
      const feedback = await this.repository.getUserFeedback(userId);
      Logger.debug(MODULE_NAME, `Found ${feedback.length} feedback entries for user: ${userId}`);
      return feedback;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get feedback statistics for a user
   */
  public async getUserFeedbackStats(userId: string): Promise<any> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback stats for user: ${userId}`);
      const stats = await this.repository.getUserFeedbackStats(userId);
      Logger.debug(MODULE_NAME, `Retrieved feedback stats for user: ${userId}`);
      return stats;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback stats for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get quality score statistics
   */
  public async getQualityScoreStats(): Promise<any> {
    try {
      Logger.debug(MODULE_NAME, 'Getting quality score statistics');
      const stats = await this.repository.getQualityScoreStats();
      Logger.debug(MODULE_NAME, 'Retrieved quality score statistics');
      return stats;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get quality score statistics');
      throw error;
    }
  }

  /**
   * Delete all feedback for a user
   */
  public async deleteUserFeedback(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting feedback for user: ${userId}`);
      const count = await this.repository.deleteUserFeedback(userId);
      Logger.debug(MODULE_NAME, `Deleted ${count} feedback entries for user: ${userId}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete feedback for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/feedback/index.ts
================================================================================

export { FeedbackService } from './FeedbackService'; 

================================================================================
File: src/services/ai/index.ts
================================================================================

export { AIService } from './AIService';

// Export sub-modules
export * from './api';
export * from './cache/index';
export * from './feedback';
export * from './types/common';
export * from './types/errors';
export * from './types/feedback';
export * from './types/requests';
export * from './types/responses'; 

================================================================================
File: src/services/ai/types/common.ts
================================================================================

// Constants
export const AI_USAGE_DB_NAME = "AIUsage";
export const RECOMMENDATION_FEEDBACK_DB_NAME = "RecommendationFeedback";
export const CACHE_DB_NAME = "AIResponseCache";

// Cache configuration
export const DEFAULT_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
export const MAX_CACHE_SIZE = 100; // Maximum number of cached responses

// Anthropic API constants
export const ANTHROPIC_API_URL = "https://api.anthropic.com/v1";
export const ANTHROPIC_API_VERSION = "2023-06-01";
// In a production app, you would use environment variables
// import { ANTHROPIC_API_KEY } from '@env';
// For now, we'll use a placeholder that you'll replace with your actual key
export const ANTHROPIC_API_KEY = "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"; // Replace this with your actual key

// Cache entry interface
export interface CacheEntry<T> {
  key: string;
  data: T;
  timestamp: number;
  expiresAt: number;
  ttl: number;
  hitCount: number;
  lastAccessed: number;
}

// Database entry interfaces
export interface CacheDbEntry {
  key: string;
  data: string;
  timestamp: number;
  expires_at: number;
  ttl: number;
  hit_count: number;
  last_accessed: number;
}

export interface KeyEntry {
  key: string;
}

export interface CountResult {
  count: number;
} 

================================================================================
File: src/services/ai/types/errors.ts
================================================================================

// Define error types for better error handling
export enum AIServiceErrorType {
  NETWORK = 'network_error',
  AUTHENTICATION = 'authentication_error',
  RATE_LIMIT = 'rate_limit_error',
  SERVER = 'server_error',
  PARSING = 'parsing_error',
  TIMEOUT = 'timeout_error',
  UNKNOWN = 'unknown_error'
}

export class AIServiceError extends Error {
  type: AIServiceErrorType;
  statusCode?: number;
  retryable: boolean;
  userMessage: string;

  constructor(
    message: string, 
    type: AIServiceErrorType = AIServiceErrorType.UNKNOWN, 
    statusCode?: number,
    retryable: boolean = false,
    userMessage: string = "An error occurred while processing your request."
  ) {
    super(message);
    this.name = 'AIServiceError';
    this.type = type;
    this.statusCode = statusCode;
    this.retryable = retryable;
    this.userMessage = userMessage;
  }
} 

================================================================================
File: src/services/ai/types/feedback.ts
================================================================================

// Feedback and evaluation types
export interface UserFeedback {
  userId: string;
  responseId: string;
  responseType: 'recommendation' | 'chat';
  helpful: boolean;
  accurate: boolean;
  relevance: number; // 1-5 scale
  comments?: string;
  timestamp: number;
}

export interface QualityScore {
  overallScore: number; // 0-100
  relevanceScore: number; // 0-100
  accuracyScore: number; // 0-100
  comprehensivenessScore: number; // 0-100
  safetyScore: number; // 0-100
  strengths: string[];
  weaknesses: string[];
  improvementSuggestions: string[];
}

export interface FeedbackPattern {
  patternId: string;
  responseType: 'recommendation' | 'chat';
  userProfileFactors: Record<string, any>;
  requestFactors: Record<string, any>;
  positiveOutcomeRate: number;
  sampleSize: number;
  lastUpdated: number;
}

// Database-specific interfaces for feedback
export interface PatternEntry {
  pattern_id: string;
  user_profile_factors: string;
  request_factors: string;
  positive_outcome_rate: number;
  sample_size: number;
}

export interface FeedbackStats {
  total: number;
  positive: number;
  relevance_sum: number;
}

export interface QualityStats {
  avg_overall: number;
  avg_relevance: number;
  avg_safety: number;
  total: number;
} 

================================================================================
File: src/services/ai/types/requests.ts
================================================================================

import { UserProfile, JournalEntry, ChatMessage } from '../../../types/ai';

export interface RecommendationRequest {
  userProfile: UserProfile;
  journalEntries?: JournalEntry[];
  desiredEffects: string[];
  medicalNeeds?: string[];
  context?: 'recreational' | 'medical' | 'wellness';
  locationCode?: string; // For regulations
}

export interface ChatRequest {
  message: string;
  userProfile: UserProfile;
  locationCode?: string;
  previousMessages?: ChatMessage[];
} 

================================================================================
File: src/services/ai/types/responses.ts
================================================================================

import { DosageSuggestion, StrainRecommendation } from '../../../types/ai';

export interface RecommendationResponse {
  recommendations: StrainRecommendation[];
  reasoning: string;
  confidenceScore: number;
  disclaimers: string[];
  dosageSuggestion?: DosageSuggestion;
  safetyNotes?: string[];
  error?: {
    message: string;
    type: string;
    recoverable: boolean;
  };
  // Adding responseId to fix the type issue in evaluateResponseQuality
  responseId?: string;
}

export interface ChatResponse {
  response: string;
  educationalLinks?: string[];
  disclaimers?: string[];
  regulatoryNotes?: string[];
  followUpSuggestions?: string[];
}

export interface JournalAnalysisResult {
  patterns: string[];
  insights: string[];
  recommendations: string[];
  safetyFlags?: string[];
}

export interface SafetyValidationResult {
  valid: boolean;
  reason?: string;
  modifications?: any; // Using any instead of Partial<RecommendationRequest> to avoid circular dependency
  safetyFlags?: string[];
  warningLevel?: 'info' | 'warning' | 'critical';
}

export interface DrugInteractionResult {
  hasInteractions: boolean;
  details?: string[];
  severity?: 'mild' | 'moderate' | 'severe';
  recommendations?: string[];
}

export interface OveruseDetectionResult {
  detected: boolean;
  level?: 'mild' | 'moderate' | 'severe';
  details?: string;
  recommendedAction?: string;
  coolingOffPeriod?: number; // in days
} 

================================================================================
File: src/services/ai/utils/hash.ts
================================================================================

/**
 * A simple SHA-256 hash implementation for string inputs
 * This is a basic implementation for caching purposes
 * In a production environment, use a proper crypto library
 */
export function SHA256(input: string): string {
  // Simple hash function for demo purposes
  // In a real app, use a proper crypto library
  let hash = 0;
  
  if (input.length === 0) {
    return hash.toString(16);
  }
  
  // Generate a simple hash
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Convert to hex string and ensure it's 64 characters long (SHA-256 length)
  const hexHash = Math.abs(hash).toString(16).padStart(8, '0');
  
  // Repeat the hash to make it look like a SHA-256 hash (64 chars)
  return (hexHash.repeat(8)).substring(0, 64);
} 

================================================================================
File: src/services/ai/utils/logging.ts
================================================================================

/**
 * Logging utility for AI service
 * Provides consistent logging format and levels
 */

// Log levels
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

// Current log level - can be changed at runtime
let currentLogLevel: LogLevel = LogLevel.INFO;

// Set the current log level
export function setLogLevel(level: LogLevel): void {
  currentLogLevel = level;
}

// Get the current log level
export function getLogLevel(): LogLevel {
  return currentLogLevel;
}

// Format a log message with timestamp and module
function formatLogMessage(module: string, message: string): string {
  const timestamp = new Date().toISOString();
  return `[${timestamp}] [${module}] ${message}`;
}

// Debug level logging
export function debug(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.DEBUG) {
    console.debug(formatLogMessage(module, message), ...args);
  }
}

// Info level logging
export function info(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.INFO) {
    console.info(formatLogMessage(module, message), ...args);
  }
}

// Warning level logging
export function warn(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.WARN) {
    console.warn(formatLogMessage(module, message), ...args);
  }
}

// Error level logging
export function error(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.ERROR) {
    console.error(formatLogMessage(module, message), ...args);
  }
}

// Log an error object with stack trace
export function logError(module: string, error: Error, message?: string): void {
  if (currentLogLevel <= LogLevel.ERROR) {
    const errorMessage = message ? `${message}: ${error.message}` : error.message;
    console.error(formatLogMessage(module, errorMessage));
    if (error.stack) {
      console.error(error.stack);
    }
  }
} 

================================================================================
File: src/services/DataService.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import { 
  BongHit, 
  ChartDataPoint, 
  DatabaseResponse, 
  UsageStats,
  TimeDistribution,
  DatabaseRow 
} from "@/src/types";
import { BONG_HITS_DATABASE_NAME, dayLookUpTable, getInsertStatements } from "@/src/constants";

interface CountResult {
  count: number;
}

export class DataService {
  private static instance: DataService;
  private db: SQLiteDatabase | null = null;
  private initializationPromise: Promise<void> | null = null;
  
  private constructor() {}

  static getInstance(): DataService {
    if (!DataService.instance) {
      DataService.instance = new DataService();
    }
    return DataService.instance;
  }

  private async initialize(): Promise<void> {
    try {
      console.log('[DataService] Initializing database...');
      this.db = await openDatabaseAsync(BONG_HITS_DATABASE_NAME);

      // Set up database with proper schema and mock data
      await this.db.execAsync(`
        PRAGMA journal_mode = WAL;
        
        DROP TABLE IF EXISTS ${BONG_HITS_DATABASE_NAME};
        
        CREATE TABLE IF NOT EXISTS ${BONG_HITS_DATABASE_NAME} (
          timestamp TIMESTAMP PRIMARY KEY NOT NULL,
          duration_ms INTEGER NOT NULL
        );
        
        CREATE INDEX IF NOT EXISTS idx_timestamp 
        ON ${BONG_HITS_DATABASE_NAME}(timestamp);
      `.concat(getInsertStatements()));

      // Verify data was inserted
      const [countResult] = await this.db.getAllAsync<CountResult>('SELECT COUNT(*) as count FROM ' + BONG_HITS_DATABASE_NAME);
      console.log('[DataService] Initialized database with', countResult.count, 'records');

    } catch (error) {
      console.error('[DataService] Failed to initialize database:', error);
      this.db = null;
      throw error;
    }
  }

  private async getDatabase(): Promise<SQLiteDatabase> {
    if (!this.db) {
      if (!this.initializationPromise) {
        this.initializationPromise = this.initialize();
      }
      await this.initializationPromise;
      this.initializationPromise = null;
    }

    if (!this.db) {
      throw new Error('Database initialization failed');
    }

    // Verify database has data
    const [countResult] = await this.db.getAllAsync<CountResult>(`
      SELECT COUNT(*) as count FROM ${BONG_HITS_DATABASE_NAME}
    `);
    console.log('[DataService] Current database record count:', countResult.count);

    return this.db;
  }

  private handleError<T>(error: unknown, operation: string): DatabaseResponse<T> {
    const errorMessage = error instanceof Error ? error.message : `Failed to ${operation}`;
    console.error(`[DataService] Error in ${operation}:`, error);
    return {
      success: false,
      error: errorMessage
    };
  }

  private validateWeeklyData(data: DatabaseRow[]): ChartDataPoint[] {
    console.log('[DataService] Validating weekly data:', data);
    const weekData = Array.from({ length: 7 }, (_, i) => ({
      label: dayLookUpTable.get(i) || "",
      value: 0
    }));
    
    data.forEach(row => {
      const dayIndex = Number(row.day);
      if (dayIndex >= 0 && dayIndex < 7) {
        weekData[dayIndex].value = Number(row.hit_count || 0);
      }
    });
    
    console.log('[DataService] Validated weekly data:', weekData);
    return weekData;
  }

  private validateMonthlyData(data: DatabaseRow[]): ChartDataPoint[] {
    console.log('[DataService] Validating monthly data:', data);
    const monthlyData = data.map(row => ({
      label: new Date(2024, Number(row.month) - 1).toLocaleString('default', { month: 'short' }),
      value: Number(row.hit_count || 0)
    }));
    console.log('[DataService] Validated monthly data:', monthlyData);
    return monthlyData;
  }

  async getWeeklyStats(): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      console.log('[DataService] Fetching weekly stats...');
      const db = await this.getDatabase();
      const results = await db.getAllAsync<DatabaseRow>(`
        SELECT 
          strftime('%w', timestamp) as day,
          COUNT(*) as hit_count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY day
        ORDER BY day
      `);

      console.log('[DataService] Raw weekly results:', results);

      if (!results?.length) {
        console.log('[DataService] No weekly data found, returning empty dataset');
        return {
          success: true,
          data: Array.from({ length: 7 }, (_, i) => ({
            label: dayLookUpTable.get(i) || "",
            value: 0
          }))
        };
      }

      const validatedData = this.validateWeeklyData(results);
      return {
        success: true,
        data: validatedData
      };

    } catch (error) {
      return this.handleError(error, 'getWeeklyStats');
    }
  }

  async getMonthlyStats(): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      console.log('[DataService] Fetching monthly stats...');
      const db = await this.getDatabase();
      const results = await db.getAllAsync<DatabaseRow>(`
        SELECT 
          strftime('%m', timestamp) as month,
          COUNT(*) as hit_count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY month
        ORDER BY month
      `);

      console.log('[DataService] Raw monthly results:', results);

      if (!results?.length) {
        console.log('[DataService] No monthly data found, returning empty dataset');
        return {
          success: true,
          data: Array.from({ length: 12 }, (_, i) => ({
            label: new Date(2024, i).toLocaleString('default', { month: 'short' }),
            value: 0
          }))
        };
      }

      const validatedData = this.validateMonthlyData(results);
      return {
        success: true,
        data: validatedData
      };

    } catch (error) {
      return this.handleError(error, 'getMonthlyStats');
    }
  }

  async getUsageStats(): Promise<DatabaseResponse<UsageStats>> {
    try {
      console.log('[DataService] Fetching usage stats...');
      const db = await this.getDatabase();
      
      // First get daily hits to calculate variance
      const dailyHitsQuery = `
        SELECT COUNT(*) as daily_hits
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY strftime('%Y-%m-%d', timestamp)
      `;

      const dailyHits = await db.getAllAsync<{ daily_hits: number }>(dailyHitsQuery);
      const dailyHitsArray = dailyHits.map(row => Number(row.daily_hits));
      const mean = dailyHitsArray.reduce((sum, val) => sum + val, 0) / dailyHitsArray.length;
      const variance = dailyHitsArray.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / dailyHitsArray.length;
      const consistency = Math.sqrt(variance);
      
      const query = `
        WITH DailyStats AS (
          SELECT 
            strftime('%Y-%m-%d', timestamp) as day,
            strftime('%w', timestamp) as weekday,
            COUNT(*) as daily_hits,
            AVG(duration_ms) as avg_duration_per_day,
            MIN(duration_ms) as min_duration,
            MAX(duration_ms) as max_duration,
            SUM(duration_ms) as total_duration_per_day
          FROM ${BONG_HITS_DATABASE_NAME}
          WHERE timestamp >= '2024-12-24'
          GROUP BY day
        ),
        WeekdayStats AS (
          SELECT
            CASE WHEN weekday IN ('0', '6') THEN 'weekend' ELSE 'weekday' END as day_type,
            AVG(daily_hits) as avg_hits,
            SUM(daily_hits) as total_hits
          FROM DailyStats
          GROUP BY day_type
        ),
        HourlyStats AS (
          SELECT 
            strftime('%H', timestamp) as hour,
            COUNT(*) as hits
          FROM ${BONG_HITS_DATABASE_NAME}
          WHERE timestamp >= '2024-12-24'
          GROUP BY hour
          ORDER BY hits DESC
        )
        SELECT 
          ROUND(AVG(d.daily_hits), 2) as average_hits_per_day,
          MAX(d.daily_hits) as peak_day_hits,
          MIN(d.daily_hits) as lowest_day_hits,
          SUM(d.daily_hits) as total_hits,
          ROUND(AVG(d.avg_duration_per_day), 2) as avg_duration,
          MIN(d.min_duration) as shortest_hit,
          MAX(d.max_duration) as longest_hit,
          SUM(d.total_duration_per_day) as total_duration,
          (SELECT hour FROM HourlyStats LIMIT 1) as most_active_hour,
          (SELECT hour FROM HourlyStats ORDER BY hits ASC LIMIT 1) as least_active_hour,
          ROUND((SELECT AVG(hits) FROM HourlyStats), 2) as avg_hits_per_hour,
          (SELECT avg_hits FROM WeekdayStats WHERE day_type = 'weekday') as weekday_avg,
          (SELECT total_hits FROM WeekdayStats WHERE day_type = 'weekday') as weekday_total,
          (SELECT avg_hits FROM WeekdayStats WHERE day_type = 'weekend') as weekend_avg,
          (SELECT total_hits FROM WeekdayStats WHERE day_type = 'weekend') as weekend_total
        FROM DailyStats d
      `;

      const [result] = await db.getAllAsync<DatabaseRow>(query);
      console.log('[DataService] Raw usage stats:', result);

      if (!result) {
        return {
          success: true,
          data: {
            averageHitsPerDay: 0,
            totalHits: 0,
            peakDayHits: 0,
            lowestDayHits: 0,
            averageDuration: 0,
            longestHit: 0,
            shortestHit: 0,
            mostActiveHour: 0,
            leastActiveHour: 0,
            totalDuration: 0,
            averageHitsPerHour: 0,
            consistency: 0,
            weekdayStats: {
              weekday: { avg: 0, total: 0 },
              weekend: { avg: 0, total: 0 }
            }
          }
        };
      }

      const stats: UsageStats = {
        averageHitsPerDay: Number(result.average_hits_per_day || 0),
        totalHits: Number(result.total_hits || 0),
        peakDayHits: Number(result.peak_day_hits || 0),
        lowestDayHits: Number(result.lowest_day_hits || 0),
        averageDuration: Number(result.avg_duration || 0),
        longestHit: Number(result.longest_hit || 0),
        shortestHit: Number(result.shortest_hit || 0),
        mostActiveHour: Number(result.most_active_hour || 0),
        leastActiveHour: Number(result.least_active_hour || 0),
        totalDuration: Number(result.total_duration || 0),
        averageHitsPerHour: Number(result.avg_hits_per_hour || 0),
        consistency: Math.round(consistency * 100) / 100,
        weekdayStats: {
          weekday: {
            avg: Number(result.weekday_avg || 0),
            total: Number(result.weekday_total || 0)
          },
          weekend: {
            avg: Number(result.weekend_avg || 0),
            total: Number(result.weekend_total || 0)
          }
        }
      };

      console.log('[DataService] Processed usage stats:', stats);
      return { success: true, data: stats };
    } catch (error) {
      return this.handleError(error, 'getUsageStats');
    }
  }

  async getTimeDistribution(): Promise<DatabaseResponse<TimeDistribution>> {
    try {
      const db = await this.getDatabase();
      const query = `
        WITH HourlyHits AS (
          SELECT 
            CAST(strftime('%H', timestamp) AS INTEGER) as hour,
            COUNT(*) as hits
          FROM ${BONG_HITS_DATABASE_NAME}
          WHERE timestamp >= '2024-12-24'
          GROUP BY hour
        )
        SELECT 
          SUM(CASE WHEN hour BETWEEN 6 AND 11 THEN hits ELSE 0 END) as morning,
          SUM(CASE WHEN hour BETWEEN 12 AND 17 THEN hits ELSE 0 END) as afternoon,
          SUM(CASE WHEN hour BETWEEN 18 AND 23 THEN hits ELSE 0 END) as evening,
          SUM(CASE WHEN hour < 6 OR hour = 0 THEN hits ELSE 0 END) as night
        FROM HourlyHits
      `;

      const [result] = await db.getAllAsync<DatabaseRow>(query);

      return {
        success: true,
        data: {
          morning: Number(result?.morning || 0),
          afternoon: Number(result?.afternoon || 0),
          evening: Number(result?.evening || 0),
          night: Number(result?.night || 0)
        }
      };
    } catch (error) {
      return this.handleError(error, 'getTimeDistribution');
    }
  }

  async getDailyAverageDatapoints(): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      console.log('[DataService] Fetching daily average datapoints...');
      const db = await this.getDatabase();
      const results = await db.getAllAsync<DatabaseRow>(`
        SELECT 
          strftime('%H', timestamp) as hour,
          COUNT(*) as count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY hour
        ORDER BY hour
      `);

      console.log('[DataService] Raw daily average results:', results);

      const processedData = Array.from({ length: 24 }, (_, i) => ({
        label: i.toString().padStart(2, '0'),
        value: 0
      }));

      results.forEach(row => {
        const hourIndex = Number(row.hour);
        if (hourIndex >= 0 && hourIndex < 24) {
          processedData[hourIndex].value = Number(row.count || 0);
        }
      });

      console.log('[DataService] Processed daily average data:', processedData);
      return {
        success: true,
        data: processedData
      };

    } catch (error) {
      return this.handleError(error, 'getDailyAverageDatapoints');
    }
  }

  async cleanup() {
    console.log('[DataService] Starting cleanup...');
    if (this.db) {
      try {
        await this.db.closeAsync();
        this.db = null;
        this.initializationPromise = null;
        console.log('[DataService] Cleanup completed successfully');
      } catch (error) {
        console.error('[DataService] Error during cleanup:', error);
        throw error;
      }
    }
  }
} 

================================================================================
File: src/services/SafetyService.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import AsyncStorage from '@react-native-async-storage/async-storage';
import { 
  RecommendationRequest, 
  RecommendationResponse, 
  SafetyValidationResult,
  DrugInteractionResult,
  OveruseDetectionResult,
  SafetyRecord,
  JournalEntry,
  UserProfile
} from '../types/ai';

// Constants for safety thresholds
const SAFETY_DB_NAME = "SafetyRecords";
const COOLING_OFF_DAYS = 7; // Default cooling off period in days
const MAX_DAILY_SESSIONS = 5; // Threshold for potential overuse warning
const HIGH_THC_THRESHOLD = 25; // THC percentage considered high potency
const MINIMUM_AGE_REQUIREMENT = 21; // Minimum age for recommendations

export class SafetyService {
  private static instance: SafetyService;
  private db: SQLiteDatabase | null = null;
  private initialized: boolean = false;
  
  private constructor() {}
  
  static getInstance(): SafetyService {
    if (!SafetyService.instance) {
      SafetyService.instance = new SafetyService();
    }
    return SafetyService.instance;
  }
  
  // Initialize database and safety features
  async initialize(): Promise<void> {
    if (this.initialized) return;
    
    try {
      console.log('[SafetyService] Initializing safety database...');
      
      this.db = await openDatabaseAsync(SAFETY_DB_NAME);
      
      // Create tables for safety records
      await this.db.execAsync(`
        PRAGMA journal_mode = WAL;
        
        CREATE TABLE IF NOT EXISTS ${SAFETY_DB_NAME} (
          id TEXT PRIMARY KEY NOT NULL,
          user_id TEXT NOT NULL,
          concern_type TEXT NOT NULL,
          concern_details TEXT NOT NULL,
          resolution_suggestions TEXT,
          cooling_off_until INTEGER,
          created_at INTEGER NOT NULL
        );
        
        CREATE INDEX IF NOT EXISTS idx_user_id 
        ON ${SAFETY_DB_NAME}(user_id);
        
        CREATE INDEX IF NOT EXISTS idx_created_at 
        ON ${SAFETY_DB_NAME}(created_at);
      `);
      
      // Initialize educational content if not already done
      const hasInitialized = await AsyncStorage.getItem('safety_initialized');
      if (!hasInitialized) {
        await this.initializeEducationalContent();
        await AsyncStorage.setItem('safety_initialized', 'true');
      }
      
      this.initialized = true;
      console.log('[SafetyService] Safety service initialized');
      
    } catch (error) {
      console.error('[SafetyService] Error initializing safety database:', error);
      throw error;
    }
  }
  
  // Core validation method for recommendation requests
  async validateRecommendationRequest(request: RecommendationRequest): Promise<SafetyValidationResult> {
    try {
      await this.ensureInitialized();
      
      const { userProfile, desiredEffects, medicalNeeds, context } = request;
      const safetyFlags: string[] = [];
      let isValid = true;
      let reason = '';
      let modifications: Partial<RecommendationRequest> = {};
      let warningLevel: 'info' | 'warning' | 'critical' = 'info';
      
      // Check for required fields
      if (!userProfile) {
        return {
          valid: false,
          reason: 'User profile is required for personalized recommendations',
          warningLevel: 'critical'
        };
      }

      // Verify age restrictions (if age is provided)
      if (userProfile.experience_level === 'beginner') {
        // For beginners, add a safety flag
        safetyFlags.push('Recommendations tailored for beginners. Start with lower doses.');
      }
      
      // Check for cooling off period
      const coolingOffStatus = await this.checkCoolingOffStatus(userProfile.id);
      if (coolingOffStatus.inCoolingOff) {
        return {
          valid: false,
          reason: `Cooling off period in effect until ${new Date(coolingOffStatus.endTime!).toLocaleDateString()}`,
          warningLevel: 'critical'
        };
      }
      
      // Check for overdose concerns based on user profile
      const overuseCheck = await this.detectOverusePatterns(userProfile.id);
      if (overuseCheck.detected) {
        if (overuseCheck.level === 'severe') {
          return {
            valid: false,
            reason: overuseCheck.details || 'Usage patterns indicate potential health concerns',
            warningLevel: 'critical'
          };
        } else {
          safetyFlags.push(overuseCheck.details || 'Frequent use detected. Consider moderating consumption.');
          warningLevel = overuseCheck.level === 'moderate' ? 'warning' : 'info';
        }
      }
      
      // Check for medication interactions if applicable
      if (userProfile.medications && userProfile.medications.length > 0) {
        const interactionCheck = await this.checkMedicationInteractions(
          userProfile.medications
        );
        
        if (interactionCheck.hasInteractions) {
          if (interactionCheck.severity === 'severe') {
            return {
              valid: false,
              reason: 'Potential serious interaction with medications detected',
              safetyFlags: interactionCheck.details,
              warningLevel: 'critical'
            };
          } else {
            safetyFlags.push(...(interactionCheck.details || []));
            warningLevel = interactionCheck.severity === 'moderate' ? 'warning' : 'info';
          }
        }
      }
      
      // Adjust recommendations for beginners
      if (userProfile.experience_level === 'beginner') {
        // Modify the request to prioritize lower THC content for beginners
        modifications = {
          ...modifications,
          context: 'wellness', // Override context for beginners
          desiredEffects: [...(request.desiredEffects || []), 'mild', 'gentle']
        };
        
        safetyFlags.push('Recommendations adjusted for beginner experience level.');
      }
      
      // Handle medical context with extra care
      if (context === 'medical' && medicalNeeds && medicalNeeds.length > 0) {
        safetyFlags.push('Medical disclaimer: Consult with a healthcare professional before use.');
        
        // Check if any medical needs require special attention
        const sensitiveConditions = ['anxiety', 'heart', 'psychiatric', 'pregnancy'];
        const hasSensitiveCondition = medicalNeeds.some(need => 
          sensitiveConditions.some(condition => need.toLowerCase().includes(condition))
        );
        
        if (hasSensitiveCondition) {
          safetyFlags.push('Some conditions may require extra caution. Medical supervision is strongly advised.');
          warningLevel = 'warning';
        }
      }
      
      // Return validation result
      return {
        valid: isValid,
        reason: reason,
        modifications: Object.keys(modifications).length > 0 ? modifications : undefined,
        safetyFlags: safetyFlags.length > 0 ? safetyFlags : undefined,
        warningLevel
      };
      
    } catch (error) {
      console.error('[SafetyService] Error validating recommendation request:', error);
      return {
        valid: false,
        reason: 'Internal safety check error. Please try again later.',
        warningLevel: 'critical'
      };
    }
  }
  
  // Process recommendation response to add appropriate safety information
  async processRecommendationResponse(
    response: RecommendationResponse, 
    userProfile: UserProfile,
    recentEntries: JournalEntry[]
  ): Promise<RecommendationResponse> {
    try {
      await this.ensureInitialized();
      
      let additionalDisclaimers: string[] = [];
      let enhancedSafetyNotes = [...(response.safetyNotes || [])];
      let recommendations = [...response.recommendations];
      
      // Ensure we always have basic disclaimers
      if (!response.disclaimers || response.disclaimers.length === 0) {
        additionalDisclaimers.push(
          "Cannabis affects individuals differently. Start with a low dose.",
          "Do not drive or operate machinery while using cannabis.",
          "Keep cannabis products away from children and pets."
        );
      }
      
      // Add experience level specific notes
      if (userProfile.experience_level === 'beginner') {
        additionalDisclaimers.push(
          "As a beginner, start with a very small amount and wait at least 2 hours before considering more.",
          "Effects may be stronger than expected for new users."
        );
      }
      
      // Check journal entries for negative patterns
      if (recentEntries.length > 0) {
        // Look for commonly reported negative effects
        const negativeEffectsMap = new Map<string, number>();
        recentEntries.forEach(entry => {
          if (entry.negative_effects) {
            entry.negative_effects.forEach(effect => {
              negativeEffectsMap.set(effect, (negativeEffectsMap.get(effect) || 0) + 1);
            });
          }
        });
        
        // Find frequent negative effects
        const frequentNegativeEffects = Array.from(negativeEffectsMap.entries())
          .filter(([_, count]) => count >= 2)
          .map(([effect]) => effect);
        
        if (frequentNegativeEffects.length > 0) {
          enhancedSafetyNotes.push(
            `Based on your journal, watch for these effects you've reported: ${frequentNegativeEffects.join(', ')}.`
          );
        }
        
        // Look for high dosage patterns
        const highDosageEntries = recentEntries.filter(entry => 
          entry.dosage > (userProfile.experience_level === 'beginner' ? 10 : 25)
        );
        
        if (highDosageEntries.length > 2) {
          enhancedSafetyNotes.push(
            "Your journal shows higher dosages than typically recommended. Consider a tolerance break or gradual reduction."
          );
          
          // Flag user for potential follow-up if overuse is detected
          await this.logSafetyConcern({
            userId: userProfile.id,
            concernType: 'overuse',
            concernDetails: 'High dosage pattern detected in journal entries',
            timestamp: Date.now(),
            resolutionSuggestions: [
              'Consider a 48-hour tolerance break',
              'Try microdosing techniques',
              'Explore lower THC varieties'
            ]
          });
        }
      }
      
      // Filter out potentially inappropriate recommendations
      if (userProfile.avoid_effects && userProfile.avoid_effects.length > 0) {
        // In a real app, this would check against a database of strain profiles
        // For this demo, we'll just add a safety note
        enhancedSafetyNotes.push(
          `Note: You've indicated you want to avoid ${userProfile.avoid_effects.join(', ')}. Adjust dosage accordingly.`
        );
      }
      
      // Include any contextual medical warnings
      if (userProfile.medical_needs && userProfile.medical_needs.length > 0) {
        additionalDisclaimers.push(
          "These recommendations are not a replacement for professional medical advice."
        );
      }
      
      // Return enhanced response
      return {
        ...response,
        disclaimers: [...(response.disclaimers || []), ...additionalDisclaimers],
        safetyNotes: enhancedSafetyNotes,
        recommendations
      };
      
    } catch (error) {
      console.error('[SafetyService] Error processing recommendation response:', error);
      // Return original response if processing fails
      return response;
    }
  }
  
  /**
   * Detects potential overuse patterns in user's consumption history
   * Uses more sophisticated pattern recognition to identify concerning usage trends
   */
  async detectOverusePatterns(userId: string): Promise<OveruseDetectionResult> {
    try {
      await this.ensureInitialized();
      
      // Get recent journal entries
      const recentEntries = await this.getRecentJournalEntries(userId, 90); // Last 90 days
      
      if (recentEntries.length < 5) {
        return { detected: false };
      }
      
      // Extract features for pattern analysis
      const features = this.extractUsageFeatures(recentEntries);
      
      // Check for increasing frequency pattern
      const weeklyUsageCounts = this.getWeeklyUsageCounts(recentEntries);
      const increasingFrequency = this.detectIncreasingTrend(weeklyUsageCounts);
      
      // Check for increasing dosage pattern
      const weeklyAvgDosages = this.getWeeklyAverageDosages(recentEntries);
      const increasingDosage = this.detectIncreasingTrend(weeklyAvgDosages);
      
      // Check for tolerance development (same dosage, decreasing effectiveness)
      const effectivenessRatios = this.getEffectivenessRatios(recentEntries);
      const decreasingEffectiveness = this.detectDecreasingTrend(effectivenessRatios);
      
      // Check for withdrawal symptoms
      const withdrawalSymptoms = this.detectWithdrawalSymptoms(recentEntries);
      
      // Determine overall risk level
      let level: 'mild' | 'moderate' | 'severe' | undefined;
      let details = '';
      let recommendedAction = '';
      let coolingOffPeriod: number | undefined;
      
      const riskFactors = [
        increasingFrequency && 'increasing usage frequency',
        increasingDosage && 'increasing dosage',
        decreasingEffectiveness && 'developing tolerance',
        withdrawalSymptoms && 'potential withdrawal symptoms'
      ].filter(Boolean);
      
      if (riskFactors.length >= 3) {
        level = 'severe';
        details = `Multiple concerning patterns detected: ${riskFactors.join(', ')}.`;
        recommendedAction = 'Consider a 7-day tolerance break and consult with a healthcare provider.';
        coolingOffPeriod = 7;
      } else if (riskFactors.length >= 2) {
        level = 'moderate';
        details = `Some concerning patterns detected: ${riskFactors.join(', ')}.`;
        recommendedAction = 'Consider scheduling regular cannabis-free days each week.';
      } else if (riskFactors.length >= 1) {
        level = 'mild';
        details = `Early warning signs detected: ${riskFactors.join(', ')}.`;
        recommendedAction = 'Consider mindful consumption practices and occasional breaks.';
      } else {
        return { detected: false };
      }
      
      // Log safety concern if moderate or severe
      if (level === 'moderate' || level === 'severe') {
        await this.logSafetyConcern({
          userId,
          concernType: 'overuse',
          concernDetails: details,
          timestamp: Date.now(),
          resolutionSuggestions: [recommendedAction],
          coolingOffUntil: level === 'severe' ? Date.now() + (coolingOffPeriod! * 24 * 60 * 60 * 1000) : undefined
        });
      }
      
      return {
        detected: true,
        level,
        details,
        recommendedAction,
        coolingOffPeriod
      };
    } catch (error) {
      console.error('[SafetyService] Error detecting overuse patterns:', error);
      return { detected: false };
    }
  }
  
  // Helper methods for pattern detection
  
  /**
   * Get recent journal entries for a user
   */
  private async getRecentJournalEntries(userId: string, days: number): Promise<JournalEntry[]> {
    // In a real implementation, this would query the journal database
    // For now, return mock data
    return [
      {
        id: "j1",
        user_id: userId,
        strain_id: 1,
        strain_name: "Blue Dream",
        consumption_method: "vaporize",
        dosage: 15,
        dosage_unit: "mg",
        effects_felt: ["Relaxed", "Happy", "Creative"],
        rating: 4,
        effectiveness: 4,
        notes: "Good for evening relaxation, helped with creativity",
        mood_before: "Stressed",
        mood_after: "Calm",
        medical_symptoms_relieved: ["Anxiety"],
        negative_effects: ["Dry mouth"],
        duration_minutes: 180,
        created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
      },
      {
        id: "j2",
        user_id: userId,
        strain_id: 2,
        strain_name: "OG Kush",
        consumption_method: "edible",
        dosage: 10,
        dosage_unit: "mg",
        effects_felt: ["Sleepy", "Relaxed", "Hungry"],
        rating: 3,
        effectiveness: 4,
        notes: "Helped with sleep, but made me too hungry",
        mood_before: "Tired",
        mood_after: "Sleepy",
        medical_symptoms_relieved: ["Insomnia"],
        negative_effects: ["Groggy morning"],
        duration_minutes: 240,
        created_at: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
      }
    ];
  }
  
  /**
   * Extract features for pattern analysis
   */
  private extractUsageFeatures(entries: JournalEntry[]): any {
    // Extract features for ML analysis
    // In a real implementation, this would extract meaningful features
    return {
      totalEntries: entries.length,
      averageDosage: entries.reduce((sum, entry) => sum + entry.dosage, 0) / entries.length,
      averageEffectiveness: entries.reduce((sum, entry) => sum + entry.effectiveness, 0) / entries.length,
      uniqueStrains: new Set(entries.map(entry => entry.strain_id)).size,
      negativeEffectsRate: entries.filter(entry => entry.negative_effects && entry.negative_effects.length > 0).length / entries.length
    };
  }
  
  /**
   * Group entries by week and count
   */
  private getWeeklyUsageCounts(entries: JournalEntry[]): number[] {
    // Group entries by week and count
    const weeklyCounts: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 12 weeks
    
    entries.forEach(entry => {
      const entryDate = new Date(entry.created_at);
      const now = new Date();
      const diffTime = Math.abs(now.getTime() - entryDate.getTime());
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      const weekIndex = Math.floor(diffDays / 7);
      
      if (weekIndex < weeklyCounts.length) {
        weeklyCounts[weekIndex]++;
      }
    });
    
    return weeklyCounts.reverse(); // Most recent first
  }
  
  /**
   * Get weekly average dosages
   */
  private getWeeklyAverageDosages(entries: JournalEntry[]): number[] {
    // Group entries by week and calculate average dosage
    const weeklyDosages: { sum: number, count: number }[] = Array(12).fill(0).map(() => ({ sum: 0, count: 0 }));
    
    entries.forEach(entry => {
      const entryDate = new Date(entry.created_at);
      const now = new Date();
      const diffTime = Math.abs(now.getTime() - entryDate.getTime());
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      const weekIndex = Math.floor(diffDays / 7);
      
      if (weekIndex < weeklyDosages.length) {
        weeklyDosages[weekIndex].sum += entry.dosage;
        weeklyDosages[weekIndex].count++;
      }
    });
    
    return weeklyDosages.map(week => week.count > 0 ? week.sum / week.count : 0).reverse();
  }
  
  /**
   * Calculate effectiveness ratios (effectiveness / dosage)
   */
  private getEffectivenessRatios(entries: JournalEntry[]): number[] {
    // Calculate effectiveness to dosage ratios over time
    const sortedEntries = [...entries].sort((a, b) => 
      new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
    );
    
    return sortedEntries.map(entry => entry.effectiveness / entry.dosage);
  }
  
  /**
   * Detect increasing trend in a series of values
   */
  private detectIncreasingTrend(values: number[]): boolean {
    if (values.length < 3) return false;
    
    // Simple linear regression
    const n = values.length;
    const indices = Array.from({ length: n }, (_, i) => i);
    
    const sumX = indices.reduce((sum, x) => sum + x, 0);
    const sumY = values.reduce((sum, y) => sum + y, 0);
    const sumXY = indices.reduce((sum, x, i) => sum + x * values[i], 0);
    const sumXX = indices.reduce((sum, x) => sum + x * x, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    
    // Check if the slope is positive and significant
    return slope > 0.1;
  }
  
  /**
   * Detect decreasing trend in a series of values
   */
  private detectDecreasingTrend(values: number[]): boolean {
    if (values.length < 3) return false;
    
    // Simple linear regression
    const n = values.length;
    const indices = Array.from({ length: n }, (_, i) => i);
    
    const sumX = indices.reduce((sum, x) => sum + x, 0);
    const sumY = values.reduce((sum, y) => sum + y, 0);
    const sumXY = indices.reduce((sum, x, i) => sum + x * values[i], 0);
    const sumXX = indices.reduce((sum, x) => sum + x * x, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    
    // Check if the slope is negative and significant
    return slope < -0.1;
  }
  
  /**
   * Detect potential withdrawal symptoms
   */
  private detectWithdrawalSymptoms(entries: JournalEntry[]): boolean {
    // Look for patterns indicating withdrawal
    // This is a simplified implementation
    
    // Check for mood deterioration after periods without use
    const sortedEntries = [...entries].sort((a, b) => 
      new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
    );
    
    // Look for gaps between entries
    for (let i = 1; i < sortedEntries.length; i++) {
      const prevEntry = sortedEntries[i - 1];
      const currEntry = sortedEntries[i];
      
      const prevDate = new Date(prevEntry.created_at);
      const currDate = new Date(currEntry.created_at);
      
      const diffHours = (currDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60);
      
      // If there's a gap of more than 48 hours and mood deteriorated
      if (diffHours > 48 && 
          currEntry.mood_before === "Irritable" || 
          currEntry.mood_before === "Anxious" ||
          currEntry.mood_before === "Restless") {
        return true;
      }
    }
    
    return false;
  }
  
  // Check for medication interactions with cannabis
  async checkMedicationInteractions(
    medications: string[]
  ): Promise<DrugInteractionResult> {
    try {
      await this.ensureInitialized();
      
      // In a real app, this would check against a medical database
      // For this demo, we'll use a simplified mock implementation
      
      // Known high-risk interactions
      const highRiskMeds = [
        'warfarin', 'clopidogrel', 'rivaroxaban', 'dabigatran', // Blood thinners
        'tacrolimus', 'cyclosporine', // Immunosuppressants
        'lithium', 'clozapine', // Psychiatric medications
        'theophylline', // Respiratory
        'amiodarone', 'digoxin' // Cardiac
      ];
      
      // Moderate risk interactions
      const moderateRiskMeds = [
        'fluoxetine', 'sertraline', 'paroxetine', 'citalopram', // SSRIs
        'zolpidem', 'eszopiclone', // Sleep medications
        'alprazolam', 'lorazepam', 'diazepam', // Benzodiazepines
        'amlodipine', 'diltiazem', // Blood pressure
        'metformin', 'glyburide', // Diabetes
        'oxycodone', 'hydrocodone', 'tramadol' // Pain medications
      ];
      
      // Check for matches
      const highRiskMatches = medications.filter(med => 
        highRiskMeds.some(risk => med.toLowerCase().includes(risk.toLowerCase()))
      );
      
      const moderateRiskMatches = medications.filter(med => 
        moderateRiskMeds.some(risk => med.toLowerCase().includes(risk.toLowerCase()))
      );
      
      if (highRiskMatches.length > 0) {
        return {
          hasInteractions: true,
          details: highRiskMatches.map(med => 
            `Potential serious interaction between cannabis and ${med}. Consult a healthcare provider before use.`
          ),
          severity: 'severe',
          recommendations: [
            'Consult with your healthcare provider before using cannabis',
            'Monitor for unexpected side effects if using both substances',
            'Consider CBD-only products which may have fewer interactions'
          ]
        };
      } else if (moderateRiskMatches.length > 0) {
        return {
          hasInteractions: true,
          details: moderateRiskMatches.map(med => 
            `Potential interaction between cannabis and ${med}. Use with caution.`
          ),
          severity: 'moderate',
          recommendations: [
            'Start with very low doses and monitor effects carefully',
            'Space out timing between medication and cannabis use',
            'Keep a detailed journal of any side effects'
          ]
        };
      }
      
      return {
        hasInteractions: false
      };
      
    } catch (error) {
      console.error('[SafetyService] Error checking drug interactions:', error);
      return {
        hasInteractions: false
      };
    }
  }
  
  // Log a safety concern for a user
  async logSafetyConcern(data: {
    userId: string;
    concernType: 'overuse' | 'negative_effects' | 'interactions';
    concernDetails: string;
    timestamp: number;
    resolutionSuggestions?: string[];
    coolingOffUntil?: number;
  }): Promise<void> {
    try {
      await this.ensureInitialized();
      
      if (!this.db) {
        throw new Error('Safety database not initialized');
      }
      
      const id = `concern_${Date.now()}`;
      
      await this.db.execAsync(`
        INSERT INTO ${SAFETY_DB_NAME} (
          id,
          user_id,
          concern_type,
          concern_details,
          resolution_suggestions,
          cooling_off_until,
          created_at
        ) VALUES (
          '${id}',
          '${data.userId}',
          '${data.concernType}',
          '${data.concernDetails}',
          ${data.resolutionSuggestions ? `'${JSON.stringify(data.resolutionSuggestions)}'` : 'NULL'},
          ${data.coolingOffUntil ? data.coolingOffUntil : 'NULL'},
          ${data.timestamp}
        )
      `);
      
      console.log('[SafetyService] Safety concern logged for user', data.userId);
      
    } catch (error) {
      console.error('[SafetyService] Error logging safety concern:', error);
      throw error;
    }
  }
  
  // Get safety history for a user
  async getSafetyHistory(userId: string): Promise<SafetyRecord[]> {
    try {
      await this.ensureInitialized();
      
      if (!this.db) {
        return [];
      }
      
      const result = await this.db.getAllAsync<any>(`
        SELECT * FROM ${SAFETY_DB_NAME}
        WHERE user_id = '${userId}'
        ORDER BY created_at DESC
      `);
      
      return result.map((row: any) => ({
        id: row.id,
        user_id: row.user_id,
        concern_type: row.concern_type as 'overuse' | 'negative_effects' | 'interactions',
        concern_details: row.concern_details,
        resolution_suggestions: row.resolution_suggestions 
          ? JSON.parse(row.resolution_suggestions) 
          : [],
        cooling_off_until: row.cooling_off_until,
        created_at: new Date(row.created_at).toISOString()
      }));
      
    } catch (error) {
      console.error('[SafetyService] Error getting safety history:', error);
      return [];
    }
  }
  
  // Check if a user is in a cooling off period
  async checkCoolingOffStatus(userId: string): Promise<{
    inCoolingOff: boolean;
    endTime?: number;
    reason?: string;
  }> {
    try {
      await this.ensureInitialized();
      
      if (!this.db) {
        return { inCoolingOff: false };
      }
      
      const now = Date.now();
      
      const [result] = await this.db.getAllAsync<any>(`
        SELECT * FROM ${SAFETY_DB_NAME}
        WHERE user_id = '${userId}' AND cooling_off_until > ${now}
        ORDER BY cooling_off_until DESC
        LIMIT 1
      `);
      
      if (!result) {
        return { inCoolingOff: false };
      }
      
      return {
        inCoolingOff: true,
        endTime: result.cooling_off_until,
        reason: result.concern_details
      };
      
    } catch (error) {
      console.error('[SafetyService] Error checking cooling off status:', error);
      return { inCoolingOff: false };
    }
  }
  
  // Private helper methods
  
  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }
  
  private async initializeEducationalContent(): Promise<void> {
    // Set up initial educational content in storage
    const educationalContent = {
      harm_reduction: [
        {
          title: "Start Low, Go Slow",
          content: "Begin with a low dose (2.5-5mg THC) and wait at least 2 hours before considering more."
        },
        {
          title: "Know Your Source",
          content: "Only purchase cannabis from legal, regulated sources to ensure quality and safety."
        },
        {
          title: "Mind Your Method",
          content: "Different consumption methods have different onset times and potency levels. Edibles take longer to feel but last longer."
        },
        {
          title: "Set and Setting",
          content: "Use in a comfortable, safe environment with trusted people, especially when trying a new product."
        },
        {
          title: "Stay Hydrated",
          content: "Drink plenty of water before, during, and after cannabis use to minimize dry mouth and dehydration."
        }
      ],
      warning_signs: [
        {
          title: "Increasing Tolerance",
          content: "Needing more cannabis to achieve the same effects is a sign of developing tolerance."
        },
        {
          title: "Preoccupation",
          content: "Thinking about cannabis frequently or planning life around cannabis use."
        },
        {
          title: "Interference",
          content: "Cannabis use affecting responsibilities, relationships, or activities you once enjoyed."
        },
        {
          title: "Withdrawal",
          content: "Experiencing irritability, sleep problems, decreased appetite, or mood changes when not using."
        }
      ],
      responsible_use: [
        {
          title: "Schedule Cannabis-Free Days",
          content: "Regular breaks help prevent tolerance and dependence. Aim for at least 2-3 cannabis-free days per week."
        },
        {
          title: "Keep a Journal",
          content: "Track your usage, effects, and how you feel the next day to identify patterns and optimal dosing."
        },
        {
          title: "Never Drive",
          content: "Cannabis impairs coordination and reaction time. Never drive or operate heavy machinery after use."
        },
        {
          title: "Secure Storage",
          content: "Store cannabis products securely and out of reach of children and pets."
        }
      ]
    };
    
    await AsyncStorage.setItem('educational_content', JSON.stringify(educationalContent));
  }
  
  // Cleanup resources
  async cleanup(): Promise<void> {
    if (this.db) {
      try {
        await this.db.closeAsync();
        this.db = null;
        this.initialized = false;
      } catch (error) {
        console.error('[SafetyService] Error during cleanup:', error);
      }
    }
  }
}

export default SafetyService.getInstance(); 

================================================================================
File: src/services/StrainService.ts
================================================================================

import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import { STRAINS_DATABASE_NAME, SAMPLE_STRAINS } from "../constants";
import { Strain } from "../dbManager";

export interface StrainSearchFilters {
  geneticType?: string;
  effects?: string[];
  minTHC?: number;
  maxTHC?: number;
  sort?: 'rating' | 'name' | 'thc';
}

export interface PaginationParams {
  page: number;
  limit: number;
}

export interface StrainSearchResult {
  success: boolean;
  data: Strain[];
  error?: string;
  total: number;
  currentPage: number;
  totalPages: number;
  hasMore: boolean;
}

export class StrainService {
  private static instance: StrainService;
  private db: SQLiteDatabase | null = null;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {}

  static getInstance(): StrainService {
    if (!StrainService.instance) {
      StrainService.instance = new StrainService();
    }
    return StrainService.instance;
  }

  private async initialize(): Promise<void> {
    try {
      console.log('[StrainService] Initializing database...');
      this.db = await openDatabaseAsync(STRAINS_DATABASE_NAME);

      // Drop existing table to ensure clean state
      await this.db.execAsync(`DROP TABLE IF EXISTS ${STRAINS_DATABASE_NAME};`);

      // Create table and indexes
      await this.db.execAsync(`
        PRAGMA journal_mode = WAL;
        
        CREATE TABLE IF NOT EXISTS ${STRAINS_DATABASE_NAME} (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          overview TEXT,
          genetic_type TEXT,
          lineage TEXT,
          thc_range TEXT,
          cbd_level TEXT,
          dominant_terpenes TEXT,
          qualitative_insights TEXT,
          effects TEXT,
          negatives TEXT,
          uses TEXT,
          thc_rating REAL,
          user_rating REAL,
          combined_rating REAL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        
        CREATE INDEX IF NOT EXISTS idx_strain_name 
        ON ${STRAINS_DATABASE_NAME}(name);
        
        CREATE INDEX IF NOT EXISTS idx_strain_genetic_type 
        ON ${STRAINS_DATABASE_NAME}(genetic_type);
        
        CREATE INDEX IF NOT EXISTS idx_strain_effects 
        ON ${STRAINS_DATABASE_NAME}(effects);
        
        CREATE INDEX IF NOT EXISTS idx_strain_rating 
        ON ${STRAINS_DATABASE_NAME}(combined_rating DESC);
      `);

      // Insert all sample strains
      console.log('[StrainService] Inserting', SAMPLE_STRAINS.length, 'sample strains...');
      
      for (const strain of SAMPLE_STRAINS) {
        try {
          await this.db.runAsync(
            `INSERT INTO ${STRAINS_DATABASE_NAME} (
              name, overview, genetic_type, lineage, thc_range,
              cbd_level, dominant_terpenes, qualitative_insights,
              effects, negatives, uses, thc_rating,
              user_rating, combined_rating
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`,
            [
              strain.name,
              strain.overview,
              strain.genetic_type,
              strain.lineage,
              strain.thc_range,
              strain.cbd_level,
              strain.dominant_terpenes,
              strain.qualitative_insights,
              strain.effects,
              strain.negatives,
              strain.uses,
              strain.thc_rating,
              strain.user_rating,
              strain.combined_rating
            ]
          );
        } catch (insertError) {
          console.error(`[StrainService] Failed to insert strain ${strain.name}:`, insertError);
          // Continue with next strain instead of failing completely
        }
      }

      // Verify the data
      const [finalCount] = await this.db.getAllAsync<{ count: number }>(
        `SELECT COUNT(*) as count FROM ${STRAINS_DATABASE_NAME}`
      );
      console.log('[StrainService] Database initialized with', finalCount?.count || 0, 'strains');

    } catch (error) {
      console.error('[StrainService] Failed to initialize database:', error);
      this.db = null;
      throw error;
    }
  }

  private async getDatabase(): Promise<SQLiteDatabase> {
    if (!this.db) {
      if (!this.initializationPromise) {
        this.initializationPromise = this.initialize();
      }
      await this.initializationPromise;
      this.initializationPromise = null;
    }

    if (!this.db) {
      throw new Error('Database initialization failed');
    }

    return this.db;
  }

  private parseTHCRange(thcRange: string): { min: number; max: number } {
    const matches = thcRange.match(/(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)/);
    if (matches) {
      return {
        min: parseFloat(matches[1]),
        max: parseFloat(matches[2])
      };
    }
    return { min: 0, max: 0 };
  }

  async searchStrains(
    query: string = '',
    filters: StrainSearchFilters = {},
    pagination: PaginationParams = { page: 1, limit: 20 }
  ): Promise<StrainSearchResult> {
    try {
      const db = await this.getDatabase();
      const { page, limit } = pagination;
      const offset = (page - 1) * limit;
      
      let whereConditions: string[] = [];
      let params: any[] = [];

      // Add search query conditions
      if (query.trim()) {
        const searchTerms = query.trim().split(/\s+/);
        searchTerms.forEach(term => {
          whereConditions.push('(name LIKE ? OR effects LIKE ? OR genetic_type LIKE ? OR uses LIKE ?)');
          const searchTerm = `%${term}%`;
          params.push(searchTerm, searchTerm, searchTerm, searchTerm);
        });
      }

      // Add filter conditions
      if (filters.geneticType) {
        whereConditions.push('genetic_type = ?');
        params.push(filters.geneticType);
      }

      if (filters.effects?.length) {
        filters.effects.forEach(effect => {
          whereConditions.push('effects LIKE ?');
          params.push(`%${effect}%`);
        });
      }

      if (filters.minTHC !== undefined) {
        whereConditions.push('CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) >= ?');
        params.push(filters.minTHC);
      }

      if (filters.maxTHC !== undefined) {
        whereConditions.push('CAST(SUBSTR(thc_range, INSTR(thc_range, "-")+1) AS FLOAT) <= ?');
        params.push(filters.maxTHC);
      }

      const whereClause = whereConditions.length 
        ? `WHERE ${whereConditions.join(' AND ')}` 
        : '';

      // Get total count
      const [countResult] = await db.getAllAsync<{ total: number }>(
        `SELECT COUNT(*) as total FROM ${STRAINS_DATABASE_NAME} ${whereClause}`,
        params
      );

      // Get filtered results
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} 
         ${whereClause} 
         ORDER BY ${this.getSortOrder(filters.sort)}
         LIMIT ? OFFSET ?`,
        [...params, limit, offset]
      );

      const total = countResult?.total || 0;
      const totalPages = Math.ceil(total / limit);

      return {
        success: true,
        data: results,
        total,
        currentPage: page,
        totalPages,
        hasMore: (page * limit) < total
      };

    } catch (error) {
      console.error('[StrainService] Search error:', error);
      return {
        success: false,
        data: [],
        error: error instanceof Error ? error.message : 'Search failed',
        total: 0,
        currentPage: 1,
        totalPages: 1,
        hasMore: false
      };
    }
  }

  private getSortOrder(sort?: StrainSearchFilters['sort']): string {
    switch (sort) {
      case 'name':
        return 'name ASC';
      case 'thc':
        return 'CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) DESC';
      case 'rating':
      default:
        return 'combined_rating DESC';
    }
  }

  async getStrainById(id: number): Promise<Strain | null> {
    try {
      const db = await this.getDatabase();
      const [strain] = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} WHERE id = ? LIMIT 1`,
        [id]
      );
      return strain || null;
    } catch (error) {
      console.error('[StrainService] Error getting strain by id:', error);
      return null;
    }
  }

  async getPopularStrains(limit: number = 10): Promise<Strain[]> {
    try {
      const db = await this.getDatabase();
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} ORDER BY combined_rating DESC LIMIT ?`,
        [limit]
      );
      return results || [];
    } catch (error) {
      console.error('[StrainService] Error getting popular strains:', error);
      return [];
    }
  }

  async getRelatedStrains(strain: Strain): Promise<Strain[]> {
    try {
      const db = await this.getDatabase();
      // Get strains with similar genetic type and effects
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME}
         WHERE id != ? 
         AND (
           genetic_type = ? 
           OR effects LIKE ?
         )
         ORDER BY combined_rating DESC
         LIMIT 5`,
        [strain.id!, strain.genetic_type, `%${strain.effects.split(',')[0]}%`]
      );
      return results || [];
    } catch (error) {
      console.error('[StrainService] Error getting related strains:', error);
      return [];
    }
  }

  async getStrainCategories(): Promise<{ [key: string]: number }> {
    try {
      const db = await this.getDatabase();
      const results = await db.getAllAsync<{ genetic_type: string; count: number }>(
        `SELECT genetic_type, COUNT(*) as count
         FROM ${STRAINS_DATABASE_NAME}
         GROUP BY genetic_type`
      );
      
      return results.reduce((acc, { genetic_type, count }) => {
        if (genetic_type) {
          acc[genetic_type] = count;
        }
        return acc;
      }, {} as { [key: string]: number });
    } catch (error) {
      console.error('[StrainService] Error getting strain categories:', error);
      return {};
    }
  }

  async cleanup(): Promise<void> {
    if (this.db) {
      try {
        await this.db.closeAsync();
        this.db = null;
        this.initializationPromise = null;
      } catch (error) {
        console.error('[StrainService] Error during cleanup:', error);
        throw error;
      }
    }
  }
}

// Export a default instance
export default StrainService.getInstance(); 

================================================================================
File: src/services/utils/hash.ts
================================================================================

/**
 * A simple SHA-256 hash implementation for string inputs
 * This is a basic implementation for caching purposes
 * In a production environment, use a proper crypto library
 */
export function SHA256(input: string): string {
  // Simple hash function for demo purposes
  // In a real app, use a proper crypto library
  let hash = 0;
  
  if (input.length === 0) {
    return hash.toString(16);
  }
  
  // Generate a simple hash
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Convert to hex string and ensure it's 64 characters long (SHA-256 length)
  const hexHash = Math.abs(hash).toString(16).padStart(8, '0');
  
  // Repeat the hash to make it look like a SHA-256 hash (64 chars)
  return (hexHash.repeat(8)).substring(0, 64);
} 

================================================================================
File: src/types.ts
================================================================================

// Core data types
export interface BongHit {
    id?: number;
    timestamp: string;
    duration_ms: number;
    intensity?: number;
    notes?: string;
}

export interface BongHitStats {
    averageDuration: number;
    longestHit: number;
    totalHits?: number;
}

export interface DailyStats {
    date: string;
    hitCount: number;
    averageDuration: number;
}

export interface AverageHourCount {
    count: number;
    hourOfDay: string;
}

// Chart-specific types
export interface ChartDataPoint {
    label: string;
    value: number;
}

export interface ChartDataset {
    data: number[];
    color: (opacity?: number) => string;
    strokeWidth: number;
}

export interface ChartData {
    labels: string[];
    datasets: ChartDataset[];
    legend?: string[];
}

// Database types
export interface DatabaseRow {
    timestamp?: string;
    duration_ms?: number;
    day?: string;
    month?: string;
    hour?: string;
    hit_count?: number;
    count?: number;
    avg_duration?: number;
    max_duration?: number;
    total_hits?: number;
    avg_hits_per_day?: number;
    avg_duration_per_day?: number;
    daily_hits?: number;
    days_with_data?: number;
    weekday_avg?: number;
    weekday_total?: number;
    weekend_avg?: number;
    weekend_total?: number;
    peak_day_hits?: number;
    lowest_day_hits?: number;
    most_active_hour?: number;
    least_active_hour?: number;
    total_duration?: number;
    avg_hits_per_hour?: number;
    hits_std_dev?: number;
    // Fields from time distribution query
    morning?: number;
    afternoon?: number;
    evening?: number;
    night?: number;
    // Fields from usage stats query
    average_hits_per_day?: number;
    shortest_hit?: number;
    longest_hit?: number;
    consistency?: number;
}

export interface UsageStats {
    // Hit counts
    averageHitsPerDay: number;
    totalHits: number;
    peakDayHits: number;
    lowestDayHits: number;
    
    // Duration stats
    averageDuration: number;  // in ms
    longestHit: number;      // in ms
    shortestHit: number;     // in ms
    
    // Time patterns
    mostActiveHour: number;  // 0-23
    leastActiveHour: number; // 0-23
    
    // Derived metrics
    totalDuration: number;   // total time in ms
    averageHitsPerHour: number;
    consistency: number;     // standard deviation of daily hits

    // Weekday vs Weekend stats
    weekdayStats: WeekdayStats;
}

// Add new interfaces for time distribution
export interface TimeDistribution {
    morning: number;
    afternoon: number;
    evening: number;
    night: number;
}

export interface WeekdayStats {
    weekday: { avg: number; total: number; };
    weekend: { avg: number; total: number; };
}

// Component Props interfaces
export interface WeeklyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface MonthlyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface NotificationProps {
    averageHits: number;
    percentageChange: number;
    onDismiss: () => void;
}

export interface DailyAverageCardProps {
    data: ChartDataPoint[];
    averageHits: number;
    onPress?: () => void;
}

export interface WeeklyUsageBannerProps {
    weeklyData: ChartDataPoint[];
    average: number;
    percentageChange: number;
    onPress?: () => void;
}

// API Response types
export interface DatabaseResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}

export interface UsageAnalytics {
    dailyAverage: number;
    weeklyAverage: number;
    percentageChange: number;
    lastUpdated: string;
}

// State management types
export interface DataState {
    weeklyData: ChartDataPoint[];
    monthlyData: ChartDataPoint[];
    usageStats: UsageStats;
    timeDistribution: TimeDistribution;
    isLoading: boolean;
    error: string | null;
}

================================================================================
File: src/types/ai.ts
================================================================================

// AI recommendation system types
export interface UserProfile {
  id: string;
  experience_level: 'beginner' | 'intermediate' | 'experienced';
  preferred_effects: string[];
  medical_needs?: string[];
  avoid_effects?: string[];
  preferred_consumption_method?: string;
  thc_tolerance?: number; // Scale 1-10
  medications?: string[];
  created_at: string;
  updated_at: string;
}

export interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: string;
}

export interface JournalEntry {
  id: string;
  user_id: string;
  strain_id: number;
  strain_name: string;
  consumption_method: string;
  dosage: number;
  dosage_unit: string;
  effects_felt: string[];
  rating: number;
  effectiveness: number;
  notes?: string;
  mood_before?: string;
  mood_after?: string;
  medical_symptoms_relieved?: string[];
  negative_effects?: string[];
  duration_minutes?: number;
  created_at: string;
}

export interface RecommendationRequest {
  userProfile: UserProfile;
  journalEntries?: JournalEntry[];
  desiredEffects: string[];
  medicalNeeds?: string[];
  context?: 'recreational' | 'medical' | 'wellness';
  locationCode?: string; // For regulations
}

export interface StrainRecommendation {
  strainId: number;
  strainName: string;
  matchScore: number; // 0-100
  reasoningFactors: {
    factor: string;
    weight: number;
  }[];
  alternativeStrains?: {
    strainId: number;
    strainName: string;
    reason: string;
  }[];
}

export interface DosageSuggestion {
  minDosage: number;
  maxDosage: number;
  unit: string;
  gradualApproach: boolean;
  notes: string;
}

export interface RecommendationResponse {
  recommendations: StrainRecommendation[];
  reasoning: string;
  confidenceScore: number;
  disclaimers: string[];
  dosageSuggestion?: DosageSuggestion;
  safetyNotes?: string[];
  error?: {
    message: string;
    type: string;
    recoverable: boolean;
  };
}

export interface ChatRequest {
  message: string;
  userProfile: UserProfile;
  locationCode?: string;
  previousMessages?: {
    role: 'user' | 'assistant';
    content: string;
  }[];
}

export interface ChatResponse {
  response: string;
  educationalLinks?: string[];
  disclaimers?: string[];
  regulatoryNotes?: string[];
  followUpSuggestions?: string[];
}

export interface JournalAnalysisResult {
  patterns: string[];
  insights: string[];
  recommendations: string[];
  safetyFlags?: string[];
}

export interface SafetyValidationResult {
  valid: boolean;
  reason?: string;
  modifications?: Partial<RecommendationRequest>;
  safetyFlags?: string[];
  warningLevel?: 'info' | 'warning' | 'critical';
}

export interface DrugInteractionResult {
  hasInteractions: boolean;
  details?: string[];
  severity?: 'mild' | 'moderate' | 'severe';
  recommendations?: string[];
}

export interface OveruseDetectionResult {
  detected: boolean;
  level?: 'mild' | 'moderate' | 'severe';
  details?: string;
  recommendedAction?: string;
  coolingOffPeriod?: number; // in days
}

export interface SafetyRecord {
  id: string;
  user_id: string;
  concern_type: 'overuse' | 'negative_effects' | 'interactions';
  concern_details: string;
  resolution_suggestions: string[];
  cooling_off_until: number | null;
  created_at: string;
} 

================================================================================
File: src/utils/animations.ts
================================================================================

import { useCallback } from 'react';
import { Platform } from 'react-native';
import {
  FadeIn,
  FadeInDown,
  FadeInUp,
  withSpring,
  withTiming,
  WithTimingConfig,
  Easing,
  useSharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

// Optimized spring configuration
export const SPRING_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100,
  restDisplacementThreshold: 0.01,
  restSpeedThreshold: 0.01,
} as const;

// Optimized timing configuration
export const TIMING_CONFIG: WithTimingConfig = {
  duration: 300,
  easing: Easing.bezier(0.25, 0.1, 0.25, 1),
} as const;

// Shared animation factory
export const createSharedAnimation = (delay: number = 0) => {
  return Platform.select({
    ios: FadeInDown.duration(300)
      .springify()
      .delay(delay)
      .damping(SPRING_CONFIG.damping)
      .mass(SPRING_CONFIG.mass),
    android: FadeIn.duration(250)
      .delay(delay)
  });
};

// Optimized press animation hook
export const useAnimatedPress = (scale: number = 0.98) => {
  const pressed = useSharedValue(false);
  
  const animatedStyle = useAnimatedStyle(() => {
    'worklet';
    return {
      transform: [{
        scale: withSpring(
          pressed.value ? scale : 1, 
          SPRING_CONFIG
        )
      }]
    };
  });

  return {
    animatedStyle,
    pressHandlers: {
      onPressIn: useCallback(() => {
        pressed.value = true;
      }, []),
      onPressOut: useCallback(() => {
        pressed.value = false;
      }, [])
    }
  };
};

// Gradient optimization utilities
export const GRADIENT_PROPS = Platform.select({
  ios: {
    shouldRasterizeIOS: true,
  },
  android: {
    renderToHardwareTextureAndroid: true,
  },
});

// Chart animation configuration
export const CHART_ANIMATION_CONFIG = {
  animationEnabled: true,
  animationDuration: 300,
  animationEasing: Easing.ease,
  propsForLabels: {
    fontSize: 10,
    fontWeight: '400'
  }
} as const;

// Optimized layout animation configuration
export const LAYOUT_ANIMATION_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100
} as const; 

================================================================================
File: src/utils/filters.ts
================================================================================

import { StrainSearchFilters } from '../services/StrainService';

export const hasActiveFilters = (filters: StrainSearchFilters): boolean => {
  return !!(
    filters.geneticType ||
    (filters.effects && filters.effects.length > 0) ||
    filters.minTHC ||
    filters.maxTHC ||
    (filters.sort && filters.sort !== 'rating')
  );
}; 

================================================================================
File: tsconfig.json
================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}