



================================================================================
File: app/(tabs)/_layout.tsx
================================================================================

import { Tabs } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarStyle: {
          backgroundColor: COLORS.background,
          borderTopColor: 'rgba(255, 255, 255, 0.1)',
        },
        tabBarActiveTintColor: COLORS.primary,
        tabBarInactiveTintColor: 'rgba(255, 255, 255, 0.5)',
        headerShown: false,
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          href: null,
        }}
      />
      <Tabs.Screen
        name="mydata"
        options={{
          title: 'My Data',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="chart-box" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="devices"
        options={{
          title: 'Devices',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="devices" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="journal"
        options={{
          title: 'Journal',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="notebook" size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="trending"
        options={{
          title: 'Trending',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="trending-up" size={24} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

================================================================================
File: app/(tabs)/devices.tsx
================================================================================

import { BluetoothContext, BluetoothHandler } from '@/src/contexts/BluetoothContext';
import { getSavedDevices, saveDevices } from '@/src/DatabaseManager';
import { SavedDevice } from '@/src/types';
import React, { useState, useEffect, useRef, useContext } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Alert,
  ScrollView
} from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import base64 from 'react-native-base64';
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '@/src/constants';
import { LinearGradient } from 'expo-linear-gradient';

export default function Devices() {
  const [savedDevices, setSavedDevices] = useState<SavedDevice[]>([]);
  const [scannedDevices, setScannedDevices] = useState<Device[]>([]);
  const [scanning, setScanning] = useState<boolean>(false);
  const [deviceConnectedId, setDeviceConnectedId] = useState<string|null >(null);
  const [connectionError, setConnectionError] = useState<string|null>(null);

  //Track devices to avoid duplicate keys when scanning
  const undiscoveredDeviceSet: React.MutableRefObject<Set<string>> = useRef(new Set<string>());
  
  const bluetoothHandler: BluetoothHandler = useContext(BluetoothContext)!;

  useEffect(() => {
    updateSavedDevices();
    
    // Check if there's already a connected device
    const connectedDevice = bluetoothHandler.getConnectedDevice();
    if (connectedDevice) {
      setDeviceConnectedId(connectedDevice.id);
    }
  }, []);

  useEffect(() => {
    // This effect will run whenever savedDevices or deviceConnectedId changes
    console.log(`Connected device ID: ${deviceConnectedId}`);
  }, [savedDevices, deviceConnectedId]);

 
  function connectAndListenToDevice(deviceId: string, device?: Device): void {
    if (deviceConnectedId === deviceId) {
      return;
    }
    
    setConnectionError(null);

    bluetoothHandler.connectToDevice(deviceId)
      .then(() => {
        try {
          bluetoothHandler.streamOnConnectedDevice();
          if (device) {
            saveDevices([device])
              .then(() => updateSavedDevices())
              .catch(err => console.error("Error saving device:", err));
          }
          setDeviceConnectedId(deviceId);
        } catch (error) {
          console.error("Error setting up stream:", error);
          setConnectionError("Failed to stream data from device");
        }
      })
      .catch(error => {
        console.error("Connection error:", error);
        setConnectionError("Failed to connect to device");
      });
  }
  
  function updateSavedDevices() {
    getSavedDevices()
      .then(devices => {
        console.log("Saved devices:", devices);
        setSavedDevices(devices);
   
        // Prevent saved devices from showing during scanning
        devices.forEach(device => {
          undiscoveredDeviceSet.current.add(device.id);
        });
      })
      .catch(error => {
        console.error("Error getting saved devices:", error);
        // Initialize with empty array if there's an error
        setSavedDevices([]);
      });
  }

  function scanDevices(): void {
    const manager: BleManager = bluetoothHandler.getBLEManager();
    setScanning(true);
    setScannedDevices([]);
    
    // Only clear the set for new devices, keep saved devices in the set
    const savedIds = new Set(savedDevices.map(device => device.id));
    undiscoveredDeviceSet.current = savedIds;

    manager.startDeviceScan(null, null, (error: BleError | null, device: Device | null) => {
      if (error) {
        console.error('Error scanning devices:', error.message);
        setScanning(false);
        return;
      }

      if (device && device.name && !undiscoveredDeviceSet.current.has(device.id)) {
        undiscoveredDeviceSet.current.add(device.id); // Add device ID to the Set
        setScannedDevices((prevDevices) => [...prevDevices, device]);
      }
    });

    // Stop scanning after 10 seconds
    setTimeout(() => {
      manager.stopDeviceScan();
      setScanning(false);
    }, 10000);
  }

  // Renders device
  const renderDevice = ({ item }: { item: Device | SavedDevice }): JSX.Element => (
    <TouchableOpacity 
      style={styles.deviceItem} 
      onPress={() => { (item instanceof Device) ? connectAndListenToDevice(item.id, item) : connectAndListenToDevice(item.id) }}
    >
      <View style={styles.deviceIconContainer}>
        <MaterialCommunityIcons name="bluetooth" size={22} color={COLORS.primary} />
      </View>
      <View style={styles.deviceInfo}>
        <Text style={styles.deviceName}>{item.name}</Text>
        <Text style={styles.deviceStatus}>
          {item.id === deviceConnectedId ? "Connected" : "Not Connected"}
        </Text>
      </View>
      <MaterialCommunityIcons 
        name="chevron-right" 
        size={24} 
        color={COLORS.text.secondary} 
      />
    </TouchableOpacity>
  );

  return (
    <SafeAreaProvider>
      <ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Devices</Text>
        </View>

        {/* My Devices Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>My Devices</Text>
          <View style={styles.sectionCard}>
            {savedDevices.length > 0 ? (
              <FlatList
                data={savedDevices}
                keyExtractor={(item) => item.id}
                renderItem={renderDevice}
                scrollEnabled={false}
                ItemSeparatorComponent={() => <View style={styles.deviceSeparator} />}
              />
            ) : (
              <View style={styles.emptyStateContainer}>
                <MaterialCommunityIcons name="devices" size={40} color={COLORS.text.tertiary} />
                <Text style={styles.emptyStateText}>No paired devices</Text>
              </View>
            )}
          </View>
        </View>

        {/* Available Devices Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Available Devices</Text>
          
          <TouchableOpacity 
            style={styles.scanButton} 
            onPress={scanDevices} 
            disabled={scanning}
          >
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark || '#00C853']}
              style={styles.scanButtonGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="bluetooth-settings" 
                size={20} 
                color="#000" 
              />
              <Text style={styles.scanButtonText}>
                {scanning ? 'Scanning...' : 'Scan for Devices'}
              </Text>
            </LinearGradient>
          </TouchableOpacity>
          
          {scanning && (
            <View style={styles.scanningIndicator}>
              <ActivityIndicator size="small" color={COLORS.primary} />
              <Text style={styles.scanningText}>Searching for devices...</Text>
            </View>
          )}
          
          {scannedDevices.length > 0 && (
            <View style={styles.sectionCard}>
              <FlatList
                data={scannedDevices}
                keyExtractor={(item) => item.id}
                renderItem={renderDevice}
                scrollEnabled={false}
                ItemSeparatorComponent={() => <View style={styles.deviceSeparator} />}
              />
            </View>
          )}
          
          {!scanning && scannedDevices.length === 0 && (
            <View style={styles.sectionCard}>
              <View style={styles.emptyStateContainer}>
                <MaterialCommunityIcons name="bluetooth-off" size={40} color={COLORS.text.tertiary} />
                <Text style={styles.emptyStateText}>No devices found</Text>
                <Text style={styles.emptyStateSubtext}>Tap the scan button to search for devices</Text>
              </View>
            </View>
          )}
        </View>
        
        {/* Connection Info Card */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Connection Info</Text>
          <View style={styles.infoCard}>
            <View style={styles.infoRow}>
              <Text style={styles.infoLabel}>Status:</Text>
              <Text style={[
                styles.infoValue, 
                deviceConnectedId ? styles.connectedText : styles.disconnectedText
              ]}>
                {deviceConnectedId ? 'Connected' : 'Disconnected'}
              </Text>
            </View>
            {deviceConnectedId && (
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Device ID:</Text>
                <Text style={styles.infoValue}>{deviceConnectedId}</Text>
              </View>
            )}
            {connectionError && (
              <View style={styles.errorContainer}>
                <MaterialCommunityIcons name="alert-circle" size={18} color="#FF5252" />
                <Text style={styles.errorText}>{connectionError}</Text>
              </View>
            )}
          </View>
        </View>
      </ScrollView>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 8,
    marginTop: 30
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.35,
  },
  section: {
    marginBottom: 24,
    paddingHorizontal: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  sectionCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
    overflow: 'hidden',
  },
  deviceItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
  },
  deviceSeparator: {
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginLeft: 56,
  },
  deviceIconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  deviceInfo: {
    flex: 1,
  },
  deviceName: {
    fontSize: 16,
    fontWeight: '500',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  deviceStatus: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  scanButton: {
    marginBottom: 16,
    borderRadius: 12,
    overflow: 'hidden',
  },
  scanButtonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    paddingHorizontal: 24,
  },
  scanButtonText: {
    color: '#000',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  scanningIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  scanningText: {
    marginLeft: 8,
    color: COLORS.text.secondary,
    fontSize: 14,
  },
  emptyStateContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 24,
  },
  emptyStateText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    marginTop: 12,
  },
  emptyStateSubtext: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginTop: 4,
    textAlign: 'center',
  },
  infoCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    padding: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
  },
  infoRow: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  infoLabel: {
    width: 100,
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  infoValue: {
    flex: 1,
    fontSize: 14,
    color: COLORS.text.primary,
  },
  connectedText: {
    color: COLORS.primary,
    fontWeight: '500',
  },
  disconnectedText: {
    color: '#FF5252',
    fontWeight: '500',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 82, 82, 0.1)',
    padding: 12,
    borderRadius: 8,
    marginTop: 8,
  },
  errorText: {
    color: '#FF5252',
    fontSize: 14,
    marginLeft: 8,
  }
});

================================================================================
File: app/(tabs)/index.tsx
================================================================================

import { Redirect } from 'expo-router';

export default function Index() {
  return <Redirect href="/mydata" />;
}

================================================================================
File: app/(tabs)/journal.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, Modal, TextInput, Button, StyleSheet } from 'react-native';
import { Calendar } from 'react-native-calendars';

export default function JournalCalendar() {
  const [selectedDate, setSelectedDate] = useState('');
  const [modalVisible, setModalVisible] = useState(false);
  const [entries, setEntries] = useState({});
  const [currentEntry, setCurrentEntry] = useState('');

  const handleDayPress = (day) => {
    const date = day.dateString;
    setSelectedDate(date);
    setCurrentEntry(entries[date] || '');
    setModalVisible(true);
  };

  const saveEntry = () => {
    setEntries({ ...entries, [selectedDate]: currentEntry });
    setModalVisible(false);
  };

  return (
    <View style={styles.container}>
      {/* Calendar */}
      <Calendar
        onDayPress={handleDayPress}
        markedDates={{
          ...Object.keys(entries).reduce((acc, date) => {
            acc[date] = { marked: true };
            return acc;
          }, {}),
          [selectedDate]: { selected: true, selectedColor: '#12a35f' },
        }}
      />

      {/* Modal for journal entry */}
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              Journal Entry for {selectedDate}
            </Text>
            <TextInput
              style={styles.input}
              multiline
              placeholder="Write your journal entry here..."
              value={currentEntry}
              onChangeText={setCurrentEntry}
            />
            <View style={styles.modalButtons}>
              <Button title="Save" onPress={saveEntry} />
              <Button title="Cancel" onPress={() => setModalVisible(false)} />
            </View>
          </View>
        </View>
      </Modal>

      {/* Display Saved Entries */}
      <View style={styles.entriesContainer}>
        <Text style={styles.entriesTitle}>Saved Journal Entries:</Text>
        {Object.keys(entries).length > 0 ? (
          Object.entries(entries).map(([date, entry]) => (
            <View key={date} style={styles.entry}>
              <Text style={styles.entryDate}>{date}</Text>
              <Text style={styles.entryText}>{entry}</Text>
            </View>
          ))
        ) : (
          <Text>No journal entries yet.</Text>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '80%',
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 20,
    alignItems: 'center',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  input: {
    width: '100%',
    height: 100,
    borderColor: '#ddd',
    borderWidth: 1,
    borderRadius: 5,
    padding: 10,
    textAlignVertical: 'top',
    marginBottom: 20,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  entriesContainer: {
    marginTop: 20,
  },
  entriesTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  entry: {
    marginBottom: 10,
  },
  entryDate: {
    fontWeight: 'bold',
  },
  entryText: {
    fontSize: 14,
  },
});


================================================================================
File: app/(tabs)/mydata.tsx
================================================================================

import React, { memo, useCallback, useState, useEffect } from 'react';
import { View, StyleSheet, TouchableOpacity, Alert } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { COLORS } from '../../src/constants';
import { useDataService } from '../../src/hooks/useDataService';
import { databaseManager } from "../../src/DatabaseManager";
import { BongHit } from '../../src/types';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LinearGradient } from 'expo-linear-gradient';
import { Text } from 'react-native';
import MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';

// Import components from their new structure
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';
import Header from '../components/mydata/Header';
import Section from '../components/mydata/Section';
import NotificationBanner from '../components/mydata/NotificationBanner';
import MedicalCard from '../components/mydata/MedicalCard';
import DailyAverageCard from '../components/mydata/DailyAverageCard';
import WeeklyUsageBanner from '../components/mydata/WeeklyUsageBanner';
import WeeklyOverviewChart from '../components/charts/WeeklyOverviewChart';
import MonthlyOverviewChart from '../components/charts/MonthlyOverviewChart';
import StatsOverviewCard from '../components/StatsOverviewCard';
import TimeDistributionCard from '../components/TimeDistributionCard';

// Import new components
import GoalTrackingCard from '../components/mydata/GoalTrackingCard';
import SetGoalModal from '../components/mydata/SetGoalModal';
import StrainUsageCard from '../components/mydata/StrainUsageCard';
import AIRecommendationCard from '../components/mydata/AIRecommendationCard';
import { BongHitLogsCard } from '../components/mydata/BongHitLogsCard';
import SubscriptionButton from '../components/mydata/SubscriptionButton';
import SubscriptionModal from '../components/mydata/SubscriptionModal';
import { AchievementsButton } from '../components/mydata/AchievementsButton';
import { useAchievements } from '../context/AchievementContext';
import { AchievementUnlockedNotification } from '../components/achievements/AchievementUnlockedNotification';

const ROUTES = {
  DAILY_AVERAGE: "/dataOverviews/dailyAverageOverview",
  WEEKLY_AVERAGE: "/dataOverviews/weeklyAverage",
  WEEKLY_OVERVIEW: "/dataOverviews/weeklyOverview",
  MONTHLY_OVERVIEW: "/dataOverviews/monthlyOverview",
  STRAIN_USAGE: "/dataOverviews/strainUsage",
  BONG_HIT_LOGS: "/dataOverviews/bongHitLogs",
} as const;

export default memo(function MyData() {
  const router = useRouter();
  const [showNotification, setShowNotification] = useState(true);
  const [goalModalVisible, setGoalModalVisible] = useState(false);
  const [dailyGoal, setDailyGoal] = useState(10); // Default goal
  const [bongHitSummary, setBongHitSummary] = useState({
    totalHits: 0,
    averageDuration: 0,
    recentTimestamp: new Date().toISOString()
  });
  const [subscriptionModalVisible, setSubscriptionModalVisible] = useState(false);
  const { stats, newlyUnlocked, clearNewlyUnlocked } = useAchievements();
  
  const { 
    weeklyData, 
    monthlyData, 
    usageStats, 
    timeDistribution,
    isLoading, 
    error 
  } = useDataService();

  useEffect(() => {
    const fetchBongHitData = async () => {
      try {
        const dataService = databaseManager;
        const bongHitLogsResponse = await databaseManager.getAllBongHitLogs();
        
        if (bongHitLogsResponse.success && bongHitLogsResponse.data && bongHitLogsResponse.data.length > 0) {
          const logs = bongHitLogsResponse.data;
          const totalDuration = logs.reduce((sum: number, log: BongHit) => sum + log.duration_ms, 0);
          
          setBongHitSummary({
            totalHits: logs.length,
            averageDuration: totalDuration / (logs.length * 1000), // convert to seconds
            recentTimestamp: logs[0].timestamp
          });
        }
      } catch (error) {
        console.error('Failed to fetch bong hit data:', error);
      }
    };
    
    fetchBongHitData();
  }, []);

  const handleNavigation = useCallback((route: keyof typeof ROUTES) => {
    router.push(ROUTES[route] as any);
  }, [router]);

  const handleNavigateToAI = () => {
    router.push('/ai/recommendations' as any);
  };
  
  const handleSubscribe = (planId: string) => {
    setSubscriptionModalVisible(false);
    // In a real app, this would process payment and update subscription status
    Alert.alert('Subscription', `Successfully subscribed to plan: ${planId}`);
  };

  const handleAchievementsPress = () => {
    router.push('/screens/AchievementsScreen' as any);
  };
  
  const handleAchievementNotificationPress = () => {
    clearNewlyUnlocked();
    router.push('/screens/AchievementsScreen' as any);
  };

  // Sample strain data - in a real app, this would come from your database
  const mockStrainData = [
    {
      strainId: 1,
      strainName: "Blue Dream",
      strainType: "Hybrid",
      usageCount: 42,
      percentageOfTotal: 35.6
    },
    {
      strainId: 2,
      strainName: "OG Kush",
      strainType: "Indica",
      usageCount: 28,
      percentageOfTotal: 23.7
    },
    {
      strainId: 3,
      strainName: "Sour Diesel",
      strainType: "Sativa",
      usageCount: 18,
      percentageOfTotal: 15.3
    }
  ];

  if (isLoading) return <LoadingView />;
  if (error) return <ErrorView error={error} />;

  const weekdayAvg = usageStats.weekdayStats?.weekday.avg || 0;
  const weekendAvg = usageStats.weekdayStats?.weekend.avg || 0;
  const percentageChange = weekdayAvg > 0 ? ((weekendAvg - weekdayAvg) / weekdayAvg) * 100 : 0;

  return (
    <SafeAreaProvider>
      <Animated.ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={false}
        entering={FadeIn.duration(200)}
        scrollEventThrottle={16}
        removeClippedSubviews={true}
      >
        <Header />

        <View style={styles.mainContent}>
          {/* Goals Section */}
          <Section title="Goals & Tracking">
            <GoalTrackingCard
              currentUsage={usageStats.averageHitsPerDay}
              goalUsage={dailyGoal}
              onEditGoal={() => setGoalModalVisible(true)}
            />
          </Section>

          <Section title="Consumption Data">
          <DailyAverageCard
              data={weeklyData}
              averageHits={usageStats.averageHitsPerDay}
              onPress={() => handleNavigation("DAILY_AVERAGE")}
            />
            <WeeklyUsageBanner
              weeklyData={weeklyData}
              average={usageStats.averageHitsPerDay}
              onPress={() => handleNavigation("WEEKLY_AVERAGE")}
            />
            <BongHitLogsCard
              totalHits={bongHitSummary.totalHits}
              averageDuration={bongHitSummary.averageDuration}
              recentTimestamp={bongHitSummary.recentTimestamp}
              onPress={() => handleNavigation("BONG_HIT_LOGS")}
            />
          </Section>

          <Section title="Usage Overview">
            <StrainUsageCard
              strainData={mockStrainData}
              totalHits={usageStats.totalHits || 100}
              onViewAll={() => handleNavigation("STRAIN_USAGE")}
            />
          </Section>

          <Section title="Detailed Statistics">
            <StatsOverviewCard stats={usageStats} />
            <TimeDistributionCard timeData={timeDistribution} />
          </Section>

          {/* AI Recommendations Card */}
          <AIRecommendationCard onPress={handleNavigateToAI} />

          <AchievementsButton 
            onPress={handleAchievementsPress}
            unlocked={stats.unlocked}
            total={stats.total}
          />
        </View>
      </Animated.ScrollView>

      {/* Goal Setting Modal */}
      <SetGoalModal
        visible={goalModalVisible}
        onClose={() => setGoalModalVisible(false)}
        onSave={(goal) => setDailyGoal(goal)}
        currentGoal={dailyGoal}
      />

      {/* Subscription Modal */}
      <SubscriptionModal
        visible={subscriptionModalVisible}
        onClose={() => setSubscriptionModalVisible(false)}
        onSubscribe={handleSubscribe}
      />

      {newlyUnlocked && (
        <AchievementUnlockedNotification 
          achievement={newlyUnlocked}
          onPress={handleAchievementNotificationPress}
          onDismiss={clearNewlyUnlocked}
        />
      )}
    </SafeAreaProvider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  contentContainer: {
    paddingBottom: 32,
  },
  mainContent: {
    paddingHorizontal: 20,
  }
});

================================================================================
File: app/(tabs)/trending.tsx
================================================================================

// app/(tabs)/trending.tsx
import React, { useState, useCallback, useEffect, memo, useMemo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { useRouter } from 'expo-router';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useStrains } from '../../src/hooks/useStrains';
import { COLORS } from '../../src/constants';
import { StrainSearchFilters } from '../../src/DatabaseManager';
import { Strain } from "@/src/types";
import { LinearGradient } from 'expo-linear-gradient';
import LoadingView from '../components/shared/LoadingView';
import Header from '../components/trending/Header';
import StrainsList from '../components/trending/StrainsList';
import CompareBar from '../components/trending/CompareBar';
import SearchFilters from '../components/trending/SearchFilters';
import { hasActiveFilters } from '../../src/utils/filters';
import Animated, { FadeIn } from 'react-native-reanimated';

const TrendingScreen = memo(() => {
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState('');
  const [showFilters, setShowFilters] = useState(false);
  const [compareList, setCompareList] = useState<Strain[]>([]);
  const [filters, setFilters] = useState<StrainSearchFilters>({
    geneticType: undefined,
    effects: [],
    sort: 'rating'
  });

  const { 
    strains,
    popularStrains,
    categories,
    isLoading,
    error,
    searchStrains,
    clearSearch,
    loadMore,
    toggleFavorite,
    isFavorite,
    pagination
  } = useStrains();

  useEffect(() => {
    const delaySearch = setTimeout(() => {
      if (searchQuery.trim() || hasActiveFilters(filters)) {
        searchStrains(searchQuery, filters);
      } else {
        clearSearch();
      }
    }, 300);

    return () => clearTimeout(delaySearch);
  }, [searchQuery, filters, searchStrains, clearSearch]);

  const handleFilterChange = useCallback((newFilters: StrainSearchFilters) => {
    setFilters(newFilters);
  }, []);

  const handleApplyFilters = useCallback(() => {
    setShowFilters(false);
  }, []);

  const handleClearSearch = useCallback(() => {
    setSearchQuery('');
    setFilters({
      geneticType: undefined,
      effects: [],
      sort: 'rating'
    });
    clearSearch();
  }, [clearSearch]);

  const handleCompareToggle = useCallback((strain: Strain) => {
    setCompareList(prev => {
      if (prev.some(s => s.id === strain.id)) {
        return prev.filter(s => s.id !== strain.id);
      }
      if (prev.length >= 3) return prev;
      return [...prev, strain];
    });
  }, []);

  const handleCompare = useCallback(() => {
    if (compareList.length >= 2) {
      router.push({
        pathname: "/dataOverviews/compare",
        params: { ids: compareList.map(s => s.id).join(',') }
      } as any);
    }
  }, [compareList, router]);

  // Memoize the displayed strains to prevent unnecessary re-renders
  const displayedStrains = useMemo(() => 
    searchQuery.trim() || hasActiveFilters(filters) ? strains : popularStrains,
    [searchQuery, filters, strains, popularStrains]
  );

  // Memoize the section title
  const sectionTitle = useMemo(() => 
    searchQuery.trim() || hasActiveFilters(filters) 
      ? `Search Results (${pagination.total})`
      : "Popular Strains",
    [searchQuery, filters, pagination.total]
  );

  if (isLoading && !strains.length && !popularStrains.length) {
    return <LoadingView />;
  }

  return (
    <SafeAreaProvider>
      <View style={styles.container}>
        {/* Black background */}
        <View style={StyleSheet.absoluteFillObject} />
        
        {/* Header with glow effect */}
        <LinearGradient
          colors={['rgba(0, 230, 118, 0.15)', 'transparent']}
          style={styles.headerGradient}
          start={{ x: 0.5, y: 0 }}
          end={{ x: 0.5, y: 0.3 }}
        />
        
        <Header 
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          showFilters={showFilters}
          setShowFilters={setShowFilters}
          filters={filters}
          handleClearSearch={handleClearSearch}
        />

        {showFilters && (
          <Animated.View 
            entering={FadeIn.duration(300)}
            style={styles.filtersContainer}
          >
            <SearchFilters
              filters={filters}
              onFilterChange={handleFilterChange}
              onApplyFilters={handleApplyFilters}
              categories={categories}
            />
          </Animated.View>
        )}

        <View style={styles.mainContent}>
          <View style={styles.sectionHeaderContainer}>
            <LinearGradient
              colors={['rgba(0, 230, 118, 0.12)', 'transparent']}
              style={styles.sectionHeaderGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
            <Text style={styles.sectionTitle}>{sectionTitle}</Text>
          </View>
          
          {/* Don't wrap this in a ScrollView since StrainsList is already virtualized */}
          <View style={styles.listWrapper}>
            <StrainsList
              strains={displayedStrains}
              onCompareToggle={handleCompareToggle}
              onFavoriteToggle={toggleFavorite}
              compareList={compareList}
              isFavorite={isFavorite}
              isLoading={isLoading}
              onEndReached={loadMore}
            />
          </View>
        </View>

        {compareList.length > 0 && (
          <CompareBar
            compareList={compareList}
            onCompareToggle={handleCompareToggle}
            onCompare={handleCompare}
          />
        )}
      </View>
    </SafeAreaProvider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000000', // Jet black background
  },
  headerGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 150,
    zIndex: 0,
  },
  filtersContainer: {
    paddingHorizontal: 20,
    paddingBottom: 16,
    marginTop: 8,
    zIndex: 1,
  },
  mainContent: {
    flex: 1,
    paddingHorizontal: 20,
  },
  sectionHeaderContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    paddingVertical: 10,
    position: 'relative',
  },
  sectionHeaderGradient: {
    position: 'absolute',
    left: -20,
    right: -20,
    top: 0,
    bottom: 0,
    height: '100%',
    borderRadius: 8,
  },
  sectionTitle: {
    fontSize: 22,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
    textShadowColor: 'rgba(0, 230, 118, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  listWrapper: {
    flex: 1,
  }
});

export default TrendingScreen;

================================================================================
File: app/ai/_layout.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { Tabs, useRouter, usePathname } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { View, ActivityIndicator, Text, StyleSheet } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../src/constants';

export default function AILayout() {
  const router = useRouter();
  const pathname = usePathname();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    // Check if the user has completed onboarding
    const checkOnboardingStatus = async () => {
      try {
        // Add a small delay to prevent UI jittering
        await new Promise(resolve => setTimeout(resolve, 300));
        
        const hasCompletedOnboarding = await AsyncStorage.getItem('ai_onboarding_completed');
        
        if (hasCompletedOnboarding !== 'true') {
          // Only redirect if we're not already on the onboarding screen
          if (!pathname.includes('/ai/onboarding')) {
            router.replace('/ai/onboarding');
          }
        }
      } catch (error) {
        console.error('Error checking onboarding status:', error);
        setError('Failed to check onboarding status');
      } finally {
        setIsLoading(false);
      }
    };
    
    checkOnboardingStatus();
  }, [router, pathname]);
  
  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <LinearGradient
          colors={['rgba(0,230,118,0.1)', 'transparent']}
          style={styles.loadingGradient}
          start={{ x: 0.5, y: 0 }}
          end={{ x: 0.5, y: 1 }}
        />
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>Loading...</Text>
      </View>
    );
  }
  
  if (error) {
    return (
      <View style={styles.errorContainer}>
        <LinearGradient
          colors={['rgba(255,107,107,0.1)', 'transparent']}
          style={styles.errorGradient}
          start={{ x: 0.5, y: 0 }}
          end={{ x: 0.5, y: 1 }}
        />
        <View style={styles.errorContent}>
          <MaterialCommunityIcons 
            name="alert-circle-outline" 
            size={48} 
            color="#ff6b6b" 
          />
          <Text style={styles.errorTitle}>Something went wrong</Text>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorSubtext}>
            Please restart the app or try again later.
          </Text>
        </View>
      </View>
    );
  }
  
  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: COLORS.primary,
        tabBarInactiveTintColor: COLORS.text.tertiary,
        tabBarStyle: {
          backgroundColor: COLORS.background,
          borderTopColor: 'rgba(255, 255, 255, 0.1)',
          borderTopWidth: 1,
          elevation: 0,
          shadowOpacity: 0,
        },
        tabBarLabelStyle: {
          fontSize: 12,
          fontWeight: '500',
        },
        headerStyle: {
          backgroundColor: COLORS.background,
          elevation: 0,
          shadowOpacity: 0,
          borderBottomWidth: 1,
          borderBottomColor: 'rgba(255, 255, 255, 0.1)',
        },
        headerTintColor: COLORS.text.primary,
        headerTitleStyle: {
          fontWeight: '600',
        }
      }}
    >
      <Tabs.Screen
        name="recommendations"
        options={{
          title: 'Recommendations',
          tabBarLabel: 'Recommendations',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="leaf" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="chat"
        options={{
          title: 'AI Assistant',
          tabBarLabel: 'Chat',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="chat-processing" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="journal-insights"
        options={{
          title: 'Journal Insights',
          tabBarLabel: 'Insights',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="chart-line" size={size} color={color} />
          ),
        }}
      />
      
      <Tabs.Screen
        name="onboarding"
        options={{
          href: null, // Hide from tab bar
          headerShown: false,
        }}
      />
    </Tabs>
  );
}

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
    position: 'relative',
  },
  loadingGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: COLORS.text.secondary,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
    padding: 24,
    position: 'relative',
  },
  errorGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  errorContent: {
    alignItems: 'center',
    backgroundColor: COLORS.cardBackground,
    padding: 24,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 107, 107, 0.2)',
    width: '90%',
    maxWidth: 400,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginTop: 16,
    marginBottom: 8,
  },
  errorText: {
    fontSize: 16,
    color: '#ff6b6b',
    textAlign: 'center',
    marginBottom: 16,
  },
  errorSubtext: {
    fontSize: 14,
    color: COLORS.text.secondary,
    textAlign: 'center',
  }
});

================================================================================
File: app/ai/chat.tsx
================================================================================

import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity, 
  FlatList,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator
} from 'react-native';
import { Stack } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { ChatMessage, UserProfile } from '../../src/types';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

// Initial welcome message
const WELCOME_MESSAGE: ChatMessage = {
  id: 'welcome',
  content: "Hi there! I'm your cannabis assistant. I can help you find strains, answer questions about cannabis, or provide guidance on usage. What would you like to know?",
  role: 'assistant',
  timestamp: new Date().toISOString()
};

export default function ChatScreen() {
  const { loading, error, chatHistory, getChatResponse, clearChatHistory } = useAIRecommendations();
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<ChatMessage[]>([WELCOME_MESSAGE]);
  const flatListRef = useRef<FlatList>(null);
  
  // Initialize chat history
  useEffect(() => {
    if (chatHistory.length > 0) {
      setMessages([WELCOME_MESSAGE, ...chatHistory]);
    }
  }, [chatHistory]);
  
  // Scroll to bottom when messages change
  useEffect(() => {
    if (flatListRef.current && messages.length > 0) {
      setTimeout(() => {
        flatListRef.current?.scrollToEnd({ animated: true });
      }, 100);
    }
  }, [messages]);
  
  // Handle sending a message
  const handleSendMessage = async () => {
    if (!message.trim()) return;
    
    const userMessage = message.trim();
    setMessage('');
    
    // Add user message to local state immediately for better UX
    const newUserMessage: ChatMessage = {
      id: `user_${Date.now()}`,
      content: userMessage,
      role: 'user',
      timestamp: new Date().toISOString()
    };
    
    setMessages(prev => [...prev, newUserMessage]);
    
    // Get AI response
    const response = await getChatResponse(userMessage, mockUserProfile);
    
    if (response) {
      setMessages(prev => [...prev, response]);
    } else if (error) {
      // Add error message if request failed
      const errorMessage: ChatMessage = {
        id: `error_${Date.now()}`,
        content: "Sorry, I'm having trouble responding right now. Please try again later.",
        role: 'assistant',
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, errorMessage]);
    }
  };
  
  // Clear chat history
  const handleClearChat = () => {
    clearChatHistory();
    setMessages([WELCOME_MESSAGE]);
  };
  
  // Render a chat message
  const renderMessage = ({ item }: { item: ChatMessage }) => {
    const isUser = item.role === 'user';
    
    return (
      <View style={[
        styles.messageContainer,
        isUser ? styles.userMessageContainer : styles.assistantMessageContainer
      ]}>
        {!isUser && (
          <View style={styles.avatarContainer}>
            <MaterialCommunityIcons name="robot" size={24} color="#fff" />
          </View>
        )}
        
        <View style={[
          styles.messageBubble,
          isUser ? styles.userMessageBubble : styles.assistantMessageBubble
        ]}>
          <Text style={styles.messageText}>{item.content}</Text>
        </View>
        
        {isUser && (
          <View style={styles.avatarContainer}>
            <MaterialCommunityIcons name="account" size={24} color="#fff" />
          </View>
        )}
      </View>
    );
  };
  
  if (loading && messages.length === 1) {
    return <LoadingView />;
  }
  
  if (error && messages.length === 1) {
    return <ErrorView error={error} />;
  }
  
  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
    >
      <Stack.Screen 
        options={{
          title: 'AI Assistant',
          headerRight: () => (
            <TouchableOpacity onPress={handleClearChat} style={styles.clearButton}>
              <MaterialCommunityIcons name="delete-outline" size={24} color={COLORS.text.primary} />
            </TouchableOpacity>
          ),
        }} 
      />
      
      <FlatList
        ref={flatListRef}
        data={messages}
        renderItem={renderMessage}
        keyExtractor={item => item.id}
        contentContainerStyle={styles.messagesContainer}
      />
      
      {error && messages.length > 1 && (
        <View style={styles.errorContainer}>
          <MaterialCommunityIcons name="alert-circle" size={20} color="#ff6b6b" />
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}
      
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.input}
          placeholder="Type a message..."
          placeholderTextColor={COLORS.text.tertiary}
          value={message}
          onChangeText={setMessage}
          multiline
          maxLength={500}
          onSubmitEditing={handleSendMessage}
        />
        
        <TouchableOpacity 
          style={[
            styles.sendButton,
            (!message.trim() || loading) && styles.disabledSendButton
          ]}
          onPress={handleSendMessage}
          disabled={!message.trim() || loading}
        >
          {loading ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <MaterialCommunityIcons name="send" size={24} color="#fff" />
          )}
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  messagesContainer: {
    padding: 16,
    paddingBottom: 24,
  },
  messageContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    alignItems: 'flex-end',
  },
  userMessageContainer: {
    justifyContent: 'flex-end',
  },
  assistantMessageContainer: {
    justifyContent: 'flex-start',
  },
  avatarContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginHorizontal: 8,
  },
  messageBubble: {
    maxWidth: '70%',
    padding: 12,
    borderRadius: 16,
  },
  userMessageBubble: {
    backgroundColor: COLORS.primary,
    borderBottomRightRadius: 4,
  },
  assistantMessageBubble: {
    backgroundColor: COLORS.cardBackground,
    borderBottomLeftRadius: 4,
  },
  messageText: {
    color: COLORS.text.primary,
    fontSize: 16,
    lineHeight: 22,
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
    backgroundColor: COLORS.cardBackground,
    alignItems: 'center',
  },
  input: {
    flex: 1,
    backgroundColor: COLORS.background,
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 10,
    color: COLORS.text.primary,
    fontSize: 16,
    maxHeight: 120,
  },
  sendButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: COLORS.primary,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 12,
  },
  disabledSendButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.3)',
  },
  clearButton: {
    padding: 8,
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    padding: 12,
    borderRadius: 8,
    margin: 12,
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
});

================================================================================
File: app/ai/index.tsx
================================================================================

import { useEffect } from 'react';
import { Redirect } from 'expo-router';

export default function AIIndex() {
  // Redirect to the recommendations screen by default
  return <Redirect href={'/ai/recommendations' as any} />;
} 

================================================================================
File: app/ai/journal-insights.tsx
================================================================================

import React, { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity,
  ActivityIndicator
} from 'react-native';
import { Stack } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { UserProfile } from '../../src/types';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Mock journal entries for demo purposes
const mockJournalEntries = [
  {
    id: "j1",
    user_id: "user123",
    strain_id: 1,
    strain_name: "Blue Dream",
    consumption_method: "vaporize",
    dosage: 15,
    dosage_unit: "mg",
    effects_felt: ["Relaxed", "Happy", "Creative"],
    rating: 4,
    effectiveness: 4,
    notes: "Good for evening relaxation, helped with creativity",
    mood_before: "Stressed",
    mood_after: "Calm",
    medical_symptoms_relieved: ["Anxiety"],
    negative_effects: ["Dry mouth"],
    duration_minutes: 180,
    created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
  },
  {
    id: "j2",
    user_id: "user123",
    strain_id: 2,
    strain_name: "OG Kush",
    consumption_method: "edible",
    dosage: 10,
    dosage_unit: "mg",
    effects_felt: ["Sleepy", "Relaxed", "Hungry"],
    rating: 3,
    effectiveness: 4,
    notes: "Helped with sleep, but made me too hungry",
    mood_before: "Tired",
    mood_after: "Sleepy",
    medical_symptoms_relieved: ["Insomnia"],
    negative_effects: ["Groggy morning"],
    duration_minutes: 240,
    created_at: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
  },
  {
    id: "j3",
    user_id: "user123",
    strain_id: 3,
    strain_name: "Sour Diesel",
    consumption_method: "flower",
    dosage: 0.5,
    dosage_unit: "g",
    effects_felt: ["Energetic", "Focused", "Creative"],
    rating: 5,
    effectiveness: 5,
    notes: "Perfect for morning use, helped with productivity",
    mood_before: "Groggy",
    mood_after: "Energized",
    medical_symptoms_relieved: ["Fatigue"],
    negative_effects: [],
    duration_minutes: 150,
    created_at: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()
  }
];

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

export default function JournalInsightsScreen() {
  const { loading, error, analyzeJournalPatterns } = useAIRecommendations();
  const [insights, setInsights] = useState<any>(null);
  
  // Handle analyzing journal entries
  const handleAnalyzeJournal = async () => {
    const analysis = await analyzeJournalPatterns(mockJournalEntries, mockUserProfile);
    if (analysis) {
      setInsights(analysis);
    }
  };
  
  if (loading && !insights) {
    return <LoadingView />;
  }
  
  if (error && !insights) {
    return <ErrorView error={error} />;
  }
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          title: 'Journal Insights',
        }} 
      />
      
      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        <View style={styles.headerContainer}>
          <Text style={styles.headerTitle}>AI Journal Analysis</Text>
          <Text style={styles.headerSubtitle}>
            Get personalized insights based on your journal entries
          </Text>
        </View>
        
        <View style={styles.journalSummaryContainer}>
          <Text style={styles.sectionTitle}>Journal Summary</Text>
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{mockJournalEntries.length}</Text>
              <Text style={styles.statLabel}>Entries</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>
                {(mockJournalEntries.reduce((sum, entry) => sum + entry.rating, 0) / mockJournalEntries.length).toFixed(1)}
              </Text>
              <Text style={styles.statLabel}>Avg Rating</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>
                {[...new Set(mockJournalEntries.map(entry => entry.strain_name))].length}
              </Text>
              <Text style={styles.statLabel}>Strains</Text>
            </View>
          </View>
        </View>
        
        <TouchableOpacity 
          style={styles.analyzeButton}
          onPress={handleAnalyzeJournal}
          disabled={loading}
        >
          <Text style={styles.analyzeButtonText}>
            {loading ? 'Analyzing...' : 'Analyze My Journal'}
          </Text>
          {loading && (
            <ActivityIndicator 
              size="small" 
              color="#fff" 
              style={styles.loadingIndicator} 
            />
          )}
        </TouchableOpacity>
        
        {error && insights && (
          <View style={styles.errorContainer}>
            <MaterialCommunityIcons name="alert-circle" size={24} color="#ff6b6b" />
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}
        
        {insights && (
          <View style={styles.insightsContainer}>
            <Text style={styles.insightsTitle}>Your Personalized Insights</Text>
            
            {/* Pattern Insights */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="chart-line" size={24} color={COLORS.primary} />
                <Text style={styles.insightHeaderText}>Usage Patterns</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.patterns?.summary || "You tend to use cannabis in the evening for relaxation. Your highest rated strains are typically Sativa dominant."}
              </Text>
            </View>
            
            {/* Effectiveness Insights */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="check-circle" size={24} color={COLORS.primary} />
                <Text style={styles.insightHeaderText}>Effectiveness</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.effectiveness?.summary || "Based on your ratings, strains with high myrcene content seem to be most effective for your needs."}
              </Text>
              <View style={styles.effectiveStrains}>
                {(insights.effectiveness?.topStrains || ["Sour Diesel", "Blue Dream"]).map((strain: string, index: number) => (
                  <View key={`strain-${index}`} style={styles.effectiveStrain}>
                    <Text style={styles.effectiveStrainText}>{strain}</Text>
                  </View>
                ))}
              </View>
            </View>
            
            {/* Recommendations */}
            <View style={styles.insightCard}>
              <View style={styles.insightHeader}>
                <MaterialCommunityIcons name="lightbulb" size={24} color={COLORS.primary} />
                <Text style={styles.insightHeaderText}>Recommendations</Text>
              </View>
              <Text style={styles.insightText}>
                {insights.recommendations?.summary || "Consider trying lower doses in the evening to improve sleep quality without morning grogginess."}
              </Text>
              <View style={styles.recommendationsList}>
                {(insights.recommendations?.tips || [
                  "Try vaporizing at a lower temperature",
                  "Consider CBD-rich strains for anxiety",
                  "Journal more consistently for better insights"
                ]).map((tip: string, index: number) => (
                  <View key={`tip-${index}`} style={styles.recommendationItem}>
                    <MaterialCommunityIcons name="arrow-right" size={16} color={COLORS.primary} />
                    <Text style={styles.recommendationText}>{tip}</Text>
                  </View>
                ))}
              </View>
            </View>
          </View>
        )}
        
        {!insights && !loading && (
          <View style={styles.placeholderContainer}>
            <MaterialCommunityIcons name="book-open-page-variant" size={64} color={COLORS.text.tertiary} />
            <Text style={styles.placeholderText}>
              Tap "Analyze My Journal" to get personalized insights based on your usage patterns
            </Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  headerContainer: {
    marginBottom: 24,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 8,
  },
  headerSubtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    lineHeight: 22,
  },
  journalSummaryContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: COLORS.primary,
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  analyzeButton: {
    backgroundColor: COLORS.primary,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    marginBottom: 24,
    flexDirection: 'row',
    justifyContent: 'center',
  },
  analyzeButtonText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  loadingIndicator: {
    marginLeft: 10,
  },
  errorContainer: {
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
    flexDirection: 'row',
    alignItems: 'center',
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
  insightsContainer: {
    marginBottom: 24,
  },
  insightsTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 16,
  },
  insightCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  insightHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  insightHeaderText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginLeft: 8,
  },
  insightText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    lineHeight: 22,
    marginBottom: 16,
  },
  effectiveStrains: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  effectiveStrain: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    borderRadius: 16,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  effectiveStrainText: {
    color: COLORS.primary,
    fontWeight: '500',
  },
  recommendationsList: {
    marginTop: 8,
  },
  recommendationItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  recommendationText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    marginLeft: 8,
    flex: 1,
  },
  placeholderContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
    marginTop: 24,
  },
  placeholderText: {
    fontSize: 16,
    color: COLORS.text.tertiary,
    textAlign: 'center',
    marginTop: 16,
    lineHeight: 24,
  },
});

================================================================================
File: app/ai/onboarding.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ActivityIndicator } from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { LinearGradient } from 'expo-linear-gradient';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Define the step type with proper icon names
type OnboardingStep = {
  title: string;
  description: string;
  icon: React.ComponentProps<typeof MaterialCommunityIcons>['name'];
  color: string;
};

const ONBOARDING_STEPS: OnboardingStep[] = [
  {
    title: "Personalized Recommendations",
    description: "Our AI analyzes your preferences and usage patterns to suggest strains tailored to your needs.",
    icon: "leaf",
    color: COLORS.primary
  },
  {
    title: "Smart Safety Checks",
    description: "We automatically check for potential interactions and usage patterns to keep you informed and safe.",
    icon: "shield-check",
    color: COLORS.primary
  },
  {
    title: "Journal Insights",
    description: "Get personalized insights from your journal entries to better understand what works for you.",
    icon: "notebook",
    color: COLORS.primary
  },
  {
    title: "AI Assistant",
    description: "Chat with our AI assistant to get answers about cannabis, effects, dosing, and more.",
    icon: "robot",
    color: COLORS.primary
  }
];

export default function AIOnboarding() {
  const router = useRouter();
  const [currentStep, setCurrentStep] = useState(0);
  const [isCompleting, setIsCompleting] = useState(false);
  const [hasChecked, setHasChecked] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Check if onboarding is already completed
  useEffect(() => {
    const checkOnboardingStatus = async () => {
      try {
        const hasCompletedOnboarding = await AsyncStorage.getItem('ai_onboarding_completed');
        if (hasCompletedOnboarding === 'true') {
          router.replace('/ai/recommendations');
        }
      } catch (error) {
        console.error('Error checking onboarding status:', error);
        setError('Failed to check onboarding status');
      } finally {
        setHasChecked(true);
      }
    };
    
    checkOnboardingStatus();
  }, [router]);
  
  const handleNext = () => {
    if (currentStep < ONBOARDING_STEPS.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      completeOnboarding();
    }
  };
  
  const completeOnboarding = async () => {
    try {
      setIsCompleting(true);
      await AsyncStorage.setItem('ai_onboarding_completed', 'true');
      
      // Add a small delay to ensure the AsyncStorage value is set
      await new Promise(resolve => setTimeout(resolve, 300));
      
      router.replace('/ai/recommendations');
    } catch (error) {
      console.error('Error saving onboarding status:', error);
      setIsCompleting(false);
      setError('Failed to complete onboarding');
    }
  };
  
  // Show loading screen while checking onboarding status
  if (!hasChecked) {
    return <LoadingView />;
  }
  
  if (error) {
    return <ErrorView error={error} />;
  }
  
  const step = ONBOARDING_STEPS[currentStep];
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          headerShown: false
        }} 
      />
      
      <LinearGradient
        colors={[COLORS.background, COLORS.background]}
        style={StyleSheet.absoluteFill}
      />
      
      <View style={styles.content}>
        <View style={styles.stepIndicators}>
          {ONBOARDING_STEPS.map((_, index) => (
            <View 
              key={index} 
              style={[
                styles.stepDot,
                currentStep === index && styles.activeStepDot
              ]} 
            />
          ))}
        </View>
        
        <View style={styles.iconContainer}>
          <LinearGradient
            colors={[step.color, `${step.color}80`]}
            style={styles.iconGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons 
              name={step.icon} 
              size={60} 
              color="#FFFFFF" 
            />
          </LinearGradient>
        </View>
        
        <Text style={styles.title}>{step.title}</Text>
        <Text style={styles.description}>{step.description}</Text>
        
        <View style={styles.buttonContainer}>
          <TouchableOpacity 
            style={styles.skipButton}
            onPress={completeOnboarding}
            disabled={isCompleting}
          >
            <Text style={styles.skipButtonText}>Skip</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={styles.nextButton}
            onPress={handleNext}
            disabled={isCompleting}
          >
            {isCompleting ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <>
                <Text style={styles.nextButtonText}>
                  {currentStep < ONBOARDING_STEPS.length - 1 ? 'Next' : 'Get Started'}
                </Text>
                <MaterialCommunityIcons 
                  name="arrow-right" 
                  size={20} 
                  color="#FFFFFF" 
                />
              </>
            )}
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  stepIndicators: {
    flexDirection: 'row',
    marginBottom: 60,
  },
  stepDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    marginHorizontal: 6,
  },
  activeStepDot: {
    backgroundColor: COLORS.primary,
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  iconContainer: {
    marginBottom: 40,
  },
  iconGradient: {
    width: 120,
    height: 120,
    borderRadius: 60,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: COLORS.text.primary,
    marginBottom: 16,
    textAlign: 'center',
  },
  description: {
    fontSize: 16,
    color: COLORS.text.secondary,
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 60,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  skipButton: {
    padding: 16,
  },
  skipButtonText: {
    color: COLORS.text.tertiary,
    fontSize: 16,
  },
  nextButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 30,
    flexDirection: 'row',
    alignItems: 'center',
    minWidth: 120,
    justifyContent: 'center',
  },
  nextButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginRight: 8,
  },
});

================================================================================
File: app/ai/recommendations.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity, 
  Alert,
  TextInput
} from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import useAIRecommendations from '../../src/hooks/useAIRecommendations';
import { RecommendationRequest, StrainRecommendation, UserProfile } from '../../src/types';
import { COLORS } from '../../src/constants';
import LoadingView from '../components/shared/LoadingView';
import ErrorView from '../components/shared/ErrorView';

// Extended StrainRecommendation for UI purposes
interface UIStrainRecommendation extends StrainRecommendation {
  name: string;
  type: string;
  effects: string[];
  reason: string;
}

// Mock user profile for demo purposes
const mockUserProfile: UserProfile = {
  id: 'user123',
  experience_level: 'intermediate',
  preferred_effects: ['relaxed', 'creative', 'uplifted'],
  medical_needs: ['stress', 'mild pain'],
  medications: [],
  avoid_effects: ['anxiety', 'paranoia'],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

export default function RecommendationsScreen() {
  const router = useRouter();
  const { 
    loading, 
    error, 
    recommendations, 
    safetyValidation,
    getRecommendations 
  } = useAIRecommendations();
  
  const [desiredEffects, setDesiredEffects] = useState<string[]>(['relaxed', 'creative']);
  const [context, setContext] = useState<'recreational' | 'medical'>('recreational');
  const [customEffect, setCustomEffect] = useState('');
  
  // Fetch recommendations on initial load
  useEffect(() => {
    fetchRecommendations();
  }, []);
  
  // Handle fetching recommendations
  const fetchRecommendations = async () => {
    const request: RecommendationRequest = {
      userProfile: mockUserProfile,
      desiredEffects,
      context,
      medicalNeeds: context === 'medical' ? mockUserProfile.medical_needs : []
    };
    
    await getRecommendations(request);
  };
  
  // Add custom effect
  const handleAddEffect = () => {
    if (customEffect.trim() && !desiredEffects.includes(customEffect.trim().toLowerCase())) {
      setDesiredEffects([...desiredEffects, customEffect.trim().toLowerCase()]);
      setCustomEffect('');
    }
  };
  
  // Remove effect
  const handleRemoveEffect = (effect: string) => {
    setDesiredEffects(desiredEffects.filter(e => e !== effect));
  };
  
  // Transform StrainRecommendation to UIStrainRecommendation
  const enhanceRecommendation = (recommendation: StrainRecommendation): UIStrainRecommendation => {
    // Extract genetic type from the reasoning factors if available
    let type = 'hybrid'; // Default to hybrid
    
    if (recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors)) {
      // Look for the genetic type in the reasoning factors
      const typeFactors = recommendation.reasoningFactors.filter(factor => 
        factor.factor.includes('Indica') || 
        factor.factor.includes('Sativa') || 
        factor.factor.includes('Hybrid')
      );
      
      if (typeFactors.length > 0) {
        const typeFactor = typeFactors[0].factor.toLowerCase();
        
        if (typeFactor.includes('indica')) {
          type = 'indica';
        } else if (typeFactor.includes('sativa')) {
          type = 'sativa';
        } else if (typeFactor.includes('hybrid')) {
          type = 'hybrid';
        }
      }
    }
    
    // Extract effects from the reasoning factors
    let effects = ['Relaxed', 'Happy']; // Default effects
    
    if (recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors)) {
      const effectsFactor = recommendation.reasoningFactors.find(factor => 
        factor.factor.includes('Matches') && factor.factor.includes('effects')
      );
      
      if (effectsFactor) {
        // Try to extract the effects from the factor text
        effects = effectsFactor.factor
          .replace('Matches', '')
          .replace('of your desired effects', '')
          .trim()
          .split(',')
          .map(e => e.trim())
          .filter(e => e.length > 0);
        
        // If we couldn't extract effects, use the desired effects from the request
        if (effects.length === 0 || (effects.length === 1 && !isNaN(parseInt(effects[0])))) {
          effects = desiredEffects.map(e => e.charAt(0).toUpperCase() + e.slice(1));
        }
      }
    }
    
    return {
      ...recommendation,
      name: recommendation.strainName,
      type: type,
      effects: effects,
      reason: recommendation.reasoningFactors && Array.isArray(recommendation.reasoningFactors) 
        ? recommendation.reasoningFactors.map(f => f.factor).join('. ')
        : 'Recommended based on your preferences'
    };
  };
  
  // Render recommendation card
  const renderRecommendationCard = (recommendation: StrainRecommendation, index: number) => {
    const enhancedRecommendation = enhanceRecommendation(recommendation);
    
    return (
      <TouchableOpacity 
        key={`recommendation-${index}`}
        style={styles.recommendationCard}
        onPress={() => Alert.alert('Strain Details', `View detailed information about ${enhancedRecommendation.name}`)}
      >
        <View style={[
          styles.strainTypeIndicator,
          { backgroundColor: getStrainTypeColor(enhancedRecommendation.type) }
        ]} />
        <View style={styles.recommendationContent}>
          <Text style={styles.strainName}>{enhancedRecommendation.name}</Text>
          <Text style={styles.strainType}>{enhancedRecommendation.type}</Text>
          <Text style={styles.matchScore}>
            {enhancedRecommendation.matchScore}% Match
          </Text>
          <Text style={styles.reasonText}>{enhancedRecommendation.reason}</Text>
          
          <View style={styles.effectsContainer}>
            {enhancedRecommendation.effects.slice(0, 3).map((effect, i) => (
              <View key={`effect-${i}`} style={styles.effectTag}>
                <Text style={styles.effectText}>{effect}</Text>
              </View>
            ))}
          </View>
        </View>
      </TouchableOpacity>
    );
  };
  
  // Get color based on strain type
  const getStrainTypeColor = (type: string): string => {
    switch(type.toLowerCase()) {
      case 'indica':
        return '#3949ab'; // Indigo color
      case 'sativa':
        return COLORS.primary; // Primary green color
      case 'hybrid':
        return '#7b1fa2'; // Purple color
      default:
        return '#757575'; // Gray color
    }
  };
  
  // Render safety warnings if any
  const renderSafetyWarnings = () => {
    if (!safetyValidation || !safetyValidation.safetyFlags) return null;
    
    return (
      <View style={styles.safetyWarningsContainer}>
        <View style={styles.safetyHeader}>
          <MaterialCommunityIcons 
            name="alert-circle-outline" 
            size={20} 
            color={safetyValidation.warningLevel === 'warning' ? '#ffb300' : '#2196f3'} 
          />
          <Text style={styles.safetyHeaderText}>Safety Information</Text>
        </View>
        
        {safetyValidation.safetyFlags.map((flag, index) => (
          <Text key={`flag-${index}`} style={styles.safetyFlag}>
             {flag}
          </Text>
        ))}
      </View>
    );
  };
  
  if (loading) {
    return <LoadingView />;
  }
  
  if (error && !recommendations) {
    return <ErrorView error={error} />;
  }
  
  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{
          title: 'AI Strain Recommendations'
        }} 
      />
      
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.contentContainer} showsVerticalScrollIndicator={false}>
        {/* Context Selector */}
        <View style={styles.contextSelector}>
          <Text style={styles.sectionTitle}>Purpose</Text>
          <View style={styles.timeRangeButtons}>
            <TouchableOpacity
              style={[
                styles.timeRangeButton,
                context === 'recreational' && styles.timeRangeButtonActive
              ]}
              onPress={() => setContext('recreational')}
            >
              <Text style={[
                styles.timeRangeButtonText,
                context === 'recreational' && styles.timeRangeButtonTextActive
              ]}>
                Recreational
              </Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={[
                styles.timeRangeButton,
                context === 'medical' && styles.timeRangeButtonActive
              ]}
              onPress={() => setContext('medical')}
            >
              <Text style={[
                styles.timeRangeButtonText,
                context === 'medical' && styles.timeRangeButtonTextActive
              ]}>
                Medical
              </Text>
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Desired Effects */}
        <View style={styles.effectsSection}>
          <Text style={styles.sectionTitle}>Desired Effects</Text>
          
          <View style={styles.selectedEffectsContainer}>
            {desiredEffects.map((effect, index) => (
              <View key={`selected-${index}`} style={styles.selectedEffect}>
                <Text style={styles.selectedEffectText}>{effect}</Text>
                <TouchableOpacity onPress={() => handleRemoveEffect(effect)}>
                  <MaterialCommunityIcons name="close-circle" size={16} color={COLORS.text.primary} />
                </TouchableOpacity>
              </View>
            ))}
          </View>
          
          <View style={styles.addEffectContainer}>
            <TextInput
              style={styles.effectInput}
              placeholder="Add desired effect..."
              placeholderTextColor={COLORS.text.tertiary}
              value={customEffect}
              onChangeText={setCustomEffect}
              onSubmitEditing={handleAddEffect}
            />
            <TouchableOpacity 
              style={styles.addEffectButton}
              onPress={handleAddEffect}
            >
              <MaterialCommunityIcons name="plus" size={20} color={COLORS.text.primary} />
            </TouchableOpacity>
          </View>
        </View>
        
        {/* Get Recommendations Button */}
        <TouchableOpacity 
          style={styles.getRecommendationsButton}
          onPress={fetchRecommendations}
        >
          <Text style={styles.getRecommendationsText}>
            Get Recommendations
          </Text>
        </TouchableOpacity>
        
        {/* Safety Warnings */}
        {renderSafetyWarnings()}
        
        {/* Error Message */}
        {error && recommendations && (
          <View style={styles.errorContainer}>
            <MaterialCommunityIcons name="alert-circle" size={24} color="#ff6b6b" />
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}
        
        {/* Recommendations */}
        {recommendations && recommendations.recommendations && Array.isArray(recommendations.recommendations) && recommendations.recommendations.length > 0 ? (
          <View style={styles.recommendationsContainer}>
            <Text style={styles.sectionTitle}>
              Your Personalized Recommendations
            </Text>
            
            {recommendations.recommendations.map((recommendation, index) => 
              renderRecommendationCard(recommendation, index)
            )}
            
            {/* Disclaimers */}
            {recommendations.disclaimers && Array.isArray(recommendations.disclaimers) && recommendations.disclaimers.length > 0 && (
              <View style={styles.disclaimersContainer}>
                <Text style={styles.insightTitle}>Important Information</Text>
                {recommendations.disclaimers.map((disclaimer, index) => (
                  <Text key={`disclaimer-${index}`} style={styles.disclaimerText}>
                     {disclaimer}
                  </Text>
                ))}
              </View>
            )}
          </View>
        ) : (
          <View style={styles.noRecommendationsContainer}>
            <Text style={styles.noRecommendationsText}>
              No recommendations available. Try adjusting your preferences or try again later.
            </Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    paddingHorizontal: 16,
    paddingBottom: 32,
  },
  contextSelector: {
    marginTop: 16,
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  timeRangeButtons: {
    flexDirection: 'row',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 12,
    padding: 4,
  },
  timeRangeButton: {
    flex: 1,
    paddingVertical: 10,
    alignItems: 'center',
    borderRadius: 8,
  },
  timeRangeButtonActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
  },
  timeRangeButtonText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  timeRangeButtonTextActive: {
    color: COLORS.primary,
    fontWeight: '600',
  },
  effectsSection: {
    marginBottom: 20,
  },
  selectedEffectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
  },
  selectedEffect: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
    borderRadius: 16,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  selectedEffectText: {
    color: COLORS.primary,
    marginRight: 6,
    fontWeight: '500',
  },
  addEffectContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  effectInput: {
    flex: 1,
    backgroundColor: COLORS.cardBackground,
    borderRadius: 8,
    padding: 12,
    color: COLORS.text.primary,
    marginRight: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  addEffectButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
    borderRadius: 8,
    padding: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  getRecommendationsButton: {
    backgroundColor: COLORS.primary,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    marginBottom: 20,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  getRecommendationsText: {
    color: '#fff',
    fontWeight: '700',
    fontSize: 16,
  },
  loadingIndicator: {
    marginLeft: 10,
  },
  safetyWarningsContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 2,
  },
  safetyHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  safetyHeaderText: {
    color: COLORS.text.primary,
    fontWeight: '600',
    marginLeft: 8,
    fontSize: 16,
  },
  safetyFlag: {
    color: COLORS.text.secondary,
    marginBottom: 4,
    lineHeight: 20,
  },
  errorContainer: {
    backgroundColor: 'rgba(255, 107, 107, 0.1)',
    borderRadius: 16,
    padding: 16,
    marginBottom: 20,
    flexDirection: 'row',
    alignItems: 'center',
  },
  errorText: {
    color: '#ff6b6b',
    marginLeft: 8,
    flex: 1,
  },
  recommendationsContainer: {
    marginBottom: 20,
  },
  recommendationCard: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    marginBottom: 16,
    overflow: 'hidden',
    flexDirection: 'row',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 3,
  },
  strainTypeIndicator: {
    width: 8,
    height: '100%',
  },
  recommendationContent: {
    padding: 16,
    flex: 1,
  },
  strainName: {
    fontSize: 18,
    fontWeight: '700',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  strainType: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 8,
    textTransform: 'capitalize'
  },
  matchScore: {
    fontSize: 16,
    fontWeight: '700',
    color: COLORS.primary,
    marginBottom: 8,
  },
  reasonText: {
    fontSize: 14,
    color: COLORS.text.secondary,
    marginBottom: 12,
    lineHeight: 20,
  },
  effectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  effectTag: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    borderRadius: 16,
    paddingVertical: 4,
    paddingHorizontal: 10,
    marginRight: 8,
    marginBottom: 4,
  },
  effectText: {
    color: COLORS.primary,
    fontSize: 12,
    fontWeight: '500',
  },
  disclaimersContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  insightTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
  },
  disclaimerText: {
    color: COLORS.text.secondary,
    marginBottom: 4,
    lineHeight: 20,
  },
  noRecommendationsContainer: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    padding: 16,
    marginTop: 20,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  noRecommendationsText: {
    color: COLORS.text.secondary,
    fontSize: 16,
    textAlign: 'center',
    lineHeight: 22,
  },
});

================================================================================
File: app/components/achievements/AchievementCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { UserAchievementWithDetails } from '../../../src/types';

interface AchievementCardProps {
  achievement: UserAchievementWithDetails;
  onPress: (achievement: UserAchievementWithDetails) => void;
}

export const AchievementCard: React.FC<AchievementCardProps> = ({ achievement, onPress }) => {
  const { name, category, progress, isUnlocked, icon } = achievement;
  
  // Define styles based on locked/unlocked state
  const cardOpacity = isUnlocked ? 1 : 0.6;
  const iconColor = isUnlocked ? '#00C853' : '#757575';
  const gradientColors = isUnlocked 
    ? ['#43A047', '#2E7D32'] as readonly [string, string]
    : ['#616161', '#424242'] as readonly [string, string];
  
  return (
    <TouchableOpacity 
      style={[styles.container, { opacity: cardOpacity }]} 
      onPress={() => onPress(achievement)}
      activeOpacity={0.8}
    >
      <LinearGradient
        colors={gradientColors}
        style={styles.gradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      >
        <View style={styles.content}>
          <View style={styles.iconContainer}>
            <MaterialCommunityIcons 
              name={icon as any || 'trophy'} 
              size={28} 
              color={iconColor} 
            />
          </View>
          
          <View style={styles.textContainer}>
            <Text style={styles.title}>{name}</Text>
            <Text style={styles.category}>{category}</Text>
            
            {!isUnlocked && (
              <View style={styles.progressContainer}>
                <View style={styles.progressBar}>
                  <View 
                    style={[
                      styles.progressFill, 
                      { width: `${Math.min(100, progress)}%` }
                    ]} 
                  />
                </View>
                <Text style={styles.progressText}>{Math.round(progress)}%</Text>
              </View>
            )}
          </View>
          
          {isUnlocked && (
            <View style={styles.completedBadge}>
              <MaterialCommunityIcons name="check-circle" size={18} color="#FFFFFF" />
            </View>
          )}
        </View>
      </LinearGradient>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  container: {
    height: 80,
    borderRadius: 12,
    marginVertical: 6,
    overflow: 'hidden',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  gradient: {
    flex: 1,
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
  },
  iconContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#1E1E1E',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  textContainer: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 2,
  },
  category: {
    fontSize: 12,
    color: '#E0E0E0',
    marginBottom: 4,
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  progressBar: {
    height: 4,
    backgroundColor: '#424242',
    borderRadius: 2,
    flex: 1,
    marginRight: 8,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#4CAF50',
    borderRadius: 2,
  },
  progressText: {
    fontSize: 12,
    color: '#E0E0E0',
    minWidth: 32,
  },
  completedBadge: {
    backgroundColor: '#4CAF50',
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
}); 

================================================================================
File: app/components/achievements/AchievementDetailModal.tsx
================================================================================

import React from 'react';
import { Modal, View, Text, StyleSheet, TouchableOpacity, ScrollView, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { UserAchievementWithDetails } from '../../../src/types';
import { COLORS } from '../../../src/constants';

interface AchievementDetailModalProps {
  visible: boolean;
  achievement: UserAchievementWithDetails | null;
  onClose: () => void;
}

export const AchievementDetailModal: React.FC<AchievementDetailModalProps> = ({ 
  visible, 
  achievement, 
  onClose 
}) => {
  if (!achievement) return null;
  
  const { name, category, unlockCondition, notes, progress, isUnlocked, dateUnlocked, icon, complexity } = achievement;
  
  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'Not yet unlocked';
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric'
    });
  };
  
  const renderComplexityStars = (level: number) => {
    return Array(3).fill(0).map((_, index) => (
      <MaterialCommunityIcons 
        key={index} 
        name="star" 
        size={16} 
        color={index < Math.min(level, 3) ? COLORS.primary : 'rgba(255, 255, 255, 0.2)'} 
        style={{ marginRight: 2 }}
      />
    ));
  };
  
  return (
    <Modal
      visible={visible}
      transparent={true}
      animationType="fade"
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.header}>
            <LinearGradient
              colors={[
                'rgba(0,230,118,0.2)',
                'rgba(0,230,118,0.05)',
                'transparent'
              ]}
              style={StyleSheet.absoluteFill}
              start={{ x: 0, y: 0 }}
              end={{ x: 0, y: 1 }}
            />
            
            <View style={styles.iconContainer}>
              <LinearGradient
                colors={['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.2)']}
                style={styles.iconGradient}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 1 }}
              >
                <MaterialCommunityIcons 
                  name={icon as any || 'trophy'} 
                  size={40} 
                  color={isUnlocked ? COLORS.primary : COLORS.text.secondary} 
                />
              </LinearGradient>
            </View>
            
            <TouchableOpacity style={styles.closeButton} onPress={onClose}>
              <MaterialCommunityIcons name="close" size={24} color={COLORS.text.secondary} />
            </TouchableOpacity>
          </View>
          
          <ScrollView style={styles.content}>
            <Text style={styles.title}>{name}</Text>
            
            <View style={styles.categoryRow}>
              <Text style={styles.categoryLabel}>{category}</Text>
              <View style={styles.complexityContainer}>
                {renderComplexityStars(complexity)}
              </View>
            </View>
            
            {!isUnlocked && (
              <View style={styles.progressSection}>
                <View style={styles.progressContainer}>
                  <View style={styles.progressBar}>
                    <View 
                      style={[
                        styles.progressFill, 
                        { width: `${Math.min(100, progress)}%` }
                      ]} 
                    />
                  </View>
                  <Text style={styles.progressText}>{Math.round(progress)}%</Text>
                </View>
              </View>
            )}
            
            <View style={styles.detailSection}>
              <Text style={styles.sectionTitle}>How to unlock</Text>
              <Text style={styles.detailText}>{unlockCondition}</Text>
            </View>
            
            {notes && (
              <View style={styles.detailSection}>
                <Text style={styles.sectionTitle}>Details</Text>
                <Text style={styles.detailText}>{notes}</Text>
              </View>
            )}
            
            <View style={styles.detailSection}>
              <Text style={styles.sectionTitle}>Status</Text>
              <View style={styles.statusRow}>
                <MaterialCommunityIcons 
                  name={isUnlocked ? "check-circle" : "clock-outline"} 
                  size={18} 
                  color={isUnlocked ? COLORS.primary : COLORS.text.secondary} 
                  style={styles.statusIcon}
                />
                <Text style={styles.statusText}>
                  {isUnlocked 
                    ? `Unlocked on ${formatDate(dateUnlocked)}` 
                    : 'Not yet unlocked'}
                </Text>
              </View>
            </View>
          </ScrollView>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    width: '100%',
    maxWidth: 500,
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.95)',
      android: 'rgba(26, 26, 26, 0.98)',
    }),
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 12,
      },
      android: {
        elevation: 8,
      },
    }),
  },
  header: {
    height: 120,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  iconContainer: {
    marginBottom: 8,
  },
  iconGradient: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.2)',
  },
  closeButton: {
    position: 'absolute',
    top: 12,
    right: 12,
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    padding: 20,
    maxHeight: 400,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: COLORS.text.primary,
    textAlign: 'center',
    marginBottom: 12,
    letterSpacing: 0.35,
  },
  categoryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  categoryLabel: {
    fontSize: 14,
    color: COLORS.text.secondary,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  complexityContainer: {
    flexDirection: 'row',
  },
  progressSection: {
    marginBottom: 20,
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  progressBar: {
    height: 8,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 4,
    flex: 1,
    marginRight: 8,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    backgroundColor: COLORS.primary,
    borderRadius: 4,
  },
  progressText: {
    fontSize: 14,
    color: COLORS.text.secondary,
    minWidth: 40,
    textAlign: 'right',
  },
  detailSection: {
    marginBottom: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    padding: 16,
    borderRadius: 12,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.25,
  },
  detailText: {
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
    letterSpacing: 0.25,
  },
  statusRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusIcon: {
    marginRight: 8,
  },
  statusText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
});

================================================================================
File: app/components/achievements/AchievementUnlockedNotification.tsx
================================================================================

import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated, TouchableOpacity, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { UserAchievementWithDetails } from '../../../src/types';
import { COLORS } from '../../../src/constants';

interface AchievementUnlockedNotificationProps {
  achievement: UserAchievementWithDetails;
  onPress: (achievement: UserAchievementWithDetails) => void;
  onDismiss: () => void;
}

export const AchievementUnlockedNotification: React.FC<AchievementUnlockedNotificationProps> = ({
  achievement,
  onPress,
  onDismiss
}) => {
  const slideAnim = useRef(new Animated.Value(-200)).current;
  const opacityAnim = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    // Slide in
    Animated.parallel([
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 500,
        useNativeDriver: true,
      }),
      Animated.timing(opacityAnim, {
        toValue: 1,
        duration: 400,
        useNativeDriver: true,
      })
    ]).start();
    
    // Auto dismiss after 5 seconds
    const timeout = setTimeout(() => {
      dismiss();
    }, 5000);
    
    return () => clearTimeout(timeout);
  }, []);
  
  const dismiss = () => {
    Animated.parallel([
      Animated.timing(slideAnim, {
        toValue: -200,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(opacityAnim, {
        toValue: 0,
        duration: 250,
        useNativeDriver: true,
      })
    ]).start(() => {
      onDismiss();
    });
  };
  
  return (
    <Animated.View
      style={[
        styles.container,
        {
          transform: [{ translateY: slideAnim }],
          opacity: opacityAnim,
        }
      ]}
    >
      <TouchableOpacity
        style={styles.touchable}
        onPress={() => {
          dismiss();
          onPress(achievement);
        }}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          <View style={styles.iconContainer}>
            <LinearGradient
              colors={['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.2)']}
              style={styles.iconGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons
                name={achievement.icon as any || 'trophy'}
                size={24}
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>
          
          <View style={styles.textContainer}>
            <Text style={styles.achievementUnlocked}>Achievement Unlocked!</Text>
            <Text style={styles.title}>{achievement.name}</Text>
          </View>
          
          <TouchableOpacity style={styles.closeButton} onPress={dismiss}>
            <MaterialCommunityIcons name="close" size={16} color={COLORS.text.secondary} />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 60,
    left: 20,
    right: 20,
    zIndex: 1000,
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  touchable: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
  },
  iconContainer: {
    marginRight: 12,
  },
  iconGradient: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  textContainer: {
    flex: 1,
  },
  achievementUnlocked: {
    fontSize: 12,
    color: COLORS.text.secondary,
    textTransform: 'uppercase',
    fontWeight: '600',
    letterSpacing: 0.5,
    marginBottom: 4,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.35,
  },
  closeButton: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================================================================================
File: app/components/ai/RecommendationFeedback.tsx
================================================================================

import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, TextInput, ActivityIndicator } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { AIService } from '../../../src/services/ai';

interface RecommendationFeedbackProps {
  userId: string;
  recommendationId: string;
  onClose: () => void;
}

export default function RecommendationFeedback({ 
  userId, 
  recommendationId, 
  onClose 
}: RecommendationFeedbackProps) {
  const [helpful, setHelpful] = useState<boolean | null>(null);
  const [accurateEffects, setAccurateEffects] = useState<boolean | null>(null);
  const [wouldTryAgain, setWouldTryAgain] = useState<boolean | null>(null);
  const [comments, setComments] = useState('');
  const [submitting, setSubmitting] = useState(false);
  
  // Get AIService instance
  const aiService = AIService.getInstance();
  
  const handleSubmit = async () => {
    if (helpful === null) return;
    
    setSubmitting(true);
    
    try {
      // Calculate relevance score (1-5) based on user feedback
      const relevance = calculateRelevanceScore(helpful, accurateEffects, wouldTryAgain);
      
      await aiService.submitRecommendationFeedback(
        userId,
        recommendationId,
        helpful,
        accurateEffects || false,
        relevance,
        comments
      );
      
      onClose();
    } catch (error) {
      console.error('Error submitting feedback:', error);
    } finally {
      setSubmitting(false);
    }
  };
  
  // Calculate a relevance score (1-5) based on user feedback
  const calculateRelevanceScore = (
    helpful: boolean, 
    accurateEffects: boolean | null, 
    wouldTryAgain: boolean | null
  ): number => {
    if (!helpful) return 1; // Not helpful at all
    
    // Base score for helpful
    let score = 3;
    
    // Add points for accurate effects
    if (accurateEffects) score += 1;
    
    // Add points for would try again
    if (wouldTryAgain) score += 1;
    
    return Math.min(score, 5); // Cap at 5
  };
  
  return (
    <View style={styles.container}>
      <Text style={styles.title}>How was this recommendation?</Text>
      
      <View style={styles.questionContainer}>
        <Text style={styles.questionText}>Was this recommendation helpful?</Text>
        <View style={styles.buttonGroup}>
          <TouchableOpacity 
            style={[
              styles.optionButton,
              helpful === true && styles.selectedButton
            ]}
            onPress={() => setHelpful(true)}
          >
            <MaterialCommunityIcons 
              name="thumb-up" 
              size={20} 
              color={helpful === true ? '#FFFFFF' : '#AAAAAA'} 
            />
            <Text style={[
              styles.optionText,
              helpful === true && styles.selectedOptionText
            ]}>Yes</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[
              styles.optionButton,
              helpful === false && styles.selectedButton
            ]}
            onPress={() => setHelpful(false)}
          >
            <MaterialCommunityIcons 
              name="thumb-down" 
              size={20} 
              color={helpful === false ? '#FFFFFF' : '#AAAAAA'} 
            />
            <Text style={[
              styles.optionText,
              helpful === false && styles.selectedOptionText
            ]}>No</Text>
          </TouchableOpacity>
        </View>
      </View>
      
      {helpful !== null && (
        <>
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>Were the effects as described?</Text>
            <View style={styles.buttonGroup}>
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  accurateEffects === true && styles.selectedButton
                ]}
                onPress={() => setAccurateEffects(true)}
              >
                <Text style={[
                  styles.optionText,
                  accurateEffects === true && styles.selectedOptionText
                ]}>Yes</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  accurateEffects === false && styles.selectedButton
                ]}
                onPress={() => setAccurateEffects(false)}
              >
                <Text style={[
                  styles.optionText,
                  accurateEffects === false && styles.selectedOptionText
                ]}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>Would you try this strain again?</Text>
            <View style={styles.buttonGroup}>
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  wouldTryAgain === true && styles.selectedButton
                ]}
                onPress={() => setWouldTryAgain(true)}
              >
                <Text style={[
                  styles.optionText,
                  wouldTryAgain === true && styles.selectedOptionText
                ]}>Yes</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.optionButton,
                  wouldTryAgain === false && styles.selectedButton
                ]}
                onPress={() => setWouldTryAgain(false)}
              >
                <Text style={[
                  styles.optionText,
                  wouldTryAgain === false && styles.selectedOptionText
                ]}>No</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          <View style={styles.commentsContainer}>
            <Text style={styles.questionText}>Additional comments (optional)</Text>
            <TextInput
              style={styles.commentsInput}
              placeholder="Share your experience..."
              placeholderTextColor="#888888"
              value={comments}
              onChangeText={setComments}
              multiline
              maxLength={500}
            />
          </View>
          
          <TouchableOpacity 
            style={styles.submitButton}
            onPress={handleSubmit}
            disabled={submitting}
          >
            {submitting ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <Text style={styles.submitButtonText}>Submit Feedback</Text>
            )}
          </TouchableOpacity>
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#1A1A1A',
    borderRadius: 16,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 20,
    textAlign: 'center',
  },
  questionContainer: {
    marginBottom: 20,
  },
  questionText: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 12,
  },
  buttonGroup: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  optionButton: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginHorizontal: 6,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  selectedButton: {
    backgroundColor: '#4CAF50',
  },
  optionText: {
    color: '#AAAAAA',
    fontSize: 16,
    marginLeft: 8,
  },
  selectedOptionText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  commentsContainer: {
    marginBottom: 20,
  },
  commentsInput: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 8,
    padding: 12,
    color: '#FFFFFF',
    height: 100,
    textAlignVertical: 'top',
  },
  submitButton: {
    backgroundColor: '#4CAF50',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
  },
  submitButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
}); 

================================================================================
File: app/components/charts/BarChart.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';

interface BarChartProps {
  data: number[];
  labels: string[];
  maxValue?: number;
  barColor?: string;
}

const BarChart: React.FC<BarChartProps> = ({ 
  data, 
  labels, 
  maxValue: propMaxValue, 
  barColor = COLORS.primary
}) => {
  // Calculate maxValue if not provided
  const maxValue = propMaxValue || Math.max(...data) * 1.2; // Add 20% padding
  const chartHeight = 220;
  const divisions = 5; // Number of horizontal lines

  // Generate y-axis labels
  const yAxisLabels = Array.from({ length: divisions + 1 }, (_, i) => {
    const value = (maxValue / divisions) * (divisions - i);
    return Math.round(value).toString();
  });

  return (
    <View style={styles.container}>
      {/* Y-axis labels */}
      <View style={styles.yAxis}>
        {yAxisLabels.map((label, index) => (
          <Text key={index} style={styles.yAxisLabel}>
            {label}
          </Text>
        ))}
      </View>

      {/* Chart area */}
      <View style={styles.chartArea}>
        {/* Horizontal grid lines */}
        {yAxisLabels.map((_, index) => (
          <View 
            key={index} 
            style={[
              styles.gridLine,
              { top: (chartHeight / divisions) * index }
            ]} 
          />
        ))}

        {/* Bars */}
        <View style={styles.barsContainer}>
          {data.map((value, index) => {
            const barHeight = (value / maxValue) * chartHeight;
            
            return (
              <View key={index} style={styles.barWrapper}>
                <View style={styles.barLabelContainer}>
                  <Text style={styles.barValue}>{value}</Text>
                </View>
                <View style={[styles.barBackground, { height: barHeight }]}>
                  <LinearGradient
                    colors={[
                      `${barColor}CC`, // 80% opacity
                      `${barColor}66`, // 40% opacity
                    ]}
                    style={[styles.bar, { height: '100%' }]}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 0, y: 1 }}
                  />
                </View>
                <Text style={styles.xAxisLabel}>{labels[index]}</Text>
              </View>
            );
          })}
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    height: 280, // Include space for labels
    paddingRight: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 12,
    padding: 16,
  },
  yAxis: {
    width: 50,
    justifyContent: 'space-between',
    marginRight: 10,
  },
  yAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    textAlign: 'right',
  },
  chartArea: {
    flex: 1,
    height: 220,
    position: 'relative',
  },
  gridLine: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  barsContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    height: '100%',
  },
  barWrapper: {
    flex: 1,
    alignItems: 'center',
    height: '100%',
    justifyContent: 'flex-end',
  },
  barLabelContainer: {
    position: 'absolute',
    top: -20,
    width: '100%',
    alignItems: 'center',
  },
  barValue: {
    color: COLORS.text.primary,
    fontSize: 12,
    fontWeight: '600',
  },
  barBackground: {
    width: '60%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
    overflow: 'hidden',
  },
  bar: {
    width: '100%',
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
  },
  xAxisLabel: {
    color: COLORS.text.secondary,
    fontSize: 12,
    marginTop: 8,
  },
});

export default BarChart; 

================================================================================
File: app/components/charts/ChartStyles.ts
================================================================================

import { StyleSheet } from 'react-native';
import { COLORS } from '../../../src/constants';

const chartStyles = StyleSheet.create({
  card: {
    backgroundColor: COLORS.cardBackground,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 20,
    padding: 20,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 15,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.08)',
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12,
  },
  headerIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: 0.38,
  },
  description: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 20,
    letterSpacing: -0.24,
    lineHeight: 20,
  },
  chartWrapper: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
  },
  chartContainer: {
    borderRadius: 16,
    overflow: 'hidden',
  },
});

export default chartStyles; 

================================================================================
File: app/components/charts/LineChart.tsx
================================================================================

import React from 'react';
import { View, StyleSheet, Dimensions } from 'react-native';
import { LineChart as RNLineChart } from 'react-native-chart-kit';
import { COLORS } from '../../../src/constants';

interface LineChartProps {
  data: number[];
  labels: string[];
  color?: string;
  width?: number;
  height?: number;
}

const screenWidth = Dimensions.get('window').width;

const LineChart: React.FC<LineChartProps> = ({
  data,
  labels,
  color = COLORS.primary,
  width = screenWidth - 64,
  height = 220
}) => {
  const chartConfig = {
    backgroundColor: 'transparent',
    backgroundGradientFrom: 'transparent',
    backgroundGradientTo: 'transparent',
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
    labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity * 0.7})`,
    style: {
      borderRadius: 16
    },
    propsForDots: {
      r: '5',
      strokeWidth: '2',
      stroke: color
    },
    propsForBackgroundLines: {
      strokeDasharray: '5, 5',
      stroke: 'rgba(255, 255, 255, 0.1)',
      strokeWidth: 1
    },
    propsForLabels: {
      fontSize: 10
    }
  };

  return (
    <View style={styles.container}>
      <RNLineChart
        data={{
          labels,
          datasets: [
            {
              data,
              color: (opacity = 1) => color ? `${color}${Math.round(opacity * 255).toString(16).padStart(2, '0')}` : `rgba(0, 230, 118, ${opacity})`,
              strokeWidth: 2
            }
          ]
        }}
        width={width}
        height={height}
        chartConfig={chartConfig}
        bezier
        style={styles.chart}
        withInnerLines={true}
        withOuterLines={false}
        withHorizontalLabels={true}
        withVerticalLabels={true}
        withDots={true}
        segments={5}
        fromZero={true}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  chart: {
    borderRadius: 16,
    paddingRight: 16,
  }
});

export default LineChart; 

================================================================================
File: app/components/charts/MonthlyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '../../../src/types';

interface MonthlyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const MonthlyOverviewChart: React.FC<MonthlyOverviewChartProps> = ({ data, onPress }) => {
  const chartData = {
    labels: data.map(item => item.label),
    datasets: [{
      data: data.map(item => item.value)
    }]
  };

  // Calculate monthly stats
  const totalHits = data.reduce((sum, month) => sum + month.value, 0);
  const avgHits = totalHits / data.length;
  const maxHits = Math.max(...data.map(month => month.value));
  const maxMonth = data.find(month => month.value === maxHits)?.label || '';
  const monthlyGrowth = data.length > 1 
    ? ((data[data.length - 1].value - data[0].value) / data[0].value * 100).toFixed(1)
    : '0';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Monthly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/month average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-areaspline" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Month</Text>
              <Text style={styles.statValue}>{maxMonth}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Growth</Text>
              <View style={styles.changeContainer}>
                <MaterialCommunityIcons 
                  name={Number(monthlyGrowth) >= 0 ? "trending-up" : "trending-down"} 
                  size={16} 
                  color={Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252'} 
                />
                <Text style={[
                  styles.changeText,
                  { color: Number(monthlyGrowth) >= 0 ? COLORS.primary : '#FF5252' }
                ]}>
                  {Math.abs(Number(monthlyGrowth))}%
                </Text>
              </View>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Monthly Analysis</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 18,
    fontWeight: '600',
    marginLeft: 4,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default MonthlyOverviewChart; 

================================================================================
File: app/components/charts/WeeklyOverviewChart.tsx
================================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { LineChart } from 'react-native-chart-kit';
import { ChartDataPoint } from '../../../src/types';

interface WeeklyOverviewChartProps {
  data: ChartDataPoint[];
  onPress?: () => void;
}

const WeeklyOverviewChart: React.FC<WeeklyOverviewChartProps> = ({ data, onPress }) => {
  const chartData = {
    labels: data.map(item => item.label),
    datasets: [{
      data: data.map(item => item.value)
    }]
  };

  // Calculate weekly stats
  const totalHits = data.reduce((sum, day) => sum + day.value, 0);
  const avgHits = totalHits / 7;
  const maxHits = Math.max(...data.map(day => day.value));
  const maxDay = data.find(day => day.value === maxHits)?.label || '';

  return (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.container}
    >
      <TouchableOpacity 
        onPress={onPress}
        style={styles.touchable}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.headerRow}>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Weekly Overview</Text>
              <Text style={styles.subtitle}>
                {avgHits.toFixed(1)} hits/day average
              </Text>
            </View>
            
            <LinearGradient
              colors={['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-line-variant" 
                size={24} 
                color={COLORS.primary}
              />
            </LinearGradient>
          </View>

          {/* Chart */}
          <View style={styles.chartContainer}>
            <LineChart
              data={chartData}
              width={Dimensions.get('window').width - 80}
              height={180}
              yAxisLabel=""
              chartConfig={{
                backgroundColor: 'transparent',
                backgroundGradientFrom: 'transparent',
                backgroundGradientTo: 'transparent',
                decimalPlaces: 0,
                color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
                labelColor: (opacity = 1) => `rgba(255, 255, 255, ${opacity})`,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: "6",
                  strokeWidth: "2",
                  stroke: COLORS.primary
                },
                fillShadowGradient: COLORS.primary,
                fillShadowGradientOpacity: 0.2
              }}
              bezier
              style={styles.chart}
              withInnerLines={false}
              withOuterLines={true}
              withVerticalLines={false}
              withHorizontalLines={true}
              withVerticalLabels={true}
              withHorizontalLabels={true}
            />
          </View>

          {/* Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Total Hits</Text>
              <Text style={styles.statValue}>{totalHits}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Peak Day</Text>
              <Text style={styles.statValue}>{maxDay}</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={styles.statLabel}>Max Hits</Text>
              <Text style={styles.statValue}>{maxHits}</Text>
            </View>
          </View>

          {/* View More Button */}
          <View style={styles.buttonContainer}>
            <LinearGradient
              colors={[COLORS.primary, COLORS.primaryDark]}
              style={styles.button}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.buttonText}>View Details</Text>
              <MaterialCommunityIcons 
                name="chevron-right" 
                size={20} 
                color="#FFF"
              />
            </LinearGradient>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  touchable: {
    width: '100%',
  },
  content: {
    padding: 20,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 8,
    letterSpacing: 0.35,
  },
  subtitle: {
    fontSize: 16,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  iconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  chartContainer: {
    marginVertical: 16,
    alignItems: 'center',
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.tertiary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  buttonContainer: {
    marginTop: 20,
    alignItems: 'flex-start',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
  },
  buttonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 4,
  },
});

export default WeeklyOverviewChart; 

================================================================================
File: app/components/Header.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { COLORS } from '@/src/constants';

interface HeaderProps {
  title: string;
}

export default function Header({ title }: HeaderProps) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: COLORS.background,
  },
  title: {
    fontSize: 28,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
}); 

================================================================================
File: app/components/shared/Card.tsx
================================================================================

import React, { forwardRef } from "react";
import { View, StyleSheet, StyleProp, ViewStyle } from "react-native";
import { COLORS } from '../../../src/constants';

interface CardProps {
    children: React.ReactNode;
    style?: StyleProp<ViewStyle>;
}

export const Card = forwardRef<View, CardProps>(({ children, style }, ref) => {
    return <View ref={ref} style={[styles.card, style]}>{children}</View>;
});

const styles = StyleSheet.create({
    card: {
        backgroundColor: COLORS.cardBackground,
        borderRadius: 16,
        elevation: 6,
        shadowColor: COLORS.primary,
        shadowOffset: {
            width: 0,
            height: 2,
        },
        shadowOpacity: 0.15,
        shadowRadius: 8,
        padding: 16,
        borderWidth: 1,
        borderColor: 'rgba(0, 230, 118, 0.1)',
    }
});

================================================================================
File: app/components/shared/ErrorView.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '@/src/constants';

interface ErrorViewProps {
  error: string;
}

export default function ErrorView({ error }: ErrorViewProps) {
  return (
    <View style={styles.container}>
      <MaterialCommunityIcons 
        name="alert-circle-outline" 
        size={48} 
        color={COLORS.error} 
      />
      <Text style={styles.title}>Error</Text>
      <Text style={styles.message}>{error}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    marginTop: 16,
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  message: {
    marginTop: 8,
    fontSize: 16,
    color: COLORS.text.secondary,
    textAlign: 'center',
  },
});

================================================================================
File: app/components/shared/LoadingView.tsx
================================================================================

import React, { useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { COLORS } from '../../../src/constants';
import Animated, { 
  withRepeat, 
  withTiming,
  useAnimatedStyle, 
  useSharedValue,
  FadeIn
} from 'react-native-reanimated';
import { TIMING_CONFIG } from '@/src/utils/animations';

export default function LoadingView() {
  const rotation = useSharedValue(0);

  useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        ...TIMING_CONFIG,
        duration: 1500 // Slightly slower for smoother rotation
      }),
      -1
    );
  }, []);

  const spinStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }]
  }));

  return (
    <View style={styles.container}>
      <Animated.View 
        entering={FadeIn.duration(300)}
        style={styles.content}
      >
        <Animated.View style={spinStyle}>
          <MaterialCommunityIcons 
            name="cannabis" 
            size={32} 
            color={COLORS.primary} 
          />
        </Animated.View>
        <Text style={styles.text}>Loading...</Text>
      </Animated.View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    alignItems: 'center',
    gap: 12,
  },
  text: {
    fontSize: 16,
    color: COLORS.text.secondary,
  },
});

================================================================================
File: app/components/StatsOverviewCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { Card } from "./shared/Card";
import { COLORS } from "../../src/constants";
import { UsageStats } from "../../src/types";
import Animated, { FadeInDown, Layout } from 'react-native-reanimated';

interface StatsOverviewCardProps {
  stats: UsageStats;
}

function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

const StatsOverviewCard: React.FC<StatsOverviewCardProps> = ({ stats }) => {
  // Enhanced gradient combinations with type assertions
  const gradientBase = ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.08)', 'transparent'] as const;
  const accentGradient = ['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.15)'] as const;
  
  // Weekly difference calculation for message
  const weekendVsWeekday = ((stats.weekdayStats.weekend.avg - stats.weekdayStats.weekday.avg) / stats.weekdayStats.weekday.avg) * 100;
  const isWeekendHigher = weekendVsWeekday > 0;

  return (
    <Animated.View 
      entering={FadeInDown.springify()}
      layout={Layout.springify()}
      style={styles.container}
    >
      {/* Enhanced Background Gradient */}
      <LinearGradient
        colors={gradientBase}
        style={styles.backgroundGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      {/* Shimmer Effect Layer */}
      <LinearGradient
        colors={['transparent', 'rgba(255,255,255,0.05)', 'transparent'] as const}
        style={styles.shimmerEffect}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />
      
      <View style={styles.content}>
        {/* Enhanced Header */}
        <View style={styles.header}>
          <View style={styles.titleRow}>
            <LinearGradient
              colors={accentGradient}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="chart-box-outline" 
                size={22} 
                color={COLORS.primary}
              />
            </LinearGradient>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Usage Statistics</Text>
              <Text style={styles.subtitle}>
                Detailed overview of your usage patterns
              </Text>
            </View>
          </View>
        </View>

        {/* Hit Counts Section */}
        <View style={styles.statsSection}>
          <Text style={styles.sectionTitle}>Hit Counts</Text>
          <View style={styles.statsContainer}>
            <LinearGradient
              colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
              style={styles.statsGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.statRow}>
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Daily Average</Text>
                  <Text style={styles.statValue}>{stats.averageHitsPerDay.toFixed(1)}</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Peak Day</Text>
                  <Text style={styles.statValue}>{stats.peakDayHits}</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Total Hits</Text>
                  <Text style={styles.statValue}>{stats.totalHits}</Text>
                </View>
              </View>
            </LinearGradient>
          </View>
        </View>

        {/* Duration Stats Section */}
        <View style={styles.statsSection}>
          <Text style={styles.sectionTitle}>Duration</Text>
          <View style={styles.statsContainer}>
            <LinearGradient
              colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
              style={styles.statsGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.statRow}>
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Average</Text>
                  <Text style={styles.statValue}>{formatDuration(stats.averageDuration)}</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Longest</Text>
                  <Text style={styles.statValue}>{formatDuration(stats.longestHit)}</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Shortest</Text>
                  <Text style={styles.statValue}>{formatDuration(stats.shortestHit)}</Text>
                </View>
              </View>
            </LinearGradient>
          </View>
        </View>

        {/* Time Patterns Section */}
        <View style={styles.statsSection}>
          <Text style={styles.sectionTitle}>Activity Patterns</Text>
          <View style={styles.statsContainer}>
            <LinearGradient
              colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
              style={styles.statsGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.statRow}>
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Peak Hours</Text>
                  <Text style={styles.statValue}>{stats.mostActiveHour}:00</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Quiet Hours</Text>
                  <Text style={styles.statValue}>{stats.leastActiveHour}:00</Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Consistency</Text>
                  <Text style={styles.statValue}>{stats.consistency.toFixed(1)}</Text>
                </View>
              </View>
            </LinearGradient>
          </View>
        </View>

        {/* Weekday vs Weekend */}
        <View style={[styles.statsSection, styles.lastSection]}>
          <Text style={styles.sectionTitle}>Weekly Distribution</Text>
          <View style={styles.statsContainer}>
            <LinearGradient
              colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
              style={styles.statsGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <View style={styles.statRow}>
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Weekday Avg</Text>
                  <Text style={styles.statValue}>
                    {stats.weekdayStats.weekday.avg.toFixed(1)}
                  </Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Weekend Avg</Text>
                  <Text style={styles.statValue}>
                    {stats.weekdayStats.weekend.avg.toFixed(1)}
                  </Text>
                </View>
                <View style={styles.statDivider} />
                <View style={styles.statItem}>
                  <Text style={styles.statLabel}>Difference</Text>
                  <View style={styles.changeContainer}>
                    <MaterialCommunityIcons 
                      name={isWeekendHigher ? "trending-up" : "trending-down"} 
                      size={16} 
                      color={isWeekendHigher ? COLORS.primary : '#FF5252'} 
                    />
                    <Text style={[
                      styles.changeText,
                      { color: isWeekendHigher ? COLORS.primary : '#FF5252' }
                    ]}>
                      {Math.abs(weekendVsWeekday).toFixed(1)}%
                    </Text>
                  </View>
                </View>
              </View>
            </LinearGradient>
          </View>
        </View>

        {/* Message Box */}
        <View style={styles.messageContainer}>
          <LinearGradient
            colors={accentGradient}
            style={styles.statusIcon}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons
              name="information-outline"
              size={24}
              color={COLORS.primary}
            />
          </LinearGradient>

          <Text style={styles.messageText}>
            Your most active times are at {stats.mostActiveHour}:00 with an average session duration of {formatDuration(stats.averageDuration)}. Your usage is {Math.abs(weekendVsWeekday).toFixed(1)}% {isWeekendHigher ? "higher" : "lower"} on weekends compared to weekdays.
          </Text>
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: COLORS.cardBackground,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    marginBottom: 16,
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 12,
      },
      android: {
        elevation: 8,
      },
    }),
  },
  backgroundGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  shimmerEffect: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.4,
  },
  content: {
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  titleContainer: {
    marginLeft: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 13,
    color: COLORS.text.secondary,
  },
  statsSection: {
    marginBottom: 20,
  },
  lastSection: {
    marginBottom: 20, // Changed from 0 to accommodate message box
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 10,
    letterSpacing: -0.24,
  },
  statsContainer: {
    borderRadius: 16,
    overflow: 'hidden',
  },
  statsGradient: {
    padding: 16,
  },
  statRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-around',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statLabel: {
    fontSize: 13,
    color: COLORS.text.secondary,
    marginBottom: 4,
  },
  statValue: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
  },
  statDivider: {
    width: 1,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginHorizontal: 8,
  },
  changeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  changeText: {
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 4,
  },
  messageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.03)',
    padding: 12,
    borderRadius: 12,
  },
  statusIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  messageText: {
    flex: 1,
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
  },
});

export default StatsOverviewCard;

================================================================================
File: app/components/TimeDistributionCard.tsx
================================================================================

import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from "../../src/constants";
import { TimeDistribution } from "../../src/types";
import Animated, { FadeInDown, Layout } from 'react-native-reanimated';

interface TimeDistributionCardProps {
  timeData: TimeDistribution;
}

type TimeSlot = 'morning' | 'afternoon' | 'evening' | 'night';

const COLORS_MAP: Record<TimeSlot, string> = {
  morning: '#FFB74D',
  afternoon: '#4FC3F7',
  evening: '#7986CB',
  night: '#9575CD',
};

const ICONS_MAP: Record<TimeSlot, keyof typeof MaterialCommunityIcons.glyphMap> = {
  morning: 'weather-sunny',
  afternoon: 'weather-partly-cloudy',
  evening: 'weather-sunset',
  night: 'weather-night',
};

const TimeDistributionCard = ({ timeData }: TimeDistributionCardProps) => {
  const total = Object.values(timeData).reduce((sum, val) => sum + val, 0);
  
  // Enhanced gradient combinations with type assertions
  const gradientBase = ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.08)', 'transparent'] as const;
  const accentGradient = ['rgba(0,230,118,0.3)', 'rgba(0,230,118,0.15)'] as const;

  const TimeSlotComponent = ({ type, value }: { type: TimeSlot; value: number }) => {
    const percentage = total === 0 ? 0 : (value / total) * 100;
    const barWidth = Math.max(0, Math.min(100, percentage));

    return (
      <Animated.View 
        entering={FadeInDown.delay(type === 'morning' ? 200 : type === 'afternoon' ? 400 : type === 'evening' ? 600 : 800).springify()}
        style={styles.timeSlot}
      >
        <View style={styles.timeSlotContent}>
          <View style={styles.timeSlotHeader}>
            <LinearGradient
              colors={[`${COLORS_MAP[type]}40`, `${COLORS_MAP[type]}20`]}
              style={styles.timeSlotIconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name={ICONS_MAP[type]} 
                size={18} 
                color={COLORS_MAP[type]} 
              />
            </LinearGradient>
            <Text style={styles.timeSlotText}>
              {type.charAt(0).toUpperCase() + type.slice(1)}
            </Text>
            <Text style={styles.percentageText}>
              {percentage.toFixed(0)}%
            </Text>
          </View>
          <View style={styles.barContainer}>
            <LinearGradient
              colors={[`${COLORS_MAP[type]}`, `${COLORS_MAP[type]}80`]}
              style={[styles.bar, { width: `${barWidth}%` }]}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            />
          </View>
        </View>
      </Animated.View>
    );
  };

  return (
    <Animated.View 
      entering={FadeInDown.springify()}
      layout={Layout.springify()}
      style={styles.container}
    >
      {/* Enhanced Background Gradient */}
      <LinearGradient
        colors={gradientBase}
        style={styles.backgroundGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      {/* Shimmer Effect Layer */}
      <LinearGradient
        colors={['transparent', 'rgba(255,255,255,0.05)', 'transparent'] as const}
        style={styles.shimmerEffect}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />
      
      <View style={styles.content}>
        {/* Enhanced Header */}
        <View style={styles.header}>
          <View style={styles.titleRow}>
            <LinearGradient
              colors={accentGradient}
              style={styles.iconContainer}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialCommunityIcons 
                name="clock-outline" 
                size={22} 
                color={COLORS.primary}
              />
            </LinearGradient>
            <View style={styles.titleContainer}>
              <Text style={styles.title}>Time Distribution</Text>
              <Text style={styles.subtitle}>
                Activity patterns throughout the day
              </Text>
            </View>
          </View>
        </View>
        
        {/* Stats Container - Using same styled container but with custom content */}
        <View style={styles.statsContainer}>
          <LinearGradient
            colors={['rgba(255,255,255,0.08)', 'rgba(255,255,255,0.03)'] as const}
            style={styles.statsGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <View style={styles.distributionContent}>
              <TimeSlotComponent type="morning" value={timeData.morning} />
              <TimeSlotComponent type="afternoon" value={timeData.afternoon} />
              <TimeSlotComponent type="evening" value={timeData.evening} />
              <TimeSlotComponent type="night" value={timeData.night} />
            </View>
          </LinearGradient>
        </View>
        
        {/* Message Box */}
        <View style={styles.messageContainer}>
          <LinearGradient
            colors={accentGradient}
            style={styles.statusIcon}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            <MaterialCommunityIcons
              name="chart-timeline-variant"
              size={24}
              color={COLORS.primary}
            />
          </LinearGradient>

          <Text style={styles.messageText}>
            Your usage is primarily during the {
              Object.entries(timeData)
                .sort((a, b) => b[1] - a[1])[0][0]
            } hours, making up {
              Math.floor((Math.max(...Object.values(timeData)) / total) * 100)
            }% of your total consumption
          </Text>
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: COLORS.cardBackground,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    marginBottom: 16,
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 12,
      },
      android: {
        elevation: 8,
      },
    }),
  },
  backgroundGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.8,
  },
  shimmerEffect: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.4,
  },
  content: {
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  titleContainer: {
    marginLeft: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 13,
    color: COLORS.text.secondary,
  },
  statsContainer: {
    borderRadius: 16,
    overflow: 'hidden',
    marginBottom: 20,
  },
  statsGradient: {
    padding: 16,
  },
  distributionContent: {
    gap: 16,
  },
  timeSlot: {
    marginBottom: 4,
  },
  timeSlotContent: {
    gap: 8,
  },
  timeSlotHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  timeSlotIconContainer: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  timeSlotText: {
    flex: 1,
    fontSize: 15,
    color: COLORS.text.primary,
    marginLeft: 12,
    letterSpacing: -0.24,
  },
  percentageText: {
    fontSize: 15,
    fontWeight: '600',
    color: COLORS.text.primary,
    width: 40,
    textAlign: 'right',
    letterSpacing: -0.24,
  },
  barContainer: {
    height: 6,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 3,
    overflow: 'hidden',
    marginTop: 4,
  },
  bar: {
    height: '100%',
    borderRadius: 3,
  },
  messageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 0,
    backgroundColor: 'rgba(255, 255, 255, 0.03)',
    padding: 12,
    borderRadius: 12,
  },
  statusIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.15)',
  },
  messageText: {
    flex: 1,
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
  },
});

export default TimeDistributionCard;

================================================================================
File: app/components/trending/CompareBar.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, FlatList } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import { Strain } from "@/src/types";
import Animated, { FadeIn } from 'react-native-reanimated';

interface CompareBarProps {
  compareList: Strain[];
  onCompareToggle: (strain: Strain) => void;
  onCompare: () => void;
}

const CompareBar = memo(({
  compareList,
  onCompareToggle,
  onCompare
}: CompareBarProps) => (
  <Animated.View 
    entering={FadeIn}
    style={styles.compareBar}
  >
    <FlatList
      horizontal
      data={compareList}
      keyExtractor={item => item.id!.toString()}
      renderItem={({ item }) => (
        <View style={styles.compareItem}>
          <Text style={styles.compareItemText}>{item.name}</Text>
          <TouchableOpacity 
            onPress={() => onCompareToggle(item)}
            style={styles.compareItemRemove}
          >
            <MaterialCommunityIcons 
              name="close" 
              size={20} 
              color={COLORS.text.secondary} 
            />
          </TouchableOpacity>
        </View>
      )}
    />
    <TouchableOpacity 
      style={[
        styles.compareButton,
        compareList.length < 2 && styles.compareButtonDisabled
      ]}
      onPress={onCompare}
      disabled={compareList.length < 2}
    >
      <Text style={styles.compareButtonText}>
        Compare ({compareList.length})
      </Text>
    </TouchableOpacity>
  </Animated.View>
));

const styles = StyleSheet.create({
  compareBar: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'rgba(26, 26, 26, 0.95)',
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 230, 118, 0.1)',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    gap: 12,
  },
  compareItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    borderRadius: 8,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    gap: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  compareItemText: {
    color: COLORS.text.primary,
    fontSize: 14,
    maxWidth: 120,
    letterSpacing: 0.2,
  },
  compareItemRemove: {
    padding: 2,
  },
  compareButton: {
    backgroundColor: COLORS.primary,
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
    opacity: 1,
  },
  compareButtonDisabled: {
    opacity: 0.5,
  },
  compareButtonText: {
    color: COLORS.background,
    fontWeight: '600',
    fontSize: 14,
    letterSpacing: 0.2,
  },
});

export default CompareBar; 

================================================================================
File: app/components/trending/Header.tsx
================================================================================

// components/trending/Header.tsx
import React, { useState, memo } from 'react';
import { View, Text, StyleSheet, TextInput, TouchableOpacity } from 'react-native';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';
import { StrainSearchFilters } from '../../../src/DatabaseManager';
import { hasActiveFilters } from '../../../src/utils/filters';
import Animated, { FadeIn } from 'react-native-reanimated';
import SearchBar from './SearchBar';

interface HeaderProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  filters: StrainSearchFilters;
  handleClearSearch: () => void;
}

const Header = ({ 
  searchQuery, 
  setSearchQuery, 
  showFilters, 
  setShowFilters,
  filters,
  handleClearSearch
}: HeaderProps) => {
  const insets = useSafeAreaInsets();
  const hasFilters = hasActiveFilters(filters);
  const hasSearchOrFilters = searchQuery.trim() || hasFilters;

  return (
    <View style={[styles.container, { paddingTop: insets.top + 10 }]}>
      <LinearGradient
        colors={['rgba(0, 230, 118, 0.15)', 'transparent']}
        style={[styles.headerGradient, { top: 0 }]}
        start={{ x: 0.5, y: 0 }}
        end={{ x: 0.5, y: 1 }}
      />
      
      <Text style={styles.title}>Trending</Text>
      
      <View style={styles.searchContainer}>
        <View style={styles.searchInputContainer}>
          <Ionicons name="search" size={20} color={COLORS.text.secondary} style={styles.searchIcon} />
          <TextInput
            style={styles.searchInput}
            placeholder="Search strains..."
            placeholderTextColor={COLORS.text.placeholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            returnKeyType="search"
          />
          {searchQuery.length > 0 && (
            <TouchableOpacity onPress={() => setSearchQuery('')} style={styles.clearButton}>
              <Ionicons name="close-circle" size={18} color={COLORS.text.secondary} />
            </TouchableOpacity>
          )}
        </View>
        
        <TouchableOpacity 
          style={[
            styles.filterButton, 
            hasFilters && styles.activeFilterButton
          ]} 
          onPress={() => setShowFilters(!showFilters)}
        >
          <Ionicons 
            name="options-outline" 
            size={20} 
            color={hasFilters ? COLORS.accent : COLORS.text.secondary} 
          />
        </TouchableOpacity>
      </View>
      
      {hasSearchOrFilters && (
        <View style={styles.clearSearchContainer}>
          <TouchableOpacity 
            style={styles.clearSearchButton}
            onPress={handleClearSearch}
          >
            <Text style={styles.clearSearchText}>Clear All</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 20,
    paddingBottom: 16,
    position: 'relative',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.05)',
  },
  headerGradient: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 150,
  },
  title: {
    fontSize: 34,
    fontWeight: '700',
    color: 'white',
    marginBottom: 20,
    letterSpacing: 0.5,
    textShadowColor: 'rgba(0, 230, 118, 0.6)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  searchInputContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.06)',
    borderRadius: 12,
    paddingHorizontal: 12,
    height: 46,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.08)',
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 46,
    color: COLORS.text.primary,
    fontSize: 16,
  },
  clearButton: {
    padding: 6,
  },
  filterButton: {
    width: 46,
    height: 46,
    borderRadius: 12,
    backgroundColor: 'rgba(255, 255, 255, 0.06)',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.08)',
  },
  activeFilterButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
    borderColor: 'rgba(0, 230, 118, 0.3)',
  },
  clearSearchContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginBottom: 4,
  },
  clearSearchButton: {
    paddingVertical: 6,
    paddingHorizontal: 10,
  },
  clearSearchText: {
    color: COLORS.accent,
    fontSize: 14,
    fontWeight: '500',
  },
});

export default Header;

================================================================================
File: app/components/trending/SearchBar.tsx
================================================================================

// app/components/trending/SearchBar.tsx
import React, { memo } from 'react';
import { View, TextInput, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { Ionicons } from '@expo/vector-icons';
import { COLORS } from '../../../src/constants';
import { LinearGradient } from 'expo-linear-gradient';
import { StrainSearchFilters } from '../../../src/DatabaseManager';
import { hasActiveFilters } from '../../../src/utils/filters';
import Animated, { useAnimatedStyle, useSharedValue, withSpring, FadeIn } from 'react-native-reanimated';

interface SearchBarProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  filters: StrainSearchFilters;
  onClear: () => void;
}

const SearchBar = memo(({
  searchQuery,
  setSearchQuery,
  showFilters,
  setShowFilters,
  filters,
  onClear
}: SearchBarProps) => {
  // Determine if we need the clear button
  const showClearButton = searchQuery.trim() || hasActiveFilters(filters);
  
  // Define filter button states
  const hasFilters = hasActiveFilters(filters);
  const isFilterActive = showFilters || hasFilters;
  
  return (
    <View style={styles.searchContainer}>
      {/* Main search input with enhanced styling */}
      <View style={styles.searchBar}>
        <LinearGradient
          colors={['rgba(0,0,0,0.2)', 'rgba(0,0,0,0.1)']}
          style={StyleSheet.absoluteFillObject}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <MaterialCommunityIcons 
          name="magnify" 
          size={22} 
          color={COLORS.text.secondary} 
          style={styles.searchIcon}
        />
        
        <TextInput
          style={styles.searchInput}
          placeholder="Search strains..."
          placeholderTextColor="rgba(255,255,255,0.4)"
          value={searchQuery}
          onChangeText={setSearchQuery}
          returnKeyType="search"
          autoCapitalize="none"
          autoCorrect={false}
          clearButtonMode="while-editing"
        />
        
        {Platform.OS === 'android' && showClearButton && (
          <TouchableOpacity 
            onPress={onClear}
            style={styles.clearButton}
          >
            <MaterialCommunityIcons 
              name="close-circle" 
              size={18} 
              color={COLORS.text.secondary} 
            />
          </TouchableOpacity>
        )}
      </View>

      {/* Enhanced filter button with states */}
      <TouchableOpacity 
        style={[styles.filterButton, isFilterActive && styles.filterButtonActive]}
        onPress={() => setShowFilters(!showFilters)}
        activeOpacity={0.7}
      >
        <LinearGradient
          colors={
            isFilterActive 
              ? ['rgba(0,230,118,0.2)', 'rgba(0,230,118,0.1)']
              : ['rgba(0,0,0,0.2)', 'rgba(0,0,0,0.1)']
          }
          style={StyleSheet.absoluteFillObject}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <MaterialCommunityIcons 
          name="filter-variant" 
          size={22} 
          color={isFilterActive ? COLORS.primary : COLORS.text.secondary} 
        />
        
        {/* Badge indicator if filters are active */}
        {hasFilters && (
          <View style={styles.filterBadge}>
            <LinearGradient
              colors={['#00E676', '#00C853']}
              style={StyleSheet.absoluteFillObject}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            />
          </View>
        )}
      </TouchableOpacity>
    </View>
  );
});

const styles = StyleSheet.create({
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  searchBar: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.25)',
    borderRadius: 12,
    height: 44,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.12)',
    overflow: 'hidden',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  searchIcon: {
    marginLeft: 12,
    marginRight: 4,
  },
  searchInput: {
    flex: 1,
    color: '#000000',
    fontSize: 16,
    fontWeight: '400',
    paddingVertical: 10,
    paddingHorizontal: 8,
  },
  clearButton: {
    padding: 8,
    marginRight: 4,
  },
  filterButton: {
    width: 44,
    height: 44,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.25)',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.12)',
    overflow: 'hidden',
    position: 'relative',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  filterButtonActive: {
    borderColor: 'rgba(0, 230, 118, 0.3)',
  },
  filterBadge: {
    position: 'absolute',
    top: 10,
    right: 10,
    width: 8,
    height: 8,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.3)',
    overflow: 'hidden',
  },
});

export default SearchBar;

================================================================================
File: app/components/trending/SearchFilters.tsx
================================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { StrainSearchFilters } from '../../../src/DatabaseManager';
import { COLORS } from '../../../src/constants';
import { LinearGradient } from 'expo-linear-gradient';

interface SearchFiltersProps {
  filters: StrainSearchFilters;
  onFilterChange: (filters: StrainSearchFilters) => void;
  onApplyFilters: () => void;
  categories: { [key: string]: number };
}

const SORT_OPTIONS = [
  { key: 'rating', label: 'Rating', icon: 'star' },
  { key: 'name', label: 'Name', icon: 'sort-alphabetical-ascending' },
  { key: 'thc', label: 'THC', icon: 'percent' },
] as const;

const COMMON_EFFECTS = [
  'Relaxed',
  'Energetic',
  'Creative',
  'Focused',
  'Euphoric',
  'Sleepy',
  'Happy',
  'Uplifted'
];

export default function SearchFilters({ 
  filters, 
  onFilterChange, 
  onApplyFilters,
  categories 
}: SearchFiltersProps) {
  const [localFilters, setLocalFilters] = useState<StrainSearchFilters>(filters);

  const handleSortChange = (sort: StrainSearchFilters['sort']) => {
    setLocalFilters(prev => ({ ...prev, sort }));
  };

  const handleEffectToggle = (effect: string) => {
    const currentEffects = localFilters.effects || [];
    const newEffects = currentEffects.includes(effect)
      ? currentEffects.filter(e => e !== effect)
      : [...currentEffects, effect];
    setLocalFilters(prev => ({ ...prev, effects: newEffects }));
  };

  const handleGeneticTypeChange = (geneticType: string | undefined) => {
    setLocalFilters(prev => ({ ...prev, geneticType }));
  };

  const handleApply = () => {
    onFilterChange(localFilters);
    onApplyFilters();
  };

  return (
    <View style={styles.container}>
      {/* Sort Options */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Sort By</Text>
        <View style={styles.sortOptions}>
          {SORT_OPTIONS.map(({ key, label, icon }) => (
            <TouchableOpacity
              key={key}
              style={[
                styles.sortOption,
                localFilters.sort === key && styles.sortOptionActive
              ]}
              onPress={() => handleSortChange(key)}
            >
              <MaterialCommunityIcons
                name={icon}
                size={18}
                color={localFilters.sort === key ? COLORS.primary : COLORS.text.secondary}
              />
              <Text style={[
                styles.sortOptionText,
                localFilters.sort === key && styles.sortOptionTextActive
              ]}>
                {label}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Genetic Types */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Genetic Type</Text>
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          style={styles.geneticTypes}
        >
          <TouchableOpacity
            style={[
              styles.typeChip,
              !localFilters.geneticType && styles.typeChipActive
            ]}
            onPress={() => handleGeneticTypeChange(undefined)}
          >
            <Text style={[
              styles.typeChipText,
              !localFilters.geneticType && styles.typeChipTextActive
            ]}>
              All
            </Text>
          </TouchableOpacity>
          {Object.entries(categories).map(([type, count]) => (
            <TouchableOpacity
              key={type}
              style={[
                styles.typeChip,
                localFilters.geneticType === type && styles.typeChipActive
              ]}
              onPress={() => handleGeneticTypeChange(type)}
            >
              <Text style={[
                styles.typeChipText,
                localFilters.geneticType === type && styles.typeChipTextActive
              ]}>
                {type} ({count})
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>

      {/* Effects */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Effects</Text>
        <View style={styles.effectsGrid}>
          {COMMON_EFFECTS.map(effect => (
            <TouchableOpacity
              key={effect}
              style={[
                styles.effectChip,
                (localFilters.effects || []).includes(effect) && styles.effectChipActive
              ]}
              onPress={() => handleEffectToggle(effect)}
            >
              <Text style={[
                styles.effectChipText,
                (localFilters.effects || []).includes(effect) && styles.effectChipTextActive
              ]}>
                {effect}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Apply Button */}
      <TouchableOpacity 
        style={styles.applyButton}
        onPress={handleApply}
      >
        <LinearGradient
          colors={[COLORS.primary, COLORS.primaryDark]}
          style={styles.applyButtonGradient}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          <Text style={styles.applyButtonText}>Apply Filters</Text>
          <MaterialCommunityIcons 
            name="check" 
            size={20} 
            color="#FFF" 
          />
        </LinearGradient>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: COLORS.cardBackground,
    borderRadius: 12,
    padding: 16,
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
  },
  sortOptions: {
    flexDirection: 'row',
    gap: 12,
  },
  sortOption: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    gap: 6,
  },
  sortOptionActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  sortOptionText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  sortOptionTextActive: {
    color: COLORS.primary,
  },
  geneticTypes: {
    flexDirection: 'row',
  },
  typeChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    marginRight: 8,
  },
  typeChipActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  typeChipText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  typeChipTextActive: {
    color: COLORS.primary,
  },
  effectsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  effectChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  effectChipActive: {
    backgroundColor: 'rgba(0, 230, 118, 0.1)',
  },
  effectChipText: {
    fontSize: 14,
    color: COLORS.text.secondary,
  },
  effectChipTextActive: {
    color: COLORS.primary,
  },
  applyButton: {
    marginTop: 20,
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  applyButtonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 8,
    width: '100%',
  },
  applyButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFF',
    marginRight: 8,
  },
});

================================================================================
File: app/components/trending/Section.tsx
================================================================================

import React, { memo } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';

interface SectionProps {
  title: string;
  children: React.ReactNode;
}

const Section = memo(({ title, children }: SectionProps) => (
  <View style={styles.sectionWrapper}>
    <LinearGradient
      colors={['rgba(0,230,118,0.1)', 'transparent']}
      style={styles.sectionDivider}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 0 }}
    />
    <View style={styles.section}>
      <LinearGradient
        colors={['rgba(0,230,118,0.1)', 'rgba(0,230,118,0.02)', 'transparent']}
        style={styles.sectionGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 0, y: 1 }}
      />
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionTitle}>{title}</Text>
      </View>
      <View style={styles.sectionContent}>
        {children}
      </View>
    </View>
  </View>
));

const styles = StyleSheet.create({
  sectionWrapper: {
    marginBottom: 32,
    position: 'relative',
  },
  sectionDivider: {
    height: 1,
    width: '100%',
    marginBottom: 16,
  },
  section: {
    borderRadius: 16,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.75)',
      android: 'rgba(26, 26, 26, 0.9)',
    }),
  },
  sectionGradient: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.5,
  },
  sectionHeader: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 230, 118, 0.1)',
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
  },
  sectionContent: {
    padding: 12,
    gap: 12,
  },
});

export default Section; 

================================================================================
File: app/components/trending/StrainsList.tsx
================================================================================

// app/components/trending/StrainsList.tsx
import React, { memo, useCallback } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  FlatList, 
  Platform
} from 'react-native';
import { useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../src/constants';
import { Strain } from "@/src/types";
import Animated, { FadeIn } from 'react-native-reanimated';

interface StrainsListProps {
  strains: Strain[];
  onCompareToggle: (strain: Strain) => void;
  onFavoriteToggle: (strainId: number) => void;
  compareList: Strain[];
  isFavorite: (strainId: number) => boolean;
  isLoading: boolean;
  onEndReached: () => void;
}

// Rating badge component for cleaner code
const RatingBadge = ({ rating }: { rating: number }) => (
  <LinearGradient
    colors={[
      rating >= 9 ? '#00E676' : rating >= 8 ? '#1DE9B6' : '#26C6DA', 
      rating >= 9 ? '#00C853' : rating >= 8 ? '#00BFA5' : '#00ACC1'
    ]}
    style={styles.ratingBadge}
    start={{ x: 0, y: 0 }}
    end={{ x: 1, y: 1 }}
  >
    <Text style={styles.ratingText}>{rating.toFixed(1)}</Text>
  </LinearGradient>
);

// Strain type badge
const TypeBadge = ({ type }: { type: string }) => {
  let gradientColors;
  
  // Different colors for different strain types
  switch(type.toLowerCase()) {
    case 'sativa':
    case 'sativa-dominant':
    case 'sativa-dominant hybrid':
      gradientColors = ['rgba(255, 160, 0, 0.2)', 'rgba(255, 160, 0, 0.1)'];
      break;
    case 'indica':
    case 'indica-dominant':
    case 'indica-dominant hybrid':
      gradientColors = ['rgba(123, 31, 162, 0.2)', 'rgba(123, 31, 162, 0.1)'];
      break;
    case 'hybrid':
      gradientColors = ['rgba(0, 176, 255, 0.2)', 'rgba(0, 176, 255, 0.1)'];
      break;
    default:
      gradientColors = ['rgba(120, 144, 156, 0.2)', 'rgba(120, 144, 156, 0.1)'];
  }
  
  return (
    <LinearGradient
      colors={gradientColors}
      style={styles.typeBadge}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 1 }}
    >
      <Text style={styles.typeBadgeText}>{type}</Text>
    </LinearGradient>
  );
};

export const StrainsList = memo(({
  strains,
  onCompareToggle,
  onFavoriteToggle,
  compareList,
  isFavorite,
  isLoading,
  onEndReached,
}: StrainsListProps) => {
  const router = useRouter();

  // Optimize with useCallback
  const renderStrainItem = useCallback(({ item: strain, index }: { item: Strain, index: number }) => (
    <Animated.View 
    entering={FadeIn.duration(150)} // Much shorter duration, no delay
    style={styles.strainItemContainer}
  >
      <TouchableOpacity
        onPress={() => router.push({
          pathname: "/strains/details",
          params: { id: strain.id }
        } as any)}
        style={styles.strainItem}
        activeOpacity={0.8}
      >
        <LinearGradient
          colors={['rgba(0, 230, 118, 0.1)', 'rgba(0, 230, 118, 0.05)', 'rgba(0, 230, 118, 0)']}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        />
        
        {/* Left content */}
        <View style={styles.strainContent}>
          <View style={styles.strainHeader}>
            <Text style={styles.strainName}>{strain.name}</Text>
            <RatingBadge rating={strain.combined_rating} />
          </View>

          <TypeBadge type={strain.genetic_type} />
          
          <Text 
            numberOfLines={2} 
            style={styles.strainDescription}
          >
            {strain.overview}
          </Text>

          {strain.effects && (
            <View style={styles.effectsContainer}>
              {strain.effects.split(',').slice(0, 3).map((effect, idx) => (
                <View key={idx} style={styles.effectBadge}>
                  <Text style={styles.effectText}>{effect.trim()}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        {/* Action buttons */}
        <View style={styles.actionButtons}>
          <TouchableOpacity 
            onPress={() => onFavoriteToggle(strain.id!)}
            style={[
              styles.actionButton,
              isFavorite(strain.id!) && styles.favoriteButton
            ]}
          >
            <MaterialCommunityIcons 
              name={isFavorite(strain.id!) ? "heart" : "heart-outline"} 
              size={22} 
              color={isFavorite(strain.id!) ? '#FFFFFF' : COLORS.text.secondary} 
            />
          </TouchableOpacity>
          
          <TouchableOpacity 
            onPress={() => onCompareToggle(strain)}
            style={[
              styles.actionButton,
              compareList.some(s => s.id === strain.id) && styles.compareButton
            ]}
            disabled={compareList.length >= 3 && !compareList.some(s => s.id === strain.id)}
          >
            <MaterialCommunityIcons 
              name={compareList.some(s => s.id === strain.id) ? "compare" : "compare-horizontal"} 
              size={22} 
              color={compareList.some(s => s.id === strain.id) ? '#FFFFFF' : COLORS.text.secondary} 
            />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    </Animated.View>
  ), [onCompareToggle, onFavoriteToggle, compareList, isFavorite, router]);

  const keyExtractor = useCallback((item: Strain, index: number) => {
    // Use unique combination of id and index if id exists, otherwise use index-based fallback
    return item.id ? `strain-${item.id}-${index}` : `strain-index-${index}`;
  }, []);
  

  if (!strains.length && !isLoading) {
    return (
      <View style={styles.emptyContainer}>
        <MaterialCommunityIcons 
          name="cannabis" 
          size={48} 
          color={COLORS.primary}
          style={{ opacity: 0.5 }}
        />
        <Text style={styles.emptyText}>
          No strains found matching your criteria
        </Text>
      </View>
    );
  }

  return (
    <FlatList
      data={strains}
      renderItem={renderStrainItem}
      keyExtractor={keyExtractor}
      contentContainerStyle={styles.content}
      onEndReached={onEndReached}
      onEndReachedThreshold={0.5}
      showsVerticalScrollIndicator={false}
      // Performance optimizations
      removeClippedSubviews={Platform.OS === 'android'}
      windowSize={5}
      maxToRenderPerBatch={5}
      initialNumToRender={8}  // Limit initial render batch
      updateCellsBatchingPeriod={50}  // Group cell updates to optimize performance
      // Add key tracking for debugging
      maintainVisibleContentPosition={{
        minIndexForVisible: 0,
      }}
    />
  );
  
});

const styles = StyleSheet.create({
  content: {
    paddingBottom: 80, // Space for the compare bar
  },
  strainItemContainer: {
    marginBottom: 16,
    borderRadius: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
  },
  strainItem: {
    backgroundColor: 'rgba(26, 32, 28, 0.95)',
    borderRadius: 16,
    overflow: 'hidden',
    flexDirection: 'row',
    padding: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.15)',
  },
  strainContent: {
    flex: 1,
  },
  strainHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  strainName: {
    fontSize: 18,
    fontWeight: '700',
    color: COLORS.text.primary,
    letterSpacing: 0.5,
    flex: 1,
    marginRight: 8,
  },
  ratingBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  ratingText: {
    color: '#FFFFFF',
    fontWeight: '700',
    fontSize: 16,
  },
  typeBadge: {
    alignSelf: 'flex-start',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 8,
    marginBottom: 10,
  },
  typeBadgeText: {
    fontSize: 13,
    color: COLORS.text.primary,
    fontWeight: '500',
  },
  strainDescription: {
    fontSize: 14,
    color: COLORS.text.secondary,
    lineHeight: 20,
    marginBottom: 12,
  },
  effectsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  effectBadge: {
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
  },
  effectText: {
    fontSize: 12,
    color: COLORS.text.secondary,
  },
  actionButtons: {
    marginLeft: 16,
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  actionButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    marginVertical: 6,
  },
  favoriteButton: {
    backgroundColor: 'rgba(255, 82, 82, 0.8)',
  },
  compareButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.8)',
  },
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(26, 32, 28, 0.5)',
    padding: 40,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
    marginVertical: 30,
  },
  emptyText: {
    fontSize: 16,
    color: COLORS.text.primary,
    textAlign: 'center',
    marginTop: 16,
    opacity: 0.8,
  },
});

export default StrainsList;

================================================================================
File: app/context/AchievementContext.tsx
================================================================================

import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { databaseManager } from '../../src/DatabaseManager';
import { UserAchievementWithDetails } from '../../src/types';
import { DatabaseResponse } from '../../src/types';

interface AchievementContextType {
  achievements: UserAchievementWithDetails[];
  stats: {
    total: number;
    unlocked: number;
    percentComplete: number;
  };
  newlyUnlocked: UserAchievementWithDetails | null;
  loading: boolean;
  loadAchievements: () => Promise<void>;
  checkAchievements: (actionType: string, data: any) => Promise<void>;
  clearNewlyUnlocked: () => void;
}

const defaultContext: AchievementContextType = {
  achievements: [],
  stats: {
    total: 0,
    unlocked: 0,
    percentComplete: 0
  },
  newlyUnlocked: null,
  loading: false,
  loadAchievements: async () => {},
  checkAchievements: async () => {},
  clearNewlyUnlocked: () => {},
};

export const AchievementContext = createContext<AchievementContextType>(defaultContext);

export const useAchievements = () => useContext(AchievementContext);

interface AchievementProviderProps {
  children: ReactNode;
}

export const AchievementProvider: React.FC<AchievementProviderProps> = ({ children }) => {
  const [achievements, setAchievements] = useState<UserAchievementWithDetails[]>([]);
  const [newlyUnlocked, setNewlyUnlocked] = useState<UserAchievementWithDetails | null>(null);
  const [loading, setLoading] = useState(false);
  const [stats, setStats] = useState({
    total: 0,
    unlocked: 0,
    percentComplete: 0
  });
  
  // In a real app, you'd get this from authentication context or similar
  const userId = 'current-user';
  
  const loadAchievements = async () => {
    try {
      setLoading(true);
      
      // Fetch achievements - note that getUserAchievements returns an array directly, not a DatabaseResponse
      const userAchievements = await databaseManager.getUserAchievements(userId);
      
      if (userAchievements && Array.isArray(userAchievements)) {
        setAchievements(userAchievements);
        
        // Calculate stats
        const totalCount = userAchievements.length;
        const unlockedCount = userAchievements.filter(a => a.isUnlocked).length;
        
        setStats({
          total: totalCount,
          unlocked: unlockedCount,
          percentComplete: totalCount > 0 ? Math.round((unlockedCount / totalCount) * 100) : 0
        });
        
        // Clear new flags
        await databaseManager.clearAchievementNewFlags(userId);
        console.log(`[AchievementContext] Loaded ${userAchievements.length} achievements`);
      } else {
        console.error('Failed to load achievements: Invalid response format');
        setAchievements([]);
        setStats({
          total: 0,
          unlocked: 0,
          percentComplete: 0
        });
      }
    } catch (error) {
      console.error('Failed to load achievements:', error instanceof Error ? error.message : 'Unknown error');
      setAchievements([]);
      setStats({
        total: 0,
        unlocked: 0,
        percentComplete: 0
      });
    } finally {
      setLoading(false);
    }
  };
  
  const checkAchievements = async (actionType: string, data: any) => {
    try {
      // Check for newly unlocked achievements based on the action
      const unlockedAchievements = await databaseManager.checkAchievements(userId, actionType, data);
      
      if (unlockedAchievements && Array.isArray(unlockedAchievements) && unlockedAchievements.length > 0) {
        // Set the most recent achievement as newly unlocked for notification
        setNewlyUnlocked(unlockedAchievements[0]);
        
        // Refresh the achievements list to reflect changes
        loadAchievements();
      }
    } catch (error) {
      console.error('Failed to check achievements:', error instanceof Error ? error.message : 'Unknown error');
    }
  };
  
  const clearNewlyUnlocked = () => {
    setNewlyUnlocked(null);
  };
  
  // Load achievements on initial mount
  useEffect(() => {
    loadAchievements();
  }, []);
  
  const value = {
    achievements,
    stats,
    newlyUnlocked,
    loading,
    loadAchievements,
    checkAchievements,
    clearNewlyUnlocked,
  };
  
  return (
    <AchievementContext.Provider value={value}>
      {children}
    </AchievementContext.Provider>
  );
}; 

================================================================================
File: app/screens/AchievementsScreen.tsx
================================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { View, StyleSheet, FlatList, Text, ActivityIndicator, RefreshControl, Platform, TouchableOpacity } from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { AchievementCard } from '../components/achievements/AchievementCard';
import { AchievementDetailModal } from '../components/achievements/AchievementDetailModal';
import { databaseManager } from '../../src/DatabaseManager';
import { UserAchievementWithDetails } from '../../src/types';
import { LinearGradient } from 'expo-linear-gradient';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { COLORS } from '../../src/constants';
import Animated, { FadeIn } from 'react-native-reanimated';
import { DatabaseResponse } from '../../src/types';

// Shared categories for filtering
const ACHIEVEMENT_CATEGORIES = [
  'All',
  'Daily & Weekly Streaks',
  'Strain Exploration',
  'Mood & Journaling',
  'Moderation & Goal-Oriented',
  'Medical-Focused',
  'Recreational-Focused',
  'AI Interaction',
  'Referral & Community',
  'Morning/Evening Check-Ins',
  'Long-Term Milestones',
  'Themed Celebrations'
];

type AchievementListItem = string | UserAchievementWithDetails;

export default function AchievementsScreen() {
  const [achievements, setAchievements] = useState<UserAchievementWithDetails[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [selectedAchievement, setSelectedAchievement] = useState<UserAchievementWithDetails | null>(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState('All');
  const [stats, setStats] = useState({
    total: 0,
    unlocked: 0,
    percentComplete: 0
  });
  
  const loadAchievements = async () => {
    try {
      setLoading(true);
      // In a real app, you'd get the actual user ID
      const userId = 'current-user';
      
      console.log('[AchievementsScreen] Fetching user achievements...');
      // Fetch achievements
      const userAchievements = await databaseManager.getUserAchievements(userId);
      console.log('[AchievementsScreen] Received achievements:', userAchievements?.length || 0);
      
      if (userAchievements && Array.isArray(userAchievements)) {
        setAchievements(userAchievements);
        
        // Calculate stats
        const totalCount = userAchievements.length;
        const unlockedCount = userAchievements.filter((a: UserAchievementWithDetails) => a.isUnlocked).length;
        
        setStats({
          total: totalCount,
          unlocked: unlockedCount,
          percentComplete: totalCount > 0 ? Math.round((unlockedCount / totalCount) * 100) : 0
        });
        
        // Clear new flags
        console.log('[AchievementsScreen] Clearing achievement new flags...');
        await databaseManager.clearAchievementNewFlags(userId);
      } else {
        // Handle case where achievements are not returned as expected
        console.error('[AchievementsScreen] Failed to load achievements: Invalid response format');
        setAchievements([]);
        setStats({
          total: 0,
          unlocked: 0,
          percentComplete: 0
        });
      }
    } catch (error) {
      console.error('[AchievementsScreen] Failed to load achievements:', error instanceof Error ? error.message : 'Unknown error');
      // Set empty state when there's an error
      setAchievements([]);
      setStats({
        total: 0,
        unlocked: 0,
        percentComplete: 0
      });
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };
  
  useEffect(() => {
    loadAchievements();
  }, []);
  
  useFocusEffect(
    useCallback(() => {
      loadAchievements();
    }, [])
  );
  
  const onRefresh = () => {
    setRefreshing(true);
    loadAchievements();
  };
  
  const handleAchievementPress = (achievement: UserAchievementWithDetails) => {
    setSelectedAchievement(achievement);
    setModalVisible(true);
  };
  
  const closeModal = () => {
    setModalVisible(false);
  };
  
  const filteredAchievements = selectedCategory === 'All'
    ? achievements
    : achievements.filter(a => a.category === selectedCategory);
  
  // Group achievements by category for the "All" view
  const groupedAchievements = filteredAchievements.reduce((groups, achievement) => {
    const category = achievement.category;
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(achievement);
    return groups;
  }, {} as Record<string, UserAchievementWithDetails[]>);
  
  const renderCategoryFilter = () => (
    <View style={styles.filterContainer}>
      <FlatList
        horizontal
        data={ACHIEVEMENT_CATEGORIES.filter(cat => 
          cat === 'All' || achievements.some(a => a.category === cat)
        )}
        keyExtractor={(item) => item}
        renderItem={({ item }) => (
          <TouchableOpacity
            style={[
              styles.filterButton,
              selectedCategory === item && styles.selectedFilterButton
            ]}
            onPress={() => setSelectedCategory(item)}
          >
            <Text 
              style={[
                styles.filterText,
                selectedCategory === item && styles.selectedFilterText
              ]}
            >
              {item}
            </Text>
          </TouchableOpacity>
        )}
        showsHorizontalScrollIndicator={false}
      />
    </View>
  );
  
  const renderHeader = () => (
    <Animated.View 
      entering={FadeIn.duration(400)}
      style={styles.header}
    >
      <View style={styles.statsCard}>
        <LinearGradient
          colors={[
            'rgba(0,230,118,0.15)',
            'rgba(0,230,118,0.05)',
            'transparent'
          ]}
          style={StyleSheet.absoluteFill}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
        />
        
        <View style={styles.statsContent}>
          <View style={styles.statItem}>
            <Text style={styles.statValue}>{stats.unlocked}</Text>
            <Text style={styles.statLabel}>Unlocked</Text>
          </View>
          
          <View style={styles.statSeparator} />
          
          <View style={styles.statItem}>
            <Text style={styles.statValue}>{stats.total}</Text>
            <Text style={styles.statLabel}>Total</Text>
          </View>
          
          <View style={styles.statSeparator} />
          
          <View style={styles.statItem}>
            <Text style={styles.statValue}>{stats.percentComplete}%</Text>
            <Text style={styles.statLabel}>Complete</Text>
          </View>
        </View>
      </View>
      
      {renderCategoryFilter()}
    </Animated.View>
  );
  
  const renderEmptyState = () => (
    <View style={styles.emptyContainer}>
      <MaterialCommunityIcons name="trophy-outline" size={60} color={COLORS.text.secondary} />
      <Text style={styles.emptyText}>No achievements available</Text>
      <Text style={styles.emptyDescription}>Achievements may still be loading or there was an error fetching your data.</Text>
      <TouchableOpacity style={styles.retryButton} onPress={onRefresh}>
        <Text style={styles.retryText}>Try Again</Text>
      </TouchableOpacity>
    </View>
  );
  
  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
      </View>
    );
  }
  
  // Determine data for the main FlatList
  const listData: AchievementListItem[] = selectedCategory === 'All'
    ? Object.keys(groupedAchievements)
    : filteredAchievements;
  
  return (
    <SafeAreaProvider>
      <View style={styles.container}>
        <FlatList
          data={listData}
          keyExtractor={(item) => {
            if (typeof item === 'string') {
              return item;
            } else {
              return item.id.toString();
            }
          }}
          renderItem={({ item }) => {
            if (selectedCategory === 'All' && typeof item === 'string') {
              // This is a category header in "All" view
              const categoryAchievements = groupedAchievements[item];
              return (
                <View style={styles.categoryHeaderContainer}>
                  <Text style={styles.categoryHeader}>{item}</Text>
                  <FlatList
                    data={categoryAchievements}
                    keyExtractor={(achievement) => achievement.id.toString()}
                    renderItem={({ item: achievement }) => (
                      <AchievementCard 
                        achievement={achievement} 
                        onPress={handleAchievementPress} 
                      />
                    )}
                    scrollEnabled={false}
                  />
                </View>
              );
            } else {
              // This is an individual achievement in filtered view
              return (
                <AchievementCard 
                  achievement={item as UserAchievementWithDetails} 
                  onPress={handleAchievementPress} 
                />
              );
            }
          }}
          ListHeaderComponent={renderHeader}
          ListEmptyComponent={renderEmptyState}
          contentContainerStyle={styles.listContent}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              colors={[COLORS.primary]}
            />
          }
        />
        
        <AchievementDetailModal
          visible={modalVisible}
          achievement={selectedAchievement}
          onClose={closeModal}
        />
      </View>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.background,
  },
  header: {
    padding: 16,
    paddingBottom: 8,
  },
  statsCard: {
    borderRadius: 20,
    marginBottom: 16,
    overflow: 'hidden',
    backgroundColor: Platform.select({
      ios: 'rgba(26, 26, 26, 0.8)',
      android: 'rgba(26, 26, 26, 0.95)',
    }),
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    ...Platform.select({
      ios: {
        shadowColor: COLORS.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 12,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  statsContent: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    padding: 20,
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statValue: {
    fontSize: 24,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.text.secondary,
    letterSpacing: 0.25,
  },
  statSeparator: {
    height: 40,
    width: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  filterContainer: {
    marginBottom: 8,
  },
  filterButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginRight: 8,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
  },
  selectedFilterButton: {
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
  },
  filterText: {
    color: COLORS.text.secondary,
    fontSize: 14,
  },
  selectedFilterText: {
    color: COLORS.primary,
    fontWeight: '600',
  },
  listContent: {
    paddingHorizontal: 16,
    paddingBottom: 16,
  },
  categoryHeaderContainer: {
    marginTop: 16,
    marginBottom: 8,
  },
  categoryHeader: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginBottom: 12,
    letterSpacing: 0.35,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
  },
  emptyText: {
    color: COLORS.text.secondary,
    fontSize: 16,
    marginTop: 16,
  },
  emptyDescription: {
    color: COLORS.text.secondary,
    fontSize: 14,
    marginTop: 8,
    textAlign: 'center',
    paddingHorizontal: 20,
  },
  retryButton: {
    marginTop: 20,
    paddingVertical: 10,
    paddingHorizontal: 20,
    backgroundColor: 'rgba(0, 230, 118, 0.2)',
    borderRadius: 20,
  },
  retryText: {
    color: COLORS.primary,
    fontWeight: '600',
  },
});

================================================================================
File: app/strains/_layout.tsx
================================================================================

import { Stack } from 'expo-router';

export default function StrainsLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="popular" 
        options={{ 
          title: "Popular Strains",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="details" 
        options={{ 
          title: "Strain Details",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
      <Stack.Screen 
        name="compare" 
        options={{ 
          title: "Compare Strains",
          headerTintColor: "#00E676",
          headerStyle: { backgroundColor: "#000000" },
        }} 
      />
    </Stack>
  );
}

================================================================================
File: app/strains/compare.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { COLORS } from '../../src/constants';
import { Strain } from "@/src/types";
import { databaseManager } from '../../src/DatabaseManager';

export default function CompareStrains() {
  const { ids } = useLocalSearchParams();
  const strainIds = typeof ids === 'string' ? ids.split(',') : [];
  
  return (
    <View style={{ flex: 1, backgroundColor: COLORS.background, padding: 20 }}>
      <Text style={{ color: COLORS.text.primary, fontSize: 18 }}>
        Compare Strains
      </Text>
      <Text style={{ color: COLORS.text.secondary, marginTop: 8 }}>
        Comparing IDs: {strainIds.join(', ')}
      </Text>
    </View>
  );
}

================================================================================
File: app/strains/details.tsx
================================================================================

import React from 'react';
import { View, Text } from 'react-native';
import { Redirect, useLocalSearchParams } from 'expo-router';
import { COLORS } from '@/src/constants';

export default function StrainDetailsRedirect() {
  const { id } = useLocalSearchParams();
  return <Redirect href={`/dataOverviews/strains/strainDetails?id=${id}`} />;
}

================================================================================
File: app/strains/popular.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList,
  TouchableOpacity,
  Platform 
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { COLORS } from '../../src/constants';
import { Strain } from "@/src/types";
import { databaseManager } from '../../src/DatabaseManager';

const PopularStrains = () => {
  const router = useRouter();
  const [strains, setStrains] = useState<Strain[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadStrains = async () => {
      try {
        setLoading(true);
        const popularStrains = await databaseManager.getPopularStrains();
        setStrains(popularStrains);
      } catch (error) {
        console.error('Failed to load popular strains', error);
      } finally {
        setLoading(false);
      }
    };

    loadStrains();
  }, []);

  const renderItem = ({ item }: { item: Strain }) => (
    <TouchableOpacity 
      style={styles.strainItem}
      onPress={() => item.id && router.push({pathname: `/strains/${item.id}`} as any)}
    >
      <View style={styles.iconContainer}>
        <MaterialCommunityIcons name="cannabis" size={24} color="#fff" />
      </View>
      <View style={styles.textContainer}>
        <Text style={styles.strainName}>{item.name}</Text>
        <Text style={styles.strainDescription}>{item.overview}</Text>
        {item.thc_range && (
          <Text style={styles.thcContent}>THC: {item.thc_range}</Text>
        )}
      </View>
      <MaterialCommunityIcons 
        name="chevron-right" 
        size={24} 
        color={colors.label.secondary} 
      />
    </TouchableOpacity>
  );

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <MaterialCommunityIcons 
            name="chevron-left" 
            size={28} 
            color={colors.label.primary} 
          />
        </TouchableOpacity>
        <Text style={styles.headerText}>Popular Strains</Text>
      </View>
      <FlatList
        data={strains}
        renderItem={renderItem}
        keyExtractor={item => item.id ? item.id.toString() : ''}
        contentContainerStyle={styles.listContainer}
        showsVerticalScrollIndicator={false}
      />
    </SafeAreaView>
  );
};

const colors = {
  label: {
    primary: "#FFFFFF",
    secondary: "#8E8E93",
    tertiary: "#636366",
  },
  background: {
    primary: "#000000",
    secondary: "#1C1C1E",
    tertiary: "#2C2C2E",
  }
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background.primary,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    paddingTop: 8,
    borderBottomWidth: 1,
    borderBottomColor: colors.background.secondary,
  },
  backButton: {
    marginRight: 8,
    padding: 4,
  },
  headerText: {
    fontSize: 24,
    fontWeight: Platform.select({ ios: '600', android: 'bold' }),
    color: colors.label.primary,
  },
  listContainer: {
    padding: 16,
  },
  strainItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    backgroundColor: colors.background.secondary,
    borderRadius: 12,
    marginBottom: 12,
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: colors.background.tertiary,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  textContainer: {
    flex: 1,
  },
  strainName: {
    fontSize: 17,
    fontWeight: Platform.select({ ios: '600', android: 'bold' }),
    color: colors.label.primary,
    marginBottom: 4,
  },
  strainDescription: {
    fontSize: 14,
    color: colors.label.secondary,
    marginBottom: 4,
  },
  thcContent: {
    fontSize: 12,
    color: colors.label.tertiary,
    fontWeight: '500',
  },
});

export default PopularStrains; 

================================================================================
File: components/charts/WeeklyOverviewChart.tsx
================================================================================

import { Card } from "@/components/Card";
import { StyleSheet, View, Text, Dimensions } from "react-native";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import { BarChart } from "react-native-chart-kit";
import { LinearGradient } from "expo-linear-gradient";
import { Datapoint } from "@/src/types";
import { useMemo } from "react";

// Keep COLORS here for now, we'll move it to constants later
const COLORS = {
  background: '#000000',
  cardBackground: '#1A1A1A',
  primary: '#00E676',       // Neon green 
  primaryLight: '#69F0AE',  // Light neon green
  primaryDark: '#00C853',   // Darker green
  text: {
    primary: '#FFFFFF',
    secondary: '#FFFFFFCC',  // 80% white
    tertiary: '#FFFFFF99',   // 60% white
  },
  chart: {
    primary: '#00E676',
    secondary: '#69F0AE',
    background: '#1A1A1A',
  },
  gradientColors: {
    start: 'rgba(0,230,118,0.4)',
    middle: 'rgba(105,240,174,0.2)',
    end: 'rgba(0,0,0,0)',
  }
};

const windowWidth = Dimensions.get("window").width;

interface WeeklyOverviewChartProps {
  data: Datapoint[];
  onPress?: () => void;
}

export function WeeklyOverviewChart({ data }: WeeklyOverviewChartProps) {
  // Memoize the chart width calculation
  const chartWidth = useMemo(() => Math.max(windowWidth - 64, 200), [windowWidth]);

  // Base chart config with optimizations
  const baseChartConfig = useMemo(() => ({
    backgroundColor: COLORS.chart.background,
    backgroundGradientFrom: COLORS.chart.background,
    backgroundGradientTo: COLORS.chart.background,
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
    labelColor: (opacity = 0.8) => `rgba(255, 255, 255, ${opacity})`,
    barPercentage: 0.7,
    useShadowColorFromDataset: false,
    withInnerLines: false,
    withVerticalLabels: true,
    withHorizontalLabels: true,
    withVerticalLines: false,
    withHorizontalLines: true,
    propsForBackgroundLines: {
      stroke: COLORS.text.tertiary,
      strokeWidth: 1,
    },
    propsForDots: {
      r: "4",
      strokeWidth: "2",
      stroke: COLORS.primaryLight,
    },
    style: {
      borderRadius: 16,
    },
    formatYLabel: (value: string) => Math.round(Number(value)).toString(),
    formatXLabel: (label: string) => label.substring(0, 3),
    segments: 4,
  }), []);

  // Memoize the data transformation
  const chartData = useMemo(() => ({
    labels: data.map((d) => d.label),
    datasets: [{ 
      data: data.map((d) => d.value),
      color: (opacity = 1) => `rgba(0, 230, 118, ${opacity})`,
      strokeWidth: 2,
    }]
  }), [data]);

  if (!data?.length) {
    return (
      <Card style={styles.card}>
        <View style={styles.cardHeader}>
          <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
          <Text style={styles.cardTitle}>Weekly Overview</Text>
        </View>
        <View style={styles.chartContainer}>
          <Text style={styles.noDataText}>No data available</Text>
        </View>
      </Card>
    );
  }

  return (
    <Card style={styles.card}>
      <View style={styles.cardHeader}>
        <MaterialCommunityIcons name="calendar-week" size={24} color={COLORS.primary} />
        <Text style={styles.cardTitle}>Weekly Overview</Text>
      </View>
      <Text style={styles.cardDescription}>Compare your usage across different days</Text>
      <View style={styles.chartContainer}>
        <LinearGradient
          colors={[
            COLORS.gradientColors.start,
            COLORS.gradientColors.middle,
            COLORS.gradientColors.end
          ]}
          start={{ x: 0, y: 0 }}
          end={{ x: 0, y: 1 }}
          style={styles.chartGradient}
        />
        <BarChart
          data={chartData}
          width={chartWidth}
          height={180}
          chartConfig={baseChartConfig}
          style={styles.chart}
          showValuesOnTopOfBars
          fromZero
          segments={4}
          flatColor={true}
          withCustomBarColorFromData={true}
        />
      </View>
    </Card>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#1A1A1A',
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 16,
    padding: 16,
    shadowColor: '#00E676',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 230, 118, 0.1)',
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  cardTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: COLORS.text.primary,
    marginLeft: 10,
  },
  cardDescription: {
    fontSize: 15,
    color: COLORS.text.secondary,
    marginTop: 4,
    marginBottom: 16,
    lineHeight: 20,
  },
  chartContainer: {
    marginTop: 16,
    alignItems: "center",
    paddingHorizontal: 8,
    backgroundColor: COLORS.cardBackground,
    borderRadius: 16,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 4,
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
    backgroundColor: COLORS.cardBackground,
    shadowColor: COLORS.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 6,
  },
  chartGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 16,
  },
  noDataText: {
    fontSize: 16,
    color: COLORS.text.secondary,
    padding: 20,
  }
}); 

================================================================================
File: components/Leaderboard.tsx
================================================================================

import React from 'react';
import { View, Text, FlatList, StyleSheet } from 'react-native';

interface LeaderboardEntry {
  id: string;
  name: string;
  score: number;
}

interface LeaderboardProps {
  data: LeaderboardEntry[];
  title: string;
}

const Leaderboard: React.FC<LeaderboardProps> = ({ title, data }) => {
  const renderItem = ({ item, index }: { item: LeaderboardEntry; index: number }) => (
    <View style={[styles.row, index === 0 ? styles.topRank : {}]}>
      <Text style={styles.rank}>{index + 1}</Text>
      <Text style={styles.name}>{item.name}</Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
      <FlatList
        data={data.sort((a, b) => b.score - a.score)} // Sort by score in descending order
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        ListEmptyComponent={<Text style={styles.empty}>No entries yet!</Text>}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 16,
    color: '#333',
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    marginVertical: 4,
    backgroundColor: '#fff',
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  topRank: {
    backgroundColor: '#ffd700', // Gold for top rank
  },
  rank: {
    fontSize: 18,
    fontWeight: 'bold',
    width: 40,
    textAlign: 'center',
  },
  name: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginLeft: 8,
  },
  score: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#12a35f',
  },
  empty: {
    textAlign: 'center',
    fontSize: 16,
    color: '#aaa',
    marginTop: 20,
  },
});

export default Leaderboard;


================================================================================
File: package.json
================================================================================

{
  "name": "canovareactnativeapp",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.37.0",
    "@expo/vector-icons": "^14.0.4",
    "@react-native-async-storage/async-storage": "^1.23.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "commander": "^13.1.0",
    "expo": "~52.0.37",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.7",
    "expo-dev-client": "~5.0.12",
    "expo-device": "^7.0.2",
    "expo-file-system": "^18.0.12",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.0",
    "expo-linear-gradient": "~14.0.2",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.17",
    "expo-sharing": "^13.0.1",
    "expo-splash-screen": "^0.29.22",
    "expo-sqlite": "~15.1.2",
    "expo-status-bar": "~2.0.0",
    "expo-symbols": "~0.2.2",
    "expo-system-ui": "~4.0.8",
    "expo-web-browser": "~14.0.2",
    "install": "^0.13.0",
    "lucide-react": "^0.475.0",
    "papaparse": "^5.5.2",
    "parse": "^3.5.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-native": "^0.76.5",
    "react-native-base64": "^0.2.1",
    "react-native-ble-plx": "^3.5.0",
    "react-native-calendars": "^1.1310.0",
    "react-native-chart-kit": "^6.12.0",
    "react-native-dotenv": "^3.4.11",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.7",
    "react-native-safe-area-context": "^4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "^15.11.2",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5"
  },
  "devDependencies": {
    "@babel/core": "^7.26.9",
    "@babel/parser": "^7.26.10",
    "@babel/traverse": "^7.26.10",
    "@react-native-community/cli": "^15.1.3",
    "@types/jest": "^29.5.14",
    "@types/react": "~18.3.12",
    "@types/react-native-base64": "^0.2.2",
    "@types/react-test-renderer": "^18.3.1",
    "jest": "^29.7.0",
    "jest-expo": "~52.0.5",
    "react-test-renderer": "^18.3.1",
    "typescript": "^5.7.3"
  },
  "private": true
}


================================================================================
File: src/constants.ts
================================================================================

export const BONG_HITS_DATABASE_NAME: string = "BongHits";
export const STRAINS_DATABASE_NAME: string = "Strains";

export const dayLookUpTable = new Map<number, string>()
dayLookUpTable.set(0, "Sun");
dayLookUpTable.set(1, "Mon");
dayLookUpTable.set(2, "Tue");
dayLookUpTable.set(3, "Wed");
dayLookUpTable.set(4, "Thu");
dayLookUpTable.set(5, "Fri");
dayLookUpTable.set(6, "Sat");

// Function to generate strain insert statements
export function getStrainInsertStatements(): string {
  return '';  // Empty implementation for now
}

export const COLORS = {
  background: '#000000',
  cardBackground: '#1A1A1A',
  primary: '#00E676',       // Neon green 
  primaryLight: '#69F0AE',  // Light neon green
  primaryDark: '#00C853',   // Darker green
  text: {
    primary: '#FFFFFF',
    secondary: '#FFFFFFCC',  // 80% white
    tertiary: '#FFFFFF99',   // 60% white
  },
  chart: {
    primary: '#00E676',
    secondary: '#69F0AE',
    background: '#1A1A1A',
  },
  gradientColors: {
    start: 'rgba(0,230,118,0.4)',
    middle: 'rgba(105,240,174,0.2)',
    end: 'rgba(0,0,0,0)',
  }
};


export const SAMPLE_STRAINS = [
  {
    name: "Trainwreck",
    overview: "Sativa-dominant hybrid known for its explosive cerebral high and rapid onset.",
    genetic_type: "Sativa-dominant Hybrid",
    lineage: "Mexican, Thai, Afghani",
    thc_range: "18-22%",
    cbd_level: "Minimal",
    dominant_terpenes: "Myrcene, Pinene",
    qualitative_insights: "Spicy, citrus aroma with a hint of pine; dense, energetic buds",
    effects: "Energized, Creative, Uplifted",
    negatives: "dry mouth, dry eyes, dizziness",
    uses: "Ideal for creative pursuits, social settings, combating fatigue",
    thc_rating: 7.5,
    user_rating: 7.0,
    combined_rating: 7.25
  },

];



// Achievement icon mapping
export const ACHIEVEMENT_ICONS = {
  "Daily & Weekly Streaks": "calendar-check",
  "Moderation & Goal-Oriented": "target",
  "Strain Exploration": "cannabis",
  "Medical-Focused": "medical-bag",
  "Recreational-Focused": "party-popper",
  "AI Interaction": "robot",
  "Mood & Journaling": "notebook",
  "Referral & Community": "account-group",
  "Morning/Evening Check-Ins": "clock-time-eight",
  "Long-Term Milestones": "trophy",
  "Themed Celebrations": "balloon"
};

// Achievement action types - for checking which achievements to evaluate
export const ACHIEVEMENT_ACTION_TYPES = {
  LOG_CONSUMPTION: "log_consumption",
  LOG_MOOD: "log_mood",
  LOG_STRAIN: "log_strain",
  CONNECT_DEVICE: "connect_device",
  USE_AI: "use_ai",
  COMPLETE_PROFILE: "complete_profile",
  REFER_FRIEND: "refer_friend",
  SET_GOAL: "set_goal",
  MEET_GOAL: "meet_goal",
  REDUCE_USAGE: "reduce_usage",
  TRACK_SYMPTOMS: "track_symptoms",
  TRACK_MORNING: "track_morning",
  TRACK_EVENING: "track_evening",
  CHECK_DATE: "check_date" // For themed celebrations
  // Add more action types as needed
};

// Achievement data - all 73 achievements from the CSV
export const ACHIEVEMENTS = [
  {
    id: 1,
    category: "Daily & Weekly Streaks",
    name: "First Step",
    unlockCondition: "Log consumption or a mood entry for the first time",
    notes: "Encourages that very first act of mindfulness.",
    icon: "foot-print",
    complexity: 1
  },

];

// Progress calculation functions for different achievement types
export const ACHIEVEMENT_TRIGGERS = {
  // Daily & Weekly Streaks
  1: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION, ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  2: [ACHIEVEMENT_ACTION_TYPES.CONNECT_DEVICE],
  3: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  4: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  5: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  6: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  7: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  8: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  9: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  10: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  11: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  12: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  
  // Moderation & Goal-Oriented
  13: [ACHIEVEMENT_ACTION_TYPES.SET_GOAL, ACHIEVEMENT_ACTION_TYPES.MEET_GOAL],
  14: [ACHIEVEMENT_ACTION_TYPES.REDUCE_USAGE],
  15: [ACHIEVEMENT_ACTION_TYPES.REDUCE_USAGE],
  16: [ACHIEVEMENT_ACTION_TYPES.MEET_GOAL],
  17: [ACHIEVEMENT_ACTION_TYPES.MEET_GOAL],
  18: [ACHIEVEMENT_ACTION_TYPES.REDUCE_USAGE],
  19: [ACHIEVEMENT_ACTION_TYPES.SET_GOAL, ACHIEVEMENT_ACTION_TYPES.MEET_GOAL],
  
  // Strain Exploration
  20: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  21: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  22: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  23: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  24: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  25: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  26: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  27: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  28: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  29: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  30: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  
  // Medical-Focused
  31: [ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS, ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  32: [ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS, ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  33: [ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS, ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  34: [ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS],
  35: [ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  36: [ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS],
  37: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION, ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS],
  38: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION, ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS],
  
  // Recreational-Focused
  39: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION, ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  40: [ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  41: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN],
  42: [ACHIEVEMENT_ACTION_TYPES.LOG_MOOD, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  43: [ACHIEVEMENT_ACTION_TYPES.LOG_MOOD, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  44: [ACHIEVEMENT_ACTION_TYPES.LOG_MOOD, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  45: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION, ACHIEVEMENT_ACTION_TYPES.MEET_GOAL],
  
  // AI Interaction
  46: [ACHIEVEMENT_ACTION_TYPES.USE_AI],
  47: [ACHIEVEMENT_ACTION_TYPES.USE_AI],
  48: [ACHIEVEMENT_ACTION_TYPES.USE_AI, ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  49: [ACHIEVEMENT_ACTION_TYPES.USE_AI],
  
  // Mood & Journaling
  50: [ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  51: [ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  52: [ACHIEVEMENT_ACTION_TYPES.LOG_STRAIN, ACHIEVEMENT_ACTION_TYPES.LOG_MOOD],
  53: [ACHIEVEMENT_ACTION_TYPES.LOG_MOOD, ACHIEVEMENT_ACTION_TYPES.TRACK_SYMPTOMS, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  
  // Referral & Community
  54: [ACHIEVEMENT_ACTION_TYPES.REFER_FRIEND],
  55: [ACHIEVEMENT_ACTION_TYPES.REFER_FRIEND],
  56: [ACHIEVEMENT_ACTION_TYPES.REFER_FRIEND],
  57: [ACHIEVEMENT_ACTION_TYPES.REFER_FRIEND],
  58: [ACHIEVEMENT_ACTION_TYPES.REFER_FRIEND],
  
  // Morning/Evening Check-Ins
  59: [ACHIEVEMENT_ACTION_TYPES.TRACK_MORNING],
  60: [ACHIEVEMENT_ACTION_TYPES.TRACK_EVENING],
  61: [ACHIEVEMENT_ACTION_TYPES.TRACK_MORNING, ACHIEVEMENT_ACTION_TYPES.TRACK_EVENING, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  
  // Long-Term Milestones
  62: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  63: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  64: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  65: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  66: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  67: [ACHIEVEMENT_ACTION_TYPES.REDUCE_USAGE, ACHIEVEMENT_ACTION_TYPES.MEET_GOAL],
  68: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  69: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  70: [ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  
  // Themed Celebrations
  71: [ACHIEVEMENT_ACTION_TYPES.CHECK_DATE, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  72: [ACHIEVEMENT_ACTION_TYPES.CHECK_DATE, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION],
  73: [ACHIEVEMENT_ACTION_TYPES.CHECK_DATE, ACHIEVEMENT_ACTION_TYPES.LOG_CONSUMPTION]
};

================================================================================
File: src/contexts/BluetoothContext.ts
================================================================================

import { createContext } from "react";
import { Alert, PermissionsAndroid, Platform } from "react-native";
import * as ExpoDevice from "expo-device";
import { BleError, BleManager, Characteristic, Device } from 'react-native-ble-plx';
import base64 from "react-native-base64";
import { databaseManager } from "../DatabaseManager";
import { parseRawTimestamp } from "../utils/functions";

type ConnectedDevice = {
    device: Device;
    serviceUUID: string;
    characteristicUUID: string
}

export class BluetoothHandler {
    private manager: BleManager;
    private connectedDevice: ConnectedDevice | null;

    constructor() {
        this.manager = new BleManager();
        this.connectedDevice = null;
    }

    public async connectToDevice(deviceId: string) {
        if (this.connectedDevice !== null) {
            // If we already have a connected device, we should:
            // 1. Check if it's the same device - if so, just return
            // 2. If it's a different device, disconnect from the current one first
            if (this.connectedDevice.device.id === deviceId) {
                console.log("Already connected to this device");
                return;
            }
            
            console.log("Disconnecting from current device before connecting to new one");
            this.disconnectFromDevice(this.connectedDevice.device);
            this.connectedDevice = null;
        }
        
        try {
            const deviceConnection: Device = await this.manager.connectToDevice(deviceId);
            await deviceConnection.discoverAllServicesAndCharacteristics();
            const services = await deviceConnection.services();
            if (services.length !== 1) {
                throw Error("Bad number of services");
            }

            const service = services[0];
            const characteristics = await service.characteristics();
            if (characteristics.length !== 1) {
                throw Error("Bad number of characteristics");
            }
            const characteristic = characteristics[0];
            this.connectedDevice = {
                device: deviceConnection,
                serviceUUID: service.uuid,
                characteristicUUID: characteristic.uuid
            }

        } catch (error) {
            console.error('Error discovering services/characteristics:', error);
            throw error; // Re-throw to allow caller to handle the error
        } finally {
            this.manager.stopDeviceScan();
        }
    }

    public disconnectFromDevice(connectedDevice: Device) {
        if (connectedDevice) {
            this.manager.cancelDeviceConnection(connectedDevice.id);
            if (this.connectedDevice?.device.id === connectedDevice.id) {
                this.connectedDevice = null;
            }
        }
    }

    /*
     * This function starts listening for data on the connected device
     */
    public streamOnConnectedDevice() {
        if (this.connectedDevice === null) {
            throw Error("Tried to stream with no device connected");
        } 
        
        // Sync data
        this.sendCurrentTimestamp()
        this.connectedDevice.device.monitorCharacteristicForService(
            this.connectedDevice.serviceUUID,
            this.connectedDevice.characteristicUUID,
            this.handleBluetoothConnection
        );
    }



    /* 
     * This function encapsulates all logic relating to listening to on the bluetooth conneciton
     */
    private handleBluetoothConnection(error: BleError | null, characteristic: Characteristic | null) {
        if (error) {
          console.log("Stream error:", error);
          return -1;
        } else if (!characteristic?.value) {
          console.log("No data was received");
          return -1;
        }

        const rawData: string[] = base64.decode(characteristic.value).split(';');
        const rawTimestamp: string = rawData[0]; //Tuesday, March 25 2025 21:40:12
        const duration: number = parseFloat(rawData[1])*100000; // 0.17
        const timestamp: string  = parseRawTimestamp(rawTimestamp);
        databaseManager.recordBongHit(timestamp, duration);
        Alert.alert(`Timestamp: ${rawTimestamp}\n Duration: ${duration}ms`);
    }

    /*
     * This function generates the current timestamp which will be used to sync the Trak+ to an accurate timestamp on connection.
     */
    private async sendCurrentTimestamp() {
        if (!this.connectedDevice) {
            throw new Error("Tried to send timestamp to device, but connection not found");
        }
        try {
            const timestamp = Math.floor(Date.now() / 1000); // Seconds, not milliseconds
            const gmtOffset = new Date().getTimezoneOffset() * 60;  // Offset in seconds (e.g., GMT-5 -> -18000)
            const base64Timestamp = base64.encode( `${timestamp},${gmtOffset}`)

            // Write data to the characteristic
            await this.manager.writeCharacteristicWithResponseForDevice(
              this.connectedDevice.device.id,
              this.connectedDevice.serviceUUID,
              this.connectedDevice.characteristicUUID,
              base64Timestamp
            );
      
            console.log(`Sent: Timestamp ${timestamp}, GMT Offset ${gmtOffset}`);
            return true;
          } catch (error) {
            console.error('Error sending data:', error);
            return false;
          }
    }


    public getBLEManager(): BleManager {
        return this.manager;
    }

    public getConnectedDevice(): Device | undefined {
        return this.connectedDevice?.device;
    }

    /*
     * Requests bluetooth permissions, accounting for platform differences
     */
    private async requestPermissions() {
        if (Platform.OS === "android") {
            if ((ExpoDevice.platformApiLevel ?? -1) < 31) {
                // Android version below 31
                const granted = await PermissionsAndroid.request(
                    PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
                    {
                        title: "Location Permission",
                        message: "Bluetooth Low Energy requires Location",
                        buttonPositive: "OK",
                    }
                );
                return granted === PermissionsAndroid.RESULTS.GRANTED;
            } else {
                // Android version above 31
                const isAndroid31PermissionsGranted = await this.requestAndroid31Permissions();

                return isAndroid31PermissionsGranted;
            }
        } else {
            //ios
            return true;
        }
    }

    private async requestAndroid31Permissions() {
        const bluetoothScanPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_SCAN,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );
        const bluetoothConnectPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.BLUETOOTH_CONNECT,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );
        const fineLocationPermission = await PermissionsAndroid.request(
            PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
            {
                title: "Location Permission",
                message: "Bluetooth Low Energy requires Location",
                buttonPositive: "OK",
            }
        );

        return (
            bluetoothScanPermission === "granted" &&
            bluetoothConnectPermission === "granted" &&
            fineLocationPermission === "granted"
        );
    }
}

export const BluetoothContext = createContext<BluetoothHandler | undefined>(undefined);


================================================================================
File: src/DatabaseManager.ts
================================================================================

// File: src/DatabaseManager.ts
// Consolidated DatabaseManager that incorporates functionality from:
// - Previous DatabaseManager
// - AsyncStorageManager
// - DataService
// - StrainService
// - ExpoSQLiteManager
// - SafetyService
// - AchievementService

import AsyncStorage from "@react-native-async-storage/async-storage";
import { openDatabaseAsync, SQLiteDatabase } from "expo-sqlite";
import {
  BONG_HITS_DATABASE_NAME,
  STRAINS_DATABASE_NAME,
  SAMPLE_STRAINS,
  ACHIEVEMENTS,
  ACHIEVEMENT_ICONS,
  ACHIEVEMENT_TRIGGERS,
  getStrainInsertStatements
} from "./constants";
import { 
  BongHit,
  BongHitStats, 
  Datapoint, 
  AverageHourCount, 
  SavedDevice, 
  Strain,
  DatabaseResponse, 
  ChartDataPoint,
  UsageStats,
  TimeDistribution,
  DatabaseRow,
  StrainSearchFilters,
  PaginationParams,
  StrainSearchResult
} from "./types";
import { 
  Achievement, 
  UserAchievement, 
  UserAchievementWithDetails 
} from "./types";
import { Device } from 'react-native-ble-plx';
import { validateBongHit, validateStrain, createValidationError, createValidationSuccess, ValidationResult } from './utils/validators';
import { getWeeklyStatsQuery, getMonthlyStatsQuery, getTimeDistributionQuery, getUsageStatsQuery } from './utils/SqlTemplates';

// Re-export types for use throughout the app
export { StrainSearchFilters, PaginationParams, StrainSearchResult };

// Import types for SafetyService methods
import {
  RecommendationRequest,
  RecommendationResponse,
  SafetyValidationResult,
  DrugInteractionResult,
  OveruseDetectionResult,
  SafetyRecord,
  JournalEntry,
  UserProfile
} from "./types";

// Near the top of the file with other interfaces
interface RawUsageStats {
  total_hits: number;
  active_days: number;
  avg_hits_per_active_day: number;
  avg_hits_per_day: number;
  avg_duration_ms: number;
  total_duration_ms: number;
  max_hits_in_day: number;
  max_avg_duration: number;
  max_duration_in_day: number;
  most_active_day: string;
  least_active_day: string;
}

const FIRST_LAUNCH_KEY = "hasLaunched";
const SAVED_DEVICES_KEY: string = 'savedDevices';
const DB_VERSION_KEY = "dbVersion";
const CURRENT_DB_VERSION = 1; // Increment this when schema changes
const SAFETY_DB_NAME = "SafetyRecords"; // Define safety DB name here since it's not in constants
const ACHIEVEMENTS_DB_NAME = "achievements.db"; // Achievements database name
const USER_ACHIEVEMENTS_TABLE = "user_achievements"; // User achievements table name

// Map of days to their abbreviations
const dayLookUpTable = new Map<number, string>([
  [0, "Sun"],
  [1, "Mon"],
  [2, "Tue"],
  [3, "Wed"],
  [4, "Thu"],
  [5, "Fri"],
  [6, "Sat"],
]);

/**
 * DatabaseManager: Centralized manager for all database operations
 * Consolidates functionality from:
 * - Previous DatabaseManager
 * - AsyncStorageManager
 * - DataService
 * - StrainService
 * - ExpoSQLiteManager
 */
export class DatabaseManager {
  private static instance: DatabaseManager;
  private databaseConnections: Map<string, SQLiteDatabase> = new Map();
  private initialized: boolean = false;
  private initializationPromise: Promise<void> | null = null;
  private migrationLock: boolean = false;
  private transactionInProgress: Map<string, boolean> = new Map(); // Database-specific transaction locks
  private lastAccessTimes: Map<string, number> = new Map(); // Track last access time
  private connectionMonitoringInterval: NodeJS.Timeout | null = null; // Interval for monitoring connections
  private connectionTimeout = 5 * 60 * 1000; // 5 minutes timeout for idle connections

  // Private constructor to prevent direct instantiation
  private constructor() {}

  /**
   * Get the singleton instance of DatabaseManager
   */
  public static getInstance(): DatabaseManager {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new DatabaseManager();
    }
    return DatabaseManager.instance;
  }

  /**
   * Checks if the application is launching for the first time.
   */
  public async isFirstLaunch(): Promise<boolean> {
    try {
      return (await AsyncStorage.getItem(FIRST_LAUNCH_KEY)) === null;
    } catch (error) {
      console.error('[DatabaseManager] Error checking first launch:', error);
      return false;
    }
  }

  /**
   * Called on first launch to run any initial setup (e.g. DB creation).
   */
  public async initializeAppOnFirstLaunch(): Promise<void> {
    try {
      await this.initialize();
      await AsyncStorage.setItem(FIRST_LAUNCH_KEY, "true");
      await AsyncStorage.setItem(SAVED_DEVICES_KEY, JSON.stringify([]));
    } catch (error) {
      console.error('[DatabaseManager] Error initializing app:', error);
      throw error;
    }
  }

  /**
   * Initializes all databases and tables with initial data.
   */
  public async initialize(options: { forceCleanup?: boolean } = {}): Promise<void> {
    // If forced cleanup is requested, close existing connections first
    if (options.forceCleanup) {
      await this.cleanup();
    }

    // If already initialized, return immediately
    if (this.initialized) {
      return;
    }
    
    // If initialization is in progress, wait for it to complete
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    
    console.info('[DatabaseManager] Initializing databases...');
    
    // Create a promise for initialization
    this.initializationPromise = this.doInitialize();
    
    return this.initializationPromise;
  }

  /**
   * Internal method to perform actual initialization logic
   */
  private async doInitialize(): Promise<void> {
    try {
      console.log('[DatabaseManager] Starting database initialization...');
      
      // Get current DB version
      const storedVersion = await AsyncStorage.getItem(DB_VERSION_KEY);
      const currentVersion = storedVersion ? parseInt(storedVersion) : 0;
      
      // Check if we need to update/initialize
      if (currentVersion < CURRENT_DB_VERSION) {
        await this.runMigrations(currentVersion);
        
        // Update the stored version
        await AsyncStorage.setItem(DB_VERSION_KEY, CURRENT_DB_VERSION.toString());
        console.log(`[DatabaseManager] Database upgraded to version ${CURRENT_DB_VERSION}`);
      } else {
        console.log('[DatabaseManager] Database already at current version');
      }

      // Existing database initialization logic here
      
      this.initialized = true;
      console.log('[DatabaseManager] All databases initialized successfully');
    } catch (error) {
      console.error('[DatabaseManager] Error initializing database:', error);
      throw error;
    } finally {
      // Clean up the promise so subsequent calls will start fresh if needed
      this.initializationPromise = null;
    }
  }

  /**
   * Run migrations from the current version to the latest version
   */
  private async runMigrations(currentVersion: number): Promise<void> {
    if (this.migrationLock) {
      console.log('[DatabaseManager] Migration already in progress, waiting...');
      return;
    }
    
    this.migrationLock = true;
    try {
      console.log('[DatabaseManager] Starting migrations from version', currentVersion);
      
      // Get the database for migrations
      const db = await this.getDatabase('migrations.db');
      
      // Set up the migrations table if it doesn't exist
      await db.execAsync(
        `CREATE TABLE IF NOT EXISTS migrations (
          version INTEGER PRIMARY KEY,
          applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`
      );
      
      // Get the list of applied migrations
      const appliedMigrations = await db.getAllAsync<{version: number}>(
        'SELECT version FROM migrations ORDER BY version ASC'
      );
      
      const appliedVersions = appliedMigrations.map(m => m.version);
      
      // Apply migrations in sequence
      for (let v = currentVersion + 1; v <= CURRENT_DB_VERSION; v++) {
        if (appliedVersions.includes(v)) {
          console.log(`[DatabaseManager] Migration version ${v} already applied, skipping`);
          continue;
        }
        
        console.log(`[DatabaseManager] Applying migration version ${v}`);
        
        // Start a transaction for the migration
        await this.executeTransaction(db, 'migrations.db', async () => {
          // Apply the migration
          await this.applyMigration(v);
          
          // Record the migration
          await db.runAsync(
            'INSERT INTO migrations (version) VALUES (?)',
            [v]
          );
        });
        
        console.log(`[DatabaseManager] Migration version ${v} applied successfully`);
      }
      
      console.log('[DatabaseManager] All migrations applied successfully');
    } catch (error) {
      console.error('[DatabaseManager] Migration failed:', error);
      throw error;
    } finally {
      this.migrationLock = false;
    }
  }

  /**
   * Validate database schemas to ensure they match expected structures
   */
  private async validateSchema(): Promise<boolean> {
    try {
      console.log('[DatabaseManager] Validating database schema...');
      
      // Validate BongHits table
      const bongHitsDb = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      const bongHitsValid = await this.validateTableSchema(bongHitsDb, BONG_HITS_DATABASE_NAME, [
        'timestamp', 'duration_ms'
      ]);
      
      if (!bongHitsValid) {
        console.error('[DatabaseManager] BongHits table schema validation failed');
        return false;
      }
      
      // Validate Strains table
      const strainsDb = await this.getDatabase(STRAINS_DATABASE_NAME);
      const strainsValid = await this.validateTableSchema(strainsDb, STRAINS_DATABASE_NAME, [
        'id', 'name', 'genetic_type', 'effects', 'thc_rating', 'combined_rating'
      ]);
      
      if (!strainsValid) {
        console.error('[DatabaseManager] Strains table schema validation failed');
        return false;
      }
      
      console.log('[DatabaseManager] Database schema validation successful');
      return true;
    } catch (error) {
      console.error('[DatabaseManager] Schema validation error:', error);
      return false;
    }
  }

  /**
   * Apply a specific migration version
   */
  private async applyMigration(version: number): Promise<void> {
    switch (version) {
      case 1:
        // Initial schema creation
        await this.migrationV1();
        break;
      // Add future migrations here:
      // case 2:
      //   await this.migrationV2();
      //   break;
      default:
        console.warn(`[DatabaseManager] No migration found for version ${version}`);
    }
  }

  /**
   * Migration v1: Initialize all databases and tables
   */
  private async migrationV1(): Promise<void> {
    await this.initializeBongHitsDb();
    await this.initializeStrainsDb();
    await this.initializeSafetyDb();
    await this.initializeAchievementsDb();
  }

  /**
   * Initialize the BongHits database
   */
  private async initializeBongHitsDb(): Promise<void> {
    try {
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      await db.execAsync(
        'PRAGMA journal_mode = WAL;' +
        `CREATE TABLE IF NOT EXISTS ${BONG_HITS_DATABASE_NAME} (
          timestamp TIMESTAMP PRIMARY KEY NOT NULL,
          duration_ms INTEGER NOT NULL
        );` +
        `CREATE INDEX IF NOT EXISTS idx_timestamp 
        ON ${BONG_HITS_DATABASE_NAME}(timestamp);`
      );
      console.log('[DatabaseManager] BongHits database initialized');
    } catch (error) {
      console.error('[DatabaseManager] Error initializing BongHits database:', error);
      throw error;
    }
  }

  /**
   * Initialize the Strains database
   */
  private async initializeStrainsDb(): Promise<void> {
    try {
      const db = await this.getDatabase(STRAINS_DATABASE_NAME);
      await db.execAsync(
        'PRAGMA journal_mode = WAL;' +
        `CREATE TABLE IF NOT EXISTS ${STRAINS_DATABASE_NAME} (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL UNIQUE,
          overview TEXT,
          genetic_type TEXT,
          lineage TEXT,
          thc_range TEXT,
          cbd_level TEXT,
          dominant_terpenes TEXT,
          qualitative_insights TEXT,
          effects TEXT,
          negatives TEXT,
          uses TEXT,
          thc_rating REAL,
          user_rating REAL,
          combined_rating REAL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );` +
        `CREATE INDEX IF NOT EXISTS idx_strain_name 
        ON ${STRAINS_DATABASE_NAME}(name);` +
        `CREATE INDEX IF NOT EXISTS idx_strain_genetic_type 
        ON ${STRAINS_DATABASE_NAME}(genetic_type);` +
        `CREATE INDEX IF NOT EXISTS idx_strain_effects 
        ON ${STRAINS_DATABASE_NAME}(effects);` +
        `CREATE INDEX IF NOT EXISTS idx_strain_rating 
        ON ${STRAINS_DATABASE_NAME}(combined_rating DESC);` +
        `CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_strain_name 
        ON ${STRAINS_DATABASE_NAME}(name);`
      );

      // Simple count check to avoid duplicate data
      const [result] = await db.getAllAsync<{count: number}>(`SELECT COUNT(*) as count FROM ${STRAINS_DATABASE_NAME}`);
      
      if (result && result.count === 0) {
        await this.insertStrainData(db);
        console.log('[DatabaseManager] Sample strain data inserted');
      } else {
        console.log(`[DatabaseManager] Strains database already contains ${result ? result.count : 0} records`);
      }
      
      console.log('[DatabaseManager] Strains database initialized');
    } catch (error) {
      throw this.handleDatabaseError(error, 'initializeStrainsDb');
    }
  }

  /**
   * Initialize the Safety database
   */
  private async initializeSafetyDb(): Promise<void> {
    try {
      const db = await this.getDatabase(SAFETY_DB_NAME);
      await db.execAsync(
        'PRAGMA journal_mode = WAL;' +
        `CREATE TABLE IF NOT EXISTS ${SAFETY_DB_NAME} (
          id TEXT PRIMARY KEY NOT NULL,
          user_id TEXT NOT NULL,
          concern_type TEXT NOT NULL,
          concern_details TEXT NOT NULL,
          resolution_suggestions TEXT,
          cooling_off_until INTEGER,
          created_at INTEGER NOT NULL
        );` +
        `CREATE INDEX IF NOT EXISTS idx_user_id 
        ON ${SAFETY_DB_NAME}(user_id);` +
        `CREATE INDEX IF NOT EXISTS idx_created_at 
        ON ${SAFETY_DB_NAME}(created_at);` +
        `CREATE INDEX IF NOT EXISTS idx_concern_type 
        ON ${SAFETY_DB_NAME}(concern_type);` +
        `CREATE INDEX IF NOT EXISTS idx_cooling_off_until 
        ON ${SAFETY_DB_NAME}(cooling_off_until);`
      );
      
      console.log('[DatabaseManager] Safety database initialized');
    } catch (error) {
      throw this.handleDatabaseError(error, 'initializeSafetyDb');
    }
  }

  /**
   * Initialize the Achievements database
   */
  private async initializeAchievementsDb(): Promise<void> {
    try {
      const db = await this.getDatabase(ACHIEVEMENTS_DB_NAME);
      
      await db.execAsync(`
        PRAGMA journal_mode = WAL;
        
        CREATE TABLE IF NOT EXISTS achievements (
          id INTEGER PRIMARY KEY,
          category TEXT NOT NULL,
          name TEXT NOT NULL,
          unlock_condition TEXT NOT NULL,
          notes TEXT,
          icon TEXT,
          complexity INTEGER DEFAULT 1
        );

        CREATE TABLE IF NOT EXISTS user_achievements (
          user_id TEXT NOT NULL,
          achievement_id INTEGER NOT NULL,
          progress REAL DEFAULT 0,
          date_unlocked TEXT,
          is_unlocked INTEGER DEFAULT 0,
          is_new INTEGER DEFAULT 0,
          progress_data TEXT,
          PRIMARY KEY (user_id, achievement_id),
          FOREIGN KEY (achievement_id) REFERENCES achievements(id)
        );
      `);
      
      // Check if achievements are already imported
      const result = await db.getFirstAsync<{count: number}>('SELECT COUNT(*) as count FROM achievements');
      const count = result?.count ?? 0;
      
      if (count === 0) {
        console.log('[DatabaseManager] Importing initial achievements...');
        const achievements = this.getInitialAchievements();
        
        // Use transactions for better performance and reliability
        await this.executeTransaction(db, ACHIEVEMENTS_DB_NAME, async () => {
          // Batch insert achievements
          for (const achievement of achievements) {
            // Validate that the achievement has all required fields
            if (!achievement.category || !achievement.name || !achievement.unlockCondition) {
              console.error(`[DatabaseManager] Skipping achievement with missing required fields:`, achievement);
              continue;
            }
            
            // Insert with parameterized query for safety
            await db.runAsync(
              `INSERT INTO achievements 
                (id, category, name, unlock_condition, notes, icon, complexity)
              VALUES (?, ?, ?, ?, ?, ?, ?)`,
              [
                achievement.id,
                achievement.category,
                achievement.name,
                achievement.unlockCondition,
                achievement.notes || "",
                achievement.icon || this.getCategoryIcon(achievement.category),
                achievement.complexity || 1
              ]
            );
          }
        });
        
        console.log(`[DatabaseManager] Imported ${achievements.length} achievements`);
      } else {
        console.log(`[DatabaseManager] ${count} achievements already exist`);
      }
      
      console.log('[DatabaseManager] Achievements database initialized');
    } catch (error) {
      console.error('[DatabaseManager] Error initializing Achievements database:', error);
      throw error;
    }
  }

  /**
   * Inserts sample strain data into the database
   */
  private async insertStrainData(db: SQLiteDatabase): Promise<void> {
    try {
      console.log('[DatabaseManager] Inserting initial strain data...');
      
      // Use a transaction for better performance and atomicity
      await this.executeTransaction(db, STRAINS_DATABASE_NAME, async () => {
        // Get the SQL statements for strain insertion
        const insertStatements = getStrainInsertStatements();
        
        // Execute all insert statements
        await db.execAsync(insertStatements);
      });
      
      console.log('[DatabaseManager] Strain data inserted successfully');
    } catch (error) {
      console.error('[DatabaseManager] Failed to insert strain data:', error);
      throw error;
    }
  }

  /**
   * Execute a transaction for a specific database
   */
  public async executeTransaction<T>(
    db: SQLiteDatabase,
    dbName: string,
    operations: () => Promise<T>
  ): Promise<T> {
    try {
      // Check if there's already a transaction in progress for this database
      if (this.transactionInProgress.get(dbName)) {
        console.log(`[DatabaseManager] Transaction already in progress for ${dbName}, waiting...`);
        // Wait for the current transaction to complete
        await this._waitForTransactionToComplete(dbName);
      }
      
      this.transactionInProgress.set(dbName, true);
      await db.execAsync('BEGIN TRANSACTION');
      
      const result = await operations();
      
      await db.execAsync('COMMIT');
      return result;
    } catch (error) {
      try {
        await db.execAsync('ROLLBACK');
      } catch (rollbackError) {
        console.error('[DatabaseManager] Error rolling back transaction:', rollbackError);
      }
      throw error;
    } finally {
      this.transactionInProgress.set(dbName, false);
    }
  }

  /**
   * Wait for a transaction to complete on a specific database
   */
  private async _waitForTransactionToComplete(dbName: string): Promise<void> {
    return new Promise(resolve => {
      const checkInterval = setInterval(() => {
        if (!this.transactionInProgress.get(dbName)) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 50);
    });
  }

  /**
   * Execute a read transaction (no locks needed)
   */
  public async executeReadTransaction<T>(
    db: SQLiteDatabase,
    dbName: string, 
    operations: () => Promise<T>
  ): Promise<T> {
    // Read transactions don't need locks in SQLite
    return operations();
  }

  /**
   * Execute a write transaction (requires locks)
   */
  public async executeWriteTransaction<T>(
    db: SQLiteDatabase,
    dbName: string,
    operations: () => Promise<T>
  ): Promise<T> {
    // Use locking for write transactions
    return this.executeTransaction(db, dbName, operations);
  }

  /**
   * Execute a transaction by database name (backward compatibility)
   */
  public async executeTransactionByName<T>(
    dbName: string, 
    operations: (db: SQLiteDatabase) => Promise<T>
  ): Promise<T> {
    const db = await this.getDatabase(dbName);
    return this.executeTransaction(db, dbName, () => operations(db));
  }

  /**
   * Get a database connection by name, creating it if it doesn't exist
   */
  public async getDatabase(dbName: string): Promise<SQLiteDatabase> {
    // Record access time
    this.lastAccessTimes.set(dbName, Date.now());
    
    // First check if we already have an open connection
    if (this.databaseConnections.has(dbName)) {
      const db = this.databaseConnections.get(dbName);
      if (db) {
        // Start monitoring if not already monitoring
        this._startConnectionMonitoring();
        return db;
      }
    }
    
    try {
      // Open the database and store the connection
      const db = await openDatabaseAsync(dbName);
      this.databaseConnections.set(dbName, db);
      
      // Start monitoring if not already monitoring
      this._startConnectionMonitoring();
      
      return db;
    } catch (error) {
      console.error(`[DatabaseManager] Error opening database ${dbName}:`, error);
      throw error;
    }
  }

  /**
   * Ensure the database manager is initialized
   */
  public async ensureInitialized(): Promise<void> {
    if (this.initialized) {
      return;
    }
    
    if (this.initializationPromise) {
      // If initialization is already in progress, wait for it to complete
      return this.initializationPromise;
    }
    
    // Otherwise, start initialization
    console.info('[DatabaseManager] Database not initialized, starting initialization now');
    return this.initialize();
  }

  /**
   * Close all database connections
   */
  public async cleanup(): Promise<void> {
    try {
      console.log('[DatabaseManager] Closing all database connections...');
      
      // Stop connection monitoring
      this._stopConnectionMonitoring();
      
      for (const [name, db] of this.databaseConnections.entries()) {
        try {
          await db.closeAsync();
          console.log(`[DatabaseManager] Closed database: ${name}`);
        } catch (closeError) {
          console.error(`[DatabaseManager] Error closing database ${name}:`, closeError);
        }
      }
      
      this.databaseConnections.clear();
      this.lastAccessTimes.clear();
      this.initialized = false;
      console.log('[DatabaseManager] All database connections closed');
    } catch (error) {
      console.error('[DatabaseManager] Error during cleanup:', error);
      throw error;
    }
  }

  /**
   * Start monitoring for idle connections
   */
  private _startConnectionMonitoring(): void {
    if (this.connectionMonitoringInterval) return;
    
    this.connectionMonitoringInterval = setInterval(() => {
      const now = Date.now();
      for (const [dbName, lastAccess] of this.lastAccessTimes.entries()) {
        if (now - lastAccess > this.connectionTimeout) {
          // Close idle connection
          this._closeIdleConnection(dbName);
        }
      }
    }, 60000); // Check every minute
    
    console.log('[DatabaseManager] Started connection monitoring');
  }

  /**
   * Stop connection monitoring
   */
  private _stopConnectionMonitoring(): void {
    if (this.connectionMonitoringInterval) {
      clearInterval(this.connectionMonitoringInterval);
      this.connectionMonitoringInterval = null;
      console.log('[DatabaseManager] Stopped connection monitoring');
    }
  }

  /**
   * Close an idle connection
   */
  private async _closeIdleConnection(dbName: string): Promise<void> {
    try {
      const db = this.databaseConnections.get(dbName);
      if (db) {
        await db.closeAsync();
        this.databaseConnections.delete(dbName);
        this.lastAccessTimes.delete(dbName);
        console.log(`[DatabaseManager] Closed idle connection: ${dbName}`);
      }
    } catch (error) {
      console.error(`[DatabaseManager] Error closing idle connection ${dbName}:`, error);
    }
  }

  /* ------------------------------------------------------------------
     Result validation helpers
   ------------------------------------------------------------------ */

  private validateBongHitStats = (stats: BongHitStats): BongHitStats => ({
    averageDuration: Math.max(0, Number(stats.averageDuration) || 0),
    longestHit: Math.max(0, Number(stats.longestHit) || 0),
  });

  // Convert ChartDataPoint to Datapoint
  private chartDataToDatapoint(point: ChartDataPoint): Datapoint {
    return {
      x: point.label,
      y: point.value
    };
  }

  private validateDatapoint = (point: {label: string, value: number}): Datapoint => ({
    x: String(point.label || ""),
    y: Math.max(0, Number(point.value) || 0),
  });

  private validateAverageHourCount = (count: AverageHourCount): AverageHourCount => ({
    hourOfDay: String(count.hourOfDay || "00"),
    count: Math.max(0, Number(count.count) || 0),
  });

  /* ------------------------------------------------------------------
     Generic error handler
   ------------------------------------------------------------------ */

  protected handleError<T>(error: unknown, operation: string): DatabaseResponse<T> {
    const errorMessage = error instanceof Error ? error.message : `Failed to ${operation}`;
    console.error(`[DatabaseManager] Error in ${operation}:`, error);
    return {
      success: false,
      error: errorMessage
    };
  }

  /* ------------------------------------------------------------------
     Achievement-related methods from AchievementService
   ------------------------------------------------------------------ */

  /**
   * Get user achievements from the database
   */
  public async getUserAchievements(userId: string): Promise<UserAchievementWithDetails[]> {
    try {
      console.log('[DatabaseManager] Getting user achievements for', userId);
      await this.ensureInitialized();
      
      // Remove redundant initialization - rely on ensureInitialized() instead
      // try {
      //   await this.initializeAchievementsDb();
      // } catch (error) {
      //   console.error('[DatabaseManager] Error ensuring achievements database is initialized:', error);
      //   return [];
      // }
      
      const db = await this.getDatabase(ACHIEVEMENTS_DB_NAME);
      
      // First ensure user has entries for all achievements
      await this.ensureUserAchievements(userId);
      
      // Get achievements with progress
      const results = await db.getAllAsync<UserAchievementWithDetails>(
        `SELECT 
          a.id, a.category, a.name, a.unlock_condition as unlockCondition, 
          a.notes, a.icon, a.complexity,
          ua.user_id as userId, a.id as achievementId, ua.progress, 
          ua.date_unlocked as dateUnlocked, 
          ua.is_unlocked as isUnlocked, ua.is_new as isNew,
          ua.progress_data as progressData
        FROM achievements a
        JOIN user_achievements ua ON a.id = ua.achievement_id
        WHERE ua.user_id = ?`,
        [userId]
      );
      
      console.log(`[DatabaseManager] Found ${results.length} achievements for user ${userId}`);
      
      // Convert SQLite's numeric booleans to actual booleans
      return results.map(achievement => ({
        ...achievement,
        isUnlocked: Boolean(achievement.isUnlocked),
        isNew: Boolean(achievement.isNew)
      }));
    } catch (error) {
      return this.handleDatabaseError(error, 'getUserAchievements', []);
    }
  }

  /**
   * Standardized error handling method
   */
  private handleDatabaseError<T>(error: unknown, operation: string, fallback?: T): T | never {
    console.error(`[DatabaseManager] Error during ${operation}:`, error);
    
    if (fallback !== undefined) {
      // Return fallback value if provided
      return fallback;
    }
    
    // Otherwise throw with a standard format
    throw new Error(`Database operation failed: ${operation}`);
  }

  /**
   * Ensure all achievements are in the user's record
   */
  private async ensureUserAchievements(userId: string): Promise<void> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(ACHIEVEMENTS_DB_NAME);
      
      // Check if the user already has achievement records
      const existingAchievements = await db.getAllAsync<{achievement_id: number}>(
        `SELECT achievement_id FROM ${USER_ACHIEVEMENTS_TABLE} WHERE user_id = ? LIMIT 1`,
        [userId]
      );
   
      if (existingAchievements.length === 0) {
        console.log(`[DatabaseManager] Creating initial achievement records for user ${userId}`);
        
        // Get all achievements
        const achievements = this.getInitialAchievements();
        
        // Create achievement records for the user
        await this.executeTransaction(db, ACHIEVEMENTS_DB_NAME, async () => {
          for (const achievement of achievements) {
            await db.runAsync(
              `INSERT INTO ${USER_ACHIEVEMENTS_TABLE} (
                user_id, achievement_id, progress, is_unlocked, is_new, progress_data
              ) VALUES (?, ?, ?, ?, ?, ?)`,
              [
                userId,
                achievement.id,
                0,
                0,
                0,
                JSON.stringify({})
              ]
            );
          }
        });
   
        console.log(`[DatabaseManager] Created ${achievements.length} achievement records for user ${userId}`);
      }
    } catch (error) {
      console.error('[DatabaseManager] Error ensuring user achievements:', error);
    }
  }
  
  /**
   * Check and update achievements based on user action
   */
  public async checkAchievements(userId: string, actionType: string, data: any): Promise<UserAchievementWithDetails[]> {
    try {
      await this.ensureInitialized();
      // Only check relevant achievements for the action type
      const relevantAchievements = await this.getAchievementsByActionType(actionType);
      const unlockedAchievements: UserAchievementWithDetails[] = [];
      
      // Process only relevant achievements for better performance
      for (const achievement of relevantAchievements) {
        const updated = await this.processAchievement(userId, achievement, actionType, data);
        if (updated && updated.isUnlocked && updated.isNew) {
          unlockedAchievements.push(updated);
        }
      }
      
      return unlockedAchievements;
      } catch (error) {
      console.error('[DatabaseManager] Failed to check achievements:', error);
        return [];
    }
  }
  
  /**
   * Update achievement progress
   */
  public async updateAchievementProgress(userId: string, achievementId: number, progress: number, data?: any): Promise<void> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(ACHIEVEMENTS_DB_NAME);
      
      // Ensure progress is between 0 and 100
      progress = Math.max(0, Math.min(100, progress));
      
      // Check if achievement is already unlocked
      const existing = await db.getFirstAsync<{is_unlocked: number}>(
        'SELECT is_unlocked FROM user_achievements WHERE user_id = ? AND achievement_id = ?',
        [userId, achievementId]
      );
      
      if (existing && existing.is_unlocked) {
        // Achievement already unlocked, don't update progress
        return;
      }
      
      // Check if this achievement should be unlocked
      const isUnlocked = progress >= 100 ? 1 : 0;
      
      // Update with parameterized queries
      await db.runAsync(
        `UPDATE user_achievements 
        SET progress = ?, 
            is_unlocked = ?, 
            is_new = ?,
            date_unlocked = ?,
            progress_data = ?
        WHERE user_id = ? AND achievement_id = ?`,
        [
          progress,
          isUnlocked,
          isUnlocked,
          isUnlocked ? new Date().toISOString() : null,
          data ? JSON.stringify(data) : null,
          userId,
          achievementId
        ]
      );
    } catch (error) {
      console.error(`[DatabaseManager] Failed to update achievement progress:`, error);
    }
  }
  
  /**
   * Clear 'new' flags on achievements
   */
  public async clearAchievementNewFlags(userId: string): Promise<void> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(ACHIEVEMENTS_DB_NAME);
      
      await db.runAsync(
        `UPDATE user_achievements SET is_new = 0 WHERE user_id = ?`,
        [userId]
      );
    } catch (error) {
      console.error('[DatabaseManager] Failed to clear achievement new flags:', error);
    }
  }
  
  /**
   * Get achievements that should be checked for a given action type
   */
  private async getAchievementsByActionType(actionType: string): Promise<Achievement[]> {
    try {
      // Get all achievement IDs that should be checked for this action type
      const relevantIds = Object.entries(ACHIEVEMENT_TRIGGERS)
        .filter(([_, triggers]) => Array.isArray(triggers) && triggers.includes(actionType))
        .map(([id]) => parseInt(id));
      
      if (relevantIds.length === 0) return [];
      
      // Get achievement details for these IDs
      return ACHIEVEMENTS.filter(achievement => relevantIds.includes(achievement.id));
    } catch (error) {
      console.error('[DatabaseManager] Failed to get achievements by action type:', error);
      return [];
    }
  }
  
  /**
   * Process an achievement to check if it should be updated
   */
  private async processAchievement(
    userId: string, 
    achievement: Achievement, 
    actionType: string, 
    data: any
  ): Promise<UserAchievementWithDetails | null> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(ACHIEVEMENTS_DB_NAME);
      
      // Get current progress
      const current = await db.getFirstAsync<{progress: number, is_unlocked: number}>(
        'SELECT progress, is_unlocked FROM user_achievements WHERE user_id = ? AND achievement_id = ?',
        [userId, achievement.id]
      );
      
      // If already unlocked or not found, exit early
      if (!current) return null;
      if (current.is_unlocked) return null;
      
      // Calculate new progress based on achievement type and action
      let newProgress = current.progress;
      
      // This is where you'd implement the logic for different achievement types
      // For now, this is a simplified example
      switch (achievement.category) {
        case 'Daily & Weekly Streaks':
          // Example: First usage achievement
          if (achievement.id === 1 && actionType === 'log_consumption') {
            newProgress = 100; // Immediately complete
          }
          break;
          
        case 'Strain Exploration':
          // Example: Try different strains
          if (actionType === 'explore_strain') {
            // Increment progress by a fixed amount, or calculate based on unique strains
            newProgress = Math.min(100, newProgress + 10);
          }
          break;
          
        // Add more category handlers
      }
      
      // Update progress
      if (newProgress !== current.progress) {
        await this.updateAchievementProgress(userId, achievement.id, newProgress);
      }
      
      // If newly unlocked, return full achievement details
      if (newProgress >= 100 && current.progress < 100) {
        const updated = await db.getFirstAsync<UserAchievementWithDetails>(
          `SELECT 
            a.id, a.category, a.name, a.unlock_condition as unlockCondition, 
            a.notes, a.icon, a.complexity,
            ua.user_id as userId, a.id as achievementId, ua.progress, 
            ua.date_unlocked as dateUnlocked, 
            ua.is_unlocked as isUnlocked, ua.is_new as isNew
          FROM achievements a
          JOIN user_achievements ua ON a.id = ua.achievement_id
          WHERE ua.user_id = ? AND a.id = ?`,
          [userId, achievement.id]
        );
        
        if (updated) {
          return {
            ...updated,
            isUnlocked: Boolean(updated.isUnlocked),
            isNew: Boolean(updated.isNew)
          };
        }
      }
      
      return null;
    } catch (error) {
      console.error('[DatabaseManager] Failed to process achievement:', error);
      return null;
    }
  }
  
  /**
   * Get initial achievements list
   */
  private getInitialAchievements(): Achievement[] {
    // Make sure ACHIEVEMENTS is defined and has values
    if (!ACHIEVEMENTS || !Array.isArray(ACHIEVEMENTS) || ACHIEVEMENTS.length === 0) {
      const error = new Error('[DatabaseManager] ACHIEVEMENTS array is not properly defined in constants.ts');
      console.error(error);
      throw error; // Throw instead of creating a fallback
    }
    
    // Return achievements from constants
    console.log(`[DatabaseManager] Returning ${ACHIEVEMENTS.length} achievements from constants`);
    return ACHIEVEMENTS;
  }
  
  /**
   * Get icon for achievement category
   */
  private getCategoryIcon(category: string): string {
    // Get icon from constants or use default
    return (ACHIEVEMENT_ICONS as Record<string, string>)[category] || 'trophy';
  }

  /* ------------------------------------------------------------------
     BongHits Data-Fetching / Query Functions
   ------------------------------------------------------------------ */

  /**
   * Retrieves average and max duration over the past 7 days.
   */
  public async getBongHitStatsFromPastWeek(): Promise<BongHitStats> {
    try {
      await this.ensureInitialized();
      const db: SQLiteDatabase = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      const results = await db.getAllAsync<{avg_duration: number, max_duration: number}>(`
        SELECT
          AVG(duration_ms) AS avg_duration,
          MAX(duration_ms) AS max_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
      `);

      if (!results.length) {
        // Fallback if no data
        return this.validateBongHitStats({ averageDuration: 0, longestHit: 0 });
      }

      const row = results[0];
      return this.validateBongHitStats({
        averageDuration: row.avg_duration,
        longestHit: row.max_duration,
      });
    } catch (error) {
      console.error("Error in getBongHitStatsFromPastWeek:", error);
      throw error;
    }
  }

  /**
   * Counts hits per day over the past week (filling day indices 0..6).
   */
  public async queryNumberOfHitsFromPastWeek(): Promise<Datapoint[]> {
    try {
      await this.ensureInitialized();
      const db: SQLiteDatabase = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      const results = await db.getAllAsync<{day: string, hit_count: number}>(`
        SELECT 
          strftime('%w', timestamp) AS day,
          COUNT(*) AS hit_count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY day
        ORDER BY day
      `);

      console.log("Weekly query results:", results);

      // Prepare an array for Sunday..Saturday
      const weekData: Datapoint[] = Array.from({ length: 7 }, (_, i) => ({
        x: dayLookUpTable.get(i) || "",
        y: 0,
      }));

      results.forEach(row => {
        const dayIndex = parseInt(row.day, 10);
        if (dayIndex >= 0 && dayIndex < 7) {
          weekData[dayIndex] = this.validateDatapoint({
            label: dayLookUpTable.get(dayIndex) || "",
            value: row.hit_count,
          });
        }
      });

      return weekData;
    } catch (error) {
      console.error("Error in queryNumberOfHitsFromPastWeek:", error);
      throw error;
    }
  }

  /**
   * Returns a list of (hourOfDay -> # of hits) since a week ago,
   * filling missing hours with 0.
   */
  public async getDailyAverageDatapoints(): Promise<AverageHourCount[]> {
    try {
      await this.ensureInitialized();
      const db: SQLiteDatabase = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      const results = await db.getAllAsync<{hourOfDay: string, count: number}>(`
        SELECT 
          strftime('%H', timestamp) AS hourOfDay,
          COUNT(*) AS count
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24'
        GROUP BY hourOfDay
        ORDER BY hourOfDay
      `);

      // Hours "00" through "23"
      const allHours = Array.from({ length: 24 }, (_, i) => i.toString().padStart(2, "0"));
      const dataMap = new Map<string, number>(
        results.map(item => [item.hourOfDay, item.count])
      );

      return allHours.map((hour) =>
        this.validateAverageHourCount({
          hourOfDay: hour,
          count: dataMap.get(hour) || 0,
        })
      );
    } catch (error) {
      console.error("Error in getDailyAverageDatapoints:", error);
      throw error;
    }
  }

  /**
   * Generic function to get data based on a time range (D=Day, W=Week, M=Month).
   * Returns both chartData and some aggregated stats.
   */
  public async getDailyStats(timeRange: string) {
    try {
      await this.ensureInitialized();
      let query = "";

      switch (timeRange) {
        case "D":
          query = `
            SELECT strftime('%H', timestamp) as label,
                 COUNT(*) as value,
                 AVG(duration_ms) as avg_duration
            FROM ${BONG_HITS_DATABASE_NAME}
            WHERE timestamp >= '2024-12-24'
            GROUP BY label
            ORDER BY label
          `;
          break;
        case "W":
          query = `
            SELECT strftime('%w', timestamp) as label,
                 COUNT(*) as value,
                 AVG(duration_ms) as avg_duration
            FROM ${BONG_HITS_DATABASE_NAME}
            WHERE timestamp >= '2024-12-24'
            GROUP BY label
            ORDER BY label
          `;
          break;
        case "M":
          query = `
            SELECT strftime('%d', timestamp) as label,
                 COUNT(*) as value,
                 AVG(duration_ms) as avg_duration
            FROM ${BONG_HITS_DATABASE_NAME}
            WHERE timestamp >= '2024-12-24'
            GROUP BY label
            ORDER BY label
          `;
          break;
        default:
          // fallback same as 'D'
          query = `
            SELECT strftime('%H', timestamp) as label,
                 COUNT(*) as value,
                 AVG(duration_ms) as avg_duration
            FROM ${BONG_HITS_DATABASE_NAME}
            WHERE timestamp >= '2024-12-24'
            GROUP BY label
            ORDER BY label
          `;
      }

      const db: SQLiteDatabase = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      const results = await db.getAllAsync<{label: string, value: number, avg_duration: number}>(query);

      // Build chart data
      const chartData = {
        labels: results.map(r => `${r.label}h`),
        datasets: [
          {
            data: results.map(r => r.value),
            color: (opacity = 1) => `rgba(0, 122, 255, ${opacity})`,
            strokeWidth: 2,
          },
        ],
        legend: ["Hits"],
      };

      // Build aggregated stats
      // If no rows, handle safely
      if (!results.length) {
        return {
          chartData,
          stats: {
            avgDuration: 0,
            totalHits: 0,
            peakHour: null,
          },
        };
      }

      const avgDuration =
        results.reduce((acc: number, curr) => acc + curr.avg_duration, 0) /
        results.length;
      const totalHits = results.reduce((acc: number, curr) => acc + curr.value, 0);
      const peak = results.reduce((a, b) => (a.value > b.value ? a : b));
      const peakHour = peak.label;

      return {
        chartData,
        stats: {
          avgDuration,
          totalHits,
          peakHour,
        },
      };
    } catch (error) {
      console.error("Error in getDailyStats:", error);
      throw error;
    }
  }

  /**
   * Record a new bong hit
   * @param timestamp ISO string timestamp of the hit
   * @param durationMs Duration of the hit in milliseconds
   */
  public async recordBongHit(timestamp: string, durationMs: number): Promise<void> {
    const hit: BongHit = { timestamp, duration_ms: durationMs };
    const validationError = validateBongHit(hit);
    
    if (validationError) {
      throw new Error(validationError);
    }
    
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      await db.runAsync(
        `INSERT INTO ${BONG_HITS_DATABASE_NAME} (timestamp, duration_ms) 
         VALUES (?, ?)`,
        [timestamp, durationMs]
      );
    } catch (error) {
      console.error('[DatabaseManager] Error recording bong hit:', error);
      throw error;
    }
  }

  /* ------------------------------------------------------------------
     Saved devices management via AsyncStorage
   ------------------------------------------------------------------ */

  public async getSavedDevices(): Promise<SavedDevice[]> {
    try {
      const savedDevices = await AsyncStorage.getItem(SAVED_DEVICES_KEY);
      if (savedDevices) {
        return JSON.parse(savedDevices) as SavedDevice[];
      }
      return [];
    } catch (error) {
      console.error("Error getting saved devices:", error);
      throw error;
    }
  }

  public async saveDevices(devices: Device[]): Promise<void> {
    try {
      let savedDevices: SavedDevice[] = await this.getSavedDevices();
      
      devices.forEach(device => {
        const savedDevice: SavedDevice = {
          id: device.id, 
          name: device.name ? device.name : "Unknown Name"
        };
        savedDevices.push(savedDevice);
      });
      
      await AsyncStorage.setItem(SAVED_DEVICES_KEY, JSON.stringify(savedDevices));
    } catch (error) {
      console.error("Error saving devices:", error);
      throw error;
    }
  }

  /* ------------------------------------------------------------------
     AsyncStorage Methods (Moved from AsyncStorageManager)
   ------------------------------------------------------------------ */

  /**
   * Generic method to get a value from AsyncStorage
   */
  public async getValue<T>(key: string): Promise<T | null> {
    try {
      const value = await AsyncStorage.getItem(key);
      if (value !== null) {
        return JSON.parse(value) as T;
      }
      return null;
    } catch (error) {
      console.error(`[DatabaseManager] Error getting value for key ${key}:`, error);
      return null;
    }
  }

  /**
   * Generic method to set a value in AsyncStorage
   */
  public async setValue<T>(key: string, value: T): Promise<void> {
    try {
      await AsyncStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`[DatabaseManager] Error setting value for key ${key}:`, error);
      throw error;
    }
  }

  /**
   * Remove a key from AsyncStorage
   */
  public async removeValue(key: string): Promise<void> {
    try {
      await AsyncStorage.removeItem(key);
    } catch (error) {
      console.error(`[DatabaseManager] Error removing key ${key}:`, error);
      throw error;
    }
  }

  /**
   * Clear all data in AsyncStorage
   * Use with caution!
   */
  public async clearAll(): Promise<void> {
    try {
      await AsyncStorage.clear();
    } catch (error) {
      console.error('[DatabaseManager] Error clearing AsyncStorage:', error);
      throw error;
    }
  }

  /* ------------------------------------------------------------------
     Strain Methods (Moved from StrainService)
   ------------------------------------------------------------------ */

  /**
   * Search strains with filters and pagination
   */
  public async searchStrains(
    query: string,
    filters: StrainSearchFilters = {},
    pagination: PaginationParams = { page: 1, limit: 10 }
  ): Promise<StrainSearchResult<Strain>> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(STRAINS_DATABASE_NAME);
      const { page, limit } = pagination;
      const offset = (page - 1) * limit;

      // Build where clause and parameters
      const whereClauses = [];
      const params: any[] = [];

      // Search by name if query is provided
      if (query && query.trim()) {
        whereClauses.push('name LIKE ?');
        params.push(`%${query.trim()}%`);
      }

      // Filter by genetic type
      if (filters.geneticType) {
        whereClauses.push('genetic_type = ?');
        params.push(filters.geneticType);
      }

      // Filter by effects
      if (filters.effects && filters.effects.length > 0) {
        const effectClauses = filters.effects.map(() => 'effects LIKE ?');
        whereClauses.push(`(${effectClauses.join(' OR ')})`);
        filters.effects.forEach(effect => params.push(`%${effect}%`));
      }

      // Filter by THC range
      if (filters.minTHC !== undefined) {
        whereClauses.push('CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) >= ?');
        params.push(filters.minTHC);
      }

      if (filters.maxTHC !== undefined) {
        whereClauses.push('CAST(SUBSTR(thc_range, INSTR(thc_range, "-")+1) AS FLOAT) <= ?');
        params.push(filters.maxTHC);
      }

      // Construct the final WHERE clause
      const whereClause = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';

      // Get total count for pagination
      const [countResult] = await db.getAllAsync<{ total: number }>(
        `SELECT COUNT(*) as total FROM ${STRAINS_DATABASE_NAME} ${whereClause}`,
        params
      );

      // Get filtered results
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} 
         ${whereClause} 
         ORDER BY ${this.getSortOrder(filters.sort)}
         LIMIT ? OFFSET ?`,
        [...params, limit, offset]
      );

      const total = countResult?.total || 0;
      const totalPages = Math.ceil(total / limit);

      return {
        data: results,
        total,
        currentPage: page,
        totalPages,
        hasMore: page < totalPages
      };
      
    } catch (error) {
      console.error('[DatabaseManager] Error searching strains:', error);
      // Return an empty result in case of error
      return {
        data: [],
        total: 0,
        currentPage: pagination.page,
        totalPages: 0,
        hasMore: false
      };
    }
  }

  /**
   * Helper method to get sort order for strain queries
   */
  private getSortOrder(sort?: StrainSearchFilters['sort']): string {
    switch (sort) {
      case 'name':
        return 'name ASC';
      case 'thc':
        return 'CAST(SUBSTR(thc_range, 1, INSTR(thc_range, "-")-1) AS FLOAT) DESC';
      case 'rating':
      default:
        return 'combined_rating DESC';
    }
  }

  /**
   * Get strain by ID
   */
  public async getStrainById(id: number): Promise<ValidationResult<Strain | null>> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(STRAINS_DATABASE_NAME);
      
      // Validate input
      if (!id || typeof id !== 'number' || id <= 0) {
        return createValidationError('INVALID_ID', 'Invalid strain ID provided');
      }
      
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} WHERE id = ? LIMIT 1`,
        [id]
      );
      
      const strain = results[0] || null;
      
      if (strain) {
        const validationError = validateStrain(strain);
        if (validationError) {
          return createValidationError('INVALID_STRAIN_DATA', validationError, { id });
        }
      }
      
      return createValidationSuccess(strain);
    } catch (error) {
      console.error('[DatabaseManager] Error getting strain by id:', error);
      return createValidationError('DB_ERROR', 'Failed to retrieve strain', { id });
    }
  }

  /**
   * Get popular strains
   */
  public async getPopularStrains(limit: number = 10): Promise<Strain[]> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(STRAINS_DATABASE_NAME);
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME} ORDER BY combined_rating DESC LIMIT ?`,
        [limit]
      );
      return results || [];
    } catch (error) {
      console.error('[DatabaseManager] Error getting popular strains:', error);
      return [];
    }
  }

  /**
   * Get related strains
   */
  public async getRelatedStrains(strain: Strain): Promise<ValidationResult<Strain[]>> {
    try {
      // Validate input
      const validationError = validateStrain(strain);
      if (validationError) {
        return createValidationError('INVALID_STRAIN', validationError);
      }
      
      if (!strain.id) {
        return createValidationError('MISSING_ID', 'Strain ID is required');
      }
      
      await this.ensureInitialized();
      const db = await this.getDatabase(STRAINS_DATABASE_NAME);
      
      // Get strains with similar genetic type and effects
      const results = await db.getAllAsync<Strain>(
        `SELECT * FROM ${STRAINS_DATABASE_NAME}
         WHERE id != ? 
         AND (
           genetic_type = ? 
           OR effects LIKE ?
         )
         ORDER BY combined_rating DESC
         LIMIT 5`,
        [strain.id, strain.genetic_type, `%${strain.effects.split(',')[0]}%`]
      );
      
      // Validate results
      for (const relatedStrain of results) {
        const strainError = validateStrain(relatedStrain);
        if (strainError) {
          console.warn(`[DatabaseManager] Invalid related strain: ${strainError}`, relatedStrain);
        }
      }
      
      return createValidationSuccess(results);
    } catch (error) {
      console.error('[DatabaseManager] Error getting related strains:', error);
      return createValidationError('DB_ERROR', 'Failed to retrieve related strains');
    }
  }

  /**
   * Get strain categories
   */
  public async getStrainCategories(): Promise<{ [key: string]: number }> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(STRAINS_DATABASE_NAME);
      const results = await db.getAllAsync<{ genetic_type: string; count: number }>(
        `SELECT genetic_type, COUNT(*) as count
         FROM ${STRAINS_DATABASE_NAME}
         GROUP BY genetic_type`
      );
      
      return results.reduce((acc, { genetic_type, count }) => {
        if (genetic_type) {
          acc[genetic_type] = count;
        }
        return acc;
      }, {} as { [key: string]: number });
    } catch (error) {
      console.error('[DatabaseManager] Error getting strain categories:', error);
      return {};
    }
  }

  /* ------------------------------------------------------------------
     Safety Methods (Moved from SafetyService)
   ------------------------------------------------------------------ */

  /**
   * Validate recommendation request for safety concerns
   */
  public async validateRecommendationRequest(request: RecommendationRequest): Promise<SafetyValidationResult> {
    try {
      await this.ensureInitialized();
      
      const { userProfile, desiredEffects, medicalNeeds, context } = request;
      const safetyFlags: string[] = [];
      let isValid = true;
      let reason = '';
      let modifications: Partial<RecommendationRequest> = {};
      let warningLevel: 'info' | 'warning' | 'critical' = 'info';
      
      // Check for required fields
      if (!userProfile) {
        return {
          valid: false,
          reason: 'User profile is required for personalized recommendations',
          warningLevel: 'critical'
        };
      }

      // Verify age restrictions (if age is provided)
      if (userProfile.experience_level === 'beginner') {
        // For beginners, add a safety flag
        safetyFlags.push('Recommendations tailored for beginners. Start with lower doses.');
      }
      
      // Check for cooling off period
      const coolingOffStatus = await this.checkCoolingOffStatus(userProfile.id);
      if (coolingOffStatus.inCoolingOff) {
        return {
          valid: false,
          reason: `Cooling off period in effect until ${new Date(coolingOffStatus.endTime!).toLocaleDateString()}`,
          warningLevel: 'critical'
        };
      }
      
      // Check for overdose concerns based on user profile
      const overuseCheck = await this.detectOverusePatterns(userProfile.id);
      if (overuseCheck.detected) {
        if (overuseCheck.level === 'severe') {
          return {
            valid: false,
            reason: overuseCheck.details || 'Usage patterns indicate potential health concerns',
            warningLevel: 'critical'
          };
        } else {
          safetyFlags.push(overuseCheck.details || 'Frequent use detected. Consider moderating consumption.');
          warningLevel = overuseCheck.level === 'moderate' ? 'warning' : 'info';
        }
      }
      
      // Check for medication interactions if applicable
      if (userProfile.medications && userProfile.medications.length > 0) {
        const interactionCheck = await this.checkMedicationInteractions(
          userProfile.medications
        );
        
        if (interactionCheck.hasInteractions) {
          if (interactionCheck.severity === 'severe') {
            return {
              valid: false,
              reason: 'Potential serious interaction with medications detected',
              safetyFlags: interactionCheck.details,
              warningLevel: 'critical'
            };
          } else {
            safetyFlags.push(...(interactionCheck.details || []));
            warningLevel = interactionCheck.severity === 'moderate' ? 'warning' : 'info';
          }
        }
      }
      
      // Adjust recommendations for beginners
      if (userProfile.experience_level === 'beginner') {
        // Modify the request to prioritize lower THC content for beginners
        modifications = {
          ...modifications,
          context: 'wellness', // Override context for beginners
          desiredEffects: [...(request.desiredEffects || []), 'mild', 'gentle']
        };
        
        safetyFlags.push('Recommendations adjusted for beginner experience level.');
      }
      
      // Handle medical context with extra care
      if (context === 'medical' && medicalNeeds && medicalNeeds.length > 0) {
        safetyFlags.push('Medical disclaimer: Consult with a healthcare professional before use.');
        
        // Check if any medical needs require special attention
        const sensitiveConditions = ['anxiety', 'heart', 'psychiatric', 'pregnancy'];
        const hasSensitiveCondition = medicalNeeds.some(need => 
          sensitiveConditions.some(condition => need.toLowerCase().includes(condition))
        );
        
        if (hasSensitiveCondition) {
          safetyFlags.push('Some conditions may require extra caution. Medical supervision is strongly advised.');
          warningLevel = 'warning';
        }
      }
      
      // Return validation result
      return {
        valid: isValid,
        reason: reason,
        modifications: Object.keys(modifications).length > 0 ? modifications : undefined,
        safetyFlags: safetyFlags.length > 0 ? safetyFlags : undefined,
        warningLevel
      };
      
    } catch (error) {
      console.error('[DatabaseManager] Error validating recommendation request:', error);
      return {
        valid: false,
        reason: 'Internal safety check error. Please try again later.',
        warningLevel: 'critical'
      };
    }
  }

  /**
   * Process recommendation response to add safety information
   */
  public async processRecommendationResponse(
    response: RecommendationResponse, 
    userProfile: UserProfile,
    recentEntries: JournalEntry[]
  ): Promise<RecommendationResponse> {
    try {
      await this.ensureInitialized();
      
      let additionalDisclaimers: string[] = [];
      let enhancedSafetyNotes = [...(response.safetyNotes || [])];
      let recommendations = [...response.recommendations];
      
      // Ensure we always have basic disclaimers
      if (!response.disclaimers || response.disclaimers.length === 0) {
        additionalDisclaimers.push(
          "Cannabis affects individuals differently. Start with a low dose.",
          "Do not drive or operate machinery while using cannabis.",
          "Keep cannabis products away from children and pets."
        );
      }
      
      // Add experience level specific notes
      if (userProfile.experience_level === 'beginner') {
        additionalDisclaimers.push(
          "As a beginner, start with a very small amount and wait at least 2 hours before considering more.",
          "Effects may be stronger than expected for new users."
        );
      }
      
      // Check journal entries for negative patterns
      if (recentEntries.length > 0) {
        // Look for commonly reported negative effects
        const negativeEffectsMap = new Map<string, number>();
        recentEntries.forEach(entry => {
          if (entry.negative_effects) {
            entry.negative_effects.forEach(effect => {
              negativeEffectsMap.set(effect, (negativeEffectsMap.get(effect) || 0) + 1);
            });
          }
        });
        
        // Find frequent negative effects
        const frequentNegativeEffects = Array.from(negativeEffectsMap.entries())
          .filter(([_, count]) => count >= 2)
          .map(([effect]) => effect);
        
        if (frequentNegativeEffects.length > 0) {
          enhancedSafetyNotes.push(
            `Based on your journal, watch for these effects you've reported: ${frequentNegativeEffects.join(', ')}.`
          );
        }
      }
      
      // Return enhanced response
      return {
        ...response,
        disclaimers: [...(response.disclaimers || []), ...additionalDisclaimers],
        safetyNotes: enhancedSafetyNotes,
        recommendations
      };
      
    } catch (error) {
      console.error('[DatabaseManager] Error processing recommendation response:', error);
      // Return original response if processing fails
      return response;
    }
  }

  /**
   * Detect overuse patterns in user behavior
   */
  public async detectOverusePatterns(userId: string): Promise<OveruseDetectionResult> {
    try {
      await this.ensureInitialized();
      
      // Get recent journal entries for analysis
      const entries = await this.getRecentJournalEntries(userId, 30); // Last 30 days
      
      if (entries.length === 0) {
        return { detected: false };
      }
      
      // Check for daily use
      const dailyUseCount = entries.length;
      const daysInPeriod = 30;
      const usageFrequency = dailyUseCount / daysInPeriod;
      
      // Check for increasing dosage trend
      const weeklyDosages = this.getWeeklyAverageDosages(entries);
      const increasingDosage = this.detectIncreasingTrend(weeklyDosages);
      
      // Check for decreasing effectiveness
      const effectivenessRatios = this.getEffectivenessRatios(entries);
      const decreasingEffectiveness = this.detectDecreasingTrend(effectivenessRatios);
      
      // Check for withdrawal symptoms
      const withdrawalSymptoms = this.detectWithdrawalSymptoms(entries);
      
      // Evaluate severity
      let level: 'mild' | 'moderate' | 'severe' = 'mild';
      let detected = false;
      let details = '';
      
      if (usageFrequency > 0.8 && increasingDosage && decreasingEffectiveness) {
        level = 'severe';
        detected = true;
        details = 'Daily use with increasing dosage and decreasing effectiveness detected.';
      } else if ((usageFrequency > 0.7 && (increasingDosage || decreasingEffectiveness)) || withdrawalSymptoms) {
        level = 'moderate';
        detected = true;
        details = 'Frequent use with potential tolerance or dependency signs detected.';
      } else if (usageFrequency > 0.5) {
        level = 'mild';
        detected = true;
        details = 'Regular use detected. Consider occasional breaks.';
      }
      
      return {
        detected,
        level,
        details
      };
      
    } catch (error) {
      console.error('[DatabaseManager] Error detecting overuse patterns:', error);
      return { detected: false };
    }
  }

  /**
   * Check for medication interactions with cannabis
   */
  public async checkMedicationInteractions(
    medications: string[]
  ): Promise<DrugInteractionResult> {
    try {
      await this.ensureInitialized();
      
      // Known medications with potential interactions
      const highRiskMedications = [
        'warfarin', 'coumadin', 'eliquis', 'xarelto', // Blood thinners
        'celexa', 'lexapro', 'prozac', 'zoloft', 'paxil', // SSRIs
        'xanax', 'valium', 'klonopin', 'ativan', // Benzodiazepines
        'vicodin', 'percocet', 'oxycodone', 'morphine', // Opioids
        'lithium', 'lamictal', 'depakote', // Mood stabilizers
      ];
      
      const moderateRiskMedications = [
        'lisinopril', 'losartan', 'metoprolol', // Blood pressure meds
        'metformin', 'glipizide', 'insulin', // Diabetes medications
        'atorvastatin', 'simvastatin', 'lipitor', // Statins
        'albuterol', 'advair', 'spiriva', // Asthma/COPD medications
      ];
      
      // Convert all to lowercase for case-insensitive matching
      const normalizedMedications = medications.map(med => med.toLowerCase());
      
      // Check for interactions
      const highRiskMatches = highRiskMedications.filter(med => 
        normalizedMedications.some(userMed => userMed.includes(med))
      );
      
      const moderateRiskMatches = moderateRiskMedications.filter(med => 
        normalizedMedications.some(userMed => userMed.includes(med))
      );
      
      // Generate detailed information
      const details: string[] = [];
      
      if (highRiskMatches.length > 0) {
        details.push(`Potential serious interactions with: ${highRiskMatches.join(', ')}.`);
        details.push('Cannabis may significantly affect how these medications work. Consult your doctor.');
      }
      
      if (moderateRiskMatches.length > 0) {
        details.push(`Possible interactions with: ${moderateRiskMatches.join(', ')}.`);
        details.push('Monitor for changes in medication effectiveness and side effects.');
      }
      
      // Determine severity
      const hasHighRisk = highRiskMatches.length > 0;
      const hasModerateRisk = moderateRiskMatches.length > 0;
      
      const severity = hasHighRisk ? 'severe' : hasModerateRisk ? 'moderate' : undefined;
      
      return {
        hasInteractions: hasHighRisk || hasModerateRisk,
        severity,
        details: details.length > 0 ? details : undefined
      };
      
    } catch (error) {
      console.error('[DatabaseManager] Error checking drug interactions:', error);
      return {
        hasInteractions: false,
        severity: undefined
      };
    }
  }

  /**
   * Log a safety concern for a user
   */
  public async logSafetyConcern(data: {
    userId: string;
    concernType: 'overuse' | 'negative_effects' | 'interactions';
    concernDetails: string;
    timestamp: number;
    resolutionSuggestions?: string[];
    coolingOffUntil?: number;
  }): Promise<void> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(SAFETY_DB_NAME);
      
      // Generate unique ID
      const id = `${data.userId}_${data.concernType}_${Date.now()}`;
      
      await db.runAsync(
        `INSERT INTO ${SAFETY_DB_NAME} (
          id, user_id, concern_type, concern_details, 
          resolution_suggestions, cooling_off_until, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          data.userId,
          data.concernType,
          data.concernDetails,
          data.resolutionSuggestions ? JSON.stringify(data.resolutionSuggestions) : null,
          data.coolingOffUntil || null,
          data.timestamp
        ]
      );
      
      console.log('[DatabaseManager] Safety concern logged for user', data.userId);
    } catch (error) {
      console.error('[DatabaseManager] Error logging safety concern:', error);
    }
  }

  /**
   * Get safety history for a user
   */
  public async getSafetyHistory(userId: string): Promise<SafetyRecord[]> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(SAFETY_DB_NAME);
      
      const records = await db.getAllAsync<{
        id: string;
        user_id: string;
        concern_type: string;
        concern_details: string;
        resolution_suggestions: string | null;
        cooling_off_until: number | null;
        created_at: number;
      }>(
        `SELECT * FROM ${SAFETY_DB_NAME}
         WHERE user_id = ?
         ORDER BY created_at DESC`,
        [userId]
      );
      
      // Convert to SafetyRecord format expected by the application
      return records.map(record => ({
        id: record.id,
        user_id: record.user_id,
        concern_type: record.concern_type as 'overuse' | 'negative_effects' | 'interactions',
        concern_details: record.concern_details,
        resolution_suggestions: record.resolution_suggestions ? JSON.parse(record.resolution_suggestions) : [],
        cooling_off_until: record.cooling_off_until,
        created_at: new Date(record.created_at).toISOString()
      }));
    } catch (error) {
      console.error('[DatabaseManager] Error getting safety history:', error);
      return [];
    }
  }

  /**
   * Check if user is in cooling off period
   */
  public async checkCoolingOffStatus(userId: string): Promise<{
    inCoolingOff: boolean;
    endTime?: number;
    reason?: string;
  }> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(SAFETY_DB_NAME);
      
      const now = Date.now();
      
      const record = await db.getFirstAsync<{
        cooling_off_until: number;
        concern_details: string;
      }>(
        `SELECT cooling_off_until, concern_details 
         FROM ${SAFETY_DB_NAME}
         WHERE user_id = ? 
         AND cooling_off_until IS NOT NULL 
         AND cooling_off_until > ?
         ORDER BY cooling_off_until DESC 
         LIMIT 1`,
        [userId, now]
      );
      
      if (record && record.cooling_off_until) {
        return {
          inCoolingOff: true,
          endTime: record.cooling_off_until,
          reason: record.concern_details
        };
      }
      
      return { inCoolingOff: false };
    } catch (error) {
      console.error('[DatabaseManager] Error checking cooling off status:', error);
      return { inCoolingOff: false };
    }
  }

  /**
   * Get recent journal entries for a user
   */
  private async getRecentJournalEntries(userId: string, days: number): Promise<JournalEntry[]> {
    try {
      await this.ensureInitialized();
      
      // Make sure journal database is initialized
      try {
        await this.initializeJournalDb();
      } catch (error) {
        console.error('[DatabaseManager] Error ensuring journal database is initialized:', error);
        return [];
      }
      
      const db = await this.getDatabase('journal.db');
      
      const entries = await db.getAllAsync<{
        id: string;
        user_id: string;
        entry_date: number;
        strain_id: number;
        strain_name: string;
        consumption_method: string;
        dosage: number;
        dosage_unit: string;
        effects_felt: string;
        rating: number;
        effectiveness: number;
        notes: string | null;
        mood_before: string | null;
        mood_after: string | null;
        medical_symptoms_relieved: string | null;
        negative_effects: string | null;
        duration_minutes: number | null;
        created_at: number;
      }>(
        `SELECT * FROM journal_entries 
         WHERE user_id = ? AND entry_date >= ?
         ORDER BY entry_date DESC`,
        [userId, Date.now() - (days * 24 * 60 * 60 * 1000)]
      );
      
      // Convert DB rows to JournalEntry format
      return entries.map(entry => ({
        id: entry.id,
        user_id: entry.user_id,
        strain_id: entry.strain_id,
        strain_name: entry.strain_name,
        consumption_method: entry.consumption_method,
        dosage: entry.dosage,
        dosage_unit: entry.dosage_unit,
        effects_felt: entry.effects_felt ? JSON.parse(entry.effects_felt) : [],
        rating: entry.rating,
        effectiveness: entry.effectiveness,
        notes: entry.notes || undefined,
        mood_before: entry.mood_before || undefined,
        mood_after: entry.mood_after || undefined,
        medical_symptoms_relieved: entry.medical_symptoms_relieved ? JSON.parse(entry.medical_symptoms_relieved) : undefined,
        negative_effects: entry.negative_effects ? JSON.parse(entry.negative_effects) : undefined,
        duration_minutes: entry.duration_minutes || undefined,
        created_at: new Date(entry.created_at).toISOString()
      }));
      
    } catch (error) {
      console.error('[DatabaseManager] Error getting recent journal entries:', error);
      return []; 
    }
  }

  /**
   * Get weekly average dosages from journal entries
   */
  private getWeeklyAverageDosages(entries: JournalEntry[]): number[] {
    // Group entries by week and calculate average dosage
    // This is a simplified implementation
    const result: number[] = [0, 0, 0, 0];
    
    if (entries.length === 0) return result;
    
    // In an actual implementation, group entries by week and calculate averages
    
    return result;
  }

  /**
   * Get effectiveness ratios from journal entries
   */
  private getEffectivenessRatios(entries: JournalEntry[]): number[] {
    // Calculate ratio of positive to negative effects over time
    // This is a simplified implementation
    return [0.8, 0.7, 0.6, 0.5]; // Example of decreasing effectiveness
  }

  /**
   * Detect increasing trend in numeric values
   */
  private detectIncreasingTrend(values: number[]): boolean {
    // Simple trend detection - check if values are generally increasing
    if (values.length < 2) return false;
    
    let increases = 0;
    let decreases = 0;
    
    for (let i = 1; i < values.length; i++) {
      if (values[i] > values[i-1]) {
        increases++;
      } else if (values[i] < values[i-1]) {
        decreases++;
      }
    }
    
    return increases > decreases;
  }

  /**
   * Detect decreasing trend in numeric values
   */
  private detectDecreasingTrend(values: number[]): boolean {
    // Simple trend detection - check if values are generally decreasing
    if (values.length < 2) return false;
    
    let increases = 0;
    let decreases = 0;
    
    for (let i = 1; i < values.length; i++) {
      if (values[i] < values[i-1]) {
        decreases++;
      } else if (values[i] > values[i-1]) {
        increases++;
      }
    }
    
    return decreases > increases;
  }

  /**
   * Detect withdrawal symptoms from journal entries
   */
  private detectWithdrawalSymptoms(entries: JournalEntry[]): boolean {
    // Check for common withdrawal symptoms in recent entries
    // This is a simplified implementation
    const withdrawalKeywords = [
      'insomnia', 'can\'t sleep', 'trouble sleeping',
      'anxiety', 'anxious', 'nervous',
      'irritable', 'irritability', 'annoyed',
      'appetite', 'hungry', 'not hungry',
      'headache', 'migraine',
      'nausea', 'sick', 'stomach',
      'sweating', 'sweats', 'night sweats',
      'craving', 'want to use'
    ];
    
    // In a real implementation, analyze entry notes for these keywords
    
    return false;
  }

  /* ------------------------------------------------------------------
     Data Methods (Moved from DataService)
   ------------------------------------------------------------------ */

  /**
   * Get weekly statistics
   */
  public async getWeeklyStats(): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      // Use SQL template
      const query = getWeeklyStatsQuery(BONG_HITS_DATABASE_NAME);
      const weekData = await db.getAllAsync<{ label: string; value: number; avg_duration: number }>(query);
      
      if (!weekData || weekData.length === 0) {
        return {
          success: true,
          data: []
        };
      }
      
      // Format data for chart display
      const data: ChartDataPoint[] = weekData.map(point => ({
        label: point.label,
        value: parseInt(String(point.value || 0)),
        meta: { avgDuration: Math.round(point.avg_duration || 0) }
      }));
      
      return { success: true, data };
    } catch (error) {
      return this.handleError(error, 'getWeeklyStats');
    }
  }
  
  /**
   * Get monthly statistics
   */
  public async getMonthlyStats(): Promise<DatabaseResponse<ChartDataPoint[]>> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      // Use SQL template
      const query = getMonthlyStatsQuery(BONG_HITS_DATABASE_NAME);
      const monthData = await db.getAllAsync<{ label: string; value: number; avg_duration: number }>(query);
      
      if (!monthData || monthData.length === 0) {
        return {
          success: true,
          data: []
        };
      }
      
      // Format data for chart display
      const data: ChartDataPoint[] = monthData.map(point => ({
        label: point.label,
        value: parseInt(String(point.value || 0)),
        meta: { avgDuration: Math.round(point.avg_duration || 0) }
      }));
      
      return { success: true, data };
    } catch (error) {
      return this.handleError(error, 'getMonthlyStats');
    }
  }

  /**
   * Get time distribution of usage
   */
  public async getTimeDistribution(): Promise<DatabaseResponse<TimeDistribution>> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      // Use SQL template
      const query = getTimeDistributionQuery(BONG_HITS_DATABASE_NAME, 30); // Last 30 days
      const [result] = await db.getAllAsync<DatabaseRow>(query);
      
      if (!result) {
        return {
          success: true,
          data: {
            morning: 0,
            afternoon: 0,
            evening: 0,
            night: 0
          }
        };
      }

      const distribution: TimeDistribution = {
        morning: Number(result.morning || 0),
        afternoon: Number(result.afternoon || 0),
        evening: Number(result.evening || 0),
        night: Number(result.night || 0)
      };

      return { success: true, data: distribution };
    } catch (error) {
      return this.handleError(error, 'getTimeDistribution');
    }
  }

  /**
   * Get usage statistics
   */
  public async getUsageStats(daysBack: number = 30): Promise<DatabaseResponse<UsageStats>> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      
      // First get daily hits to calculate variance
      const dailyHitsQuery = `
        SELECT COUNT(*) as daily_hits
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
        GROUP BY strftime('%Y-%m-%d', timestamp)
      `;

      const dailyHits = await db.getAllAsync<{ daily_hits: number }>(dailyHitsQuery);
      
      // Handle case with no data
      if (!dailyHits.length) {
        return {
          success: true,
          data: {
            totalHits: 0,
            averageHitsPerDay: 0,
            averageHitsPerHour: 0,
            averageDuration: 0,
            totalDuration: 0,
            peakDayHits: 0,
            lowestDayHits: 0,
            mostActiveHour: 0,
            leastActiveHour: 0,
            longestHit: 0,
            shortestHit: 0,
            consistency: 0,
            weekdayStats: {
              weekday: { total: 0, avg: 0 },
              weekend: { total: 0, avg: 0 }
            }
          }
        };
      }

      // Calculate consistency score based on standard deviation of daily hits
      const hitValues = dailyHits.map(row => row.daily_hits);
      const stdDev = this.calculateStandardDeviation(hitValues);
      const mean = hitValues.reduce((a, b) => a + b, 0) / hitValues.length;
      const cv = mean > 0 ? (stdDev / mean) * 100 : 0;
      const consistencyScore = Math.min(10, 10 * Math.exp(-0.05 * cv)); // Scale to 0-10
      
      // Get main usage stats query
      const query = getUsageStatsQuery(BONG_HITS_DATABASE_NAME, daysBack);
      const statsResult = await db.getFirstAsync<RawUsageStats>(query);
      
      if (!statsResult) {
        return { success: false, error: "Failed to get usage stats" };
      }
      
      console.log(`[DatabaseManager] Raw usage stats:`, statsResult);
      
      // Get hourly distribution for most/least active hour
      const hourlyQuery = `
        SELECT 
          CAST(strftime('%H', timestamp) AS INTEGER) as hour,
          COUNT(*) as hits
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
        GROUP BY hour
        ORDER BY hits DESC
      `;
      
      const hourlyResults = await db.getAllAsync<{ hour: number, hits: number }>(hourlyQuery);
      const mostActiveHour = hourlyResults.length > 0 ? hourlyResults[0].hour : 0;
      const leastActiveHour = hourlyResults.length > 0 ? hourlyResults[hourlyResults.length - 1].hour : 0;
      
      // Get min/max duration
      const durationQuery = `
        SELECT 
          MIN(duration_ms) as min_duration,
          MAX(duration_ms) as max_duration
        FROM ${BONG_HITS_DATABASE_NAME}
        WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
      `;
      
      const durationResult = await db.getFirstAsync<{ min_duration: number, max_duration: number }>(durationQuery);
      
      // Calculate weekday vs weekend stats
      const weekdayQuery = `
        WITH DayStats AS (
          SELECT 
            CASE WHEN strftime('%w', timestamp) IN ('0', '6') THEN 'weekend' ELSE 'weekday' END as day_type,
            strftime('%Y-%m-%d', timestamp) as date,
            COUNT(*) as hits
          FROM ${BONG_HITS_DATABASE_NAME}
          WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
          GROUP BY day_type, date
        )
        SELECT 
          day_type,
          SUM(hits) as total_hits,
          AVG(hits) as avg_hits
        FROM DayStats
        GROUP BY day_type
      `;
      
      const weekdayResults = await db.getAllAsync<{ day_type: string, total_hits: number, avg_hits: number }>(weekdayQuery);
      
      const weekdayStats = {
        weekday: { total: 0, avg: 0 },
        weekend: { total: 0, avg: 0 }
      };
      
      weekdayResults.forEach(row => {
        if (row.day_type === 'weekday') {
          weekdayStats.weekday.total = row.total_hits;
          weekdayStats.weekday.avg = row.avg_hits;
        } else {
          weekdayStats.weekend.total = row.total_hits;
          weekdayStats.weekend.avg = row.avg_hits;
        }
      });
      
      // Create final stats object
      const stats: UsageStats = {
        totalHits: statsResult.total_hits,
        averageHitsPerDay: statsResult.avg_hits_per_active_day, // Use avg per active day instead of dividing by fixed period
        averageHitsPerHour: statsResult.total_hits / 24 / statsResult.active_days, // Also adjust hourly rate by active days
        averageDuration: statsResult.avg_duration_ms,
        totalDuration: statsResult.total_duration_ms,
        peakDayHits: statsResult.max_hits_in_day,
        lowestDayHits: Math.min(...hitValues),
        mostActiveHour: mostActiveHour,
        leastActiveHour: leastActiveHour,
        longestHit: durationResult?.max_duration || 0,
        shortestHit: durationResult?.min_duration || 0,
        consistency: Number(consistencyScore.toFixed(2)),
        weekdayStats
      };
      
      console.log(`[DatabaseManager] Processed usage stats:`, stats);
      
      return {
        success: true,
        data: stats
      };
    } catch (error) {
      return this.handleError(error, "getUsageStats");
    }
  }

  /**
   * Initialize a journal database
   */
  private async initializeJournalDb(): Promise<void> {
    try {
      const db = await this.getDatabase('journal.db');
      await db.execAsync(
        'PRAGMA journal_mode = WAL;' +
        `CREATE TABLE IF NOT EXISTS journal_entries (
          id TEXT PRIMARY KEY NOT NULL,
          user_id TEXT NOT NULL,
          entry_date INTEGER NOT NULL,
          strain_id INTEGER NOT NULL,
          strain_name TEXT NOT NULL,
          consumption_method TEXT NOT NULL,
          dosage REAL NOT NULL,
          dosage_unit TEXT NOT NULL,
          effects_felt TEXT NOT NULL,
          rating INTEGER NOT NULL,
          effectiveness INTEGER NOT NULL,
          notes TEXT,
          mood_before TEXT,
          mood_after TEXT,
          medical_symptoms_relieved TEXT,
          negative_effects TEXT,
          duration_minutes INTEGER,
          created_at INTEGER NOT NULL
        );` +
        `CREATE INDEX IF NOT EXISTS idx_journal_user_id ON journal_entries(user_id);` +
        `CREATE INDEX IF NOT EXISTS idx_journal_entry_date ON journal_entries(entry_date);` +
        `CREATE INDEX IF NOT EXISTS idx_journal_strain_id ON journal_entries(strain_id);` +
        `CREATE INDEX IF NOT EXISTS idx_journal_strain_name ON journal_entries(strain_name);` +
        `CREATE INDEX IF NOT EXISTS idx_journal_consumption_method ON journal_entries(consumption_method);` +
        `CREATE INDEX IF NOT EXISTS idx_journal_rating ON journal_entries(rating);` +
        `CREATE INDEX IF NOT EXISTS idx_journal_effectiveness ON journal_entries(effectiveness);`
      );
      
      console.log('[DatabaseManager] Journal database initialized');
    } catch (error) {
      throw this.handleDatabaseError(error, 'initializeJournalDb');
    }
  }

  /**
   * Get all bong hit logs from the database
   */
  public async getAllBongHitLogs(): Promise<DatabaseResponse<BongHit[]>> {
    try {
      await this.ensureInitialized();
      const db = await this.getDatabase(BONG_HITS_DATABASE_NAME);
      const results = await db.getAllAsync<BongHit>(`
        SELECT 
          timestamp,
          duration_ms
        FROM ${BONG_HITS_DATABASE_NAME}
        ORDER BY timestamp DESC
      `);

      console.log('[DatabaseManager] Retrieved', results.length, 'bong hit logs');
      return {
        success: true,
        data: results
      };
    } catch (error) {
      return this.handleError(error, 'getAllBongHitLogs');
    }
  }

  /**
   * Check if two SQL types are compatible
   * @param actual The actual type from the database
   * @param expected The expected type from the schema definition
   * @returns Whether the types are compatible
   */
  private isCompatibleType(actual: string, expected: string): boolean {
    actual = actual.toUpperCase();
    expected = expected.toUpperCase();
    
    // Check integer types
    if (expected.includes('INTEGER') || expected.includes('INT')) {
      return actual.includes('INT') || actual.includes('INTEGER') || actual.includes('BIGINT');
    }
    
    // Check text types
    if (expected.includes('TEXT')) {
      return actual.includes('TEXT') || actual.includes('CHAR') || actual.includes('CLOB');
    }
    
    // Check real/float types
    if (expected.includes('REAL') || expected.includes('FLOAT')) {
      return actual.includes('REAL') || actual.includes('FLOA') || actual.includes('DOUB');
    }
    
    // Default to exact match
    return actual === expected;
  }

  /**
   * Validate column type in database table
   * @param db Database connection
   * @param table Table name
   * @param column Column name
   * @param expectedType Expected column type
   * @returns Whether the column has a compatible type
   */
  private async validateColumnType(db: SQLiteDatabase, table: string, column: string, expectedType: string): Promise<boolean> {
    const tableInfo = await db.getAllAsync<{name: string, type: string}>(`PRAGMA table_info(${table})`);
    const columnInfo = tableInfo.find(info => info.name === column);
    
    if (!columnInfo) return false;
    return this.isCompatibleType(columnInfo.type, expectedType);
  }

  /**
   * Validate that a table schema contains all required columns
   * @param db Database connection
   * @param table Table name
   * @param requiredColumns Column names that must exist in the table
   * @returns Whether all required columns exist
   */
  private async validateTableSchema(db: SQLiteDatabase, table: string, requiredColumns: string[]): Promise<boolean> {
    const tableInfo = await db.getAllAsync<{name: string}>(`PRAGMA table_info(${table})`);
    const columnNames = tableInfo.map(col => col.name);
    
    // Check if all required columns exist
    return requiredColumns.every(col => columnNames.includes(col));
  }

  /**
   * Calculate the standard deviation of an array of numbers
   */
  private calculateStandardDeviation(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDifferences = values.map(val => Math.pow(val - mean, 2));
    const variance = squaredDifferences.reduce((sum, val) => sum + val, 0) / values.length;
    
    return Math.sqrt(variance);
  }
}

// Export a singleton instance for backwards compatibility
export const databaseManager = DatabaseManager.getInstance();

// Export functions for backwards compatibility with the original module API
export async function isFirstLaunch(): Promise<boolean> {
  return databaseManager.isFirstLaunch();
}

export async function initializeAppOnFirstLaunch(): Promise<void> {
  return databaseManager.initializeAppOnFirstLaunch();
}

export async function initializeAsyncDb(): Promise<void> {
  // This is now handled by the DatabaseManager initialize method
  await databaseManager.initialize();
}

export async function getBongHitStatsFromPastWeek(): Promise<BongHitStats> {
  return databaseManager.getBongHitStatsFromPastWeek();
}

export async function queryNumberOfHitsFromPastWeek(): Promise<Datapoint[]> {
  return databaseManager.queryNumberOfHitsFromPastWeek();
}

export async function getDailyAverageDatapoints(): Promise<AverageHourCount[]> {
  return databaseManager.getDailyAverageDatapoints();
}

export async function getDailyStats(timeRange: string) {
  return databaseManager.getDailyStats(timeRange);
}

export async function getSavedDevices(): Promise<SavedDevice[]> {
  return databaseManager.getSavedDevices();
}

export async function saveDevices(devices: Device[]): Promise<void> {
  return databaseManager.saveDevices(devices);
} 

================================================================================
File: src/dbchecker/dbValidator.ts
================================================================================

import { databaseManager } from "../DatabaseManager";
import { 
  BONG_HITS_DATABASE_NAME, 
  STRAINS_DATABASE_NAME 
} from "../constants";
import { DatabaseResponse, Strain } from "../types";

/**
 * DbValidator - Utility to validate the database implementation
 * Runs a series of checks to verify that everything is working correctly
 */
export class DbValidator {
  public static async validateDatabaseSetup(): Promise<ValidationResult> {
    console.log('[DbValidator] Starting database validation...');
    const results: ValidationResult = {
      success: true,
      errors: [],
      warnings: [],
      componentResults: {},
    };

    // Validate database manager
    try {
      await this.validateDatabaseManager(results);
    } catch (error) {
      results.success = false;
      results.errors.push(`DatabaseManager validation failed: ${error instanceof Error ? error.message : String(error)}`);
    }

    console.log('[DbValidator] Database validation completed.');
    console.log('[DbValidator] Success:', results.success);
    
    if (results.errors.length) {
      console.error('[DbValidator] Errors:', results.errors);
    }
    
    if (results.warnings.length) {
      console.warn('[DbValidator] Warnings:', results.warnings);
    }

    return results;
  }

  private static async validateDatabaseManager(results: ValidationResult): Promise<void> {
    console.log('[DbValidator] Validating DatabaseManager...');
    
    // Check if we can initialize
    await databaseManager.ensureInitialized();
    
    // Check if database connections work
    const bongHitsDb = await databaseManager.getDatabase(BONG_HITS_DATABASE_NAME);
    const strainsDb = await databaseManager.getDatabase(STRAINS_DATABASE_NAME);
    
    // Validate BongHits table exists
    try {
      const bongHitsTableInfo = await bongHitsDb.getAllAsync('PRAGMA table_info(bong_hits)');
      results.componentResults.bongHitsTableExists = bongHitsTableInfo.length > 0;
      
      if (!results.componentResults.bongHitsTableExists) {
        results.warnings.push('BongHits table does not exist');
      }
    } catch (error) {
      results.componentResults.bongHitsTableExists = false;
      results.warnings.push(`Error checking BongHits table: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Validate Strains table exists
    try {
      const strainsTableInfo = await strainsDb.getAllAsync('PRAGMA table_info(strains)');
      results.componentResults.strainsTableExists = strainsTableInfo.length > 0;
      
      if (!results.componentResults.strainsTableExists) {
        results.warnings.push('Strains table does not exist');
      }
    } catch (error) {
      results.componentResults.strainsTableExists = false;
      results.warnings.push(`Error checking Strains table: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if transactions work
    try {
      await databaseManager.executeTransactionByName(BONG_HITS_DATABASE_NAME, async (db) => {
        const result = await db.getAllAsync('SELECT 1 as test');
        return result;
      });
      results.componentResults.transactionsWork = true;
    } catch (error) {
      results.componentResults.transactionsWork = false;
      results.errors.push(`Transactions failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can get weekly stats
    try {
      const weeklyStats = await databaseManager.getWeeklyStats();
      results.componentResults.weeklyStatsWork = weeklyStats.success;
      
      if (!weeklyStats.success) {
        results.warnings.push(`Weekly stats failed: ${weeklyStats.error}`);
      }
    } catch (error) {
      results.componentResults.weeklyStatsWork = false;
      results.warnings.push(`Weekly stats failed with exception: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can get strain data
    try {
      const popularStrains: Strain[] = await databaseManager.getPopularStrains(1);
      if (popularStrains && popularStrains.length > 0) {
        results.componentResults.strainsDataWorks = true;
      } else {
        results.componentResults.strainsDataWorks = false;
        results.warnings.push('No strain data returned');
      }
    } catch (error) {
      results.componentResults.strainsDataWorks = false;
      results.warnings.push(`Strain data retrieval failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Check if we can perform AsyncStorage operations
    try {
      const testKey = 'dbValidator_test';
      const testValue = { test: true, timestamp: Date.now() };
      
      await databaseManager.setValue(testKey, testValue);
      const retrievedValue = await databaseManager.getValue<{ test: boolean; timestamp: number }>(testKey);
      
      results.componentResults.asyncStorageWorks = 
        retrievedValue !== null && typeof retrievedValue === 'object' && 'test' in retrievedValue;
      
      // Clean up
      await databaseManager.removeValue(testKey);
    } catch (error) {
      results.componentResults.asyncStorageWorks = false;
      results.errors.push(`AsyncStorage operations failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    console.log('[DbValidator] DatabaseManager validation completed');
  }
}

export interface ValidationResult {
  success: boolean;
  errors: string[];
  warnings: string[];
  componentResults: {
    [key: string]: boolean | undefined;
    bongHitsTableExists?: boolean;
    strainsTableExists?: boolean;
    transactionsWork?: boolean;
    asyncStorageWorks?: boolean;
    expoSqliteWorks?: boolean;
    weeklyStatsWork?: boolean;
    strainsDataWorks?: boolean;
  };
}

// Export a function to run the validation
export async function validateDatabase(): Promise<ValidationResult> {
  return DbValidator.validateDatabaseSetup();
}

export default validateDatabase; 

================================================================================
File: src/hooks/useAIRecommendations.ts
================================================================================

import { useState, useEffect, useCallback, useRef } from 'react';
import { AIService } from '../services/ai';
import { ChatRequest } from '../services/ai/types/requests';
import { databaseManager } from '../DatabaseManager';
import { 
  RecommendationRequest, 
  RecommendationResponse, 
  ChatMessage, 
  UserProfile,
  JournalEntry,
  SafetyValidationResult,
  SafetyRecord
} from '../types';
import { DatabaseResponse } from '../types';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Cache keys
const RECOMMENDATIONS_CACHE_KEY = 'ai_recommendations_cache';
const RECOMMENDATIONS_CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

export const useAIRecommendations = () => {
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [recommendations, setRecommendations] = useState<RecommendationResponse | null>(null);
  const [safetyValidation, setSafetyValidation] = useState<SafetyValidationResult | null>(null);
  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  
  // Track initialization state
  const isInitialized = useRef<boolean>(false);
  const cleanupCalled = useRef<boolean>(false);
  
  // Get AIService instance
  const aiService = AIService.getInstance();
  
  // Initialize services
  useEffect(() => {
    const initServices = async () => {
      if (isInitialized.current) return;
      
      try {
        // First ensure database is initialized
        await databaseManager.ensureInitialized();
        
        // Then initialize AI service
        await aiService.initialize();
        
        isInitialized.current = true;
        
        // Load cached recommendations only after initialization
        await loadCachedRecommendations();
      } catch (err) {
        console.error('Error initializing AI or Database services:', err);
        setError('Failed to initialize recommendation services');
      }
    };
    
    initServices();
    
    return () => {
      // Cleanup only if not already called
      if (!cleanupCalled.current) {
        cleanupCalled.current = true;
      }
    };
  }, []);
  
  // Load cached recommendations
  const loadCachedRecommendations = async () => {
    try {
      const cachedData = await AsyncStorage.getItem(RECOMMENDATIONS_CACHE_KEY);
      
      if (cachedData) {
        const { recommendations: cachedRecommendations, timestamp } = JSON.parse(cachedData);
        
        // Check if cache is still valid
        if (Date.now() - timestamp < RECOMMENDATIONS_CACHE_EXPIRY) {
          setRecommendations(cachedRecommendations);
        }
      }
    } catch (err) {
      console.warn('Error loading cached recommendations:', err);
      // Non-critical error, don't set error state
    }
  };
  
  // Cache recommendations
  const cacheRecommendations = async (recommendations: RecommendationResponse) => {
    try {
      await AsyncStorage.setItem(
        RECOMMENDATIONS_CACHE_KEY,
        JSON.stringify({
          recommendations,
          timestamp: Date.now()
        })
      );
    } catch (err) {
      console.warn('Error caching recommendations:', err);
      // Non-critical error, don't set error state
    }
  };
  
  // Get strain recommendations with safety checks
  const getRecommendations = useCallback(async (
    request: RecommendationRequest,
    recentEntries: JournalEntry[] = []
  ): Promise<RecommendationResponse | null> => {
    setLoading(true);
    setError(null);
    
    try {
      // Validate request for safety concerns
      const validationResult = await databaseManager.validateRecommendationRequest(request);
      setSafetyValidation(validationResult);
      
      // If request is invalid due to safety concerns, return early
      if (!validationResult.valid) {
        setError(validationResult.reason || 'Request failed safety validation');
        setLoading(false);
        return null;
      }
      
      // Apply any safety modifications to the request
      const safeRequest = validationResult.modifications 
        ? { ...request, ...validationResult.modifications }
        : request;
      
      // Get recommendations from AI service
      const rawRecommendations = await aiService.getRecommendations(safeRequest);
      
      // Process recommendations through safety service
      const safeRecommendations = await databaseManager.processRecommendationResponse(
        rawRecommendations,
        request.userProfile,
        recentEntries
      );
      
      // Update state and cache
      setRecommendations(safeRecommendations);
      cacheRecommendations(safeRecommendations);
      
      setLoading(false);
      return safeRecommendations;
      
    } catch (err) {
      console.error('Error getting recommendations:', err);
      setError('Failed to get recommendations. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [aiService]);
  
  // Get chat response
  const getChatResponse = useCallback(async (
    message: string,
    userProfile: UserProfile
  ): Promise<ChatMessage | null> => {
    setLoading(true);
    setError(null);
    
    try {
      // Add user message to history
      const userMessage: ChatMessage = {
        id: `user_${Date.now()}`,
        content: message,
        role: 'user',
        timestamp: new Date().toISOString()
      };
      
      setChatHistory(prev => [...prev, userMessage]);
      
      // Create chat request - convert ChatMessage to the simplified format expected by AIService
      const chatRequest: ChatRequest = {
        message,
        userProfile,
        // Only include the role and content properties that AIService needs
        previousMessages: chatHistory.length > 0 
          ? chatHistory.map(msg => ({ 
              role: msg.role, 
              content: msg.content 
            })) as any // Use type assertion to bypass the type check
          : undefined
      };
      
      // Get AI response
      const aiResponseData = await aiService.getChatResponse(chatRequest);
      
      // Create chat message from response
      const aiResponseMessage: ChatMessage = {
        id: `assistant_${Date.now()}`,
        content: aiResponseData.response,
        role: 'assistant',
        timestamp: new Date().toISOString()
      };
      
      // Add AI response to history
      setChatHistory(prev => [...prev, aiResponseMessage]);
      
      setLoading(false);
      return aiResponseMessage;
      
    } catch (err) {
      console.error('Error getting chat response:', err);
      setError('Failed to get response. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [chatHistory, aiService]);
  
  // Analyze journal patterns
  const analyzeJournalPatterns = useCallback(async (
    entries: JournalEntry[],
    userProfile: UserProfile
  ) => {
    setLoading(true);
    setError(null);
    
    try {
      const analysis = await aiService.analyzeJournalEntries(userProfile.id, entries);
      setLoading(false);
      return analysis;
      
    } catch (err) {
      console.error('Error analyzing journal patterns:', err);
      setError('Failed to analyze journal entries. Please try again later.');
      setLoading(false);
      return null;
    }
  }, [aiService]);
  
  // Clear chat history
  const clearChatHistory = useCallback(() => {
    setChatHistory([]);
  }, []);
  
  // Get safety history
  const getSafetyHistory = useCallback(async (userId: string) => {
    try {
      return await databaseManager.getSafetyHistory(userId);
    } catch (err) {
      console.error('Error getting safety history:', err);
      return [];
    }
  }, []);
  
  return {
    loading,
    error,
    recommendations,
    safetyValidation,
    chatHistory,
    getRecommendations,
    getChatResponse,
    analyzeJournalPatterns,
    clearChatHistory,
    getSafetyHistory
  };
};

export default useAIRecommendations; 

================================================================================
File: src/hooks/useDataService.ts
================================================================================

import { useState, useEffect } from 'react';
import { databaseManager } from '@/src/DatabaseManager';
import { DataState, ChartDataPoint, UsageStats, WeekdayStats } from '@/src/types';

const DEFAULT_STATE: DataState = {
  weeklyData: [],
  monthlyData: [],
  usageStats: {
    averageHitsPerDay: 0,
    totalHits: 0,
    peakDayHits: 0,
    lowestDayHits: 0,
    averageDuration: 0,
    longestHit: 0,
    shortestHit: 0,
    mostActiveHour: 0,
    leastActiveHour: 0,
    totalDuration: 0,
    averageHitsPerHour: 0,
    consistency: 0,
    weekdayStats: {
      weekday: { avg: 0, total: 0 },
      weekend: { avg: 0, total: 0 }
    }
  },
  timeDistribution: {
    morning: 0,
    afternoon: 0,
    evening: 0,
    night: 0
  },
  isLoading: true,
  error: null
};

export function useDataService() {
  const [state, setState] = useState<DataState>(DEFAULT_STATE);

  useEffect(() => {
    let isMounted = true;

    const loadData = async () => {
      try {
        // Log for debugging
        console.log('[useDataService] Starting data fetch...');

        // Set initial loading state
        if (!isMounted) return;
        setState(prev => ({ ...prev, isLoading: true, error: null }));

        // Fetch data sequentially to avoid race conditions
        console.log('[useDataService] Fetching weekly stats...');
        const weeklyStats = await databaseManager.getWeeklyStats();
        if (!isMounted) return;
        console.log('[useDataService] Weekly stats:', weeklyStats);

        console.log('[useDataService] Fetching monthly stats...');
        const monthlyStats = await databaseManager.getMonthlyStats();
        if (!isMounted) return;
        console.log('[useDataService] Monthly stats:', monthlyStats);

        console.log('[useDataService] Fetching usage stats...');
        const usageStats = await databaseManager.getUsageStats();
        if (!isMounted) return;
        console.log('[useDataService] Usage stats:', usageStats);

        console.log('[useDataService] Fetching time distribution...');
        const timeDistribution = await databaseManager.getTimeDistribution();
        if (!isMounted) return;
        console.log('[useDataService] Time distribution:', timeDistribution);

        // Collect any errors from the responses
        const errors: string[] = [];
        if (!weeklyStats.success) errors.push(`Weekly stats: ${weeklyStats.error}`);
        if (!monthlyStats.success) errors.push(`Monthly stats: ${monthlyStats.error}`);
        if (!usageStats.success) errors.push(`Usage stats: ${usageStats.error}`);
        if (!timeDistribution.success) errors.push(`Time distribution: ${timeDistribution.error}`);

        if (errors.length > 0) {
          const errorMessage = errors.join('; ');
          console.error('[useDataService] Data fetch errors:', errorMessage);
          if (isMounted) {
            setState(prev => ({
              ...prev,
              isLoading: false,
              error: errorMessage
            }));
          }
          return;
        }

        // Update state only if all requests succeeded and component is mounted
        console.log('[useDataService] All data fetched successfully, updating state...');
        if (isMounted) {
          setState({
            ...DEFAULT_STATE,
            weeklyData: weeklyStats.data!,
            monthlyData: monthlyStats.data!,
            usageStats: {
              ...DEFAULT_STATE.usageStats,
              ...usageStats.data!
            },
            timeDistribution: timeDistribution.data!,
            isLoading: false,
            error: null
          });
        }
      } catch (error) {
        console.error('[useDataService] Unexpected error in loadData:', error);
        if (isMounted) {
          setState(prev => ({
            ...prev,
            isLoading: false,
            error: error instanceof Error ? error.message : 'An unexpected error occurred while fetching data'
          }));
        }
      }
    };

    loadData();

    return () => {
      console.log('[useDataService] Cleaning up...');
      isMounted = false;
    };
  }, []); // Empty dependency array as we only want to run this once

  return state;
} 

================================================================================
File: src/hooks/useStrains.ts
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { StrainSearchFilters, PaginationParams } from '../DatabaseManager';
import { databaseManager } from '../DatabaseManager';
import { Strain } from "../types";

export interface UseStrainState {
  strains: Strain[];
  popularStrains: Strain[];
  categories: { [key: string]: number };
  isLoading: boolean;
  error: string | null;
  pagination: {
    total: number;
    currentPage: number;
    totalPages: number;
    hasMore: boolean;
  };
}

export interface UseStrainActions {
  searchStrains: (query: string, filters: StrainSearchFilters) => Promise<void>;
  loadMore: () => void;
  toggleFavorite: (strainId: number) => Promise<void>;
  isFavorite: (strainId: number) => boolean;
  clearSearch: () => void;
  getStrainDetails: (id: number) => Promise<Strain | null>;
  getRelatedStrains: (strain: Strain) => Promise<Strain[]>;
}

const INITIAL_STATE: UseStrainState = {
  strains: [],
  popularStrains: [],
  categories: {},
  isLoading: false,
  error: null,
  pagination: {
    total: 0,
    currentPage: 1,
    totalPages: 1,
    hasMore: false
  }
};

export function useStrains(): UseStrainState & UseStrainActions {
  const [state, setState] = useState<UseStrainState>(INITIAL_STATE);
  const [filters, setFilters] = useState<StrainSearchFilters>({});
  const [favoriteStrains, setFavoriteStrains] = useState<number[]>([]);

  // Load initial data
  useEffect(() => {
    loadInitialData();
  }, []);

  const loadInitialData = async () => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      
      const [popularStrains, categories] = await Promise.all([
        databaseManager.getPopularStrains(),
        databaseManager.getStrainCategories()
      ]);

      setState(prev => ({
        ...prev,
        popularStrains,
        categories,
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Failed to load initial data',
        isLoading: false
      }));
    }
  };

  const searchStrains = useCallback(async (
    query: string,
    newFilters: StrainSearchFilters = {},
    page: number = 1
  ) => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      setFilters(newFilters);

      const result = await databaseManager.searchStrains(query, newFilters, { page, limit: 10 });

      setState(prev => ({
        ...prev,
        strains: page === 1 ? result.data : [...prev.strains, ...result.data],
        pagination: {
          total: result.total,
          currentPage: result.currentPage,
          totalPages: result.totalPages,
          hasMore: result.hasMore
        },
        isLoading: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Search failed',
        isLoading: false
      }));
    }
  }, []);

  const loadMore = useCallback(() => {
    if (state.pagination.hasMore && !state.isLoading) {
      const nextPage = state.pagination.currentPage + 1;
      searchStrains('', filters, nextPage);
    }
  }, [state.pagination, state.isLoading, filters, searchStrains]);

  const toggleFavorite = useCallback(async (strainId: number) => {
    setFavoriteStrains(prev => {
      const isFavorited = prev.includes(strainId);
      return isFavorited 
        ? prev.filter(id => id !== strainId)
        : [...prev, strainId];
    });
  }, []);

  const isFavorite = useCallback((strainId: number) => {
    return favoriteStrains.includes(strainId);
  }, [favoriteStrains]);

  const clearSearch = useCallback(() => {
    setState(prev => ({
      ...prev,
      strains: [],
      pagination: {
        total: 0,
        currentPage: 1,
        totalPages: 1,
        hasMore: false
      }
    }));
  }, []);

  const getStrainDetails = useCallback(async (id: number): Promise<Strain | null> => {
    try {
      return await databaseManager.getStrainById(id);
    } catch (error) {
      console.error('[useStrains] Error getting strain details:', error);
      return null;
    }
  }, []);

  const getRelatedStrains = useCallback(async (strain: Strain): Promise<Strain[]> => {
    try {
      return await databaseManager.getRelatedStrains(strain);
    } catch (error) {
      console.error('[useStrains] Error getting related strains:', error);
      return [];
    }
  }, []);

  return {
    ...state,
    searchStrains,
    loadMore,
    toggleFavorite,
    isFavorite,
    clearSearch,
    getStrainDetails,
    getRelatedStrains
  };
} 

================================================================================
File: src/hooks/useTimeRangeData.ts
================================================================================

import { useState, useCallback, useEffect } from 'react';
import { useDataService } from './useDataService';

export type TimeRange = 'D' | 'W' | 'M' | 'Y';

interface TimeRangeData {
  chartData: number[];
  chartLabels: string[];
  averageValue: number;
  maxValue: number;
  minValue: number;
  weekdayAvg?: number;
  weekendAvg?: number;
}

export function useTimeRangeData(initialRange: TimeRange = 'W') {
  const { weeklyData, monthlyData, usageStats, isLoading: isDataLoading, error: dataError } = useDataService();
  const [timeRange, setTimeRange] = useState<TimeRange>(initialRange);
  const [data, setData] = useState<TimeRangeData>({
    chartData: [],
    chartLabels: [],
    averageValue: 0,
    maxValue: 0,
    minValue: 0,
    weekdayAvg: 0,
    weekendAvg: 0
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Function to fetch data based on time range
  const fetchDataByTimeRange = useCallback(async (range: TimeRange) => {
    if (isDataLoading || dataError) return;
    const averageValue = usageStats.averageHitsPerDay;
    const maxValue = usageStats.peakDayHits; // Use the peak day value
    const minValue = usageStats.lowestDayHits > 0 ? usageStats.lowestDayHits : 0;
    setIsLoading(true);
    setError(null);
    
    try {
      // In a real implementation, this would call your data service
      // For now, we'll use the existing data and simulate different time ranges
      let chartData: number[] = [];
      let chartLabels: string[] = [];
      
      switch(range) {
        case 'D': // Daily (hours)
          // Simulate hourly data for today
          chartData = Array.from({ length: 24 }, () => Math.floor(Math.random() * 10));
          chartLabels = Array.from({ length: 24 }, (_, i) => `${i}:00`);
          break;
        case 'W': // Weekly (days)
          // Use the existing weekly data
          chartData = weeklyData.map(d => d.value);
          chartLabels = weeklyData.map(d => d.label);
          break;
        case 'M': // Monthly (days)
          // Simulate daily data for a month
          chartData = Array.from({ length: 30 }, () => Math.floor(Math.random() * 20));
          chartLabels = Array.from({ length: 30 }, (_, i) => `${i+1}`);
          break;
        case 'Y': // Yearly (months)
          // Use the existing monthly data
          chartData = monthlyData.map(d => d.value);
          chartLabels = monthlyData.map(d => d.label);
          break;
      }

      let weekdayAvg = usageStats.weekdayStats?.weekday.avg || 0;
      let weekendAvg = usageStats.weekdayStats?.weekend.avg || 0;
      
      if (range !== 'W') {
        // Simulate different stats for other time ranges
        weekdayAvg = averageValue * 0.9; // Slightly lower for weekdays
        weekendAvg = averageValue * 1.2; // Slightly higher for weekends
      }
      
      setData({
        chartData,
        chartLabels,
        averageValue,
        maxValue,
        minValue,
        weekdayAvg,
        weekendAvg
      });
    } catch (err) {
      console.error("Error fetching time range data:", err);
      setError(err instanceof Error ? err.message : "An unknown error occurred");
    } finally {
      setIsLoading(false);
    }
  }, [weeklyData, monthlyData, usageStats, isDataLoading, dataError]);

  // Update data when time range changes
  useEffect(() => {
    fetchDataByTimeRange(timeRange);
  }, [timeRange, fetchDataByTimeRange]);

  return {
    timeRange,
    setTimeRange,
    data,
    isLoading: isLoading || isDataLoading,
    error: error || dataError,
    fetchDataByTimeRange
  };
} 

================================================================================
File: src/services/ai/AIService.ts
================================================================================

import * as Logger from './utils/logging';
import { DatabaseManager } from './database/DatabaseManager';
import { CacheManager } from './cache/CacheManager';
import { FeedbackService } from './feedback/FeedbackService';
import { AnthropicAPI } from './api/AnthropicAPI';
import { AIServiceError, AIServiceErrorType } from './types/errors';
import { 
  RecommendationRequest, 
  ChatRequest 
} from './types/requests';
import { 
  RecommendationResponse, 
  ChatResponse,
  JournalAnalysisResult,
  SafetyValidationResult,
  DrugInteractionResult,
  OveruseDetectionResult
} from './types/responses';
import { UserFeedback, QualityScore } from './types/feedback';
import { DEFAULT_CACHE_TTL } from './types/common';
// Import types from the main app types
import { 
  UserProfile, 
  JournalEntry, 
  StrainRecommendation, 
  DosageSuggestion,
  ChatMessage
} from '../../types';
import { MemoryCache } from './cache/MemoryCache';
import { PersistentCache } from './cache/PersistentCache';
import { databaseManager } from "../../DatabaseManager";
import { Strain } from "@/src/types";

const MODULE_NAME = 'AIService';

/**
 * AI Service
 * Main service for AI-powered features in the Canova app
 */
export class AIService {
  private static instance: AIService;
  private cacheManager: CacheManager;
  private feedbackService: FeedbackService;
  private api: AnthropicAPI;
  private initialized: boolean = false;
  private useMockResponses: boolean = false;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {
    this.cacheManager = CacheManager.getInstance();
    this.feedbackService = FeedbackService.getInstance();
    this.api = new AnthropicAPI();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of AIService
   */
  public static getInstance(): AIService {
    if (!AIService.instance) {
      AIService.instance = new AIService();
    }
    return AIService.instance;
  }

  /**
   * Initialize the AI service and its dependencies
   */
  public async initialize(): Promise<void> {
    // If already initialized, return immediately
    if (this.initialized) {
      return;
    }
    
    // If initialization is in progress, wait for it to complete
    if (this.initializationPromise) {
      return this.initializationPromise;
    }

    console.info('[AIService] Initializing AI service');
    
    // Create a promise for initialization
    this.initializationPromise = (async () => {
      try {
        // First ensure DatabaseManager is initialized
        await databaseManager.ensureInitialized();
        
        // Initialize cache manager
        console.info('[CacheManager] Initializing cache manager');
        this.cacheManager = CacheManager.getInstance();
        await this.cacheManager.initialize();
        console.info('[CacheManager] Cache manager initialized successfully');
        
        // Initialize feedback service (after cache manager)
        console.info('[FeedbackService] Initializing feedback service');
        this.feedbackService = FeedbackService.getInstance();
        await this.feedbackService.initialize();
        console.info('[FeedbackService] Feedback service initialized successfully');
        
        // Initialize API client - use existing method
        this.api = new AnthropicAPI();
        
        this.initialized = true;
        console.info('[AIService] AI service initialized successfully');
      } catch (error) {
        console.error('[AIService] Failed to initialize:', error);
        throw error;
      } finally {
        this.initializationPromise = null;
      }
    })();
    
    return this.initializationPromise;
  }

  /**
   * Configure the AI service
   */
  public configure(options: {
    useMockResponses?: boolean;
    cacheEnabled?: boolean;
    cacheTtl?: number;
    cacheMaxSize?: number;
  }): void {
    if (options.useMockResponses !== undefined) {
      this.useMockResponses = options.useMockResponses;
      Logger.info(MODULE_NAME, `Mock responses ${this.useMockResponses ? 'enabled' : 'disabled'}`);
    }
    
    // Configure cache if options provided
    if (options.cacheEnabled !== undefined || options.cacheTtl !== undefined || options.cacheMaxSize !== undefined) {
      try {
        this.cacheManager.configure(
          options.cacheEnabled ?? true,
          options.cacheTtl ?? DEFAULT_CACHE_TTL,
          options.cacheMaxSize ?? 100
        );
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to configure cache manager');
      }
    }
  }

  /**
   * Check if the service is initialized
   */
  private checkInitialized(): void {
    if (!this.initialized) {
      console.warn('[AIService] AI service not initialized, initializing now...');
      // Instead of throwing an error, start initialization and continue
      // This prevents errors when components try to use the service before initialization
      this.initialize().catch(err => {
        console.error('[AIService] Initialization failed:', err);
      });
    }
  }

  /**
   * Get real strain recommendations from the database based on user preferences
   */
  private async getRealStrainRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    try {
      Logger.info(MODULE_NAME, 'Getting real strain recommendations from database');
      
      // Extract desired effects from the request
      const { desiredEffects, context, medicalNeeds } = request;
      Logger.info(MODULE_NAME, `Desired effects: ${desiredEffects.join(', ')}`);
      
      // Get all strains from the database
      const allStrainsResult = await databaseManager.searchStrains('', {}, { page: 1, limit: 100 });
      Logger.info(MODULE_NAME, `All strains search result: Found ${allStrainsResult.data?.length || 0} strains`);
      
      if (!allStrainsResult.data || allStrainsResult.data.length === 0) {
        Logger.warn(MODULE_NAME, 'No strains found in database at all');
        return this.getMockRecommendations(request); // Fallback to mock data if no results
      }
      
      // Log some sample effects from the database to understand what's available
      const sampleEffects = allStrainsResult.data.slice(0, 5).map((strain: Strain) => {
        return `${strain.name}: ${strain.effects}`;
      });
      Logger.info(MODULE_NAME, `Sample effects in database: ${sampleEffects.join(' | ')}`);
      
      // Use the AI to interpret the natural language query and match it to strain effects
      const matchedStrains = await this.matchStrainsWithAI(desiredEffects, allStrainsResult.data, context, medicalNeeds);
      
      // If we don't have any recommendations, use mock data
      if (!matchedStrains || matchedStrains.length === 0) {
        Logger.warn(MODULE_NAME, 'No matching strains found after AI matching');
        return this.getMockRecommendations(request);
      }
      
      // Log the top 5 scored strains
      const topScores = matchedStrains.slice(0, 5).map(s => `${s.strain.name}: ${s.matchScore}%`);
      Logger.info(MODULE_NAME, `Top scored strains: ${topScores.join(', ')}`);
      
      // Take top 5 recommendations
      const topRecommendations = matchedStrains
        .slice(0, 5)
        .map(s => ({
          strainId: s.strain.id || 0,
          strainName: s.strain.name,
          matchScore: s.matchScore,
          reasoningFactors: s.reasoningFactors,
          alternativeStrains: [] // Could be populated with similar strains
        }));
      
      Logger.info(MODULE_NAME, `Returning ${topRecommendations.length} recommendations`);
      
      return {
        recommendations: topRecommendations,
        reasoning: `Based on your request for "${desiredEffects.join(', ')}", I've found strains that are likely to match your preferences.`,
        confidenceScore: 90,
        disclaimers: [
          'Individual experiences may vary',
          'Start with a low dose and gradually increase as needed',
          'Consult with a healthcare professional before use, especially if you have medical conditions or take medications'
        ],
        dosageSuggestion: {
          minDosage: 5,
          maxDosage: 10,
          unit: 'mg THC',
          gradualApproach: true,
          notes: 'Start low and go slow. Wait at least 2 hours before consuming more edibles.'
        },
        safetyNotes: [
          'Do not drive or operate heavy machinery after use',
          'Keep out of reach of children and pets',
          'Store in a cool, dry place away from direct sunlight'
        ]
      };
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get real strain recommendations');
      // Fallback to mock data if there's an error
      return this.getMockRecommendations(request);
    }
  }

  /**
   * Use AI to match strains with natural language queries
   */
  private async matchStrainsWithAI(
    desiredEffects: string[], 
    strains: Strain[], 
    context?: string,
    medicalNeeds?: string[]
  ): Promise<Array<{
    strain: Strain;
    matchScore: number;
    reasoningFactors: Array<{ factor: string; weight: number }>;
  }>> {
    try {
      // If we're not using the real API, use a simpler matching approach
      if (this.useMockResponses) {
        return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
      }
      
      // Create a prompt for the AI to match strains
      const prompt = `
        You are an expert cannabis strain matcher. I need you to match the following user's desired effects with the most appropriate strains from our database.
        
        User's desired effects: "${desiredEffects.join(', ')}"
        ${context ? `Context: ${context}` : ''}
        ${medicalNeeds && medicalNeeds.length > 0 ? `Medical needs: ${medicalNeeds.join(', ')}` : ''}
        
        Here are the available strains with their effects:
        ${strains.slice(0, 50).map(strain => 
          `- ${strain.name} (${strain.genetic_type}, THC: ${strain.thc_range}): ${strain.effects}${strain.uses ? ` | Uses: ${strain.uses}` : ''}`
        ).join('\n')}
        
        Please analyze the user's request and match it with the most appropriate strains. For each matched strain, provide:
        1. The strain name
        2. A match score (0-100)
        3. 2-3 specific reasoning factors explaining why this strain matches the user's request
        
        Return your response as a JSON array with the following structure:
        [
          {
            "strainName": "Strain Name",
            "matchScore": 85,
            "reasoningFactors": [
              {"factor": "Specific reason this strain matches", "weight": 0.5},
              {"factor": "Another specific reason", "weight": 0.3},
              {"factor": "Additional information about the strain", "weight": 0.2}
            ]
          }
        ]
        
        Only include strains with a match score above 50. Limit your response to the top 10 matches.
      `;
      
      // Call the AI API
      const response = await this.api.sendMessage([
        { role: 'user', content: prompt }
      ], 2000, 0.7);
      
      // Parse the response
      try {
        // Extract JSON from the response (it might be wrapped in markdown code blocks)
        const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)\s*```/) || 
                          response.match(/\[\s*\{\s*"strainName"/);
        
        const jsonStr = jsonMatch ? jsonMatch[1] || response : response;
        const matches = JSON.parse(jsonStr);
        
        if (!Array.isArray(matches)) {
          throw new Error('Response is not an array');
        }
        
        // Map the AI matches to our strain objects
        const matchedStrains = matches.map(match => {
          // Find the corresponding strain object
          const strain = strains.find(s => s.name === match.strainName);
          
          if (!strain) {
            Logger.warn(MODULE_NAME, `Strain not found: ${match.strainName}`);
            return null;
          }
          
          return {
            strain,
            matchScore: match.matchScore,
            reasoningFactors: match.reasoningFactors
          };
        }).filter((match): match is { 
          strain: Strain; 
          matchScore: number; 
          reasoningFactors: Array<{ factor: string; weight: number }> 
        } => match !== null);
        
        Logger.info(MODULE_NAME, `AI matched ${matchedStrains.length} strains`);
        
        return matchedStrains;
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, 'Failed to parse AI strain matching response');
        // Fallback to simple matching
        return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to match strains with AI');
      // Fallback to simple matching
      return this.matchStrainsSimple(desiredEffects, strains, context, medicalNeeds);
    }
  }
  
  /**
   * Simple strain matching algorithm as a fallback
   */
  private matchStrainsSimple(
    desiredEffects: string[], 
    strains: Strain[], 
    context?: string,
    medicalNeeds?: string[]
  ): Array<{
    strain: Strain;
    matchScore: number;
    reasoningFactors: Array<{ factor: string; weight: number }>;
  }> {
    // Common cannabis effects for basic matching
    const commonEffects = {
      'happy': ['euphoric', 'uplifted', 'joyful', 'cheerful', 'blissful'],
      'relaxed': ['calm', 'peaceful', 'tranquil', 'mellow', 'soothing'],
      'creative': ['inspired', 'imaginative', 'artistic', 'focused'],
      'energetic': ['active', 'lively', 'stimulating', 'invigorating'],
      'sleepy': ['sedated', 'drowsy', 'restful', 'sleep', 'tired'],
      'hungry': ['appetite', 'munchies', 'food'],
      'pain relief': ['analgesic', 'pain', 'ache', 'sore'],
      'stress relief': ['stress', 'anxiety', 'tension', 'worry']
    };
    
    // Score each strain
    const scoredStrains = strains.map(strain => {
      // Parse effects into an array
      const strainEffects = strain.effects.split(',').map(e => e.trim().toLowerCase());
      
      // Calculate a basic match score
      let matchScore = 0;
      const matchedEffects: string[] = [];
      
      // Check each desired effect against strain effects
      desiredEffects.forEach(desiredEffect => {
        const desiredLower = desiredEffect.toLowerCase();
        
        // Direct match
        const directMatch = strainEffects.some(effect => 
          effect.includes(desiredLower) || desiredLower.includes(effect)
        );
        
        if (directMatch) {
          matchScore += 25;
          matchedEffects.push(desiredEffect);
          return;
        }
        
        // Check against common effects
        for (const [effect, synonyms] of Object.entries(commonEffects)) {
          // If desired effect contains this effect or synonyms
          if (desiredLower.includes(effect) || synonyms.some(s => desiredLower.includes(s))) {
            // Check if strain has this effect
            const hasEffect = strainEffects.some(strainEffect => 
              strainEffect.includes(effect) || synonyms.some(s => strainEffect.includes(s))
            );
            
            if (hasEffect) {
              matchScore += 20;
              matchedEffects.push(effect);
              return;
            }
          }
        }
        
        // Check for partial word matches
        const desiredWords = desiredLower.split(/\s+/).filter(w => w.length > 3);
        const hasPartialMatch = strainEffects.some(effect => 
          desiredWords.some(word => effect.includes(word))
        );
        
        if (hasPartialMatch) {
          matchScore += 10;
        }
      });
      
      // Boost score for context matches
      if (context === 'medical' && strain.uses && 
          (strain.uses.toLowerCase().includes('medical') || 
           (medicalNeeds && medicalNeeds.some(need => strain.uses.toLowerCase().includes(need.toLowerCase()))))) {
        matchScore += 15;
      } else if (context === 'recreational' && strainEffects.some(e => e.includes('euphoric'))) {
        matchScore += 15;
      }
      
      // Cap score at 100
      matchScore = Math.min(matchScore, 100);
      
      // Create reasoning factors
      const reasoningFactors = [];
      
      if (matchedEffects.length > 0) {
        reasoningFactors.push({
          factor: `Matches your desired effects: ${matchedEffects.join(', ')}`,
          weight: 0.5
        });
      }
      
      if (context === 'medical' && strain.uses) {
        reasoningFactors.push({
          factor: `Good for medical use: ${strain.uses}`,
          weight: 0.3
        });
      }
      
      reasoningFactors.push({
        factor: `${strain.genetic_type} with ${strain.thc_range} THC content`,
        weight: 0.2
      });
      
      return {
        strain,
        matchScore,
        reasoningFactors
      };
    });
    
    // Sort by match score (highest first) and filter out low scores
    return scoredStrains
      .filter(s => s.matchScore > 0)
      .sort((a, b) => b.matchScore - a.matchScore);
  }

  /**
   * Get strain recommendations based on user profile and preferences
   */
  public async getRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Getting strain recommendations');
      
      // Generate a unique response ID
      const responseId = `rec_${Date.now()}`;
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey(request);
      const cachedResponse = await this.cacheManager.get<RecommendationResponse>(cacheKey);
      
      if (cachedResponse) {
        Logger.info(MODULE_NAME, 'Returning cached recommendations');
        // Add the responseId to the cached response
        return { ...cachedResponse, responseId };
      }
      
      // If using mock responses, return a mock response
      if (this.useMockResponses) {
        const mockResponse = this.getMockRecommendations(request);
        
        // Cache the response
        await this.cacheManager.set(cacheKey, mockResponse);
        
        Logger.info(MODULE_NAME, 'Returning mock recommendations');
        return { ...mockResponse, responseId };
      }
      
      // Get real recommendations from the database
      const realRecommendations = await this.getRealStrainRecommendations(request);
      
      // Add the responseId
      const result: RecommendationResponse = {
        ...realRecommendations,
        responseId
      };
      
      // Cache the response
      await this.cacheManager.set(cacheKey, result);
      
      Logger.info(MODULE_NAME, 'Recommendations generated successfully');
      return result;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get recommendations');
      throw error;
    }
  }

  /**
   * Format a recommendation prompt for the AI
   */
  private formatRecommendationPrompt(request: RecommendationRequest): string {
    // Create a detailed prompt for the AI
    return `
      You are an AI assistant for a cannabis recommendation app called Canova.
      Please provide personalized cannabis strain recommendations based on the following user profile and preferences:
      
      User Profile:
      ${JSON.stringify(request.userProfile, null, 2)}
      
      Desired Effects:
      ${request.desiredEffects.join(', ')}
      
      ${request.medicalNeeds ? `Medical Needs: ${request.medicalNeeds.join(', ')}` : ''}
      ${request.context ? `Context: ${request.context}` : ''}
      ${request.locationCode ? `Location Code: ${request.locationCode}` : ''}
      
      ${request.journalEntries ? `Recent Journal Entries:
      ${JSON.stringify(request.journalEntries, null, 2)}` : ''}
      
      Please provide:
      1. A list of 3-5 strain recommendations with detailed information about each
      2. A brief explanation of why each strain was recommended
      3. Suggested dosage guidelines
      4. Any safety considerations or warnings
      
      Format your response as a JSON object with the following structure:
      {
        "recommendations": [
          {
            "name": "Strain Name",
            "type": "Indica/Sativa/Hybrid",
            "thcContent": "THC percentage range",
            "cbdContent": "CBD percentage range",
            "effects": ["effect1", "effect2", ...],
            "medicalBenefits": ["benefit1", "benefit2", ...],
            "flavors": ["flavor1", "flavor2", ...],
            "description": "Detailed description"
          }
        ],
        "reasoning": "Explanation of recommendations",
        "confidenceScore": 0-100,
        "disclaimers": ["disclaimer1", "disclaimer2", ...],
        "dosageSuggestion": {
          "beginner": "Beginner dosage",
          "intermediate": "Intermediate dosage",
          "experienced": "Experienced dosage",
          "notes": "Additional notes"
        },
        "safetyNotes": ["note1", "note2", ...]
      }
    `;
  }

  /**
   * Parse the AI response into a structured recommendation
   */
  private parseRecommendationResponse(response: string): RecommendationResponse {
    try {
      // Try to parse the response as JSON
      const parsedResponse = JSON.parse(response) as RecommendationResponse;
      
      // Validate the response structure
      if (!parsedResponse.recommendations || !Array.isArray(parsedResponse.recommendations)) {
        throw new Error('Invalid response structure: recommendations array missing');
      }
      
      return parsedResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to parse recommendation response');
      
      // If parsing fails, try to extract information from the text response
      // This is a fallback mechanism for when the AI doesn't return valid JSON
      
      // For now, return a simple error response
      return {
        recommendations: [],
        reasoning: 'Failed to parse AI response',
        confidenceScore: 0,
        disclaimers: ['The AI response could not be properly parsed'],
        error: {
          message: 'Failed to parse AI response',
          type: 'parsing_error',
          recoverable: false
        }
      };
    }
  }

  /**
   * Generate mock recommendations for testing
   */
  private getMockRecommendations(request: RecommendationRequest): RecommendationResponse {
    return {
      recommendations: [
        {
          strainId: 1,
          strainName: 'Blue Dream',
          matchScore: 95,
          reasoningFactors: [
            { factor: 'Matches desired effects', weight: 0.5 },
            { factor: 'Good for stress relief', weight: 0.3 },
            { factor: 'Balanced hybrid', weight: 0.2 }
          ],
          alternativeStrains: [
            { strainId: 4, strainName: 'Harlequin', reason: 'Higher CBD content' }
          ]
        },
        {
          strainId: 2,
          strainName: 'OG Kush',
          matchScore: 90,
          reasoningFactors: [
            { factor: 'Strong pain relief', weight: 0.6 },
            { factor: 'Matches user experience level', weight: 0.4 }
          ],
          alternativeStrains: [
            { strainId: 5, strainName: 'Bubba Kush', reason: 'Similar effects with more sedation' }
          ]
        },
        {
          strainId: 3,
          strainName: 'Granddaddy Purple',
          matchScore: 85,
          reasoningFactors: [
            { factor: 'Good for sleep', weight: 0.7 },
            { factor: 'Matches flavor preferences', weight: 0.3 }
          ],
          alternativeStrains: [
            { strainId: 6, strainName: 'Northern Lights', reason: 'Similar relaxation effects' }
          ]
        }
      ],
      reasoning: `Based on the user's profile and preferences, I've recommended strains that align with their desired effects and medical needs. Blue Dream offers a balanced experience, OG Kush provides potent relief, and Granddaddy Purple is excellent for relaxation and sleep.`,
      confidenceScore: 85,
      disclaimers: [
        'Individual experiences may vary',
        'Start with a low dose and gradually increase as needed',
        'Consult with a healthcare professional before use, especially if you have medical conditions or take medications'
      ],
      dosageSuggestion: {
        minDosage: 5,
        maxDosage: 10,
        unit: 'mg THC',
        gradualApproach: true,
        notes: 'Start low and go slow. Wait at least 2 hours before consuming more edibles.'
      },
      safetyNotes: [
        'Do not drive or operate heavy machinery after use',
        'Keep out of reach of children and pets',
        'Store in a cool, dry place away from direct sunlight'
      ]
    };
  }

  /**
   * Submit user feedback for a recommendation
   */
  public async submitRecommendationFeedback(
    userId: string,
    responseId: string,
    helpful: boolean,
    accurate: boolean,
    relevance: number,
    comments?: string
  ): Promise<string> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Submitting recommendation feedback for response: ${responseId}`);
      
      const feedback: UserFeedback = {
        userId,
        responseId,
        responseType: 'recommendation',
        helpful,
        accurate,
        relevance,
        comments,
        timestamp: Date.now()
      };
      
      // Submit the feedback using the feedback service
      const feedbackId = await this.feedbackService.submitFeedback(feedback);
      
      Logger.info(MODULE_NAME, `Recommendation feedback submitted: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit recommendation feedback for response: ${responseId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to submit recommendation feedback',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while submitting your feedback. Please try again later.'
      );
    }
  }

  /**
   * Get a response to a user's chat message
   */
  public async getChatResponse(request: ChatRequest): Promise<ChatResponse> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Getting chat response');
      
      // Generate a unique response ID
      const responseId = `chat_${Date.now()}`;
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey(request);
      const cachedResponse = await this.cacheManager.get<ChatResponse>(cacheKey);
      
      if (cachedResponse) {
        Logger.info(MODULE_NAME, 'Returning cached chat response');
        return cachedResponse;
      }
      
      // If using mock responses, return a mock response
      if (this.useMockResponses) {
        const mockResponse = this.getMockChatResponse(request);
        
        // Cache the response
        await this.cacheManager.set(cacheKey, mockResponse);
        
        Logger.info(MODULE_NAME, 'Returning mock chat response');
        return mockResponse;
      }
      
      // Format messages for the API
      const messages = this.formatChatMessages(request);
      
      // Call the API
      const response = await this.api.sendMessage(messages, 2000, 0.7);
      
      // Parse the response
      const chatResponse = this.parseChatResponse(response);
      
      // Cache the response
      await this.cacheManager.set(cacheKey, chatResponse);
      
      Logger.info(MODULE_NAME, 'Chat response generated successfully');
      return chatResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get chat response');
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to get chat response',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while generating a response. Please try again later.'
      );
    }
  }

  /**
   * Format chat messages for the API
   */
  private formatChatMessages(request: ChatRequest): Array<{ role: 'user' | 'assistant'; content: string }> {
    const messages: Array<{ role: 'user' | 'assistant'; content: string }> = [];
    
    // Add system message with context
    messages.push({
      role: 'user',
      content: `You are an AI assistant for a cannabis app called Canova. You provide helpful, accurate, and educational information about cannabis. 
      
      User Profile:
      ${JSON.stringify(request.userProfile, null, 2)}
      
      ${request.locationCode ? `Location Code: ${request.locationCode}` : ''}
      
      Please provide informative, educational responses. Include relevant scientific information when appropriate. Always prioritize safety and responsible use. If you don't know something, say so rather than providing incorrect information.`
    });
    
    // Add previous messages if available
    if (request.previousMessages && request.previousMessages.length > 0) {
      request.previousMessages.forEach(msg => {
        messages.push({
          role: msg.role as 'user' | 'assistant',
          content: msg.content
        });
      });
    }
    
    // Add the current message
    messages.push({
      role: 'user',
      content: request.message
    });
    
    return messages;
  }

  /**
   * Parse the AI response into a structured chat response
   */
  private parseChatResponse(response: string): ChatResponse {
    // For chat, we can use the response text directly
    const chatResponse: ChatResponse = {
      response: response,
      // Extract educational links if present
      educationalLinks: this.extractLinks(response),
      // Add disclaimers
      disclaimers: [
        'This information is for educational purposes only and not medical advice.',
        'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
      ]
    };
    
    return chatResponse;
  }

  /**
   * Extract links from a text response
   */
  private extractLinks(text: string): string[] {
    const links: string[] = [];
    const linkRegex = /https?:\/\/[^\s]+/g;
    const matches = text.match(linkRegex);
    
    if (matches) {
      matches.forEach(link => {
        links.push(link);
      });
    }
    
    return links;
  }

  /**
   * Generate a mock chat response for testing
   */
  private getMockChatResponse(request: ChatRequest): ChatResponse {
    // Simple mock response based on the request message
    const message = request.message.toLowerCase();
    
    if (message.includes('strain') || message.includes('recommend')) {
      return {
        response: `Based on your profile, I'd recommend considering strains like Blue Dream, OG Kush, or Granddaddy Purple. Blue Dream is a balanced hybrid that provides relaxation without sedation, OG Kush offers potent relief from stress and pain, and Granddaddy Purple is excellent for sleep and deep relaxation. Always start with a low dose, especially if you're new to cannabis.`,
        educationalLinks: ['https://www.leafly.com/strains/blue-dream', 'https://www.leafly.com/strains/og-kush'],
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    } else if (message.includes('cbd') || message.includes('thc')) {
      return {
        response: `THC (tetrahydrocannabinol) and CBD (cannabidiol) are the two most well-known cannabinoids in cannabis. THC is primarily responsible for the psychoactive effects or "high," while CBD is non-intoxicating and associated with various potential therapeutic benefits. The ratio of THC to CBD in a strain can significantly influence its effects. High-THC strains tend to be more intoxicating, while high-CBD strains are often used for their potential therapeutic properties without strong psychoactive effects.`,
        educationalLinks: ['https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5345356/'],
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    } else {
      return {
        response: `Thank you for your question about cannabis. I'm here to provide educational information and guidance based on scientific research. If you have specific questions about strains, effects, consumption methods, or safety considerations, feel free to ask. Remember that individual experiences with cannabis can vary significantly based on factors like body chemistry, tolerance, and the specific product used.`,
        disclaimers: [
          'This information is for educational purposes only and not medical advice.',
          'Consult with a healthcare professional before using cannabis, especially for medical conditions.'
        ]
      };
    }
  }

  /**
   * Submit user feedback for a chat response
   */
  public async submitChatFeedback(
    userId: string,
    responseId: string,
    helpful: boolean,
    accurate: boolean,
    relevance: number,
    comments?: string
  ): Promise<string> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Submitting chat feedback for response: ${responseId}`);
      
      const feedback: UserFeedback = {
        userId,
        responseId,
        responseType: 'chat',
        helpful,
        accurate,
        relevance,
        comments,
        timestamp: Date.now()
      };
      
      // Submit the feedback using the feedback service
      const feedbackId = await this.feedbackService.submitFeedback(feedback);
      
      Logger.info(MODULE_NAME, `Chat feedback submitted: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit chat feedback for response: ${responseId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to submit chat feedback',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while submitting your feedback. Please try again later.'
      );
    }
  }

  /**
   * Analyze journal entries for patterns and insights
   */
  public async analyzeJournalEntries(
    userId: string,
    journalEntries: JournalEntry[]
  ): Promise<JournalAnalysisResult> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, `Analyzing journal entries for user: ${userId}`);
      
      // If no entries, return empty analysis
      if (!journalEntries || journalEntries.length === 0) {
        Logger.info(MODULE_NAME, 'No journal entries to analyze');
        return {
          patterns: [],
          insights: [],
          recommendations: []
        };
      }
      
      // Check cache first
      const cacheKey = this.cacheManager.generateKey({
        userId,
        journalEntries: journalEntries.map(entry => ({
          id: entry.id,
          created_at: entry.created_at
        }))
      });
      
      const cachedAnalysis = await this.cacheManager.get<JournalAnalysisResult>(cacheKey);
      
      if (cachedAnalysis) {
        Logger.info(MODULE_NAME, 'Returning cached journal analysis');
        return cachedAnalysis;
      }
      
      // If using mock responses, return a mock analysis
      if (this.useMockResponses) {
        const mockAnalysis = this.getMockJournalAnalysis(journalEntries);
        
        // Cache the analysis
        await this.cacheManager.set(cacheKey, mockAnalysis);
        
        Logger.info(MODULE_NAME, 'Returning mock journal analysis');
        return mockAnalysis;
      }
      
      // Format the prompt for the AI
      const prompt = this.formatJournalAnalysisPrompt(journalEntries);
      
      // Call the API
      const response = await this.api.sendMessage([
        { role: 'user', content: prompt }
      ], 2000, 0.7);
      
      // Parse the response
      const analysis = this.parseJournalAnalysisResponse(response);
      
      // Cache the analysis
      await this.cacheManager.set(cacheKey, analysis);
      
      Logger.info(MODULE_NAME, 'Journal analysis completed successfully');
      return analysis;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to analyze journal entries for user: ${userId}`);
      
      if (error instanceof AIServiceError) {
        throw error;
      }
      
      throw new AIServiceError(
        'Failed to analyze journal entries',
        AIServiceErrorType.UNKNOWN,
        undefined,
        true,
        'An error occurred while analyzing your journal entries. Please try again later.'
      );
    }
  }

  /**
   * Format a journal analysis prompt for the AI
   */
  private formatJournalAnalysisPrompt(journalEntries: JournalEntry[]): string {
    return `
      You are an AI assistant for a cannabis app called Canova.
      Please analyze the following journal entries to identify patterns, insights, and potential recommendations:
      
      Journal Entries:
      ${JSON.stringify(journalEntries, null, 2)}
      
      For each entry, consider:
      - Strain used
      - Dosage
      - Consumption method
      - Effects experienced
      - Time of day
      - User's mood before and after
      - Any side effects
      
      Please provide:
      1. Patterns you've identified across entries
      2. Insights about what works well and what doesn't for this user
      3. Recommendations for strains, dosages, or consumption methods based on the data
      4. Any safety flags or concerns that should be addressed
      
      Format your response as a JSON object with the following structure:
      {
        "patterns": ["pattern1", "pattern2", ...],
        "insights": ["insight1", "insight2", ...],
        "recommendations": ["recommendation1", "recommendation2", ...],
        "safetyFlags": ["flag1", "flag2", ...] // Optional, include only if relevant
      }
    `;
  }

  /**
   * Parse the AI response into a structured journal analysis
   */
  private parseJournalAnalysisResponse(response: string): JournalAnalysisResult {
    try {
      // Try to parse the response as JSON
      const parsedResponse = JSON.parse(response) as JournalAnalysisResult;
      
      // Validate the response structure
      if (!parsedResponse.patterns || !parsedResponse.insights || !parsedResponse.recommendations) {
        throw new Error('Invalid response structure: required fields missing');
      }
      
      return parsedResponse;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to parse journal analysis response');
      
      // Return a simple error response
      return {
        patterns: ['Could not identify patterns due to parsing error'],
        insights: ['Could not generate insights due to parsing error'],
        recommendations: ['Please try again later or contact support']
      };
    }
  }

  /**
   * Generate mock journal analysis for testing
   */
  private getMockJournalAnalysis(journalEntries: JournalEntry[]): JournalAnalysisResult {
    // Simple mock analysis based on the number of entries
    if (journalEntries.length >= 5) {
      return {
        patterns: [
          'Higher satisfaction with indica strains in the evening',
          'Edibles tend to cause more anxiety than vaping',
          'Morning use of low-THC strains improves focus without impairment'
        ],
        insights: [
          'You respond well to balanced THC:CBD ratios for pain management',
          'Strains high in limonene terpenes seem to elevate your mood consistently',
          'Consumption 2-3 hours before bedtime improves sleep quality'
        ],
        recommendations: [
          'Try Granddaddy Purple for evening relaxation',
          'Consider microdosing with a 1:1 THC:CBD tincture for daytime pain relief',
          'Experiment with lower temperatures when vaping to reduce throat irritation'
        ]
      };
    } else {
      return {
        patterns: [
          'Not enough entries to identify reliable patterns yet',
          'Initial preference for hybrid strains noted'
        ],
        insights: [
          'More journal entries needed for meaningful insights',
          'Consider recording more details about effects and context'
        ],
        recommendations: [
          'Continue journaling consistently to build more data',
          'Try varying your consumption methods to compare effects',
          'Record your experience with different terpene profiles'
        ]
      };
    }
  }

  /**
   * Validate the safety of a recommendation request
   */
  public async validateRecommendationSafety(
    request: RecommendationRequest
  ): Promise<SafetyValidationResult> {
    this.checkInitialized();
    
    try {
      Logger.info(MODULE_NAME, 'Validating recommendation request safety');
      
      // Check for basic safety issues
      const basicSafetyCheck = this.performBasicSafetyCheck(request);
      if (!basicSafetyCheck.valid) {
        Logger.info(MODULE_NAME, `Safety validation failed: ${basicSafetyCheck.reason}`);
        return basicSafetyCheck;
      }
      
      // Check for potential drug interactions
      const interactionResult = await this.checkDrugInteractions(request);
      if (interactionResult.hasInteractions && interactionResult.severity === 'severe') {
        Logger.info(MODULE_NAME, 'Safety validation failed: Severe drug interactions detected');
        return {
          valid: false,
          reason: 'Potential severe drug interactions detected',
          safetyFlags: interactionResult.details,
          warningLevel: 'critical'
        };
      }
      
      // Check for potential overuse
      const overuseResult = await this.detectOveruse(request.userProfile.id);
      if (overuseResult.detected && overuseResult.level === 'severe') {
        Logger.info(MODULE_NAME, 'Safety validation failed: Severe overuse pattern detected');
        return {
          valid: false,
          reason: 'Potential overuse pattern detected',
          safetyFlags: [overuseResult.details || 'Frequent high-dose usage pattern detected'],
          warningLevel: 'critical'
        };
      }
      
      // If there are moderate concerns, return valid but with warnings
      if (
        (interactionResult.hasInteractions && interactionResult.severity === 'moderate') ||
        (overuseResult.detected && overuseResult.level === 'moderate')
      ) {
        const safetyFlags = [
          ...(interactionResult.hasInteractions ? interactionResult.details || [] : []),
          ...(overuseResult.detected && overuseResult.details ? [overuseResult.details] : [])
        ];
        
        Logger.info(MODULE_NAME, 'Safety validation passed with warnings');
        return {
          valid: true,
          safetyFlags,
          warningLevel: 'warning'
        };
      }
      
      // If there are mild concerns, return valid but with info
      if (
        (interactionResult.hasInteractions && interactionResult.severity === 'mild') ||
        (overuseResult.detected && overuseResult.level === 'mild')
      ) {
        const safetyFlags = [
          ...(interactionResult.hasInteractions ? interactionResult.details || [] : []),
          ...(overuseResult.detected && overuseResult.details ? [overuseResult.details] : [])
        ];
        
        Logger.info(MODULE_NAME, 'Safety validation passed with information');
        return {
          valid: true,
          safetyFlags,
          warningLevel: 'info'
        };
      }
      
      // All checks passed
      Logger.info(MODULE_NAME, 'Safety validation passed');
      return {
        valid: true
      };
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to validate recommendation safety');
      
      // Return a conservative result in case of error
      return {
        valid: true,
        reason: 'Safety validation could not be completed',
        safetyFlags: ['Safety validation encountered an error, proceed with caution'],
        warningLevel: 'warning'
      };
    }
  }

  /**
   * Perform basic safety checks on a recommendation request
   */
  private performBasicSafetyCheck(request: RecommendationRequest): SafetyValidationResult {
    // Check for underage users based on experience level
    if (request.userProfile.experience_level === 'beginner') {
      // For beginners, we'll add extra caution
      return {
        valid: true,
        safetyFlags: ['User is a beginner, recommend starting with low doses'],
        warningLevel: 'info'
      };
    }
    
    // Check for pregnancy or other medical conditions
    if (request.userProfile.medical_needs && 
        request.userProfile.medical_needs.some((condition: string) => 
          condition.toLowerCase().includes('pregnant') || 
          condition.toLowerCase().includes('pregnancy')
        )) {
      return {
        valid: false,
        reason: 'Cannabis use is not recommended during pregnancy',
        warningLevel: 'critical'
      };
    }
    
    // Check for severe mental health conditions
    const severeConditions = ['schizophrenia', 'psychosis', 'severe depression', 'bipolar disorder'];
    if (request.userProfile.medical_needs && 
        request.userProfile.medical_needs.some((condition: string) => 
          severeConditions.some(severe => condition.toLowerCase().includes(severe))
        )) {
      return {
        valid: false,
        reason: 'Cannabis use may exacerbate certain mental health conditions',
        warningLevel: 'critical'
      };
    }
    
    // All basic checks passed
    return {
      valid: true
    };
  }

  /**
   * Check for potential drug interactions
   */
  private async checkDrugInteractions(request: RecommendationRequest): Promise<DrugInteractionResult> {
    // In a real implementation, this would check against a database of known drug interactions
    // For now, we'll just check for some common medications that have known interactions
    
    const highRiskMedications = [
      'warfarin', 'clopidogrel', 'amiodarone', 'tacrolimus', 'cyclosporine',
      'sedative', 'benzodiazepine', 'opioid', 'alcohol'
    ];
    
    const moderateRiskMedications = [
      'antidepressant', 'ssri', 'antipsychotic', 'stimulant', 'adhd medication',
      'blood pressure', 'hypertension', 'beta blocker'
    ];
    
    if (!request.userProfile.medications || request.userProfile.medications.length === 0) {
      return {
        hasInteractions: false
      };
    }
    
    const highRiskFound = request.userProfile.medications.some((med: string) => 
      highRiskMedications.some(risk => med.toLowerCase().includes(risk))
    );
    
    if (highRiskFound) {
      return {
        hasInteractions: true,
        severity: 'severe',
        details: [
          'Potential severe interaction with one or more medications',
          'Cannabis may increase or decrease the effects of certain medications',
          'Consult with a healthcare provider before using cannabis'
        ],
        recommendations: [
          'Consult with a healthcare provider before using cannabis',
          'Consider alternative treatments',
          'If approved by a healthcare provider, start with very low doses and monitor closely'
        ]
      };
    }
    
    const moderateRiskFound = request.userProfile.medications.some((med: string) => 
      moderateRiskMedications.some(risk => med.toLowerCase().includes(risk))
    );
    
    if (moderateRiskFound) {
      return {
        hasInteractions: true,
        severity: 'moderate',
        details: [
          'Potential moderate interaction with one or more medications',
          'Cannabis may affect how your medications work'
        ],
        recommendations: [
          'Consult with a healthcare provider before using cannabis',
          'Start with low doses and monitor for any adverse effects',
          'Keep a journal of effects to share with your healthcare provider'
        ]
      };
    }
    
    // No known interactions found
    return {
      hasInteractions: false
    };
  }

  /**
   * Detect potential overuse patterns
   */
  private async detectOveruse(userId: string): Promise<OveruseDetectionResult> {
    // In a real implementation, this would analyze usage patterns from the user's history
    // For now, we'll just return a mock result
    
    // Simulate a 10% chance of detecting mild overuse
    const randomValue = Math.random();
    
    if (randomValue < 0.01) {
      // 1% chance of severe overuse
      return {
        detected: true,
        level: 'severe',
        details: 'Frequent high-dose usage pattern detected',
        recommendedAction: 'Consider taking a tolerance break and consulting with a healthcare provider',
        coolingOffPeriod: 14 // 14 days
      };
    } else if (randomValue < 0.05) {
      // 4% chance of moderate overuse
      return {
        detected: true,
        level: 'moderate',
        details: 'Increasing frequency of use detected',
        recommendedAction: 'Consider moderating use and monitoring effects more closely',
        coolingOffPeriod: 7 // 7 days
      };
    } else if (randomValue < 0.10) {
      // 5% chance of mild overuse
      return {
        detected: true,
        level: 'mild',
        details: 'Slight increase in usage frequency noted',
        recommendedAction: 'Be mindful of consumption patterns and consider occasional breaks',
        coolingOffPeriod: 2 // 2 days
      };
    }
    
    // No overuse detected
    return {
      detected: false
    };
  }
} 

================================================================================
File: src/services/ai/cache/CacheManager.ts
================================================================================

import * as Logger from '../utils/logging';
import { MemoryCache } from './MemoryCache';
import { PersistentCache } from './PersistentCache';
import { SHA256 } from '../utils/hash';
import { DEFAULT_CACHE_TTL, MAX_CACHE_SIZE, CacheDbEntry } from '../types/common';
import { DatabaseManager } from '../database/DatabaseManager';

const MODULE_NAME = 'CacheManager';

/**
 * Cache Manager
 * Orchestrates both memory and persistent caches
 */
export class CacheManager {
  private static instance: CacheManager;
  private memoryCache: MemoryCache;
  private persistentCache: PersistentCache;
  private enabled: boolean = true;
  private defaultTtl: number = DEFAULT_CACHE_TTL;
  private initialized: boolean = false;
  private initializationPromise: Promise<void> | null = null;

  private constructor() {
    this.memoryCache = new MemoryCache(MAX_CACHE_SIZE);
    this.persistentCache = new PersistentCache();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of CacheManager
   */
  public static getInstance(): CacheManager {
    if (!CacheManager.instance) {
      CacheManager.instance = new CacheManager();
    }
    return CacheManager.instance;
  }

  /**
   * Initialize the cache manager
   */
  public async initialize(): Promise<void> {
    // If already initialized, return immediately
    if (this.initialized) {
      console.debug('[CacheManager] Already initialized');
      return;
    }
    
    // If initialization is already in progress, wait for it to complete
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    
    console.info('[CacheManager] Initializing cache manager');
    
    // Create a promise for initialization
    this.initializationPromise = (async () => {
      try {
        // Wait for DatabaseManager to be initialized first
        const dbManager = DatabaseManager.getInstance();
        await dbManager.initialize();
        
        // Load frequently accessed entries into memory cache
        await this.loadFrequentEntries();
        
        // Delete expired entries
        await this.pruneCache();
        
        this.initialized = true;
        console.info('[CacheManager] Cache manager initialized successfully');
      } catch (error) {
        console.error('[CacheManager] Failed to initialize cache manager:', error);
        throw error;
      } finally {
        this.initializationPromise = null;
      }
    })();
    
    return this.initializationPromise;
  }

  /**
   * Configure the cache
   */
  public configure(enabled: boolean, ttlMs: number = DEFAULT_CACHE_TTL, maxSize: number = MAX_CACHE_SIZE): void {
    this.enabled = enabled;
    this.defaultTtl = ttlMs;
    this.memoryCache.setMaxSize(maxSize);
    
    Logger.info(MODULE_NAME, `Cache configured: enabled=${enabled}, ttl=${ttlMs}ms, maxSize=${maxSize}`);
  }

  /**
   * Generate a cache key from request data
   */
  public generateKey(requestData: any): string {
    try {
      // Create a stable representation of the request data
      const stableRepresentation = this.createStableRepresentation(requestData);
      
      // Generate a hash of the stable representation
      const hash = SHA256(stableRepresentation);
      
      // Extract user ID if available for easier cache invalidation
      let userId = '';
      if (requestData.userProfile && requestData.userProfile.id) {
        userId = requestData.userProfile.id;
      } else if (requestData.userId) {
        userId = requestData.userId;
      }
      
      // Create a key with user ID prefix for easier user-specific cache invalidation
      const key = userId ? `user:${userId}:${hash}` : hash;
      
      Logger.debug(MODULE_NAME, `Generated cache key: ${key}`);
      return key;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to generate cache key');
      // Return a timestamp-based key as fallback
      return `fallback:${Date.now()}`;
    }
  }

  /**
   * Create a stable representation of an object
   * Ensures that the same object always produces the same string
   * regardless of property order
   */
  private createStableRepresentation(obj: any): string {
    if (obj === null || obj === undefined) {
      return '';
    }
    
    if (typeof obj !== 'object') {
      return String(obj);
    }
    
    if (Array.isArray(obj)) {
      return '[' + obj.map(item => this.createStableRepresentation(item)).join(',') + ']';
    }
    
    // Sort keys to ensure stable order
    const sortedKeys = Object.keys(obj).sort();
    
    return '{' + sortedKeys.map(key => {
      // Skip functions and undefined values
      if (typeof obj[key] === 'function' || obj[key] === undefined) {
        return '';
      }
      return `"${key}":${this.createStableRepresentation(obj[key])}`;
    }).filter(Boolean).join(',') + '}';
  }

  /**
   * Get a value from the cache
   */
  public async get<T>(key: string): Promise<T | null> {
    if (!this.enabled) {
      Logger.debug(MODULE_NAME, 'Cache is disabled, skipping get');
      return null;
    }
    
    try {
      // Check if initialized
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Cache not initialized, initializing now...');
        await this.initialize();
      }
      
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      // Try memory cache first
      const memoryEntry = this.memoryCache.get<T>(key);
      if (memoryEntry) {
        // Check if the entry is expired
        if (memoryEntry.expiresAt < Date.now()) {
          Logger.debug(MODULE_NAME, `Memory cache entry expired for key: ${key}`);
          this.memoryCache.delete(key);
          return null;
        }
        
        Logger.debug(MODULE_NAME, `Memory cache hit for key: ${key}`);
        return memoryEntry.data;
      }
      
      // Try persistent cache
      const persistentData = await this.persistentCache.get<T>(key);
      if (persistentData) {
        // Store in memory cache for faster access next time
        this.memoryCache.set(key, persistentData, this.defaultTtl);
        
        Logger.debug(MODULE_NAME, `Persistent cache hit for key: ${key}`);
        return persistentData;
      }
      
      Logger.debug(MODULE_NAME, `Cache miss for key: ${key}`);
      return null;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      return null;
    }
  }

  /**
   * Set a value in the cache
   */
  public async set<T>(key: string, data: T, ttl: number = this.defaultTtl): Promise<void> {
    if (!this.enabled) {
      Logger.debug(MODULE_NAME, 'Cache is disabled, skipping set');
      return;
    }
    
    if (data === null || data === undefined) {
      Logger.error(MODULE_NAME, `Cannot cache null or undefined data for key: ${key}`);
      return;
    }
    
    try {
      // Check if initialized
      if (!this.initialized) {
        Logger.warn(MODULE_NAME, 'Cache not initialized, initializing now...');
        await this.initialize();
      }
      
      Logger.debug(MODULE_NAME, `Setting cache entry with key: ${key}`);
      
      // Store in memory cache
      this.memoryCache.set(key, data, ttl);
      
      // Store in persistent cache
      await this.persistentCache.set(key, data, ttl);
      
      Logger.debug(MODULE_NAME, `Cache entry set for key: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to set cache entry: ${key}`);
      // If persistent cache fails, delete from memory cache to maintain consistency
      this.memoryCache.delete(key);
    }
  }

  /**
   * Delete a value from the cache
   */
  public async delete(key: string): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      
      // Delete from memory cache
      this.memoryCache.delete(key);
      
      // Delete from persistent cache
      await this.persistentCache.delete(key);
      
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
    }
  }

  /**
   * Delete all cache entries that match a pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      
      // Delete from memory cache
      const memoryCount = this.memoryCache.deleteByPattern(pattern);
      
      // Delete from persistent cache
      const persistentCount = await this.persistentCache.deleteByPattern(pattern);
      
      Logger.debug(MODULE_NAME, `Deleted ${memoryCount} memory cache entries and ${persistentCount} persistent cache entries matching pattern: ${pattern}`);
      return Math.max(memoryCount, persistentCount);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      return 0;
    }
  }

  /**
   * Clear all cache entries
   */
  public async clear(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      
      // Clear memory cache
      this.memoryCache.clear();
      
      // Clear persistent cache
      await this.persistentCache.clear();
      
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
    }
  }

  /**
   * Delete all cache entries for a specific user
   */
  public async deleteForUser(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting cache entries for user: ${userId}`);
      
      // Delete from memory cache
      const memoryCount = this.memoryCache.deleteByPattern(`user:${userId}`);
      
      // Get all keys for the user from persistent cache
      const keys = await this.persistentCache.getKeysForUser(userId);
      
      // Delete each key from persistent cache
      for (const key of keys) {
        await this.persistentCache.delete(key);
      }
      
      Logger.debug(MODULE_NAME, `Deleted ${memoryCount} memory cache entries and ${keys.length} persistent cache entries for user: ${userId}`);
      return keys.length;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries for user: ${userId}`);
      return 0;
    }
  }

  /**
   * Prune the cache by removing expired entries
   */
  public async pruneCache(): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, 'Pruning cache');
      
      // Delete expired entries from memory cache
      const memoryCount = this.memoryCache.deleteExpired();
      
      // Delete expired entries from persistent cache
      const persistentCount = await this.persistentCache.deleteExpired();
      
      Logger.debug(MODULE_NAME, `Pruned ${memoryCount} memory cache entries and ${persistentCount} persistent cache entries`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to prune cache');
    }
  }

  /**
   * Load frequently accessed entries into memory cache
   */
  private async loadFrequentEntries(limit: number = 20): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Loading ${limit} most frequently accessed cache entries into memory`);
      
      // Get most frequently used entries from persistent cache
      const entries = await this.persistentCache.getMostFrequentlyUsed(limit);
      
      // Load each entry into memory cache
      for (const entry of entries) {
        try {
          const data = JSON.parse(entry.data);
          const ttl = entry.expires_at - Date.now();
          
          // Only load if not expired
          if (ttl > 0) {
            this.memoryCache.set(entry.key, data, ttl);
          }
        } catch (error) {
          Logger.logError(MODULE_NAME, error as Error, `Failed to parse data for key: ${entry.key}`);
        }
      }
      
      Logger.debug(MODULE_NAME, `Loaded ${entries.length} cache entries into memory`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to load frequent cache entries');
    }
  }
} 

================================================================================
File: src/services/ai/cache/index.ts
================================================================================

export { CacheManager } from './CacheManager';
export { MemoryCache } from './MemoryCache';
export { PersistentCache } from './PersistentCache'; 

================================================================================
File: src/services/ai/cache/MemoryCache.ts
================================================================================

import * as Logger from '../utils/logging';
import { CacheEntry, MAX_CACHE_SIZE } from '../types/common';

const MODULE_NAME = 'MemoryCache';

/**
 * In-memory cache implementation
 * Provides fast access to frequently used cache entries
 */
export class MemoryCache {
  private cache: Map<string, CacheEntry<any>> = new Map();
  private maxSize: number;

  constructor(maxSize: number = MAX_CACHE_SIZE) {
    this.maxSize = maxSize;
    Logger.debug(MODULE_NAME, `Initialized with max size: ${maxSize}`);
  }

  /**
   * Set the maximum size of the cache
   */
  public setMaxSize(size: number): void {
    this.maxSize = size;
    Logger.debug(MODULE_NAME, `Max size updated to: ${size}`);
    
    // If the current size exceeds the new max size, prune the cache
    if (this.cache.size > this.maxSize) {
      this.prune();
    }
  }

  /**
   * Get the current size of the cache
   */
  public size(): number {
    return this.cache.size;
  }

  /**
   * Check if the cache contains an entry with the given key
   */
  public has(key: string): boolean {
    return this.cache.has(key);
  }

  /**
   * Get an entry from the cache
   */
  public get<T>(key: string): CacheEntry<T> | undefined {
    const entry = this.cache.get(key) as CacheEntry<T> | undefined;
    
    if (entry) {
      // Update hit count and last accessed time
      entry.hitCount += 1;
      entry.lastAccessed = Date.now();
      Logger.debug(MODULE_NAME, `Cache hit for key: ${key}, hit count: ${entry.hitCount}`);
    } else {
      Logger.debug(MODULE_NAME, `Cache miss for key: ${key}`);
    }
    
    return entry;
  }

  /**
   * Set an entry in the cache
   */
  public set<T>(key: string, data: T, ttl: number): void {
    const now = Date.now();
    const expiresAt = now + ttl;
    
    // Check if we need to make room in the cache
    if (!this.cache.has(key) && this.cache.size >= this.maxSize) {
      this.evictOne();
    }
    
    // Create or update the cache entry
    this.cache.set(key, {
      key,
      data,
      timestamp: now,
      expiresAt,
      ttl,
      hitCount: 0,
      lastAccessed: now
    });
    
    Logger.debug(MODULE_NAME, `Set cache entry for key: ${key}, expires at: ${new Date(expiresAt).toISOString()}`);
  }

  /**
   * Delete an entry from the cache
   */
  public delete(key: string): boolean {
    const result = this.cache.delete(key);
    Logger.debug(MODULE_NAME, `Deleted cache entry for key: ${key}, success: ${result}`);
    return result;
  }

  /**
   * Clear all entries from the cache
   */
  public clear(): void {
    this.cache.clear();
    Logger.debug(MODULE_NAME, 'Cleared all cache entries');
  }

  /**
   * Get all keys in the cache
   */
  public keys(): string[] {
    return Array.from(this.cache.keys());
  }

  /**
   * Get all entries in the cache
   */
  public entries<T>(): Array<[string, CacheEntry<T>]> {
    return Array.from(this.cache.entries()) as Array<[string, CacheEntry<T>]>;
  }

  /**
   * Delete all entries that match a pattern
   */
  public deleteByPattern(pattern: string): number {
    let count = 0;
    const regex = new RegExp(pattern);
    
    // Convert keys iterator to array before iterating
    const keys = Array.from(this.cache.keys());
    for (const key of keys) {
      if (regex.test(key)) {
        this.cache.delete(key);
        count++;
      }
    }
    
    Logger.debug(MODULE_NAME, `Deleted ${count} entries matching pattern: ${pattern}`);
    return count;
  }

  /**
   * Delete all expired entries
   */
  public deleteExpired(): number {
    let count = 0;
    const now = Date.now();
    
    // Convert entries iterator to array before iterating
    const entries = Array.from(this.cache.entries());
    for (const [key, entry] of entries) {
      if (entry.expiresAt <= now) {
        this.cache.delete(key);
        count++;
      }
    }
    
    Logger.debug(MODULE_NAME, `Deleted ${count} expired entries`);
    return count;
  }

  /**
   * Prune the cache to the maximum size
   */
  private prune(): void {
    if (this.cache.size <= this.maxSize) {
      return;
    }
    
    const entriesToRemove = this.cache.size - this.maxSize;
    Logger.debug(MODULE_NAME, `Pruning cache, removing ${entriesToRemove} entries`);
    
    // Sort entries by last accessed time (oldest first)
    const sortedEntries = Array.from(this.cache.entries())
      .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);
    
    // Remove the oldest entries
    for (let i = 0; i < entriesToRemove; i++) {
      this.cache.delete(sortedEntries[i][0]);
    }
  }

  /**
   * Evict one entry from the cache
   * Uses a combination of last accessed time and hit count to determine which entry to evict
   */
  private evictOne(): void {
    if (this.cache.size === 0) {
      return;
    }
    
    Logger.debug(MODULE_NAME, 'Evicting one entry from cache');
    
    // Sort entries by a score that combines last accessed time and hit count
    // Lower score = better candidate for eviction
    const now = Date.now();
    const sortedEntries = Array.from(this.cache.entries())
      .map(([key, entry]) => {
        // Calculate a score based on recency and popularity
        // More recent access and higher hit count = higher score = less likely to be evicted
        const recency = (now - entry.lastAccessed) / 1000; // seconds since last access
        const popularity = Math.log1p(entry.hitCount); // logarithmic scaling of hit count
        const score = popularity / recency; // higher hit count and more recent = higher score
        return { key, score };
      })
      .sort((a, b) => a.score - b.score); // sort by score (ascending)
    
    // Evict the entry with the lowest score
    const keyToEvict = sortedEntries[0].key;
    this.cache.delete(keyToEvict);
    Logger.debug(MODULE_NAME, `Evicted cache entry for key: ${keyToEvict}`);
  }
} 

================================================================================
File: src/services/ai/cache/PersistentCache.ts
================================================================================

import * as Logger from '../utils/logging';
import { CacheRepository } from '../database/repositories/CacheRepository';
import { CacheDbEntry } from '../types/common';
import { DatabaseManager } from '../database/DatabaseManager';

const MODULE_NAME = 'PersistentCache';

/**
 * Persistent cache implementation using SQLite
 * Provides durable storage for cache entries
 */
export class PersistentCache {
  private repository: CacheRepository;
  private initialized: boolean = false;

  constructor() {
    this.repository = new CacheRepository();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Initialize the persistent cache
   */
  private async ensureInitialized(): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      // Make sure the database is initialized - use initialize method
      const dbManager = DatabaseManager.getInstance();
      await dbManager.initialize();
      this.initialized = true;
      console.debug('[PersistentCache] Database initialized');
    } catch (error) {
      console.error('[PersistentCache] Failed to initialize database:', error);
      throw new Error('Cache database not initialized');
    }
  }

  /**
   * Store an entry in the persistent cache
   */
  public async set(key: string, data: any, ttl: number): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Storing cache entry with key: ${key}`);
      
      // Validate data before storing
      if (data === null || data === undefined) {
        Logger.error(MODULE_NAME, `Cannot store null or undefined data for key: ${key}`);
        throw new Error('Cannot store null or undefined data in cache');
      }
      
      const now = Date.now();
      const expiresAt = now + ttl;
      
      // Serialize data to JSON string
      let serializedData: string;
      try {
        serializedData = JSON.stringify(data);
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, `Failed to serialize data for key: ${key}`);
        throw new Error(`Failed to serialize data for cache key: ${key}`);
      }
      
      // Store in persistent cache
      await this.repository.storeResponse(key, serializedData, now, expiresAt, ttl);
      
      Logger.debug(MODULE_NAME, `Cache entry stored successfully: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to store cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Get an entry from the persistent cache
   */
  public async get<T>(key: string): Promise<T | null> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting cache entry with key: ${key}`);
      
      const entry = await this.repository.getResponse(key);
      
      if (!entry) {
        Logger.debug(MODULE_NAME, `No cache entry found for key: ${key}`);
        return null;
      }
      
      // Check if the entry is expired
      if (entry.expires_at < Date.now()) {
        Logger.debug(MODULE_NAME, `Cache entry expired for key: ${key}`);
        await this.delete(key);
        return null;
      }
      
      // Update hit count and last accessed time
      await this.repository.updateStats(key, entry.hit_count + 1, Date.now());
      
      // Parse the serialized data
      try {
        const data = JSON.parse(entry.data) as T;
        Logger.debug(MODULE_NAME, `Cache hit for key: ${key}`);
        return data;
      } catch (error) {
        Logger.logError(MODULE_NAME, error as Error, `Failed to parse data for key: ${key}`);
        await this.delete(key);
        return null;
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache entry: ${key}`);
      return null;
    }
  }

  /**
   * Delete an entry from the persistent cache
   */
  public async delete(key: string): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Deleting cache entry: ${key}`);
      await this.repository.deleteEntry(key);
      Logger.debug(MODULE_NAME, `Cache entry deleted: ${key}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entry: ${key}`);
      throw error;
    }
  }

  /**
   * Delete entries by pattern
   */
  public async deleteByPattern(pattern: string): Promise<number> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Deleting cache entries by pattern: ${pattern}`);
      const count = await this.repository.deleteByPattern(pattern);
      Logger.debug(MODULE_NAME, `Deleted ${count} cache entries matching pattern: ${pattern}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete cache entries by pattern: ${pattern}`);
      throw error;
    }
  }

  /**
   * Clear all entries from the persistent cache
   */
  public async clear(): Promise<void> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, 'Clearing all cache entries');
      await this.repository.clearAll();
      Logger.debug(MODULE_NAME, 'All cache entries cleared');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to clear all cache entries');
      throw error;
    }
  }

  /**
   * Delete expired entries
   */
  public async deleteExpired(): Promise<number> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, 'Deleting expired cache entries');
      const count = await this.repository.deleteExpired();
      Logger.debug(MODULE_NAME, `Deleted ${count} expired cache entries`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to delete expired cache entries');
      throw error;
    }
  }

  /**
   * Get the most frequently used cache entries
   */
  public async getMostFrequentlyUsed(limit: number): Promise<CacheDbEntry[]> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting ${limit} most frequently used cache entries`);
      const entries = await this.repository.getMostFrequentlyUsed(limit);
      Logger.debug(MODULE_NAME, `Found ${entries.length} most frequently used cache entries`);
      return entries;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get most frequently used cache entries');
      throw error;
    }
  }

  /**
   * Get all keys for a specific user
   */
  public async getKeysForUser(userId: string): Promise<string[]> {
    try {
      await this.ensureInitialized();
      
      Logger.debug(MODULE_NAME, `Getting cache keys for user: ${userId}`);
      const keyEntries = await this.repository.getKeysForUser(userId);
      const keys = keyEntries.map(entry => entry.key);
      Logger.debug(MODULE_NAME, `Found ${keys.length} cache keys for user: ${userId}`);
      return keys;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get cache keys for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/feedback/FeedbackService.ts
================================================================================

import * as Logger from '../utils/logging';
import { FeedbackRepository } from '../database/repositories/FeedbackRepository';
import { UserFeedback, QualityScore, FeedbackPattern } from '../types/feedback';
import { AnthropicAPI } from '../api/AnthropicAPI';

const MODULE_NAME = 'FeedbackService';

/**
 * Feedback Service
 * Handles user feedback and response quality evaluation
 */
export class FeedbackService {
  private static instance: FeedbackService;
  private repository: FeedbackRepository;
  private api: AnthropicAPI;
  private initialized: boolean = false;

  private constructor() {
    this.repository = new FeedbackRepository();
    this.api = new AnthropicAPI();
    Logger.debug(MODULE_NAME, 'Initialized');
  }

  /**
   * Get the singleton instance of FeedbackService
   */
  public static getInstance(): FeedbackService {
    if (!FeedbackService.instance) {
      FeedbackService.instance = new FeedbackService();
    }
    return FeedbackService.instance;
  }

  /**
   * Initialize the feedback service
   */
  public async initialize(): Promise<void> {
    if (this.initialized) {
      Logger.debug(MODULE_NAME, 'Already initialized');
      return;
    }

    try {
      Logger.info(MODULE_NAME, 'Initializing feedback service');
      this.initialized = true;
      Logger.info(MODULE_NAME, 'Feedback service initialized successfully');
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to initialize feedback service');
      throw error;
    }
  }

  /**
   * Submit user feedback
   */
  public async submitFeedback(feedback: UserFeedback): Promise<string> {
    try {
      Logger.info(MODULE_NAME, `Submitting feedback for response: ${feedback.responseId}`);
      
      // Generate a unique ID for the feedback
      const feedbackId = `fb_${Date.now()}`;
      
      // Store the feedback
      await this.repository.storeFeedback(feedback, feedbackId);
      
      // Evaluate the response quality in the background
      this.evaluateResponseQuality(feedback.responseId, feedback.responseType)
        .catch(error => {
          Logger.logError(MODULE_NAME, error as Error, `Failed to evaluate response quality for: ${feedback.responseId}`);
        });
      
      // Extract feedback patterns in the background
      this.extractFeedbackPatterns(feedback)
        .catch(error => {
          Logger.logError(MODULE_NAME, error as Error, `Failed to extract feedback patterns for: ${feedback.responseId}`);
        });
      
      Logger.info(MODULE_NAME, `Feedback submitted successfully: ${feedbackId}`);
      return feedbackId;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to submit feedback for response: ${feedback.responseId}`);
      throw error;
    }
  }

  /**
   * Evaluate the quality of a response
   */
  public async evaluateResponseQuality(
    responseId: string,
    responseType: 'recommendation' | 'chat',
    responseData?: any
  ): Promise<QualityScore> {
    try {
      Logger.info(MODULE_NAME, `Evaluating quality for response: ${responseId}`);
      
      // Generate a unique ID for the evaluation
      const evaluationId = `eval_${Date.now()}`;
      
      // If we have an API key and want to use the real API
      const useRealApi = false; // Set to true to use the real API
      
      if (useRealApi) {
        // Format the evaluation prompt
        const prompt = `
          You are an expert evaluator of AI responses for a cannabis recommendation app.
          Please evaluate the following ${responseType} response:
          
          ${JSON.stringify(responseData)}
          
          Provide a quality score on a scale of 0-100 for the following aspects:
          - Overall quality
          - Relevance to user needs
          - Accuracy of information
          - Comprehensiveness
          - Safety considerations
          
          Also list:
          - 3 strengths of the response
          - 3 weaknesses of the response
          - 3 suggestions for improvement
          
          Format your response as a JSON object with the following structure:
          {
            "overallScore": number,
            "relevanceScore": number,
            "accuracyScore": number,
            "comprehensivenessScore": number,
            "safetyScore": number,
            "strengths": string[],
            "weaknesses": string[],
            "improvementSuggestions": string[]
          }
        `;
        
        // Call the API
        const response = await this.api.sendMessage([
          { role: 'user', content: prompt }
        ], 2000, 0.3);
        
        // Parse the response
        const qualityScore = JSON.parse(response) as QualityScore;
        
        // Store the quality score
        await this.repository.storeQualityScore(evaluationId, responseId, qualityScore);
        
        Logger.info(MODULE_NAME, `Quality evaluation completed for response: ${responseId}`);
        return qualityScore;
      } else {
        // For testing or when API is not available, generate a mock quality score
        const mockQualityScore: QualityScore = {
          overallScore: 85,
          relevanceScore: 80,
          accuracyScore: 90,
          comprehensivenessScore: 85,
          safetyScore: 95,
          strengths: [
            'Provides detailed information about the recommended strains',
            'Includes safety considerations and dosage guidelines',
            'Explains the reasoning behind the recommendations'
          ],
          weaknesses: [
            'Could provide more context about potential side effects',
            'Limited information about alternative options',
            'Dosage recommendations could be more personalized'
          ],
          improvementSuggestions: [
            'Include more information about potential side effects',
            'Provide alternative recommendations for different scenarios',
            'Enhance personalization of dosage recommendations'
          ]
        };
        
        // Store the mock quality score
        await this.repository.storeQualityScore(evaluationId, responseId, mockQualityScore);
        
        Logger.info(MODULE_NAME, `Mock quality evaluation completed for response: ${responseId}`);
        return mockQualityScore;
      }
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to evaluate quality for response: ${responseId}`);
      
      // Return a default quality score in case of error
      return {
        overallScore: 70,
        relevanceScore: 70,
        accuracyScore: 70,
        comprehensivenessScore: 70,
        safetyScore: 70,
        strengths: ['Not evaluated due to error'],
        weaknesses: ['Not evaluated due to error'],
        improvementSuggestions: ['Not evaluated due to error']
      };
    }
  }

  /**
   * Extract feedback patterns from user feedback
   */
  private async extractFeedbackPatterns(feedback: UserFeedback): Promise<void> {
    try {
      Logger.debug(MODULE_NAME, `Extracting feedback patterns for response: ${feedback.responseId}`);
      
      // In a real implementation, this would analyze the feedback and extract patterns
      // For now, we'll just create a simple pattern based on the feedback
      
      // Create a pattern ID based on user profile and request factors
      const patternId = `pattern_${feedback.responseType}_${Date.now()}`;
      
      // Check if the pattern already exists
      const existingPattern = await this.repository.getPattern(patternId);
      
      if (existingPattern) {
        // Update the existing pattern
        const updatedPattern: FeedbackPattern = {
          patternId,
          responseType: feedback.responseType,
          userProfileFactors: { userId: feedback.userId },
          requestFactors: { responseId: feedback.responseId },
          positiveOutcomeRate: feedback.helpful ? 1 : 0,
          sampleSize: 1,
          lastUpdated: Date.now()
        };
        
        await this.repository.storePattern(updatedPattern);
      } else {
        // Create a new pattern
        const newPattern: FeedbackPattern = {
          patternId,
          responseType: feedback.responseType,
          userProfileFactors: { userId: feedback.userId },
          requestFactors: { responseId: feedback.responseId },
          positiveOutcomeRate: feedback.helpful ? 1 : 0,
          sampleSize: 1,
          lastUpdated: Date.now()
        };
        
        await this.repository.storePattern(newPattern);
      }
      
      Logger.debug(MODULE_NAME, `Feedback patterns extracted for response: ${feedback.responseId}`);
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to extract feedback patterns for response: ${feedback.responseId}`);
    }
  }

  /**
   * Get all feedback for a user
   */
  public async getUserFeedback(userId: string): Promise<UserFeedback[]> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback for user: ${userId}`);
      const feedback = await this.repository.getUserFeedback(userId);
      Logger.debug(MODULE_NAME, `Found ${feedback.length} feedback entries for user: ${userId}`);
      return feedback;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get feedback statistics for a user
   */
  public async getUserFeedbackStats(userId: string): Promise<any> {
    try {
      Logger.debug(MODULE_NAME, `Getting feedback stats for user: ${userId}`);
      const stats = await this.repository.getUserFeedbackStats(userId);
      Logger.debug(MODULE_NAME, `Retrieved feedback stats for user: ${userId}`);
      return stats;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to get feedback stats for user: ${userId}`);
      throw error;
    }
  }

  /**
   * Get quality score statistics
   */
  public async getQualityScoreStats(): Promise<any> {
    try {
      Logger.debug(MODULE_NAME, 'Getting quality score statistics');
      const stats = await this.repository.getQualityScoreStats();
      Logger.debug(MODULE_NAME, 'Retrieved quality score statistics');
      return stats;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, 'Failed to get quality score statistics');
      throw error;
    }
  }

  /**
   * Delete all feedback for a user
   */
  public async deleteUserFeedback(userId: string): Promise<number> {
    try {
      Logger.debug(MODULE_NAME, `Deleting feedback for user: ${userId}`);
      const count = await this.repository.deleteUserFeedback(userId);
      Logger.debug(MODULE_NAME, `Deleted ${count} feedback entries for user: ${userId}`);
      return count;
    } catch (error) {
      Logger.logError(MODULE_NAME, error as Error, `Failed to delete feedback for user: ${userId}`);
      throw error;
    }
  }
} 

================================================================================
File: src/services/ai/feedback/index.ts
================================================================================

export { FeedbackService } from './FeedbackService'; 

================================================================================
File: src/services/ai/index.ts
================================================================================

export { AIService } from './AIService';

// Export sub-modules
export * from './api';
export * from './cache/index';
export * from './feedback';
export * from './types/common';
export * from './types/errors';
export * from './types/feedback';
export * from './types/requests';
export * from './types/responses'; 

================================================================================
File: src/services/ai/types/common.ts
================================================================================

// Constants
export const AI_USAGE_DB_NAME = "AIUsage";
export const RECOMMENDATION_FEEDBACK_DB_NAME = "RecommendationFeedback";
export const CACHE_DB_NAME = "AIResponseCache";

// Cache configuration
export const DEFAULT_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
export const MAX_CACHE_SIZE = 100; // Maximum number of cached responses

// Anthropic API constants
export const ANTHROPIC_API_URL = "https://api.anthropic.com/v1";
export const ANTHROPIC_API_VERSION = "2023-06-01";
// In a production app, you would use environment variables
// import { ANTHROPIC_API_KEY } from '@env';
// For now, we'll use a placeholder that you'll replace with your actual key
export const ANTHROPIC_API_KEY = "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"; // Replace this with your actual key

// Cache entry interface
export interface CacheEntry<T> {
  key: string;
  data: T;
  timestamp: number;
  expiresAt: number;
  ttl: number;
  hitCount: number;
  lastAccessed: number;
}

// Database entry interfaces
export interface CacheDbEntry {
  key: string;
  data: string;
  timestamp: number;
  expires_at: number;
  ttl: number;
  hit_count: number;
  last_accessed: number;
}

export interface KeyEntry {
  key: string;
}

export interface CountResult {
  count: number;
} 

================================================================================
File: src/services/ai/types/errors.ts
================================================================================

// Define error types for better error handling
export enum AIServiceErrorType {
  NETWORK = 'network_error',
  AUTHENTICATION = 'authentication_error',
  RATE_LIMIT = 'rate_limit_error',
  SERVER = 'server_error',
  PARSING = 'parsing_error',
  TIMEOUT = 'timeout_error',
  UNKNOWN = 'unknown_error'
}

export class AIServiceError extends Error {
  type: AIServiceErrorType;
  statusCode?: number;
  retryable: boolean;
  userMessage: string;

  constructor(
    message: string, 
    type: AIServiceErrorType = AIServiceErrorType.UNKNOWN, 
    statusCode?: number,
    retryable: boolean = false,
    userMessage: string = "An error occurred while processing your request."
  ) {
    super(message);
    this.name = 'AIServiceError';
    this.type = type;
    this.statusCode = statusCode;
    this.retryable = retryable;
    this.userMessage = userMessage;
  }
} 

================================================================================
File: src/services/ai/types/feedback.ts
================================================================================

// Feedback and evaluation types
export interface UserFeedback {
  userId: string;
  responseId: string;
  responseType: 'recommendation' | 'chat';
  helpful: boolean;
  accurate: boolean;
  relevance: number; // 1-5 scale
  comments?: string;
  timestamp: number;
}

export interface QualityScore {
  overallScore: number; // 0-100
  relevanceScore: number; // 0-100
  accuracyScore: number; // 0-100
  comprehensivenessScore: number; // 0-100
  safetyScore: number; // 0-100
  strengths: string[];
  weaknesses: string[];
  improvementSuggestions: string[];
}

export interface FeedbackPattern {
  patternId: string;
  responseType: 'recommendation' | 'chat';
  userProfileFactors: Record<string, any>;
  requestFactors: Record<string, any>;
  positiveOutcomeRate: number;
  sampleSize: number;
  lastUpdated: number;
}

// Database-specific interfaces for feedback
export interface PatternEntry {
  pattern_id: string;
  user_profile_factors: string;
  request_factors: string;
  positive_outcome_rate: number;
  sample_size: number;
}

export interface FeedbackStats {
  total: number;
  positive: number;
  relevance_sum: number;
}

export interface QualityStats {
  avg_overall: number;
  avg_relevance: number;
  avg_safety: number;
  total: number;
} 

================================================================================
File: src/services/ai/types/requests.ts
================================================================================

import { UserProfile, JournalEntry, ChatMessage } from '../../../types';

export interface RecommendationRequest {
  userProfile: UserProfile;
  journalEntries?: JournalEntry[];
  desiredEffects: string[];
  medicalNeeds?: string[];
  context?: 'recreational' | 'medical' | 'wellness';
  locationCode?: string; // For regulations
}

export interface ChatRequest {
  message: string;
  userProfile: UserProfile;
  locationCode?: string;
  previousMessages?: ChatMessage[];
} 

================================================================================
File: src/services/ai/types/responses.ts
================================================================================

import { DosageSuggestion, StrainRecommendation } from '../../../types';

export interface RecommendationResponse {
  recommendations: StrainRecommendation[];
  reasoning: string;
  confidenceScore: number;
  disclaimers: string[];
  dosageSuggestion?: DosageSuggestion;
  safetyNotes?: string[];
  error?: {
    message: string;
    type: string;
    recoverable: boolean;
  };
  // Adding responseId to fix the type issue in evaluateResponseQuality
  responseId?: string;
}

export interface ChatResponse {
  response: string;
  educationalLinks?: string[];
  disclaimers?: string[];
  regulatoryNotes?: string[];
  followUpSuggestions?: string[];
}

export interface JournalAnalysisResult {
  patterns: string[];
  insights: string[];
  recommendations: string[];
  safetyFlags?: string[];
}

export interface SafetyValidationResult {
  valid: boolean;
  reason?: string;
  modifications?: Partial<any>; // Changed from Partial<RecommendationRequest> to avoid circular dependency
  safetyFlags?: string[];
  warningLevel?: 'info' | 'warning' | 'critical';
}

export interface DrugInteractionResult {
  hasInteractions: boolean;
  details?: string[];
  severity?: 'mild' | 'moderate' | 'severe';
  recommendations?: string[];
}

export interface OveruseDetectionResult {
  detected: boolean;
  level?: 'mild' | 'moderate' | 'severe';
  details?: string;
  recommendedAction?: string;
  coolingOffPeriod?: number; // in days
} 

================================================================================
File: src/services/ai/utils/hash.ts
================================================================================

/**
 * A simple SHA-256 hash implementation for string inputs
 * This is a basic implementation for caching purposes
 * In a production environment, use a proper crypto library
 */
export function SHA256(input: string): string {
  // Simple hash function for demo purposes
  // In a real app, use a proper crypto library
  let hash = 0;
  
  if (input.length === 0) {
    return hash.toString(16);
  }
  
  // Generate a simple hash
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Convert to hex string and ensure it's 64 characters long (SHA-256 length)
  const hexHash = Math.abs(hash).toString(16).padStart(8, '0');
  
  // Repeat the hash to make it look like a SHA-256 hash (64 chars)
  return (hexHash.repeat(8)).substring(0, 64);
} 

================================================================================
File: src/services/ai/utils/logging.ts
================================================================================

/**
 * Logging utility for AI service
 * Provides consistent logging format and levels
 */

// Log levels
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

// Current log level - can be changed at runtime
let currentLogLevel: LogLevel = LogLevel.INFO;

// Set the current log level
export function setLogLevel(level: LogLevel): void {
  currentLogLevel = level;
}

// Get the current log level
export function getLogLevel(): LogLevel {
  return currentLogLevel;
}

// Format a log message with timestamp and module
function formatLogMessage(module: string, message: string): string {
  const timestamp = new Date().toISOString();
  return `[${timestamp}] [${module}] ${message}`;
}

// Debug level logging
export function debug(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.DEBUG) {
    console.debug(formatLogMessage(module, message), ...args);
  }
}

// Info level logging
export function info(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.INFO) {
    console.info(formatLogMessage(module, message), ...args);
  }
}

// Warning level logging
export function warn(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.WARN) {
    console.warn(formatLogMessage(module, message), ...args);
  }
}

// Error level logging
export function error(module: string, message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.ERROR) {
    console.error(formatLogMessage(module, message), ...args);
  }
}

// Log an error object with stack trace
export function logError(module: string, error: Error, message?: string): void {
  if (currentLogLevel <= LogLevel.ERROR) {
    const errorMessage = message ? `${message}: ${error.message}` : error.message;
    console.error(formatLogMessage(module, errorMessage));
    if (error.stack) {
      console.error(error.stack);
    }
  }
} 

================================================================================
File: src/types.ts
================================================================================

// Core data types
export interface BongHit {
    id?: number;
    timestamp: string;
    duration_ms: number;
    intensity?: number;
    notes?: string;
}

export interface BongHitStats {
    averageDuration: number;
    longestHit: number;
    totalHits?: number;
}

export interface DailyStats {
    date: string;
    hitCount: number;
    averageDuration: number;
}

export interface AverageHourCount {
    count: number;
    hourOfDay: string;
}

export interface Datapoint {
    x: string | number;
    y: number;
}

// Chart-specific types
export interface ChartDataPoint {
    label: string;
    value: number;
}

export interface ChartDataset {
    data: number[];
    color: (opacity?: number) => string;
    strokeWidth: number;
}

export interface ChartData {
    labels: string[];
    datasets: ChartDataset[];
    legend?: string[];
}

// Database types
export interface DatabaseRow {
    timestamp?: string;
    duration_ms?: number;
    day?: string;
    month?: string;
    hour?: string;
    hit_count?: number;
    count?: number;
    avg_duration?: number;
    max_duration?: number;
    total_hits?: number;
    avg_hits_per_day?: number;
    avg_duration_per_day?: number;
    daily_hits?: number;
    days_with_data?: number;
    weekday_avg?: number;
    weekday_total?: number;
    weekend_avg?: number;
    weekend_total?: number;
    peak_day_hits?: number;
    lowest_day_hits?: number;
    most_active_hour?: number;
    least_active_hour?: number;
    total_duration?: number;
    avg_hits_per_hour?: number;
    hits_std_dev?: number;
    // Fields from time distribution query
    morning?: number;
    afternoon?: number;
    evening?: number;
    night?: number;
    // Fields from usage stats query
    average_hits_per_day?: number;
    shortest_hit?: number;
    longest_hit?: number;
    consistency?: number;
}

export interface UsageStats {
    // Hit counts
    averageHitsPerDay: number;
    totalHits: number;
    peakDayHits: number;
    lowestDayHits: number;
    
    // Duration stats
    averageDuration: number;  // in ms
    longestHit: number;      // in ms
    shortestHit: number;     // in ms
    
    // Time patterns
    mostActiveHour: number;  // 0-23
    leastActiveHour: number; // 0-23
    
    // Derived metrics
    totalDuration: number;   // total time in ms
    averageHitsPerHour: number;
    consistency: number;     // standard deviation of daily hits

    // Weekday vs Weekend stats
    weekdayStats: WeekdayStats;
}

// Add new interfaces for time distribution
export interface TimeDistribution {
    morning: number;
    afternoon: number;
    evening: number;
    night: number;
}

export interface WeekdayStats {
    weekday: { avg: number; total: number; };
    weekend: { avg: number; total: number; };
}

// Component Props interfaces
export interface WeeklyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface MonthlyChartProps {
    data: ChartDataPoint[];
    onPress?: () => void;
}

export interface NotificationProps {
    averageHits: number;
    percentageChange: number;
    onDismiss: () => void;
}

export interface DailyAverageCardProps {
    data: ChartDataPoint[];
    averageHits: number;
    onPress?: () => void;
}

export interface WeeklyUsageBannerProps {
    weeklyData: ChartDataPoint[];
    average: number;
    percentageChange: number;
    onPress?: () => void;
}

// API Response types
export interface DatabaseResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}

export interface UsageAnalytics {
    dailyAverage: number;
    weeklyAverage: number;
    percentageChange: number;
    lastUpdated: string;
}

export interface SavedDevice {
    id: string;
    name: string;
}

// State management types
export interface DataState {
    weeklyData: ChartDataPoint[];
    monthlyData: ChartDataPoint[];
    usageStats: UsageStats;
    timeDistribution: TimeDistribution;
    isLoading: boolean;
    error: string | null;
}

export interface Strain {
  id?: number;
  name: string;
  overview: string;
  genetic_type: string;
  lineage: string;
  thc_range: string;
  cbd_level: string;
  dominant_terpenes: string;
  qualitative_insights: string;
  effects: string;
  negatives: string;
  uses: string;
  thc_rating: number;
  user_rating: number;
  combined_rating: number;
  created_at?: string;
}

/**
 * Filters for searching strains
 */
export interface StrainSearchFilters {
  geneticType?: 'Indica' | 'Sativa' | 'Hybrid';
  effects?: string[];
  sort?: 'name' | 'rating' | 'thc' | 'cbd';
  minTHC?: number;
  maxTHC?: number;
  minCBD?: number;
  maxCBD?: number;
  category?: string;
}

/**
 * Pagination parameters for search results
 */
export interface PaginationParams {
  page: number;
  limit: number;
}

/**
 * Strain search result
 */
export interface StrainSearchResult<T> {
  data: T[];
  total: number;
  currentPage: number;
  totalPages: number;
  hasMore: boolean;
}

// =========================================================
// Achievement types (moved from src/types/achievements.ts)
// =========================================================

export interface Achievement {
  id: number;
  category: string;
  name: string;
  unlockCondition: string;
  notes: string;
  icon: string; // MaterialCommunityIcons name
  complexity: number; // For achievement difficulty/value
}

export interface UserAchievement {
  userId: string;
  achievementId: number;
  progress: number; // 0-100%
  dateUnlocked: string | null;
  isUnlocked: boolean;
  isNew: boolean; // For notifications
  progressData?: any; // JSON data for specific tracking
}

// Extended UserAchievement with achievement details for UI
export interface UserAchievementWithDetails extends UserAchievement {
  id: number;
  category: string;
  name: string;
  unlockCondition: string;
  notes: string;
  icon: string;
  complexity: number;
}

// =========================================================
// AI-related types (moved from src/types/ai.ts)
// =========================================================

// AI recommendation system types
export interface UserProfile {
  id: string;
  experience_level: 'beginner' | 'intermediate' | 'experienced';
  preferred_effects: string[];
  medical_needs?: string[];
  avoid_effects?: string[];
  preferred_consumption_method?: string;
  thc_tolerance?: number; // Scale 1-10
  medications?: string[];
  created_at: string;
  updated_at: string;
}

export interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: string;
}

export interface JournalEntry {
  id: string;
  user_id: string;
  strain_id: number;
  strain_name: string;
  consumption_method: string;
  dosage: number;
  dosage_unit: string;
  effects_felt: string[];
  rating: number;
  effectiveness: number;
  notes?: string;
  mood_before?: string;
  mood_after?: string;
  medical_symptoms_relieved?: string[];
  negative_effects?: string[];
  duration_minutes?: number;
  created_at: string;
}

export interface RecommendationRequest {
  userProfile: UserProfile;
  journalEntries?: JournalEntry[];
  desiredEffects: string[];
  medicalNeeds?: string[];
  context?: 'recreational' | 'medical' | 'wellness';
  locationCode?: string; // For regulations
}

export interface StrainRecommendation {
  strainId: number;
  strainName: string;
  matchScore: number; // 0-100
  reasoningFactors: {
    factor: string;
    weight: number;
  }[];
  alternativeStrains?: {
    strainId: number;
    strainName: string;
    reason: string;
  }[];
}

export interface DosageSuggestion {
  minDosage: number;
  maxDosage: number;
  unit: string;
  gradualApproach: boolean;
  notes: string;
}

export interface RecommendationResponse {
  recommendations: StrainRecommendation[];
  reasoning: string;
  confidenceScore: number;
  disclaimers: string[];
  dosageSuggestion?: DosageSuggestion;
  safetyNotes?: string[];
  error?: {
    message: string;
    type: string;
    recoverable: boolean;
  };
}

export interface ChatRequest {
  message: string;
  userProfile: UserProfile;
  locationCode?: string;
  previousMessages?: {
    role: 'user' | 'assistant';
    content: string;
  }[];
}

export interface ChatResponse {
  response: string;
  educationalLinks?: string[];
  disclaimers?: string[];
  regulatoryNotes?: string[];
  followUpSuggestions?: string[];
}

export interface JournalAnalysisResult {
  patterns: string[];
  insights: string[];
  recommendations: string[];
  safetyFlags?: string[];
}

export interface SafetyValidationResult {
  valid: boolean;
  reason?: string;
  modifications?: Partial<RecommendationRequest>;
  safetyFlags?: string[];
  warningLevel?: 'info' | 'warning' | 'critical';
}

export interface DrugInteractionResult {
  hasInteractions: boolean;
  details?: string[];
  severity?: 'mild' | 'moderate' | 'severe';
  recommendations?: string[];
}

export interface OveruseDetectionResult {
  detected: boolean;
  level?: 'mild' | 'moderate' | 'severe';
  details?: string;
  recommendedAction?: string;
  coolingOffPeriod?: number; // in days
}

export interface SafetyRecord {
  id: string;
  user_id: string;
  concern_type: 'overuse' | 'negative_effects' | 'interactions';
  concern_details: string;
  resolution_suggestions: string[];
  cooling_off_until: number | null;
  created_at: string;
}


================================================================================
File: src/utils/animations.ts
================================================================================

import { useCallback } from 'react';
import { Platform } from 'react-native';
import {
  FadeIn,
  FadeInDown,
  FadeInUp,
  withSpring,
  withTiming,
  WithTimingConfig,
  Easing,
  useSharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

// Optimized spring configuration
export const SPRING_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100,
  restDisplacementThreshold: 0.01,
  restSpeedThreshold: 0.01,
} as const;

// Optimized timing configuration
export const TIMING_CONFIG: WithTimingConfig = {
  duration: 300,
  easing: Easing.bezier(0.25, 0.1, 0.25, 1),
} as const;

// Shared animation factory
export const createSharedAnimation = (delay: number = 0) => {
  return Platform.select({
    ios: FadeInDown.duration(300)
      .springify()
      .delay(delay)
      .damping(SPRING_CONFIG.damping)
      .mass(SPRING_CONFIG.mass),
    android: FadeIn.duration(250)
      .delay(delay)
  });
};

// Optimized press animation hook
export const useAnimatedPress = (scale: number = 0.98) => {
  const pressed = useSharedValue(false);
  
  const animatedStyle = useAnimatedStyle(() => {
    'worklet';
    return {
      transform: [{
        scale: withSpring(
          pressed.value ? scale : 1, 
          SPRING_CONFIG
        )
      }]
    };
  });

  return {
    animatedStyle,
    pressHandlers: {
      onPressIn: useCallback(() => {
        pressed.value = true;
      }, []),
      onPressOut: useCallback(() => {
        pressed.value = false;
      }, [])
    }
  };
};

// Gradient optimization utilities
export const GRADIENT_PROPS = Platform.select({
  ios: {
    shouldRasterizeIOS: true,
  },
  android: {
    renderToHardwareTextureAndroid: true,
  },
});

// Chart animation configuration
export const CHART_ANIMATION_CONFIG = {
  animationEnabled: true,
  animationDuration: 300,
  animationEasing: Easing.ease,
  propsForLabels: {
    fontSize: 10,
    fontWeight: '400'
  }
} as const;

// Optimized layout animation configuration
export const LAYOUT_ANIMATION_CONFIG = {
  damping: 10,
  mass: 0.3,
  stiffness: 100
} as const; 

================================================================================
File: src/utils/filters.ts
================================================================================

import { StrainSearchFilters } from '../DatabaseManager';

export const hasActiveFilters = (filters: StrainSearchFilters): boolean => {
  return !!(
    filters.geneticType ||
    (filters.effects && filters.effects.length > 0) ||
    filters.minTHC ||
    filters.maxTHC ||
    (filters.sort && filters.sort !== 'rating')
  );
}; 

================================================================================
File: src/utils/functions.ts
================================================================================

const monthStringToInt: { [key: string]: number } = {
    "January": 1,
    "February": 2,
    "March": 3,
    "April": 4,
    "May": 5,
    "June": 6,
    "July": 7,
    "August": 8,
    "September": 9,
    "October": 10,
    "November": 11,
    "December": 12,
};

/*
 * Parses data into a format that we can use for SQL
 */
export function parseRawTimestamp(rawTimestamp: string): string {
    // Remove day, then separate by spaces
    const parts: string[] = rawTimestamp.split(',')[1].split(' ');
    console.log(parts)
    const month: string = `${monthStringToInt[parts[1]]}`;
    const day: string = parts[2];
    const year: string = parts[3];
    const time: string = parts[4];
    return `${year}-${month}-${day} ${time}`;
}

================================================================================
File: src/utils/QueryBuilder.ts
================================================================================

/**
 * QueryBuilder - A simple SQL query builder for SQLite
 * 
 * This class provides a fluent interface for building SQL queries
 * without having to write raw SQL strings.
 */
export class QueryBuilder {
  private selectCols: string[] = [];
  private fromTableName: string = '';
  private whereConditions: string[] = [];
  private orderByClauses: string[] = [];
  private groupByClauses: string[] = [];
  private limitValue: number | null = null;
  private offsetValue: number | null = null;
  private paramValues: any[] = [];
  
  /**
   * Select columns to include in the query
   * @param columns Column names to select
   * @returns this instance for chaining
   */
  selectColumns(columns: string | string[]): QueryBuilder {
    if (Array.isArray(columns)) {
      this.selectCols.push(...columns);
    } else {
      this.selectCols.push(columns);
    }
    return this;
  }
  
  /**
   * Set the table to query from
   * @param table Table name
   * @returns this instance for chaining
   */
  from(table: string): QueryBuilder {
    this.fromTableName = table;
    return this;
  }
  
  /**
   * Add a WHERE condition with parameters
   * @param condition SQL condition as string
   * @param params Parameters to bind to the condition
   * @returns this instance for chaining
   */
  whereClause(condition: string, ...params: any[]): QueryBuilder {
    this.whereConditions.push(condition);
    this.paramValues.push(...params);
    return this;
  }

  /**
   * Add an ORDER BY clause
   * @param column Column to order by
   * @param direction Sort direction (ASC or DESC)
   * @returns this instance for chaining
   */
  orderByColumn(column: string, direction: 'ASC' | 'DESC' = 'ASC'): QueryBuilder {
    this.orderByClauses.push(`${column} ${direction}`);
    return this;
  }

  /**
   * Add a GROUP BY clause
   * @param columns Columns to group by
   * @returns this instance for chaining
   */
  groupByColumns(columns: string | string[]): QueryBuilder {
    if (Array.isArray(columns)) {
      this.groupByClauses.push(...columns);
    } else {
      this.groupByClauses.push(columns);
    }
    return this;
  }

  /**
   * Set LIMIT clause
   * @param limit Maximum number of rows to return
   * @returns this instance for chaining
   */
  limitTo(limit: number): QueryBuilder {
    this.limitValue = limit;
    return this;
  }

  /**
   * Set OFFSET clause
   * @param offset Number of rows to skip
   * @returns this instance for chaining
   */
  offsetBy(offset: number): QueryBuilder {
    this.offsetValue = offset;
    return this;
  }
  
  /**
   * Build the final SQL query and parameters
   * @returns Object containing the query string and parameters array
   */
  build(): { query: string, params: any[] } {
    const parts: string[] = [];
    
    // SELECT clause
    parts.push(`SELECT ${this.selectCols.length > 0 ? this.selectCols.join(', ') : '*'}`);
    
    // FROM clause
    parts.push(`FROM ${this.fromTableName}`);
    
    // WHERE clause
    if (this.whereConditions.length > 0) {
      parts.push(`WHERE ${this.whereConditions.join(' AND ')}`);
    }
    
    // GROUP BY clause
    if (this.groupByClauses.length > 0) {
      parts.push(`GROUP BY ${this.groupByClauses.join(', ')}`);
    }
    
    // ORDER BY clause
    if (this.orderByClauses.length > 0) {
      parts.push(`ORDER BY ${this.orderByClauses.join(', ')}`);
    }
    
    // LIMIT clause
    if (this.limitValue !== null) {
      parts.push(`LIMIT ${this.limitValue}`);
    }
    
    // OFFSET clause
    if (this.offsetValue !== null) {
      parts.push(`OFFSET ${this.offsetValue}`);
    }
    
    return {
      query: parts.join(' '),
      params: this.paramValues
    };
  }
} 

================================================================================
File: src/utils/SqlTemplates.ts
================================================================================

/**
 * SQL Templates
 * 
 * This file contains template functions for commonly used SQL queries.
 * It helps to keep the SQL queries organized, maintainable, and separated
 * from the database logic.
 */

/**
 * Get the query for usage statistics
 * @param tableName The table name to query from
 * @param daysBack Number of days to look back
 * @returns SQL query string
 */
export function getUsageStatsQuery(tableName: string, daysBack: number): string {
  return `
    WITH DailyStats AS (
      SELECT 
        strftime('%Y-%m-%d', timestamp) as day,
        strftime('%w', timestamp) as weekday,
        COUNT(*) as daily_hits,
        AVG(duration_ms) as avg_duration_per_day,
        MIN(duration_ms) as min_duration,
        MAX(duration_ms) as max_duration,
        SUM(duration_ms) as total_duration_per_day
      FROM ${tableName}
      WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
      GROUP BY day
    ),
    TotalStats AS (
      SELECT 
        COUNT(*) as total_hits,
        COUNT(DISTINCT strftime('%Y-%m-%d', timestamp)) as active_days,
        AVG(duration_ms) as overall_avg_duration,
        SUM(duration_ms) as total_duration
      FROM ${tableName}
      WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
    ),
    DayOfWeekStats AS (
      SELECT 
        weekday, 
        COUNT(*) as total_hits,
        AVG(daily_hits) as avg_hits_per_day
      FROM DailyStats
      GROUP BY weekday
    )
    SELECT 
      (SELECT total_hits FROM TotalStats) as total_hits,
      (SELECT active_days FROM TotalStats) as active_days,
      (SELECT CAST(total_hits AS REAL) / active_days FROM TotalStats) as avg_hits_per_active_day,
      (SELECT CAST(total_hits AS REAL) / ${daysBack} FROM TotalStats) as avg_hits_per_day,
      (SELECT overall_avg_duration FROM TotalStats) as avg_duration_ms,
      (SELECT total_duration FROM TotalStats) as total_duration_ms,
      (SELECT MAX(daily_hits) FROM DailyStats) as max_hits_in_day,
      (SELECT MAX(avg_duration_per_day) FROM DailyStats) as max_avg_duration,
      (SELECT MAX(total_duration_per_day) FROM DailyStats) as max_duration_in_day,
      (SELECT weekday FROM DayOfWeekStats ORDER BY total_hits DESC LIMIT 1) as most_active_day,
      (SELECT weekday FROM DayOfWeekStats ORDER BY total_hits ASC LIMIT 1) as least_active_day
  `;
}

/**
 * Get the query for time distribution of usage
 * @param tableName The table name to query from
 * @param daysBack Number of days to look back
 * @returns SQL query string
 */
export function getTimeDistributionQuery(tableName: string, daysBack: number): string {
  return `
    WITH HourlyHits AS (
      SELECT 
        CAST(strftime('%H', timestamp) AS INTEGER) as hour,
        COUNT(*) as hits
      FROM ${tableName}
      WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
      GROUP BY hour
    ),
    TotalHits AS (
      SELECT SUM(hits) as total FROM HourlyHits
    )
    SELECT
      CAST((SELECT COALESCE(SUM(hits), 0) FROM HourlyHits WHERE hour >= 5 AND hour < 12) AS REAL) / 
        (SELECT CASE WHEN total = 0 THEN 1 ELSE total END FROM TotalHits) as morning,
      CAST((SELECT COALESCE(SUM(hits), 0) FROM HourlyHits WHERE hour >= 12 AND hour < 17) AS REAL) / 
        (SELECT CASE WHEN total = 0 THEN 1 ELSE total END FROM TotalHits) as afternoon,
      CAST((SELECT COALESCE(SUM(hits), 0) FROM HourlyHits WHERE hour >= 17 AND hour < 22) AS REAL) / 
        (SELECT CASE WHEN total = 0 THEN 1 ELSE total END FROM TotalHits) as evening,
      CAST((SELECT COALESCE(SUM(hits), 0) FROM HourlyHits WHERE hour >= 22 OR hour < 5) AS REAL) / 
        (SELECT CASE WHEN total = 0 THEN 1 ELSE total END FROM TotalHits) as night
  `;
}

/**
 * Get the query for weekly stats
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getWeeklyStatsQuery(tableName: string): string {
  return `
    WITH WeekData AS (
      SELECT 
        strftime('%W', timestamp) as week,
        COUNT(*) as count,
        AVG(duration_ms) as avg_duration
      FROM ${tableName}
      WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
      GROUP BY week
      ORDER BY week DESC
      LIMIT 7
    )
    SELECT 
      week as label,
      count as value,
      avg_duration
    FROM WeekData
    ORDER BY week ASC
  `;
}

/**
 * Get the query for monthly stats
 * @param tableName The table name to query from
 * @returns SQL query string
 */
export function getMonthlyStatsQuery(tableName: string): string {
  return `
    WITH MonthData AS (
      SELECT 
        strftime('%m', timestamp) as month,
        COUNT(*) as count,
        AVG(duration_ms) as avg_duration
      FROM ${tableName}
      WHERE timestamp >= '2024-12-24' -- Hardcoded date for testing
      GROUP BY month
      ORDER BY month DESC
      LIMIT 12
    )
    SELECT 
      month as label,
      count as value,
      avg_duration
    FROM MonthData
    ORDER BY month ASC
  `;
}

/**
 * Get query for finding strains with filter conditions
 * @param filters Filter conditions 
 * @returns SQL query parts (where clause, params)
 */
export function buildStrainFilterQuery(
  query: string,
  filters: {
    genetic_type?: string;
    effects?: string[];
    minThc?: number;
    maxThc?: number;
  }
): { whereClause: string, params: any[] } {
  const whereClauses = [];
  const params: any[] = [];

  // Search by name if query is provided
  if (query && query.trim() !== '') {
    whereClauses.push('(name LIKE ? OR genetic_type LIKE ? OR effects LIKE ?)');
    const searchTerm = `%${query}%`;
    params.push(searchTerm, searchTerm, searchTerm);
  }

  // Filter by genetic type
  if (filters.genetic_type) {
    whereClauses.push('genetic_type = ?');
    params.push(filters.genetic_type);
  }

  // Filter by effects
  if (filters.effects && filters.effects.length > 0) {
    const effectClauses = filters.effects.map(() => 'effects LIKE ?');
    whereClauses.push(`(${effectClauses.join(' OR ')})`);
    filters.effects.forEach(effect => params.push(`%${effect}%`));
  }

  // Filter by THC range
  if (filters.minThc !== undefined) {
    whereClauses.push('thc_rating >= ?');
    params.push(filters.minThc);
  }

  if (filters.maxThc !== undefined) {
    whereClauses.push('thc_rating <= ?');
    params.push(filters.maxThc);
  }

  return {
    whereClause: whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '',
    params
  };
} 

================================================================================
File: src/utils/validators.ts
================================================================================

import { BongHit, Strain, JournalEntry, SafetyRecord } from '../types';

/**
 * Validators utility
 * 
 * Contains domain-specific validation functions for various data types
 * used throughout the application.
 */

/**
 * Validate a BongHit object
 * @param hit The BongHit to validate
 * @returns Error message if invalid, null if valid
 */
export function validateBongHit(hit: BongHit): string | null {
  if (!hit) return 'Bong hit data is required';
  if (!hit.timestamp) return 'Timestamp is required';
  if (!isValidISOTimestamp(hit.timestamp)) return 'Invalid timestamp format';
  if (typeof hit.duration_ms !== 'number') return 'Duration must be a number';
  if (hit.duration_ms <= 0) return 'Duration must be positive';
  return null; // Valid
}

/**
 * Validate a Strain object
 * @param strain The Strain to validate
 * @returns Error message if invalid, null if valid
 */
export function validateStrain(strain: Strain): string | null {
  if (!strain) return 'Strain data is required';
  if (!strain.name || strain.name.trim() === '') return 'Strain name is required';
  if (!strain.genetic_type) return 'Genetic type is required';
  if (strain.thc_rating != null && (typeof strain.thc_rating !== 'number' || strain.thc_rating < 0 || strain.thc_rating > 100)) {
    return 'THC rating must be a number between 0 and 100';
  }
  return null; // Valid
}

/**
 * Validate a SafetyRecord object
 * @param record The SafetyRecord to validate
 * @returns Error message if invalid, null if valid
 */
export function validateSafetyRecord(record: SafetyRecord): string | null {
  if (!record) return 'Safety record is required';
  if (!record.id) return 'Safety record ID is required';
  if (!record.user_id) return 'User ID is required';
  if (!record.concern_type) return 'Concern type is required';
  if (!record.concern_details || record.concern_details.trim() === '') return 'Concern details are required';
  if (!record.created_at) return 'Created timestamp is required';
  return null; // Valid
}

/**
 * Validate a JournalEntry object
 * @param entry The JournalEntry to validate
 * @returns Error message if invalid, null if valid
 */
export function validateJournalEntry(entry: JournalEntry): string | null {
  if (!entry) return 'Journal entry is required';
  if (!entry.id) return 'Entry ID is required';
  if (!entry.user_id) return 'User ID is required';
  if (!entry.created_at) return 'Created timestamp is required';
  if (!isValidISOTimestamp(entry.created_at)) return 'Invalid timestamp format';
  return null; // Valid
}

/**
 * Check if a string is a valid ISO timestamp
 * @param timestamp The timestamp string to validate
 * @returns Whether the string is a valid ISO timestamp
 */
export function isValidISOTimestamp(timestamp: string): boolean {
  if (typeof timestamp !== 'string') return false;
  const date = new Date(timestamp);
  return !isNaN(date.getTime()) && date.toISOString() === timestamp;
}

/**
 * Create a validation error result
 * @param code Error code
 * @param message Error message
 * @param data Optional data related to the error
 * @returns Validation error result object
 */
export function createValidationError<T>(code: string, message: string, data?: any): { 
  success: false, 
  error: string, 
  code: string, 
  data?: any 
} {
  return {
    success: false,
    error: message,
    code,
    data
  };
}

/**
 * Create a successful validation result
 * @param data The validated data
 * @returns Successful validation result object
 */
export function createValidationSuccess<T>(data: T): {
  success: true,
  data: T
} {
  return {
    success: true,
    data
  };
}

/**
 * Validation result type
 */
export type ValidationResult<T> = 
  | { success: true, data: T }
  | { success: false, error: string, code: string, data?: any }; 

================================================================================
File: tsconfig.json
================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}